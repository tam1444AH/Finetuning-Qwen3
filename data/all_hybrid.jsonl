{"filename":"cryptol\/examples\/splitAt.cry","filetype":"cry","content":"x = [1,2,3,4] : [_][8]\n\ny = (splitAt x) : ([2][8],[2][8])\n\na = y.0 @ 0\nb = y.0 @ 1\nc = y.1 @ 0\nd = y.1 @ 1\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/AE.cry","filetype":"cry","content":"\/*\nImplementation of the algorithms from the paper\n  \"Automated Analysis and Synthesis of Authenticated Encryption Schemes\"\n  by Viet Tung Hoang, Jonathan Katz, and Alex J. Malozemoff\n*\/\nmodule AE where\n\nparameter\n  type A : *            type K : *            type n : #            type p : #            type tagAmount : #\n\n  type constraint (fin p, fin n, n >= tagAmount)\n\n  \/\/ Process a single block using this key and tweak\n  tweak_cipher : K -> { nonce : [n], state : A, z : [64] } -> [n] -> [n]\n\n  \/\/ Cost for using the tweak\n  Cost : [64]\n\n  Enc : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Dec : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Tag : K -> { nonce : [n], state : A, z : [64] } -> [p*n] -> [n]\n\n\/\/ The unit at which `Enc` operates\ntype Node       = { message : WorkBlock, state : State }\n\n\/\/ Some encryption schemes process multiple blocks at once\ntype WorkBlock  = [p*n]\n\ntype State      = [p*n]  \/\/ The state for `p` blocks\n\ntype Tweak      = { nonce : Nonce, state : A, z : Int }\ntype Nonce      = [n]\n\n\/*\nproperty\n\n  \/\/ The tweak in the `i`th query to the tweak_cipher\n  tweak_prop i { nonce = n, state = a, z = v } =\n               { nonce = n, state = a, z = v + i - 1 }\n\n\n  \/\/ Property of decrypt\n  Dec_prop : Tweak -> Node -> Bit\n  Dec_prop t { message = m, state = x } =\n       Dec t { message = c, state = x } == { message = m, state = y }\n       where { message = c, state = y } = Enc t x m\n*\/\n\ntype Int = [64]\n\nencrypt :\n  {m} fin m => K -> Nonce -> A -> [m * (p * n)] -> [m * (p * n) + tagAmount]\nencrypt key nonce state inputMsg = encMsg # tag\n\n  where\n  encMsg = join rest.0.message\n\n  tag = take (Tag key (tweak (1 - final.1)) final.0.state)\n\n  final = steps ! 0\n\n  steps = [ ({ message = undefined, state = zero }, 1) ] # rest\n  rest  = [ (Enc key (tweak v) { message = m, state = prev.state }, v + Cost)\n          | (prev,v) <- steps\n          | m        <- chunks\n          ]\n\n  \/\/ XXX: isn't v i  just 1 + i * Cost\n\n  chunks : [m] [p * n]\n  chunks = split inputMsg\n\n  tweak : Int -> Tweak\n  tweak v = { nonce = nonce, state = state, z = v }\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/xor_cipher.cry","filetype":"cry","content":"encrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\nencrypt key plaintext = [pt ^ key | pt <- plaintext ]\n\ndecrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\ndecrypt key ciphertext = [ct ^ key | ct <- ciphertext ]\n\nproperty roundtrip k ip = decrypt k (encrypt k ip) == ip","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/zero_weird.cry","filetype":"cry","content":"x : {a}() => a -> [16]\nx v = zero v \n\nproperty xprop v = x v == 0\n\ny : [12] -> [4] -> [17]\ny a b = zero a b\n\nproperty yprop v w = y v w == 0\n\nt1 = x 13\nt2 = y 2 3\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/builtin_lifting.cry","filetype":"cry","content":"\/\/builtins lift over tuples, seqs, and records\n\n\/\/this file uses addition to model a builtin\n\/\/but this should work for any builtin operators\n\nx = [True,False]\ny = [False,True]\n\n\/\/make sure bitvectors are numbers\nproperty p1 = x == (2 : [2])\n\n\/\/same thing written 2 different ways\nproperty p2 = x + y == 3\nproperty p3 = x + y == [True,True]\n\n\nxx = [[True,False]]\nyy = [[False,True]]\n\n\/\/addition lifts pointwise over sequences\nproperty p4 = xx + yy == [3]\n\n\/\/negation is a unary operator that also lifts over sequences\nproperty p5 = ~ xx == yy\n\n\nxinf = [2 ... ]\nyinf = [3 ... ]\n\n\/\/addition lifts pointwise over infinite lists\nproperty p6 = (xinf + yinf) @ (0 : [0]) == (1 : [2])\n\n\/\/negation lifts pointwise over an infinite list\nproperty p7 = (~ xinf) @ (0 : [0]) == (1 : [2])\n\nxrec = { x = 2 : [2], y = 2 : [2] } : {x : [2], y : [2]}\n\nproperty p8 = xrec + xrec + xrec == xrec\n\n\/\/lift over tuples and records at the same time\nproperty p9 = (2,2,xrec) + (2,2,xrec) + (2,2,xrec) == (2:[2],2:[2],xrec) \n\n\/\/lift unary over tuples and lists\nproperty p10 = (~ { x = (1,2), y = [3,4,5] }) == {x = (0:[1],1:[2]), y = [4, 3, 2] : [3][3] }\n\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/inflist.cry","filetype":"cry","content":"a = [1 ... ]\nb = [1,2 ... ]\nc = [1 .. 5]\nd = [1,3 .. 9]\n\nproperty t1 = a @ 3 == 1\nproperty t2 = b @ 3 == 1\nproperty t3 = c @ 3 == 4\nproperty t4 = d @ 3 == 4\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/Karatsuba.cry","filetype":"cry","content":"\/*\n * Copyright (c) 2017 Galois, Inc.\n * Distributed under the terms of the BSD3 license (see LICENSE file)\n *\n * This module defines a Karatsuba multiplier, which is polymorphic over the\n * bitwidth of the constituent limbs and the size of the inputs.\n *\n * Note the trick of using `make_atleast` in the recursive case to teach the\n * typecheker that the current bitwidth is long enough for the split multiplier\n * to be sensible.  The minimum width for which the splitting recursive case\n * works out happens to be 6.  This is the smallest width for which the\n * divide-in-half strategy leaves enough bits left over for the additions\n * steps not to overflow.\n *\n * Note that if one wishes to simulate using a standard CPU to perform Karatsuba\n * multiplies, the limb width should be set to ONE LESS THAN the standard\n * machine word size, e.g. 63 bits for a 64 bit machine.  This ensures that\n * the intermediate additions will fit into a machine word.  Note that the the\n * final `2*(limb+1)`-width additions will also have to be assembled manually\n * using \"add with carry\" operations or similar.\n *\/\n\nmodule Karatsuba where\n\n\/\/ The divide-and-conquer Karatsuba multiplier.  If the argument width\n\/\/ is greater than the limb width, then the recursive `splitmult` multiplier\n\/\/ is called; otherwise, a standard multiply is used.\n\nkmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 1) => [n] -> [n] -> [2*n]\n\nkmult x y =\n if `n >= (`limb : [max (width limb) (width n)]) then\n   take (splitmult`{limb} (make_atleast`{limb} x) (make_atleast`{limb} y))\n else\n   (zero#x)*(zero#y)\n\n\n\/\/ Force a bitvector to be at least `n` bits long.  As used above, this operation\n\/\/ should always be a no-op, but teaches the typechecker a necessary inequality\n\/\/ to call the `splitmult` operation.\n\nmake_atleast : {n, m, a} (fin n, fin m, Zero a) => [m]a -> [max n m]a\nmake_atleast x = zero#x\n\n\n\n\/\/ Execute the recursive step of Karatsuba's multiplication. Split the\n\/\/ input words into high and low bit portions; then perform three\n\/\/ recursive multiplies using these intermediate, shorter bitsequences.\n\nsplitmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 6)\n         => [n] -> [n] -> [2*n]\n\nsplitmult x y = (ac # bd) + (zero # ad_bc # (zero:[low]))\n  where\n   type hi  = n\/2\n   type low = n - hi\n\n   (a,b) = splitAt`{hi} x\n   (c,d) = splitAt`{hi} y\n\n   ac : [2*hi]\n   ac = kmult`{limb,hi} a c\n\n   bd : [2*low]\n   bd = kmult`{limb,low} b d\n\n   a_b = (zext a) + (zext b)\n   c_d = (zext c) + (zext d)\n\n   ad_bc : [2*(low+1)]\n   ad_bc = (kmult`{limb,low+1} a_b c_d) - (zext ac) - (zext bd)\n\n\n\/\/ Verify Karatsuba's algorithm computes the correct answer\n\/\/ for some fixed settings of the parameters.\n\/\/\n\/\/ SMT solvers have great difficutly with these proofs, and I have\n\/\/ only gotten small bit sizes to return with successful proofs.\n\nproperty splitmult_correct_tiny (x:[9]) (y:[9]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_small (x:[11]) (y:[11]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_medium(x:[17]) (y:[17]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_large (x:[59]) (y:[59]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_huge (x:[511]) (y:[511]) =\n  zext x * zext y == splitmult`{limb=63} x y\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/comp.cry","filetype":"cry","content":"x : [_]([2],[3],[3],[4])\nx = [(a,b,c,d) | a <- [1,2], b <- [3,4] | c <- [5,6], d <- [7,8,9] ]\n\nproperty t1 = x @ 0 == (1,3,5,7)\nproperty t2 = x @ 2 == (2,3,5,9)\nproperty t3 = x @ 3 == (2,4,6,7)\n\ny = [(a,b,c) | a <- [1,2,3], b <- [1,2] | c <- [1 ... ] ]\n\nproperty t4 = y @ 3 == (2,2,0)\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/mini.cry","filetype":"cry","content":"id : [32] -> [32]\nid x = rec x\n  where rec k = if (k == 0) then 0 else 1 + rec (k + (-1))\n\n\ninflist = [1 ... ] : [_][8]\n\nrc = {x = 3 : [8], y = 5 : [8]}\n\nmy_true = rc.x\n\ntup = (1 : [8], 2 : [8], 3 : [8], 4 : [8])\n\nmy_3 = tup.2\n\nsup = y where y = 3 : [8]\n\n\ngf28Add : {n} (fin n) => [n][8] -> [8]\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngex = gf28Add [1,2]\n\nsum : [_][8] -> [_][8]\nsum x = rec\n  where rec = [ p + q | p <- x | q <- [1,2,3,4] ]\n  ","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/Test.cry","filetype":"cry","content":"\/\/ Don't load this on its own -- it gets pulled in by, e.g., DEStest.cry\n\nmodule Test where\nimport Cipher\n\nevktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\nevktest (cipher, vkeysCTs, PT) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, CT) <- vkeysCTs ]\n\nevttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\nevttest (cipher, Key, vtextPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (PT, CT) <- vtextPCTs ]\n\nekatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\nekatest (cipher, kaKPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, PT, CT) <- kaKPCTs ]\n\ndvktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\ndvktest (cipher, vkeysCTs, PT) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, CT) <- vkeysCTs ]\n\ndvttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\ndvttest (cipher, Key, vtextPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (PT, CT) <- vtextPCTs ]\n\ndkatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\ndkatest (cipher, kaKPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, PT, CT) <- kaKPCTs ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/builtins.cry","filetype":"cry","content":"\/\/Here's a test of some builtin operators\n\/\/nothing too deep, just making sure they all work out\n\nt : [8]\nt = if True then 5 else 4 f : [8]\nf = if False then 3 else 5 times : [8]\ntimes = 5 * 1 * 2 * 3 div : [8]\ndiv = (((30\/1)\/2)\/3) mod : [8]\nmod = 205%10 exp : [8]\nexp = 2^^7 lgtest : [8]\nlgtest = lg2 128 p : [8]\np = 3+2 m : [8]\nm = 8-3 neg : [8]\nneg = -(-5) comp : [8]\ncomp = ~250 ","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/props.cry","filetype":"cry","content":"x = [True, False]\ny = [False, True]\nz = x + y\n\nproperty p1 = z == 3\n\nxx = [[True,False]]\nyy = [[False, True]]\nzz = xx + yy\n\n\n\nt : {a} [a*3] -> [a*3][a*3]\nt d = zero\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/demote.cry","filetype":"cry","content":"x : {a}(fin a) => [a] -> [(a*2)+3]\nx v = 0 + 1\n\ny = x (2 : [3])\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/append.cry","filetype":"cry","content":"x : [_][8]\nx = [1,2,3,4,5,19,12,38,5,3]\n\ny : [_][8]\ny = [19,3,27,5,12]\n\nz = x # y\n\nm = z @ (0 : [1]) w = z @ 2 t = z @ 10 v = z @ 11 ","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/split.cry","filetype":"cry","content":"x = [1,2,3,4] : [_][8]\n\ny = (split x) : [2][2][8]\n\na = (y@0) @ 0\nb = (y@0) @ 1\nc = (y@1) @ 0\nd = (y@1) @ 1\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/lib\/Array.cry","filetype":"cry","content":"module Array where\n\nprimitive type Array : * -> * -> *\n\nprimitive arrayConstant : {a, b} b -> (Array a b)\nprimitive arrayLookup : {a, b} (Array a b) -> a -> b\nprimitive arrayUpdate : {a, b} (Array a b) -> a -> b -> (Array a b)\nprimitive arrayEq : {n, a} (Array [n] a) -> (Array [n] a) -> Bool\n\n\/**\n * Copy elements from the source array to the destination array.\n *\n * 'arrayCopy dest_arr dest_idx src_arr src_idx len' copies the\n * elements from 'src_arr' at indices '[src_idx ..< (src_idx + len)]' into\n * 'dest_arr' at indices '[dest_idx ..< (dest_idx + len)]'.\n *\n * The result is undefined if either 'dest_idx + len' or 'src_idx + len'\n * wraps around.\n *\/\nprimitive arrayCopy : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> (Array [n] a)\n\/**\n * Set elements of the given array.\n *\n * 'arraySet' arr idx val len' sets the elements of 'arr' at indices\n * '[idx ..< (idx + len)]' to 'val'.\n *\n * The result is undefined if 'idx + len' wraps around.\n *\/\nprimitive arraySet : {n, a} (Array [n] a) -> [n] -> a -> [n] -> (Array [n] a)\n\/**\n * Check whether the lhs array and rhs array are equal at a range of\n * indices.\n *\n * 'arrayRangeEq sym lhs_arr lhs_idx rhs_arr rhs_idx len' checks whether\n * the elements of 'lhs_arr' at indices '[lhs_idx ..< (lhs_idx + len)]' and\n * the elements of 'rhs_arr' at indices '[rhs_idx ..< (rhs_idx + len)]' are\n * equal.\n *\n * The result is undefined if either 'lhs_idx + len' or 'rhs_idx + len'\n * wraps around.\n *\/\nprimitive arrayRangeEqual : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> Bool\n\narrayRangeLookup : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b\narrayRangeLookup arr idx = res\n  where\n    res @ i = arrayLookup arr (idx + i)\n\narrayRangeUpdate : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b -> (Array a b)\narrayRangeUpdate arr idx vals = arrs ! 0\n  where\n    arrs = [arr] # [ arrayUpdate acc (idx + i) val | acc <- arrs | i <- [0 ..< n] | val <- vals ]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/lib\/SuiteB.cry","filetype":"cry","content":"module SuiteB where\n\n\/***** AES ******\/\n\n\/**\n * Key schedule parameter setting for AES-128\n *\/\ntype AES128 = 4\n\n\/**\n * Key schedule parameter setting for AES-192\n *\/\ntype AES192 = 6\n\n\/**\n * Key schedule parameter setting for AES-256\n *\/\ntype AES256 = 8\n\n\/**\n * Element of an AES key schedule for use in a particular round\n *\/\ntype AESRoundKey = [4][32]\n\n\/**\n * Expanded encryption key schedule for AES\n *\/\ntype AESEncryptKeySchedule k =\n  { aesEncInitialKey : AESRoundKey\n  , aesEncRoundKeys  : [k+5]AESRoundKey\n  , aesEncFinalKey   : AESRoundKey\n  }\n\n\/**\n * Expanded decryption key schedule for AES\n *\/\ntype AESDecryptKeySchedule k =\n  { aesDecInitialKey : AESRoundKey\n  , aesDecRoundKeys  : [k+5]AESRoundKey\n  , aesDecFinalKey   : AESRoundKey\n  }\n\n\/**\n * Encryption key expansion for AES-128.\n *   See FIPS 197, section 5.2.\n *\/\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule = aesExpandEncryptSchedule\n\n\/**\n * Decryption key expansion for AES-128, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule = aesExpandDecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-128.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules = aesExpandSchedules\n\n\/**\n * Encryption key expansion for AES-192.\n *   See FIPS 197, section 5.2.\n *\/\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule = aesExpandEncryptSchedule\n\n\/**\n * Decryption key expansion for AES-192, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule = aesExpandDecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-192.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules = aesExpandSchedules\n\n\n\/**\n * Encryption key expansion for AES-256.\n *   See FIPS 197, section 5.2\n *\/\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule = aesExpandEncryptSchedule\n\n\/**\n * Decryption key expansion for AES-256, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule = aesExpandDecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-256.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules = aesExpandSchedules\n\n\/**\n * AES block encryption algorithm.\n *   See FIPS 197, section 5.1.\n *\/\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock schedule plaintext = rnf (join final)\n  where\n  final = (AESEncFinalRound (rds!0)) ^ schedule.aesEncFinalKey\n\n  rds = [ schedule.aesEncInitialKey ^ split plaintext ] #\n        [ AESEncRound r ^ rdk\n        | rdk <- schedule.aesEncRoundKeys\n        | r   <- rds\n        ]\n\n\/**\n * AES block decryption algorithm, via the \"equivalent inverse cypher\".\n *   See FIPS 197, section 5.3.5.\n *\/\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock schedule cyphertext = rnf (join final)\n  where\n  final = (AESDecFinalRound (rds!0)) ^ schedule.aesDecFinalKey\n\n  rds = [ split cyphertext ^ schedule.aesDecInitialKey ] #\n        [ AESDecRound r ^ rdk\n        | rdk <- schedule.aesDecRoundKeys\n        | r   <- rds\n        ]\n\nprivate\n    aesExpandEncryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESEncryptKeySchedule k\n    aesExpandEncryptSchedule key = rnf\n         { aesEncInitialKey = ks @  0\n         , aesEncRoundKeys  = ks @@ [ 1 .. k+5 ]\n         , aesEncFinalKey   = ks @  `(k+6)\n         }\n      where\n      ks : [k+7]AESRoundKey\n      ks = groupBy`{4} (AESKeyExpand`{k} (split key))\n\n    aesEncToDecSchedule : {k} (fin k) => AESEncryptKeySchedule k -> AESDecryptKeySchedule k\n    aesEncToDecSchedule enc = rnf\n       { aesDecInitialKey = enc.aesEncFinalKey\n       , aesDecRoundKeys  = map AESInvMixColumns (reverse (enc.aesEncRoundKeys))\n       , aesDecFinalKey   = enc.aesEncInitialKey\n       }\n\n    aesExpandDecryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESDecryptKeySchedule k\n    aesExpandDecryptSchedule key = aesEncToDecSchedule (aesExpandEncryptSchedule key)\n\n    aesExpandSchedules : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> (AESEncryptKeySchedule k, AESDecryptKeySchedule k)\n    aesExpandSchedules key = (encS, aesEncToDecSchedule encS)\n      where encS = aesExpandEncryptSchedule key\n\n    primitive AESEncRound      : [4][32] -> [4][32]\n    primitive AESEncFinalRound : [4][32] -> [4][32]\n    primitive AESDecRound      : [4][32] -> [4][32]\n    primitive AESDecFinalRound : [4][32] -> [4][32]\n    primitive AESInvMixColumns : [4][32] -> [4][32]\n    primitive AESKeyExpand     : {k} (fin k, k >= 4, 8 >= k) => [k][32] -> [4*(k+7)][32]\n\n\n\/***** SHA2 *****\/\n\n\/**\n * The SHA-224 secure hash algorithm.  See FIPS 180-4, section 6.3.\n *\/\nsha224 : {L} (fin L) => [L] -> [224]\nsha224 msg = join (processSHA2_224 (sha2blocks`{32} msg))\n\n\/**\n * The SHA-256 secure hash algorithm.  See FIPS 180-4, section 6.2.2.\n *\/\nsha256 : {L} (fin L) => [L] -> [256]\nsha256 msg = join (processSHA2_256 (sha2blocks`{32} msg))\n\n\/**\n * The SHA-384 secure hash algorithm.  See FIPS 180-4, section 6.5.\n *\/\nsha384 : {L} (fin L) => [L] -> [384]\nsha384 msg = join (processSHA2_384 (sha2blocks`{64} msg))\n\n\/**\n * The SHA-512 secure hash algorithm.  See FIPS 180-4, section 6.4.\n *\/\nsha512 : {L} (fin L) => [L] -> [512]\nsha512 msg = join (processSHA2_512 (sha2blocks`{64} msg))\n\nprivate\n    type sha2_block_size w = 16 * w\n    type sha2_num_blocks w L = (L+1+2*w) \/^ sha2_block_size w\n    type sha2_padded_size w L = sha2_num_blocks w L * sha2_block_size w\n\n    sha2pad : {w, L} (fin w, fin L, w >= 1) => [L] -> [sha2_padded_size w L]\n    sha2pad M = rnf (M # 0b1 # zero # ((fromInteger `L) : [2*w]))\n\n    sha2blocks : {w, L} (fin w, fin L, w >= 1) =>\n      [L] -> [sha2_num_blocks w L][16][w]\n    sha2blocks msg = [ split x | x <- split (sha2pad`{w} msg) ]\n\n    \/**\n     * Apply the SHA224 hash algorithm to a sequence of SHA256-size blocks,\n     * which are assumed to already be correctly padded.\n     *\/\n    primitive processSHA2_224 : {n} (fin n) => [n][16][32] -> [7][32]\n\n    \/**\n     * Apply the SHA256 hash algorithm to a sequence of SHA256-size blocks,\n     * which are assumed to already be correctly padded.\n     *\/\n    primitive processSHA2_256 : {n} (fin n) => [n][16][32] -> [8][32]\n\n    \/**\n     * Apply the SHA384 hash algorithm to a sequence of SHA512-size blocks,\n     * which are assumed to already be correctly padded.\n     *\/\n    primitive processSHA2_384 : {n} (fin n) => [n][16][64] -> [6][64]\n\n    \/**\n     * Apply the SHA512 hash algorithm to a sequence of SHA512-size blocks,\n     * which are assumed to already be correctly padded.\n     *\/\n    primitive processSHA2_512 : {n} (fin n) => [n][16][64] -> [8][64]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/lib\/Float.cry","filetype":"cry","content":"module Float where\n\nprimitive type ValidFloat : # -> # -> Prop\n\n\/** IEEE-754 floating point numbers. *\/\nprimitive type { exponent : #, precision : #}\n  ValidFloat exponent precision => Float exponent precision : *\n\n\/** An abbreviation for common 16-bit floating point numbers. *\/\ntype Float16  = Float 5 11\n\n\/** An abbreviation for common 32-bit floating point numbers. *\/\ntype Float32  = Float 8 24\n\n\/** An abbreviation for common 64-bit floating point numbers. *\/\ntype Float64  = Float 11 53\n\n\/** An abbreviation for common 128-bit floating point numbers. *\/\ntype Float128 = Float 15 113\n\n\/** An abbreviation for common 256-bit floating point numbers. *\/\ntype Float256 = Float 19 237\n\n\n\n\/* ----------------------------------------------------------------------\n * Rounding modes (this should be an enumeration type, when we add these)\n *---------------------------------------------------------------------- *\/\n\n\/**\n * A 'RoundingMode' is used to specify the precise behavior of some\n * floating point primitives.\n *\n * There are five valid 'RoundingMode' values:\n *  * roundNearestEven\n *  * roundNearestAway\n *  * roundPositive\n *  * roundNegative\n *  * roundZero\n *\/\ntype RoundingMode = [3]\n\n\/** Round toward nearest, ties go to even. *\/\nroundNearestEven, rne : RoundingMode\nroundNearestEven = 0\nrne              = roundNearestEven\n\n\/** Round toward nearest, ties away from zero. *\/\nroundNearestAway, rna : RoundingMode\nroundNearestAway  = 1\nrna               = roundNearestAway\n\n\/** Round toward positive infinity. *\/\nroundPositive, rtp : RoundingMode\nroundPositive     = 2\nrtp               = roundPositive\n\n\/** Round toward negative infinity. *\/\nroundNegative, rtn : RoundingMode\nroundNegative     = 3\nrtn               = roundNegative\n\n\/** Round toward zero. *\/\nroundZero, rtz : RoundingMode\nroundZero         = 4\nrtz               = roundZero\n\n\n\n\/** Not a number. *\/\nprimitive\n  fpNaN : {e,p} ValidFloat e p => Float e p\n\n\/** Positive infinity. *\/\nprimitive\n  fpPosInf : {e,p} ValidFloat e p => Float e p\n\n\/** Negative infinity. *\/\nfpNegInf : {e,p} ValidFloat e p => Float e p\nfpNegInf = - fpPosInf\n\n\/** Positive zero. *\/\nfpPosZero : {e,p} ValidFloat e p => Float e p\nfpPosZero = zero\n\n\/** Negative zero. *\/\nfpNegZero : {e,p} ValidFloat e p => Float e p\nfpNegZero = - fpPosZero\n\n\n\/** A floating point number using the exact bit pattern,\nin IEEE interchange format with layout:\n\n  (sign : [1]) # (biased_exponent : [e]) # (significand : [p-1])\n*\/\nprimitive\n  fpFromBits : {e,p} ValidFloat e p => [e + p] -> Float e p\n\n\/** Export a floating point number in IEEE interchange format with layout:\n\n  (sign : [1]) # (biased_exponent : [e]) # (significand : [p-1])\n\nNaN is represented as:\n  * positive:           sign        == 0\n  * quiet with no info: significand == 0b1 # 0\n*\/\nprimitive\n  fpToBits : {e,p} ValidFloat e p => Float e p -> [e + p]\n\n\n\n\n\n\/\/ Operations in `Cmp` use IEEE reasoning.\n\n\/** Check if two floating point numbers are representationally the same.\nIn particular, the following hold:\n    *    NaN       =.= NaN\n    * ~ (pfNegZero =.= fpPosZero)\n*\/\nprimitive\n  (=.=) : {e,p} ValidFloat e p => Float e p -> Float e p -> Bool\n\ninfix 20 =.=\n\n\/** Test if this value is not-a-number (NaN). *\/\nprimitive fpIsNaN : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/** Test if this value is positive or negative infinity. *\/\nprimitive fpIsInf : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/** Test if this value is positive or negative zero. *\/\nprimitive fpIsZero : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/** Test if this value is negative. *\/\nprimitive fpIsNeg : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/** Test if this value is normal (not NaN, not infinite, not zero, and not subnormal). *\/\nprimitive fpIsNormal : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/**\n * Test if this value is subnormal.  Subnormal values are nonzero\n * values with magnitudes smaller than can be represented with the\n * normal implicit leading bit convention.\n *\/\nprimitive fpIsSubnormal : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/* Returns true for numbers that are not an infinity or NaN. *\/\nfpIsFinite : {e,p} ValidFloat e p => Float e p -> Bool\nfpIsFinite f = ~ (fpIsNaN f \\\/ fpIsInf f )\n\n\n\/** Add floating point numbers using the given rounding mode. *\/\nprimitive\n  fpAdd : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\n\/** Subtract floating point numbers using the given rounding mode. *\/\nprimitive\n  fpSub : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\n\/** Multiply floating point numbers using the given rounding mode. *\/\nprimitive\n  fpMul : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\n\/** Divide floating point numbers using the given rounding mode. *\/\nprimitive\n  fpDiv : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\n\/**\n * Fused-multiply-add.  'fpFMA r x y z' computes the value '(x*y)+z',\n * rounding the result according to mode 'r' only after performing both\n * operations.\n *\/\nprimitive\n  fpFMA : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p -> Float e p\n\n\/**\n * Absolute value of a floating-point value.\n *\/\nprimitive\n  fpAbs : {e,p} ValidFloat e p =>\n    Float e p -> Float e p\n\n\/**\n * Square root of a floating-point value.  The square root of\n * a negative value yiels NaN, except that the sqaure root of\n * '-0.0' is '-0.0'.\n *\/\nprimitive\n  fpSqrt : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p\n\n\/** Convert a floating point number to a rational.\nIt is an error to use this with infinity or NaN **\/\nprimitive\n  fpToRational : {e,p} ValidFloat e p =>\n    Float e p -> Rational\n\n\/** Convert a rational to a floating point number, using the\ngiven rounding mode, if the number cannot be represented exactly. *\/\nprimitive\n  fpFromRational : {e,p} ValidFloat e p =>\n    RoundingMode -> Rational -> Float e p\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/lib\/PrimeEC.cry","filetype":"cry","content":"module PrimeEC where\n\n\/**\n * The type of points of an elliptic curve in affine coordinates.\n * The coefficients are taken from the prime field 'Z p' with 'p > 3'.\n * This is intended to represent all the \"normal\" points\n * on the curve, which satisfy 'x^^3 == y^^2 - 3x + b', \n * for some curve parameter 'b'.  This type cannot represent\n * the special projective \"point at infinity\".\n *\/\ntype AffinePoint p =\n  { x : Z p\n  , y : Z p\n  }\n\n\/**\n * The type of points of an elliptic curve in (homogeneous)\n * projective coordinates.  The coefficients are taken from the\n * prime field 'Z p' with 'p > 3'. These points should be understood as\n * representatives of equivalence classes of points, where two representatives\n * 'S' and 'T' are equivalent iff one is a scalar multiple of the other. That\n * is, 'S' and 'T' are equivalent iff there exists some 'k' where\n * 'S.x == k*T.x \/\\ S.y == k*T.y \/\\ S.z == k*T.z'.  Finally, the\n * vector with all coordinates equal to 0 is excluded and does not\n * represent any point.\n *\n * Note that all the affine points are easily embedded into projective\n * coordinates by simply setting the `z` coordinate to 1, and the \"point at\n * infinity\" is represented by any point with 'z == 0'.  Further, for any\n * projective point with 'z != 0', we can compute the corresponding affine\n * point by simply multiplying the x and y coordinates by the inverse of z.\n *\/\ntype ProjectivePoint p =\n  { x : Z p\n  , y : Z p\n  , z : Z p\n  }\n\n\/**\n * 'ec_is_point_affine b S' checks that the supposed affine elliptic curve\n * point 'S' in fact lies on the curve defined by the curve parameter 'b'.  Here,\n * and throughout this module, we assume the curve parameter 'a' is equal to\n * '-3'.  Precisely, this function checks the following condition:\n *\n *     S.y^^2 == S.x^^3 - 3*S.x + b\n *\/\nec_is_point_affine : {p} (prime p, p > 3) => Z p -> AffinePoint p -> Bit\nec_is_point_affine b S = S.y^^2 == S.x^^3 - (3*S.x) + b\n\n\n\/**\n * 'ec_is_nonsingular' checks that the given curve parameter 'b' gives rise to\n * a non-singular elliptic curve, appropriate for use in ECC.\n *\n * Precisely, this checks that '4*a^^3 + 27*b^^2 != 0 mod p'.  Here, and\n * throughout this module, we assume 'a = -3'.\n *\/\nec_is_nonsingular : {p} (prime p, p > 3) => Z p -> Bit\nec_is_nonsingular b = (fromInteger 4) * a^^3 + (fromInteger 27) * b^^2 != 0\n  where a = -3 : Z p\n\n\/**\n * Returns true if the given point is the identity \"point at infinity.\"\n * This is true whenever the 'z' coordinate is 0, but one of the 'x' or\n * 'y' coordinates is nonzero.\n *\/\nec_is_identity : {p} (prime p, p > 3) => ProjectivePoint p -> Bit\nec_is_identity S = S.z == 0 \/\\ ~(S.x == 0 \/\\ S.y == 0)\n\n\/**\n * Test two projective points for equality, up to the equivalence relation\n * on projective points.\n *\/\nec_equal : {p} (prime p, p > 3) => ProjectivePoint p -> ProjectivePoint p -> Bit\nec_equal S T =\n  (S.z == 0 \/\\ T.z == 0) \\\/\n  (S.z != 0 \/\\ T.z != 0 \/\\ ec_affinify S == ec_affinify T)\n\n\/**\n * Compute a projective representative for the given affine point.\n *\/\nec_projectify : {p} (prime p, p > 3) => AffinePoint p -> ProjectivePoint p\nec_projectify R = { x = R.x, y = R.y, z = 1 }\n\n\/**\n * Compute the affine point corresponding to the given projective point.\n * This results in an error if the 'z' component of the given point is 0,\n * in which case there is no corresponding affine point.\n *\/\nec_affinify : {p} (prime p, p > 3) => ProjectivePoint p -> AffinePoint p\nec_affinify S =\n if S.z == 0 then error \"Cannot affinify the point at infinity\" else R\n    where\n      R = {x = lambda^^2 * S.x, y = lambda^^3 * S.y }\n      lambda = recip S.z\n\n\/**\n * Coerce an integer modulo 'p' to a bitvector. This will reduce the value\n * modulo '2^^a' if necessary.\n *\/\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = fromInteger (fromZ x)\n\n\/**\n * Coerce a bitvector value to an integer modulo 'p'.  This will\n * reduce the value modulo 'p' if necessary.\n *\/\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = fromInteger (toInteger x)\n\n\/**\n * Given a projective point 'S', compute '2S = S+S'.\n *\/\nprimitive ec_double : {p} (prime p, p > 3) =>\n  ProjectivePoint p -> ProjectivePoint p\n\n\/**\n * Given two projective points 'S' and 'T' where neither is the identity,\n * compute 'S+T'. If the points are not known to be distinct from the point\n * at infinity, use 'ec_add' instead.\n *\/\nprimitive ec_add_nonzero : {p} (prime p, p > 3) =>\n  ProjectivePoint p -> ProjectivePoint p -> ProjectivePoint p\n\n\/**\n * Given a projective point 'S', compute its negation, '-S'\n *\/\nec_negate : {p} (prime p, p > 3) => ProjectivePoint p -> ProjectivePoint p\nec_negate S = { x = S.x, y = -S.y, z = S.z }\n\n\/**\n * Given two projective points 'S' and 'T' compute 'S+T'.\n *\/\nec_add : {p} (prime p, p > 3) =>\n  ProjectivePoint p -> ProjectivePoint p -> ProjectivePoint p\nec_add S T =\n  if S.z == 0 then T\n   | T.z == 0 then S\n   else R\n where R = ec_add_nonzero S T\n\n\/**\n * Given two projective points 'S' and 'T' compute 'S-T'.\n *\/\nec_sub : {p} (prime p, p > 3) =>\n  ProjectivePoint p -> ProjectivePoint p -> ProjectivePoint p\nec_sub S T = ec_add S U\n where U = { x = T.x, y = -T.y, z = T.z }\n\n\/**\n * Given a scalar value 'k' and a projective point 'S', compute the\n * scalar multiplication 'kS'.\n *\/\nprimitive ec_mult : {p} (prime p, p > 3) =>\n  Z p -> ProjectivePoint p -> ProjectivePoint p\n\n\/**\n * Given a scalar value 'j' and a projective point 'S', and another scalar\n * value 'k' and point 'T', compute the \"twin\" scalar multiplication 'jS + kT'.\n *\/\nprimitive ec_twin_mult : {p} (prime p, p > 3) =>\n  Z p -> ProjectivePoint p -> Z p -> ProjectivePoint p -> ProjectivePoint p\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol\/lib\/Cryptol.cry","filetype":"cry","content":"module Cryptol where\n\ninfixr  5 ==>\ninfixr 10 \\\/\ninfixr 15 \/\\\ninfix  20 ==, ===, !=, !==\ninfix  30 >, >=, <, <=, <$, >$, <=$, >=$\ninfixr 40 ||\ninfixl 45 ^\ninfixr 50 &&\ninfixr 60 #\ninfixl 70 <<, <<<, >>, >>>, >>$\ninfixl 80 +, -\ninfixl 90 *, \/, %, \/$, %$, %^, \/^\ninfixr 95 ^^\ninfixl 100 @, @@, !, !!\n\n\n\/\/ Base types -----------------------------------------------------------------------\n\n\/** The type of boolean values. *\/\nprimitive type Bit : *\n\n\/** The type of unbounded integers. *\/\nprimitive type Integer : *\n\n\/**\n * 'Z n' is the type of integers, modulo 'n'.\n *\n * The values of 'Z n' may be thought of as equivalence\n * classes of integers according to the equivalence\n * 'x ~ y' iff 'n' divides 'x - y'.  'Z n' naturally\n * forms a ring, but does not support integral division\n * or indexing.\n *\n * However, you may use the 'fromZ' operation\n * to project values in 'Z n' into the integers if such operations\n * are required.  This will compute the reduced representative\n * of the equivalence class. In other words, 'fromZ' computes\n * the (unique) integer value 'i'  where '0 <= i < n' and\n * 'i' is in the given equivalence class.\n *\n * If the modulus 'n' is prime, 'Z n' also\n * supports computing inverses and forms a field.\n *\/\nprimitive type {n : #} (fin n, n >= 1) => Z n : *\n\n\/**\n * 'Rational' is the type of rational numbers.\n * Rational numbers form a Field (and thus a Ring).\n *\n * The 'ratio' operation may be used to directly create\n * rational values from as a ratio of integers, or\n * the 'fromInteger' method and the field operations\n * can be used.\n *\/\nprimitive type Rational : *\n\ntype Bool = Bit\ntype Word n = [n]\ntype Char = [8]\ntype String n = [n]Char\n\n\/\/ Numeric operators and constraints ----------------------------------------------\n\n\/** A numeric type representing infinity. *\/\nprimitive type inf : #\n\n\/** Assert that two numeric types are equal. *\/\nprimitive type (==) : # -> # -> Prop\n\n\/** Assert that two numeric types are different. *\/\nprimitive type (!=) : # -> # -> Prop\n\n\/** Assert that the first numeric type is larger than, or equal to the second.*\/\nprimitive type (>=) : # -> # -> Prop\n\n\/** Assert that a numeric type is a proper natural number (not 'inf'). *\/\nprimitive type fin : # -> Prop\n\n\/** Assert that a numeric type is a prime number. *\/\nprimitive type prime : # -> Prop\n\n\/** Add numeric types. *\/\nprimitive type (+) : # -> # -> #\n\n\/** Multiply numeric types. *\/\nprimitive type (*) : # -> # -> #\n\n\/** Subtract numeric types. *\/\nprimitive type\n  {m : #, n : # }\n  (fin n, m >= n) =>\n  m - n : #\n\n\/** Divide numeric types, rounding down. *\/\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m \/ n : #\n\n\/** Remainder of numeric type division. *\/\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m % n : #\n\n\/** Exponentiate numeric types. *\/\nprimitive type (^^) : # -> # -> #\n\n\/** The number of bits required to represent the value of a numeric type. *\/\nprimitive type width : # -> #\n\n\/**\n * The ceiling of the base-2 logarithm of a numeric type.\n * We define 'lg2 n = width (n - 1)' for nonzero n, and 'lg2 0 = 0'.\n *\/\ntype lg2 n = width (max n 1 - 1)\n\n\/** The smaller of two numeric types. *\/\nprimitive type min : # -> # -> #\n\n\/** The larger of two numeric types. *\/\nprimitive type max : # -> # -> #\n\n\/** Divide numeric types, rounding up. *\/\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m \/^ n : #\n\n\/** How much we need to add to make a proper multiple of the second argument. *\/\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m %^ n : #\n\n\/** The length of an enumeration. *\/\nprimitive type\n  { start : #, next : #, last : # }\n  (fin start, fin next, fin last, start != next) =>\n  lengthFromThenTo start next last : #\n\n\/**\n * Assert that the first numeric type is less than or equal to the second.\n *\/\ntype constraint i <= j = (j >= i)\n\n\/**\n * Assert that the first numeric type is greater than the second.\n *\/\ntype constraint i > j = i >= j + 1\n\n\/**\n * Assert that the first numeric type is less than the second.\n *\/\ntype constraint i < j = j >= i + 1\n\n\n\/\/ The Literal class ----------------------------------------------------\n\n\/** 'Literal n a' asserts that type 'a' contains the number 'n'. *\/\nprimitive type Literal : # -> * -> Prop\n\n\/**\n * 'LiteralLessThan n a' asserts that the type 'a' contains all the\n * natural numbers strictly below 'n'.  Note that we may have 'n = inf',\n * in which case the type 'a' must be unbounded.\n *\/\nprimitive type LiteralLessThan : # -> * -> Prop\n\n\/**\n * The value corresponding to a numeric type.\n *\/\nprimitive number : {val, rep} Literal val rep => rep\n\n\/**\n * An alternative name for 'number', present for backward compatibility.\n *\/\ndemote : {val, rep} Literal val rep => rep\ndemote = number`{val}\n\n\/**\n * Return the length of a sequence.  Note that the result depends only\n * on the type of the argument, not its value.\n *\/\nlength : {n, a, b} (fin n, Literal n b) => [n]a -> b\nlength _ = `n\n\n\/**\n * A finite sequence counting up from 'first' to 'last'.\n *\n * '[x .. y]' is syntactic sugar for 'fromTo`{first=x,last=y}'.\n *\/\nprimitive fromTo : {first, last, a}\n  (fin last, last >= first, Literal last a) =>\n  [1 + (last - first)]a\n\n\/**\n * A possibly infinite sequence counting up from 'first' up to (but not including) 'bound'.\n *\n * '[ x ..< y ]' is syntactic sugar for 'fromToLessThan`{first=x,bound=y}'.\n *\n * Note that if 'first' = 'bound' then the sequence will be empty.  If 'bound = inf'\n * then the sequence will be infinite, and will eventually wrap around for bounded types.\n *\/\nprimitive fromToLessThan :\n  {first, bound, a} (fin first, bound >= first, LiteralLessThan bound a) =>\n  [bound - first]a\n\n\/**\n * A finite sequence counting up from 'first' to 'last' by 'stride'.\n * Note that 'last' will only be an element of the enumeration if\n * 'stride' divides 'last - first' evenly.\n *\n * '[x .. y by n]' is syntactic sugar for 'fromToBy`{first=x,last=y,stride=n}'.\n *\/\nprimitive fromToBy : {first, last, stride, a}\n  (fin last, fin stride, stride >= 1, last >= first, Literal last a) =>\n  [1 + (last - first)\/stride]a\n\n\/**\n * A finite sequence counting from 'first' up to (but not including) 'bound'\n * by 'stride'.  Note that if 'first = bound' then the sequence will\n * be empty.  If 'bound = inf' then the sequence will be infinite, and will\n * eventually wrap around for bounded types.\n *\n * '[x ..< y by n]' is syntactic sugar for 'fromToByLessThan`{first=x,bound=y,stride=n}'.\n *\/\nprimitive fromToByLessThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, bound >= first, LiteralLessThan bound a) =>\n  [(bound - first)\/^stride]a\n\n\/**\n * A finite sequence counting from 'first' down to 'last' by 'stride'.\n * Note that 'last' will only be an element of the enumeration if\n * 'stride' divides 'first - last' evenly.\n *\n * '[x .. y down by n]' is syntactic sugar for 'fromToDownBy`{first=x,last=y,stride=n}'.\n *\/\nprimitive fromToDownBy : {first, last, stride, a}\n  (fin first, fin stride, stride >= 1, first >= last, Literal first a) =>\n  [1 + (first - last)\/stride]a\n\n\/**\n * A finite sequence counting from 'first' down to (but not including)\n * 'bound' by 'stride'.\n *\n * '[x ..> y down by n]' is syntactic sugar for\n * 'fromToDownByGreaterThan`{first=x,bound=y,stride=n}'.\n *\n * Note that if 'first = bound' the sequence will be empty.\n *\/\nprimitive fromToDownByGreaterThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, first >= bound, Literal first a) =>\n  [(first - bound)\/^stride]a\n\n\/**\n * A finite arithmetic sequence starting with 'first' and 'next',\n * stopping when the values reach or would skip over 'last'.\n *\n * '[x,y..z]' is syntactic sugar for 'fromThenTo`{first=x,next=y,last=z}'.\n *\/\nprimitive fromThenTo : {first, next, last, a, len}\n                       ( fin first, fin next, fin last\n                       , Literal first a, Literal next a, Literal last a\n                       , first != next\n                       , lengthFromThenTo first next last == len) => [len]a\n\n\/\/ Fractional Literals ---------------------\n\n\/** 'FLiteral m n r a' asserts that the type 'a' contains the\nfraction 'm\/n'.  The flag 'r' indicates if we should round ('r >= 1')\nor report an error if the number can't be represented exactly. *\/\nprimitive type FLiteral : # -> # -> # -> * -> Prop\n\n\/** A fractional literal corresponding to 'm\/n' *\/\nprimitive\n  fraction : { m, n, r, a } FLiteral m n r a => a\n\n\n\n\n\n\n\n\/\/ The Zero class -------------------------------------------------------\n\n\/** Value types that have a notion of 'zero'. *\/\nprimitive type Zero : * -> Prop\n\n\/**\n * Gives an arbitrary shaped value whose bits are all False.\n * ~zero likewise gives an arbitrary shaped value whose bits are all True.\n *\/\nprimitive zero : {a} (Zero a) => a\n\n\n\/\/ The Logic class ------------------------------------------------------\n\n\/** Value types that support logical operations. *\/\nprimitive type Logic : * -> Prop\n\n\/**\n * Logical 'and' over bits. Extends element-wise over sequences, tuples.\n *\/\nprimitive (&&) : {a} (Logic a) => a -> a -> a\n\n\/**\n * Logical 'or' over bits. Extends element-wise over sequences, tuples.\n *\/\nprimitive (||) : {a} (Logic a) => a -> a -> a\n\n\/**\n * Logical 'exclusive or' over bits. Extends element-wise over sequences, tuples.\n *\/\nprimitive (^) : {a} (Logic a) => a -> a -> a\n\n\/**\n * Bitwise complement. The prefix notation '~ x'\n * is syntactic sugar for 'complement x'.\n *\/\nprimitive complement : {a} (Logic a) => a -> a\n\n\n\/\/ The Ring class -------------------------------------------------------\n\n\/**\n * Value types that support ring addition and multiplication.\n *\n * Floating-point values are only approximately a ring, but\n * nonetheless inhabit this class.\n *\/\nprimitive type Ring : * -> Prop\n\n\/**\n * Converts an unbounded integer to a value in a Ring using the following rules:\n *   * to bitvector type [n]:\n *     the value is reduced modulo 2^^n,\n *   * to Z n:\n *     the value is reduced modulo n,\n *   * floating point types:\n *     the value is rounded to the nearest representable value,\n *   * sequences other than bitvectors:\n *     elements are computed by using `fromInteger` pointwise\n *     Example: (fromInteger 2 : [3][8]) === [ 0x02, 0x02, 0x02 ]\n *   * tuples and records:\n *     elements are computed by using `fromInteger` pointwise\n *     Example: (fromInteger 2 : (Integer,[3][8])) === (2, [ 0x2, 0x2, 0x2 ])\n *   * functions:\n *     a constant function returning `fromInteger` on the result type\n *\/\nprimitive fromInteger : {a} (Ring a) => Integer -> a\n\n\/**\n * Add two values.\n *  * For type [n], addition is modulo 2^^n.\n *  * Structured values are added element-wise.\n *\/\nprimitive (+) : {a} (Ring a) => a -> a -> a\n\n\/**\n * Subtract two values.\n *  * For type [n], subtraction is modulo 2^^n.\n *  * Structured values are subtracted element-wise.\n *  * Satisfies 'a - b = a + negate b'.\n * See also: 'negate'.\n *\/\nprimitive (-) : {a} (Ring a) => a -> a -> a\n\n\/**\n * Multiply two values.\n *  * For type [n], multiplication is modulo 2^^n.\n *  * Structured values are multiplied element-wise.\n *\/\nprimitive (*) : {a} (Ring a) => a -> a -> a\n\n\/**\n * Returns the additive inverse of its argument.\n * Over structured values, operates element-wise.\n * The prefix notation '- x' is syntactic sugar\n * for 'negate x'.\n *\n * Satisfies 'a + negate a = 0'.\n * Satisfies 'negate a = ~a + 1' for bitvector values.\n *\/\nprimitive negate : {a} (Ring a) => a -> a\n\n\n\/**\n * Value types that correspond to a segment of the\n * integers. These types support integer division and\n * modulus, indexing into sequences, and enumeration.\n *\/\nprimitive type Integral : * -> Prop\n\n\/**\n * Divide two values, rounding down (toward negative infinity).\n *  * For type [n], the arguments are treated as unsigned.\n *  * Division by zero is undefined.\n *\/\nprimitive (\/) : {a} (Integral a) => a -> a -> a\n\n\/**\n * Compute the remainder from dividing two values.\n *  * For type [n], the arguments are treated as unsigned.\n *  * Remainder of division by zero is undefined.\n *  * Satisfies 'x % y == x - (x \/ y) * y'.\n *\/\nprimitive (%) : {a} (Integral a) => a -> a -> a\n\n\/**\n * Converts a value of an integral type to an integer.\n *\/\nprimitive toInteger : {a} (Integral a) => a -> Integer\n\n\/**\n * Compute the exponentiation of a value in a ring.\n *  * For type [n], the exponent is treated as unsigned.\n *  * It is an error to raise a value to a negative integer exponent.\n *  * Satisfies: 'x ^^ 0 == fromInteger 1'\n *  * Satisfies: 'x ^^ e == x * x ^^ (e-1)' when 'e > 0'.\n *\/\nprimitive (^^) : {a, e} (Ring a, Integral e) => a -> e -> a\n\n\/**\n * An infinite sequence counting up from the given starting value.\n * '[x...]' is syntactic sugar for 'infFrom x'.\n *\/\nprimitive infFrom : {a} (Integral a) => a -> [inf]a\n\n\/**\n * An infinite arithmetic sequence starting with the given two values.\n * '[x,y...]' is syntactic sugar for 'infFromThen x y'.\n *\/\nprimitive infFromThen : {a} (Integral a) => a -> a -> [inf]a\n\n\n\/**\n * Value types that correspond to a field; that is,\n * a ring also possessing multiplicative inverses for\n * non-zero elements.\n *\n * Floating-point values are only approximately a field,\n * but nonetheless inhabit this class.\n *\/\nprimitive type Field : * -> Prop\n\n\/**\n * Reciprocal\n *\n * Compute the multiplicative inverse of an element of a field.\n * The reciprocal of 0 is undefined.\n *\/\nprimitive recip : {a} (Field a) => a -> a\n\n\/**\n * Field division\n *\n * The division operation in a field.\n * Satisfies 'x \/. y == x * (recip y)'\n *\n * Field division by 0 is undefined.\n *\/\nprimitive (\/.) : {a} (Field a) => a -> a -> a\n\n\n\/** Value types that can be rounded to integer values. *\/\nprimitive type Round : * -> Prop\n\n\/**\n * Ceiling function.\n *\n * Given 'x', compute the smallest integer 'i'\n * such that 'x <= i'.\n *\/\nprimitive ceiling : {a} (Round a) => a -> Integer\n\n\/**\n * Floor function.\n *\n * Given 'x', compute the largest integer 'i'\n * such that 'i <= x'.\n *\/\nprimitive floor : {a} (Round a) => a -> Integer\n\n\/**\n * Truncate the value toward 0.\n *\n * Given 'x' compute the nearest integer between\n * 'x' and 0.  For nonnegative 'x', this is floor,\n * and for negative 'x' this is ceiling.\n *\/\nprimitive trunc : {a} (Round a) => a -> Integer\n\n\/**\n * Round to the nearest integer, ties away from 0.\n *\n * Ties are broken away from 0.  For nonnegative 'x'\n * this is 'floor (x + 0.5)'.  For negative 'x' this\n * is 'ceiling (x - 0.5)'.\n *\/\nprimitive roundAway : {a} (Round a) => a -> Integer\n\n\/**\n * Round to the nearest integer, ties to even.\n *\n * Ties are broken to the nearest even integer.\n *\/\nprimitive roundToEven : {a} (Round a) => a -> Integer\n\n\n\/** Value types that support equality comparisons. *\/\nprimitive type Eq : * -> Prop\n\n\/**\n * Compares any two values of the same type for equality.\n *\/\nprimitive (==) : {a} (Eq a) => a -> a -> Bit\n\n\/**\n * Compares any two values of the same type for inequality.\n *\/\nprimitive (!=) : {a} (Eq a) => a -> a -> Bit\n\n\/**\n * Compare the outputs of two functions for equality.\n *\/\n(===) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf === g = \\ x -> f x == g x\n\n\/**\n * Compare the outputs of two functions for inequality.\n *\/\n(!==) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf !== g = \\x -> f x != g x\n\n\n\/** Value types that support equality and ordering comparisons. *\/\nprimitive type Cmp : * -> Prop\n\n\/**\n * Less-than. Only works on comparable arguments.\n *\n * Bitvectors are compared using unsigned arithmetic.\n *\/\nprimitive (<) : {a} (Cmp a) => a -> a -> Bit\n\n\/**\n * Greater-than of two comparable arguments.\n *\n * Bitvectors are compared using unsigned arithmetic.\n *\/\nprimitive (>) : {a} (Cmp a) => a -> a -> Bit\n\n\/**\n * Less-than or equal of two comparable arguments.\n *\n * Bitvectors are compared using unsigned arithmetic.\n *\/\nprimitive (<=) : {a} (Cmp a) => a -> a -> Bit\n\n\/**\n * Greater-than or equal of two comparable arguments.\n *\n * Bitvectors are compared using unsigned arithmetic.\n *\/\nprimitive (>=) : {a} (Cmp a) => a -> a -> Bit\n\n\/**\n * Returns the smaller of two comparable arguments.\n * Bitvectors are compared using unsigned arithmetic.\n *\/\nmin : {a} (Cmp a) => a -> a -> a\nmin x y = if x < y then x else y\n\n\/**\n * Returns the greater of two comparable arguments.\n * Bitvectors are compared using unsigned arithmetic.\n *\/\nmax : {a} (Cmp a) => a -> a -> a\nmax x y = if x > y then x else y\n\n\/**\n * Compute the absolute value of a value from an ordered ring.\n * Bitvector values are considered unsigned, so this is\n * the identity function on [n].\n *\/\nabs : {a} (Cmp a, Ring a) => a -> a\nabs x = if x < fromInteger 0 then negate x else x\n\n\n\/** Value types that support signed comparisons. *\/\nprimitive type SignedCmp : * -> Prop\n\n\/**\n * 2's complement signed less-than.\n *\/\nprimitive (<$) : {a} (SignedCmp a) => a -> a -> Bit\n\n\/**\n * 2's complement signed greater-than.\n *\/\n(>$) : {a} (SignedCmp a) => a -> a -> Bit\nx >$ y = y <$ x\n\n\/**\n * 2's complement signed less-than-or-equal.\n *\/\n(<=$) : {a} (SignedCmp a) => a -> a -> Bit\nx <=$ y = ~(y <$ x)\n\n\/**\n * 2's complement signed greater-than-or-equal.\n *\/\n(>=$) : {a} (SignedCmp a) => a -> a -> Bit\nx >=$ y = ~(x <$ y)\n\n\/**\n * The 'Option a' type represents an optional value. Every 'Option a' value is\n * either 'Some' and contains a value of type 'a', or 'None' and does not. Among\n * other uses, optional values are useful for modeling return values for partial\n * functions, i.e., functions that are not defined over their entire input\n * range. In these situations, 'None' can be used as a placeholder return value.\n *\/\nenum Option a = None | Some a\n\n\/**\n * Values of the 'Result t e' type can either be 'Ok', representing success and\n * containing a value of type 't', or 'Err', representing error and containing\n * an error value of type 'e'. Functions can return 'Result' whenever errors are\n * expected and recoverable. For instance, 'e' might be a 'String' with an error\n * message, or it might be an 'Integer' with an error code.\n *\/\nenum Result t e = Ok t | Err e\n\n\/**\n * The constant True. Corresponds to the bit value 1.\n *\/\nprimitive True  : Bit\n\n\/**\n * The constant False. Corresponds to the bit value 0.\n *\/\nprimitive False : Bit\n\n\/**\n * Short-cutting boolean conjunction function.\n * If the first argument is False, the second argument\n * is not evaluated.\n *\/\n(\/\\) : Bit -> Bit -> Bit\nx \/\\ y = if x then y else False\n\n\/**\n * Short-cutting boolean disjunction function.\n * If the first argument is True, the second argument\n * is not evaluated.\n *\/\n(\\\/) : Bit -> Bit -> Bit\nx \\\/ y = if x then True else y\n\n\/**\n * Short-cutting logical implication.\n * If the first argument is False, the second argument is\n * not evaluated.\n *\/\n(==>) : Bit -> Bit -> Bit\na ==> b = if a then b else True\n\n\n\/\/ Bitvector specific operations ----------------------------------\n\n\/**\n * 2's complement signed division.  Division rounds toward 0.\n *  Division by 0 is undefined.\n *\n *  * Satisfies 'x == x %$ y + (x \/$ y) * y' for 'y != 0'.\n *\/\nprimitive (\/$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\n\/**\n * 2's complement signed remainder.  Division rounds toward 0.\n * Division by 0 is undefined.  Satisfies the following for 'y != 0'\n *\n *  * 'x %$ y == x - (x \/$ y) * y'.\n *  * 'x >=$ 0 ==> x %$ y >=$ 0'\n *  * 'x <=$ 0 ==> x %$ y <=$ 0'\n *\/\nprimitive (%$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\n\/**\n * Unsigned carry.  Returns true if the unsigned addition of the given\n * bitvector arguments would result in an unsigned overflow.\n *\/\ncarry : {n} (fin n) => [n] -> [n] -> Bit\ncarry x y = (x + y) < x\n\n\/**\n * Signed carry.  Returns true if the 2's complement signed addition of the\n * given bitvector arguments would result in a signed overflow.\n *\/\nscarry : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nscarry x y = (sx == sy) && (sx != sz)\n  where\n    z  = x + y\n    sx = head x\n    sy = head y\n    sz = head z\n\n\/**\n * Signed borrow.  Returns true if the 2's complement signed subtraction of the\n * given bitvector arguments would result in a signed overflow.\n *\/\nsborrow : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsborrow x y = ( x <$ (x-y) ) ^ head y\n\n\/**\n * Zero extension of a bitvector.\n *\/\nzext : {m, n} (fin m, m >= n) => [n] -> [m]\nzext x = zero # x\n\n\/**\n * Sign extension of a bitvector.\n *\/\nsext : {m, n} (fin m, m >= n, n >= 1) => [n] -> [m]\nsext x = newbits # x\n  where newbits = if head x then ~zero else zero\n\n\/**\n * 2's complement signed (arithmetic) right shift.  The first argument\n * is the sequence to shift (considered as a signed value),\n * the second argument is the number of positions to shift\n * by (considered as an unsigned value).\n *\/\nprimitive (>>$) : {n, ix} (fin n, n >= 1, Integral ix) => [n] -> ix -> [n]\n\n\/**\n * The ceiling of the base-2 logarithm of an unsigned bitvector.\n * We set 'lg2 0 = 0'.\n *\/\nprimitive lg2 : {n} (fin n) => [n] -> [n]\n\n\/**\n * Convert a signed 2's complement bitvector to an integer.\n *\/\nprimitive toSignedInteger : {n} (fin n, n >= 1) => [n] -> Integer\n\n\n\/\/ Rational specific operations ----------------------------------------------\n\n\/**\n * Compute the ratio of two integers as a rational.\n * Ratio is undefined if the denominator is 0.\n *\n * 'ratio x y = (fromInteger x \/. fromInteger y) : Rational'\n *\/\nprimitive ratio : Integer -> Integer -> Rational\n\n\n\/\/ Zn specific operations ----------------------------------------------------\n\n\/**\n * Converts an integer modulo n to an unbounded integer in the range 0 to n-1.\n *\/\nprimitive fromZ : {n} (fin n, n >= 1) => Z n -> Integer\n\n\n\/\/ Sequence operations -------------------------------------------------------\n\n\/**\n * Concatenates two sequences.  On bitvectors, the most-significant bits\n * are in the left argument, and the least-significant bits are in the right.\n *\/\nprimitive (#) : {front, back, a} (fin front) => [front]a -> [back]a\n                                             -> [front + back] a\n\n\/**\n * Splits a sequence into a pair of sequences.\n * 'splitAt z = (x, y)' iff 'x # y = z'.\n *\/\nsplitAt : {front, back, a} (fin front) => [front + back]a\n                                       -> ([front]a, [back]a)\nsplitAt xs = (take`{front,back} xs, drop`{front,back} xs)\n\n\/**\n * Concatenates a list of sequences.\n * 'join' is the inverse function to 'split'.\n *\/\nprimitive join : {parts, each, a} (fin each) => [parts][each]a\n                                             -> [parts * each]a\n\n\/**\n * Splits a sequence into 'parts' groups with 'each' elements.\n * 'split' is the inverse function to 'join'.\n *\/\nprimitive split : {parts, each, a} (fin each) => [parts * each]a\n                                              -> [parts][each]a\n\n\/**\n * Reverses the elements in a sequence.\n *\/\nprimitive reverse : {n, a} (fin n) => [n]a -> [n]a\n\n\/**\n * Transposes a matrix.\n * Satisfies the property 'transpose m @ i @ j == m @ j @ i'.\n *\/\nprimitive transpose : {rows, cols, a} [rows][cols]a -> [cols][rows]a\n\n\/**\n * Select the first (left-most) 'front' elements of a sequence.\n *\/\nprimitive take : {front, back, a} [front + back]a -> [front]a\n\n\/**\n * Select all the elements after (to the right of) the 'front' elements of a sequence.\n *\/\nprimitive drop : {front, back, a} (fin front) => [front + back]a -> [back]a\n\n\/**\n * Drop the first (left-most) element of a sequence.\n *\/\ntail : {n, a} [1 + n]a -> [n]a\ntail xs = drop`{1} xs\n\n\/**\n * Return the first (left-most) element of a sequence.\n *\/\nhead : {n, a} [1 + n]a -> a\nhead xs = xs @ (0 : Integer)\n\n\/**\n * Return the right-most element of a sequence.\n *\/\nlast : {n, a} (fin n) => [1 + n]a -> a\nlast xs = xs ! (0 : Integer)\n\n\/**\n * Same as 'split', but with a different type argument order.\n * Take a sequence of elements and break it into 'parts' sequences\n * of 'each' elements.\n *\/\ngroupBy : {each, parts, a} (fin each) => [parts * each]a -> [parts][each]a\ngroupBy = split`{parts=parts}\n\n\/**\n * Left shift.  The first argument is the sequence to shift, the second is the\n * number of positions to shift by.\n *\/\nprimitive (<<) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\n\/**\n * Right shift.  The first argument is the sequence to shift, the second is the\n * number of positions to shift by.\n *\/\nprimitive (>>) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\n\/**\n * Left rotate.  The first argument is the sequence to rotate, the second is the\n * number of positions to rotate by.\n *\/\nprimitive (<<<) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\n\/**\n * Right rotate.  The first argument is the sequence to rotate, the second is\n * the number of positions to rotate by.\n *\/\nprimitive (>>>) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\n\/**\n * Index operator.  The first argument is a sequence.  The second argument is\n * the zero-based index of the element to select from the sequence.\n *\/\nprimitive (@) : {n, a, ix} (Integral ix) => [n]a -> ix -> a\n\n\/**\n * Bulk index operator.  The first argument is a sequence.  The second argument\n * is a sequence of the zero-based indices of the elements to select.\n *\/\n(@@) : {n, k, ix, a} (Integral ix) => [n]a -> [k]ix -> [k]a\nxs @@ is = [ xs @ i | i <- is ]\n\n\/**\n * Reverse index operator.  The first argument is a finite sequence.  The second\n * argument is the zero-based index of the element to select, starting from the\n * end of the sequence.\n *\/\nprimitive (!) : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a\n\n\/**\n * Bulk reverse index operator.  The first argument is a finite sequence.  The\n * second argument is a sequence of the zero-based indices of the elements to\n * select, starting from the end of the sequence.\n *\/\n(!!) : {n, k, ix, a} (fin n, Integral ix) => [n]a -> [k]ix -> [k]a\nxs !! is = [ xs ! i | i <- is ]\n\n\/**\n * Update the given sequence with new value at the given index position.\n * The first argument is a sequence. The second argument is the zero-based\n * index of the element to update, starting from the front of the sequence.\n * The third argument is the new element.  The return value is the\n * initial sequence updated so that the indicated index has the given value.\n *\/\nprimitive update : {n, a, ix} (Integral ix) => [n]a -> ix -> a -> [n]a\n\n\/**\n * Update the given sequence with new value at the given index position.\n * The first argument is a sequence. The second argument is the zero-based\n * index of the element to update, starting from the end of the sequence.\n * The third argument is the new element.  The return value is the\n * initial sequence updated so that the indicated index has the given value.\n *\/\nprimitive updateEnd : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a -> [n]a\n\n\/**\n * Perform a series of updates to a sequence.  The first argument is\n * the initial sequence to update.  The second argument is a sequence\n * of indices, and the third argument is a sequence of values.\n * This function applies the 'update' function in sequence with the\n * given update pairs.\n *\/\nupdates : {n, k, ix, a} (Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdates xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = update xs i b\n\n\/**\n * Perform a series of updates to a sequence.  The first argument is\n * the initial sequence to update.  The second argument is a sequence\n * of indices, and the third argument is a sequence of values.\n * This function applies the 'updateEnd' function in sequence with the\n * given update pairs.\n *\/\nupdatesEnd : {n, k, ix, a} (fin n, Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdatesEnd xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = updateEnd xs i b\n\n\/**\n * Produce a sequence using a generating function.\n * Satisfies 'generate f @ i == f i' for all 'i' between '0' and 'n-1'.\n *\n * Declarations of the form 'x @ i = e' are syntactic sugar for\n * 'x = generate (\\i -> e)'.\n *\/\ngenerate : {n, a, ix} (Integral ix, LiteralLessThan n ix) => (ix -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. <n] ]\n\n\n\/**\n * Sort a sequence of elements. Equivalent to 'sortBy (<=)'.\n *\/\nsort : {a, n} (Cmp a, fin n) => [n]a -> [n]a\nsort = sortBy (<=)\n\n\/**\n * Sort a sequence according to the given less-than-or-equal relation.\n * The sorting is stable, so it preserves the relative position of any\n * pair of elements that are equivalent according to the order relation.\n *\/\nsortBy : {a, n} (fin n) => (a -> a -> Bit) -> [n]a -> [n]a\nsortBy le ((xs : [n\/2]a) # (ys : [n\/^2]a)) = take zs.0\n  where\n    xs' = if `(n\/2)  == (1 : Integer) then xs else sortBy le xs\n    ys' = if `(n\/^2) == (1 : Integer) then ys else sortBy le ys\n    zs  = [ if i == `(n\/2)        then (ys'@j, i  , j+1)\n             | j == `(n\/^2)       then (xs'@i, i+1, j  )\n             | le (xs'@i) (ys'@j) then (xs'@i, i+1, j  )\n            else                       (ys'@j, i  , j+1)\n          | (_, i , j) <- [ (undefined, 0 : Integer, 0 : Integer) ] # zs\n          ]\n\n\/\/ GF_2^n polynomial computations -------------------------------------------\n\n\/**\n * Performs multiplication of polynomials over GF(2).\n *\/\nprimitive pmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\n\n\/**\n * Performs division of polynomials over GF(2).\n *\/\nprimitive pdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\n\n\/**\n * Performs modulus of polynomials over GF(2).\n *\/\nprimitive pmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\n\n\/\/ Experimental primitives ------------------------------------------------------------\n\n\/**\n * Parallel map.  The given function is applied to each element in the\n * given finite sequence, and the results are computed in parallel.\n * The values in the resulting sequence are reduced to normal form,\n * as is done with the deepseq operation.\n *\n * The Eq constraint restricts this operation to types\n * where reduction to normal form makes sense.\n *\n * This function is experimental.\n *\/\nprimitive parmap : {a, b, n} (Eq b, fin n) => (a -> b) -> [n]a -> [n]b\n\n\n\/\/ Utility operations -----------------------------------------------------------------\n\n\/**\n * A strictness-increasing operation.  The first operand\n * is reduced to normal form before evaluating the second\n * argument.\n *\n * The Eq constraint restricts this operation to types\n * where reduction to normal form makes sense.\n *\/\nprimitive deepseq : {a, b} Eq a => a -> b -> b\n\n\/**\n * Reduce to normal form.\n *\n * The Eq constraint restricts this operation to types\n * where reduction to normal form makes sense.\n *\/\nrnf : {a} Eq a => a -> a\nrnf x = deepseq x x\n\n\/**\n * Raise a run-time error with the given message.\n * This function can be called at any type.\n *\/\nprimitive error : {a, n} (fin n) => String n -> a\n\n\/**\n * Raise a run-time error with a generic message.\n * This function can be called at any type.\n *\/\nundefined : {a} a\nundefined = error \"undefined\"\n\n\/**\n * Assert that the given condition holds, and raise an error\n * with the given message if it does not.  If the condition\n * holds, return the third argument unchanged.\n *\/\nassert : {a, n} (fin n) => Bit -> String n -> a -> a\nassert pred msg x = if pred then x else error msg\n\n\/**\n * Generates random values from a seed.  When called with a function, currently\n * generates a function that always returns zero.\n *\/\nprimitive random : {a} [256] -> a\n\n\/**\n * Debugging function for tracing.  The first argument is a string,\n * which is prepended to the printed value of the second argument.\n * This combined string is then printed when the trace function is\n * evaluated.  The return value is equal to the third argument.\n *\n * The exact timing and number of times the trace message is printed\n * depend on the internal details of the Cryptol evaluation order,\n * which are unspecified.  Thus, the output produced by this\n * operation may be difficult to predict.\n *\/\nprimitive trace : {n, a, b} (fin n) => String n -> a -> b -> b\n\n\/**\n * Debugging function for tracing values.  The first argument is a string,\n * which is prepended to the printed value of the second argument.\n * This combined string is then printed when the trace function is\n * evaluated.  The return value is equal to the second argument.\n *\n * The exact timing and number of times the trace message is printed\n * depend on the internal details of the Cryptol evaluation order,\n * which are unspecified.  Thus, the output produced by this\n * operation may be difficult to predict.\n *\/\ntraceVal : {n, a} (fin n) => String n -> a -> a\ntraceVal msg x = trace msg x x\n\n\n\/* Functions previously in Cryptol::Extras *\/\n\n\/**\n * Conjunction of all bits in a sequence.\n *\/\nand : {n} (fin n) => [n]Bit -> Bit\nand xs = ~zero == xs\n\n\/**\n * Disjunction of all bits in a sequence.\n *\/\nor : {n} (fin n) => [n]Bit -> Bit\nor xs = zero != xs\n\n\/**\n * Conjunction after applying a predicate to all elements.\n *\/\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = foldl' (\/\\) True (map f xs)\n\n\/**\n * Disjunction after applying a predicate to all elements.\n *\/\nany : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = foldl' (\\\/) False (map f xs)\n\n\/**\n * Map a function over a sequence.\n *\/\nmap : {n, a, b} (a -> b) -> [n]a -> [n]b\nmap f xs = [f x | x <- xs]\n\n\/**\n * Functional left fold.\n *\n * foldl (+) 0 [1,2,3] = ((0 + 1) + 2) + 3\n *\/\nprimitive foldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\n\n\/**\n * Functional left fold, with strict evaluation of the accumulator value.\n * The accumulator is reduced to normal form at each step.  The Eq constraint\n * restricts the accumulator to types where reduction to normal form makes sense.\n *\n * foldl' (+) 0 [1,2,3] = ((0 + 1) + 2) + 3\n *\/\nprimitive foldl' : {n, a, b} (fin n, Eq a) => (a -> b -> a) -> a -> [n]b -> a\n\n\/**\n * Functional right fold.\n *\n * foldr (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs = foldl g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Functional right fold, with strict evaluation of the accumulator value.\n * The accumulator is reduced to weak head normal form at each step.\n *\n * foldr' (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr' : {n, a, b} (fin n, Eq b) => (a -> b -> b) -> b -> [n]a -> b\nfoldr' f acc xs = foldl' g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Compute the sum of the values in the sequence.\n *\/\nsum : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nsum xs = foldl' (+) (fromInteger 0) xs\n\n\/**\n * Compute the product of the values in the sequence.\n *\/\nproduct : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nproduct xs = foldl' (*) (fromInteger 1) xs\n\n\/**\n * Scan left is like a foldl that also emits the intermediate values.\n *\/\nprimitive scanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\n\n\/**\n * Scan right is like a foldr that also emits the intermediate values.\n *\/\nscanr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> [1+n]b\nscanr f acc xs = reverse (scanl (\\a b -> f b a) acc (reverse xs))\n\n\/**\n * Repeat a value.\n *\/\nrepeat : {n, a} a -> [n]a\nrepeat x = [ x | _ <- zero : [n] ]\n\n\/**\n * 'elem x xs' returns true if x is equal to a value in xs.\n *\/\nelem : {n, a} (fin n, Eq a) => a -> [n]a -> Bit\nelem a xs = any (\\x -> x == a) xs\n\n\/**\n * Create a list of tuples from two lists.\n *\/\nzip : {n, a, b} [n]a -> [n]b -> [n](a, b)\nzip xs ys = [(x,y) | x <- xs | y <- ys]\n\n\/**\n * Create a list by applying the function to each pair of elements in the input.\n *\/\nzipWith : {n, a, b, c} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]\n\n\/**\n * Transform a function into uncurried form.\n *\/\nuncurry : {a, b, c} (a -> b -> c) -> (a, b) -> c\nuncurry f = \\(a, b) -> f a b\n\n\/**\n * Transform a function into curried form.\n *\/\ncurry : {a, b, c} ((a, b) -> c) -> a -> b -> c\ncurry f = \\a b -> f (a, b)\n\n\/**\n * Map a function iteratively over a seed value, producing an infinite\n * list of successive function applications.\n *\/\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = scanl (\\x _ -> f x) z (zero:[inf]())\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/bench\/data\/SHA512.cry","filetype":"cry","content":"\/\/ Provided by @sdwelle as a performance regression in issue #269\n\nmodule SHA512 where\n\n\/*\nsha512 : {b, a} (a*1024 == 128 + b + 1 + 1024 - (b+129) % 1024,\n                 a*1024 % 1024 == 0,\n                 a * 1024 - b >= 129,\n                 2^^128 - 1 >= b,\n                 fin (a + 1)) => [b] -> [512]\n\n                 *\/\nsha512 M = result\n  where\n    M' = (pad M)\n    blocks = (groupBy`{1024} M')\n    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]\n    result = (join (hash!0))\n\nprocessBlock : [1024] -> [8][64] -> [8][64]\nprocessBlock block Hprev = Hs\n  where\n    Mi = split block : [16][64]\n    Ws = (messageSch Mi)\n    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]\n    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]\n\nstep : [8][64] -> [64] -> [8] -> [8][64]\nstep [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']\n  where\n    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt\n    T2 = (SIGMA0 a) + (Maj a b c)\n    h' = g\n    g' = f\n    f' = e\n    e' = d + T1\n    d' = c\n    c' = b\n    b' = a\n    a' = T1 + T2\n\nmessageSch : [16][64] -> [80][64]\nmessageSch Mi = W\n  where\n    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]\n\npad : {l, k} (fin l,\n              l <= ((2^^128) - 1),\n              l >= 0,\n              fin k,\n              k - l >= 129,\n              k == 128 + l + 1 + 1024 - ((l+129)%1024),\n              k%1024 == 0) => [l] -> [k]\npad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])\n\nCh : [64] -> [64] -> [64] -> [64]\nCh x y z = (x && y) ^ ((~x) && z)\n\nMaj : [64] -> [64] -> [64] -> [64]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nSIGMA0 : [64] -> [64]\nSIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA1 : [64] -> [64]\nSIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma0 : [64] -> [64]\nsigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma1 : [64] -> [64]\nsigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n\nH0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]\n\nK = [\n0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n]\n\n\nproperty testVector1 x = sha512 0xfd2203e467574e834ab07c9097ae164532f24be1eb5d88f1af7748ceff0d2c67a21f4e4097f9d3bb4e9fbf97186e0db6db0100230a52b453d421f8ab9c9a6043aa3295ea20d2f06a2f37470d8a99075f1b8a8336f6228cf08b5942fc1fb4299c7d2480e8e82bce175540bdfad7752bc95b577f229515394f3ae5cec870a4b2f8 == 0xa21b1077d52b27ac545af63b32746c6e3c51cb0cb9f281eb9f3580a6d4996d5c9917d2a6e484627a9d5a06fa1b25327a9d710e027387fc3e07d7c4d14c6086cc\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/rust\/cry-ffi\/Example.cry","filetype":"cry","content":"module Example where\n\nimport Float\n\nnewtype N = { unN : [8] }\n\nforeign abstract test_bool : Bit -> Bit\nforeign abstract test_u8 : [8] -> [8]\nforeign abstract test_u16 : [16] -> [16]\nforeign abstract test_u32 : [32] -> [32]\nforeign abstract test_u64 : [64] -> [64]\nforeign abstract test_u128 : [128] -> [128]\nforeign abstract test_i8 : [8] -> [8]\nforeign abstract test_i16 : [16] -> [16]\nforeign abstract test_i32 : [32] -> [32]\nforeign abstract test_i64 : [64] -> [64]\nforeign abstract test_i128 : [128] -> [128]\nforeign abstract test_integer : Integer -> Integer\nforeign abstract test_rational : Rational -> Rational\nforeign abstract test_float : Float32 -> Float32\nforeign abstract test_double : Float64 -> Float64\nforeign abstract test_array_16_u8 : [16][8] -> [16][8]\nforeign abstract test_record0 : {} -> {}\nforeign abstract test_record1_u8 : { x : [8] } -> { x : [8] }\nforeign abstract test_record2_u8_u16 : { x : [8], y : [16] } -> { x : [8], y : [16] }\nforeign abstract test_tuple0 : () -> ()\nforeign abstract test_tuple2_u8_u16 : ([8], [16]) -> ([8], [16])\nforeign abstract test_newtype_u8 : N -> N\nforeign abstract test_option_u8 : Option [8] -> Option [8]\nforeign abstract test_result_u16_u32 : Result [16] [32] -> Result [16] [32]\nforeign abstract test_two_u8_args : [8] -> [8] -> [8]\nforeign abstract test_two_u128_res : [128] -> ([128], [128])\nforeign abstract test_z7 : Z 7 -> Z 7\nforeign abstract test_param : {n} (fin n, n >= 1) => Z n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/T007.cry","filetype":"cry","content":"submodule F where\n  parameter\n    type n : #\n    x      : [n]\n    type constraint (fin n, n >= 4)\n\n  y : [n]\n  y = x + 11\n\n\nsubmodule I where\n  type n = 8\n  x = 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/enum\/CheckEnumPartialError.cry","filetype":"cry","content":"enum Maybe a = Nothing | Just a\n\nmaybeMapBad1 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad1 f m =\n  case m of\n    Just x -> Just (f x)\n\nmaybeMapBad2 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad2 f m =\n  case m of\n    Nothing -> Nothing\n\nenum Foo = A | B | C\n\nfooBad1 : Foo -> ()\nfooBad1 f =\n  case f of\n    A -> ()\n\nfooGood : Foo -> ()\nfooGood f =\n  case f of\n    A -> ()\n    _ -> ()\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/enum\/CheckProveEnum.cry","filetype":"cry","content":"enum Maybe a = Nothing | Just a\n\nmaybeEqual : {a} (Eq a) => Maybe a -> Maybe a -> Bit\nmaybeEqual m1 m2 =\n  case m1 of\n    Just x1 ->\n      case m2 of\n        Just x2 -> x1 == x2\n        Nothing -> False\n    Nothing ->\n      case m2 of\n        Just x2 -> False\n        Nothing -> True\n\nmaybeMap : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMap f m =\n  case m of\n    Just x  -> Just (f x)\n    Nothing -> Nothing\n\nmaybeMapProp : Maybe [8] -> Bit\nproperty maybeMapProp m =\n  maybeEqual\n    (maybeMap (\\x -> x + 1) (maybeMap (\\x -> x + 1) m))\n    (maybeMap (\\x -> x + 2) m)\n\nenum Either a b = Left a | Right b\n\neitherEqual : {a, b} (Eq a, Eq b) => Either a b -> Either a b -> Bit\neitherEqual e1 e2 =\n  case e1 of\n    Left x1 ->\n      case e2 of\n        Left x2  -> x1 == x2\n        Right y2 -> False\n    Right y1 ->\n      case e2 of\n        Left x2  -> False\n        Right y2 -> y1 == y2\n\neitherMapLeft : {a, a', b} (a -> a') -> Either a b -> Either a' b\neitherMapLeft f e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right y\n\neitherMapRight : {a, b, b'} (b -> b') -> Either a b -> Either a b'\neitherMapRight g e =\n  case e of\n    Left x  -> Left x\n    Right y -> Right (g y)\n\neitherMapBoth : {a, a', b, b'} (a -> a') -> (b -> b') -> Either a b -> Either a' b'\neitherMapBoth f g e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right (g y)\n\neitherMapProp : Either [8] [8] -> Bit\nproperty eitherMapProp e =\n  eitherEqual\n    (eitherMapLeft (\\x -> x + 1) (eitherMapRight (\\y -> y + 1) e))\n    (eitherMapBoth (\\x -> x + 1) (\\y -> y + 1) e)\n\nenum Foo a = Bar | Baz | Quux | Fred [8] a\n\nfooEqual : {a} (Eq a) => Foo a -> Foo a -> Bit\nfooEqual f1 f2 =\n  case f1 of\n    Bar ->\n      case f2 of\n        Bar        -> True\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> False\n    Baz ->\n      case f2 of\n        Bar        -> False\n        Baz        -> True\n        Quux       -> False\n        Fred y1 y2 -> False\n    Quux ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> True\n        Fred y1 y2 -> False\n    Fred x1 x2 ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> (x1 == y1) \/\\ (x2 == y2)\n\nfooMap : {a, b} (a -> b) -> Foo a -> Foo b\nfooMap f ff =\n  case ff of\n    Bar      -> Bar\n    Baz      -> Baz\n    Quux     -> Quux\n    Fred x y -> Fred x (f y)\n\nfooMapProp : Foo [8] -> Bit\nproperty fooMapProp f =\n  fooEqual\n    (fooMap (\\x -> x + 1) (fooMap (\\x -> x + 1) f))\n    (fooMap (\\x -> x + 2) f)\n\nenum Letter = A | B | C\n\nletterEqual : Letter -> Letter -> Bit\nletterEqual l1 l2 =\n  case l1 of\n    A ->\n      case l2 of\n        A -> True\n        B -> False\n        C -> False\n    B ->\n      case l2 of\n        A -> False\n        B -> True\n        C -> False\n    C ->\n      case l2 of\n        A -> False\n        B -> False\n        C -> True\n\nletterRotate : Letter -> Letter\nletterRotate l =\n  case l of\n    A -> B\n    B -> C\n    C -> A\n\nletterRotateProp : Letter -> Bit\nproperty letterRotateProp l =\n  letterEqual l (letterRotate (letterRotate (letterRotate l)))\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/parser\/tuples-records.cry","filetype":"cry","content":"\/\/ Tuples\ntuple           = (0xFF, 0xFF)\nnested_tuple1   = (0xFF, (0xFF,0xFF))\nnested_tupel2   = ((0xFF,0xFF), 0xFF)\nempty_tuple     = ()\n\n\/\/ Records\nrecord          = { x = 0xFF, y = 0xFF }\nnested_record   = { x = 0xFF, y = { x = 0xFF, y = 0xFF }}\nempty_records   = {}\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/parser\/docs.cry","filetype":"cry","content":"\/**\n * Test that doc strings work on signatures\n *\/\ntest1 : Bit\ntest1 = True\n\n\/**\n * Test that doc strings work on value bindings\n *\/\ntest2 = True\n\n\/**\n * Test that doc strings work on function bindings\n *\/\ntest3 x = x\n\n\/**\n * Test that doc strings work on property declarations\n *\/\nproperty test4 x = (x : Bit)\n\n\/**\n * Test that doc strings work on fixity declarations\n *\/\ninfixl 5 ++\n\n(++) : {a} a -> a -> a\nx ++ _ = x\n\n\/**\n * Test that doc strings are preserved on private declarations\n *\/\nprivate test5 = ()\n\n\n\/**\n * Test that doc strings are preserved on type synonyms\n *\/\ntype Foo = ()\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/parser\/T437.cry","filetype":"cry","content":"mk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n  \/\/ Change output when state has magic value.\n  fn' = fn + if k == magic then 1 else 0\n\ngenerate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. n-1] ]\n\ninfixl 1 $\nf $ x = f x\n\nfoo : [10][4]\nfoo = generate $ \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n\nbar : [10][4]\nbar = generate \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/parser\/unary.cry","filetype":"cry","content":"\/\/ test that the unary operators parse correctly\ntest1 = (~ (5 : [8]) + 2) == (~ (5 : [8])) + 2\ntest2 = (- (5 : [8]) + 2) == (- (5 : [8])) + 2\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/parser\/pat1.cry","filetype":"cry","content":"f1 (x,y) = x\nf2 (x # y) = x\nf3 [x,y,z] = x + y + z\nf4 {x = a, y = b } = a\nf5 ((x : [8]) # (y : [10])) = x # y : [10]\nf6 (x # y : [10]) = x\nf7 (x # (y : [10])) = x\n\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/parser\/infix-1.cry","filetype":"cry","content":"infixl 4 ++\ninfixl 5 **\n\n(++) : [8] -> [8] -> [8]\nx ++ y = x + y\n\n(**) : {a} (Ring a) => a -> a -> a\nx ** y = x * y\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/parser\/infix-2.cry","filetype":"cry","content":"import Cryptol as c\n\n\/**\n * Test that qualified infix operators work\n *\/\ntest1 = [c::True,c::False] c::+ [c::True,c::False] c::== c::zero\n\n\/**\n * Test that qualified operators used in prefix form work\n *\/\ntest2 = (c::+) c::zero [c::True] c::== [c::True]\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol\/tests\/parser\/applications.cry","filetype":"cry","content":"g x   = x\nf x y = y\n\napp1 = g 0xFF\napp2 = f 0xFF 0xFF\napp3 = 0xFF + 0xFF\napp4 = 0x01 + 0x02 + 0x03\napp5 = 0x01 + 0x02 * 0x03\napp6 = 0x01 * 0x02 + 0x03\napp7 = 0x01 * g 0xFF + 0x02\napp8 = f (0x01 * g 0xFF + 0x02) 0xFF\napp9 = g (g 0xFF)\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/suiteb\/aes-mct-ecb.cry","filetype":"cry","content":"import SuiteB\n\n\n\/\/ ***********************************************************************\n\/\/ ** Additional pseudorandom sample test vectors, using the ECB MCT test\n\/\/ ** https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/aes\/aesmct.zip\n\/\/ **\n\/\/ ** See AESAVS Section 6.4.1 for a description of the test algorithm\n\/\/ ***********************************************************************\n\ntype AESTestVector n =\n  { key        : [n]\n  , plaintext  : [128]\n  , ciphertext : [128]\n  }\n\n\nmct_ecb_encrypt_128 : [128] -> [128] -> [100](AESTestVector 128)\nmct_ecb_encrypt_128 initialKey initialPt = vs\n  where\n  vs@i = { key = keys@i, plaintext=pts@(i*1000), ciphertext=cts@(i*1000 + 999) }\n\n  pts : [100*1000][128]\n  pts = [initialPt] # take cts\n\n  cts : [100*1000][128]\n  cts@i = aesEncryptBlock (schedules@(i\/1000)) (pts@i)\n\n  keys : [100][128]\n  keys = [initialKey] # [ k ^ (xs!0)\n                        | xs <- take`{99} (groupBy`{1000} cts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESEncryptKeySchedule AES128)\n  schedules = map aes128EncryptSchedule keys\n\n\nmct_ecb_decrypt_128 : [128] -> [128] -> [100](AESTestVector 128)\nmct_ecb_decrypt_128 initialKey initialCt = vs\n  where\n  vs@i = { key = keys@i, ciphertext=cts@(i*1000), plaintext=pts@(i*1000 + 999) }\n\n  cts : [100*1000][128]\n  cts = [initialCt] # take pts\n\n  pts : [100*1000][128]\n  pts@i = aesDecryptBlock (schedules@(i\/1000)) (cts@i)\n\n  keys : [100][128]\n  keys = [initialKey] # [ k ^ (xs!0)\n                        | xs <- take`{99} (groupBy`{1000} pts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESDecryptKeySchedule AES128)\n  schedules = map aes128DecryptSchedule keys\n\nproperty aes128_MCT_vectors_encrypt_correct =\n  aes128_MCT_encrypt_test_vectors ==\n  mct_ecb_encrypt_128 0x139a35422f1d61de3c91787fe0507afd 0xb9145a768b7dc489a096b546f43b231f\n\nproperty aes128_MCT_vectors_decrypt_correct =\n  aes128_MCT_decrypt_test_vectors ==\n  mct_ecb_decrypt_128 0x0c60e7bf20ada9baa9e1ddf0d1540726 0xb08a29b11a500ea3aca42c36675b9785\n\naes128_MCT_encrypt_test_vectors : [100](AESTestVector 128)\naes128_MCT_encrypt_test_vectors =\n [{ key = 0x139a35422f1d61de3c91787fe0507afd\n  , plaintext = 0xb9145a768b7dc489a096b546f43b231f\n  , ciphertext = 0xd7c3ffac9031238650901e157364c386\n  },\n\n  { key = 0xc459caeebf2c42586c01666a9334b97b\n  , plaintext = 0xd7c3ffac9031238650901e157364c386\n  , ciphertext = 0xbc3637da2daf8fcf7c68bb28c143a0a4\n  },\n\n  { key = 0x786ffd349283cd971069dd42527719df\n  , plaintext = 0xbc3637da2daf8fcf7c68bb28c143a0a4\n  , ciphertext = 0x9c88a8db798f48df1ac4936afa959eac\n  },\n\n  { key = 0xe4e755efeb0c85480aad4e28a8e28773\n  , plaintext = 0x9c88a8db798f48df1ac4936afa959eac\n  , ciphertext = 0xb87aaa1c76a775d94c2ddf82abe5c66e\n  },\n\n  { key = 0x5c9dfff39dabf091468091aa0307411d\n  , plaintext = 0xb87aaa1c76a775d94c2ddf82abe5c66e\n  , ciphertext = 0x79ee212734f14d1bf5a59d46e8c2fa34\n  },\n\n  { key = 0x2573ded4a95abd8ab3250cecebc5bb29\n  , plaintext = 0x79ee212734f14d1bf5a59d46e8c2fa34\n  , ciphertext = 0x09df49135aeb8e373a19fa457ab280a0\n  },\n\n  { key = 0x2cac97c7f3b133bd893cf6a991773b89\n  , plaintext = 0x09df49135aeb8e373a19fa457ab280a0\n  , ciphertext = 0xc52263efa6379209d17e87ac250615cb\n  },\n\n  { key = 0xe98ef4285586a1b458427105b4712e42\n  , plaintext = 0xc52263efa6379209d17e87ac250615cb\n  , ciphertext = 0x336bed017e10a247ee92989862431163\n  },\n\n  { key = 0xdae519292b9603f3b6d0e99dd6323f21\n  , plaintext = 0x336bed017e10a247ee92989862431163\n  , ciphertext = 0xb13310581ffe5b10aaefdeb8992aec18\n  },\n\n  { key = 0x6bd60971346858e31c3f37254f18d339\n  , plaintext = 0xb13310581ffe5b10aaefdeb8992aec18\n  , ciphertext = 0xb0eaede3f3eebfef88822a6ede1950b1\n  },\n\n  { key = 0xdb3ce492c786e70c94bd1d4b91018388\n  , plaintext = 0xb0eaede3f3eebfef88822a6ede1950b1\n  , ciphertext = 0x37891fc253b00de13155d5517e1b7890\n  },\n\n  { key = 0xecb5fb509436eaeda5e8c81aef1afb18\n  , plaintext = 0x37891fc253b00de13155d5517e1b7890\n  , ciphertext = 0x8f574c85fa44af2d43c95ee5f627fc9d\n  },\n\n  { key = 0x63e2b7d56e7245c0e62196ff193d0785\n  , plaintext = 0x8f574c85fa44af2d43c95ee5f627fc9d\n  , ciphertext = 0x6c0af6709225f328a0225b2280efa3e3\n  },\n\n  { key = 0x0fe841a5fc57b6e84603cddd99d2a466\n  , plaintext = 0x6c0af6709225f328a0225b2280efa3e3\n  , ciphertext = 0xe2dc36073fe192e712373a8702e8adce\n  },\n\n  { key = 0xed3477a2c3b6240f5434f75a9b3a09a8\n  , plaintext = 0xe2dc36073fe192e712373a8702e8adce\n  , ciphertext = 0x1e91d1e1f82f1d320186210a792f7ba1\n  },\n\n  { key = 0xf3a5a6433b99393d55b2d650e2157209\n  , plaintext = 0x1e91d1e1f82f1d320186210a792f7ba1\n  , ciphertext = 0x228eac74166da261d7fa83f43d9ddd2f\n  },\n\n  { key = 0xd12b0a372df49b5c824855a4df88af26\n  , plaintext = 0x228eac74166da261d7fa83f43d9ddd2f\n  , ciphertext = 0x25d0de6a894361a1b83d5fa2fd607f26\n  },\n\n  { key = 0xf4fbd45da4b7fafd3a750a0622e8d000\n  , plaintext = 0x25d0de6a894361a1b83d5fa2fd607f26\n  , ciphertext = 0x36095dc3e659ec50ca7f6f8207d20031\n  },\n\n  { key = 0xc2f2899e42ee16adf00a6584253ad031\n  , plaintext = 0x36095dc3e659ec50ca7f6f8207d20031\n  , ciphertext = 0x8dbfe965078468875d86145164c4ab4f\n  },\n\n  { key = 0x4f4d60fb456a7e2aad8c71d541fe7b7e\n  , plaintext = 0x8dbfe965078468875d86145164c4ab4f\n  , ciphertext = 0x4032bb8137d4b9eb93644359a995bb4e\n  },\n\n  { key = 0x0f7fdb7a72bec7c13ee8328ce86bc030\n  , plaintext = 0x4032bb8137d4b9eb93644359a995bb4e\n  , ciphertext = 0x85308aa92c625a25bd5f4a40375c6baa\n  },\n\n  { key = 0x8a4f51d35edc9de483b778ccdf37ab9a\n  , plaintext = 0x85308aa92c625a25bd5f4a40375c6baa\n  , ciphertext = 0x73283fc59e04e80a867e478d97a3f388\n  },\n\n  { key = 0xf9676e16c0d875ee05c93f4148945812\n  , plaintext = 0x73283fc59e04e80a867e478d97a3f388\n  , ciphertext = 0x418c1fe377e4ef9832f20286b167f916\n  },\n\n  { key = 0xb8eb71f5b73c9a76373b3dc7f9f3a104\n  , plaintext = 0x418c1fe377e4ef9832f20286b167f916\n  , ciphertext = 0x60ad1341525e67cffdd68ff671253c77\n  },\n\n  { key = 0xd84662b4e562fdb9caedb23188d69d73\n  , plaintext = 0x60ad1341525e67cffdd68ff671253c77\n  , ciphertext = 0x4edf6e01a76de6153d17713a49d5b028\n  },\n\n  { key = 0x96990cb5420f1bacf7fac30bc1032d5b\n  , plaintext = 0x4edf6e01a76de6153d17713a49d5b028\n  , ciphertext = 0x2c85ebf9e3d80596f78712df56ac77cd\n  },\n\n  { key = 0xba1ce74ca1d71e3a007dd1d497af5a96\n  , plaintext = 0x2c85ebf9e3d80596f78712df56ac77cd\n  , ciphertext = 0x8fc8ef9ab7462712977e87c741795ece\n  },\n\n  { key = 0x35d408d61691392897035613d6d60458\n  , plaintext = 0x8fc8ef9ab7462712977e87c741795ece\n  , ciphertext = 0x37e9ac800cfb19133b4e9b0c418ca098\n  },\n\n  { key = 0x023da4561a6a203bac4dcd1f975aa4c0\n  , plaintext = 0x37e9ac800cfb19133b4e9b0c418ca098\n  , ciphertext = 0xcb7cd7619caa605e45f95f5b31a85495\n  },\n\n  { key = 0xc941733786c04065e9b49244a6f2f055\n  , plaintext = 0xcb7cd7619caa605e45f95f5b31a85495\n  , ciphertext = 0x6e265e5fd030847b8841bf6652996392\n  },\n\n  { key = 0xa7672d6856f0c41e61f52d22f46b93c7\n  , plaintext = 0x6e265e5fd030847b8841bf6652996392\n  , ciphertext = 0x5c9a7d2ce1c86f0b3425b3b6aae108e0\n  },\n\n  { key = 0xfbfd5044b738ab1555d09e945e8a9b27\n  , plaintext = 0x5c9a7d2ce1c86f0b3425b3b6aae108e0\n  , ciphertext = 0xc911dee5ff318a7e799f92daadcb3d9a\n  },\n\n  { key = 0x32ec8ea14809216b2c4f0c4ef341a6bd\n  , plaintext = 0xc911dee5ff318a7e799f92daadcb3d9a\n  , ciphertext = 0x7a3afdf10410f1c47c7d928d4a8d432a\n  },\n\n  { key = 0x48d673504c19d0af50329ec3b9cce597\n  , plaintext = 0x7a3afdf10410f1c47c7d928d4a8d432a\n  , ciphertext = 0xc681b7b6d3ec9dc91012e3b7427c67ad\n  },\n\n  { key = 0x8e57c4e69ff54d6640207d74fbb0823a\n  , plaintext = 0xc681b7b6d3ec9dc91012e3b7427c67ad\n  , ciphertext = 0xcd3f84bbe958536d502065eb37ae10b4\n  },\n\n  { key = 0x4368405d76ad1e0b1000189fcc1e928e\n  , plaintext = 0xcd3f84bbe958536d502065eb37ae10b4\n  , ciphertext = 0x879db797e686b9116c25c07f4ae67593\n  },\n\n  { key = 0xc4f5f7ca902ba71a7c25d8e086f8e71d\n  , plaintext = 0x879db797e686b9116c25c07f4ae67593\n  , ciphertext = 0x5959ebd7a1167713429eda69538c536b\n  },\n\n  { key = 0x9dac1c1d313dd0093ebb0289d574b476\n  , plaintext = 0x5959ebd7a1167713429eda69538c536b\n  , ciphertext = 0xf57101d7fa19f97a31d60b276312717c\n  },\n\n  { key = 0x68dd1dcacb2429730f6d09aeb666c50a\n  , plaintext = 0xf57101d7fa19f97a31d60b276312717c\n  , ciphertext = 0x6dfbbc2b147568c55adbfdc3c706edb0\n  },\n\n  { key = 0x0526a1e1df5141b655b6f46d716028ba\n  , plaintext = 0x6dfbbc2b147568c55adbfdc3c706edb0\n  , ciphertext = 0x9c4ea9002306d75e7b0f03e2a72b7a1d\n  },\n\n  { key = 0x996808e1fc5796e82eb9f78fd64b52a7\n  , plaintext = 0x9c4ea9002306d75e7b0f03e2a72b7a1d\n  , ciphertext = 0xcb9975336cc05f0114f26bde4cc84f8d\n  },\n\n  { key = 0x52f17dd29097c9e93a4b9c519a831d2a\n  , plaintext = 0xcb9975336cc05f0114f26bde4cc84f8d\n  , ciphertext = 0x902c4250cff110d792938e8dcd534cf0\n  },\n\n  { key = 0xc2dd3f825f66d93ea8d812dc57d051da\n  , plaintext = 0x902c4250cff110d792938e8dcd534cf0\n  , ciphertext = 0x140242f195ef2ef7f6ee23574c071311\n  },\n\n  { key = 0xd6df7d73ca89f7c95e36318b1bd742cb\n  , plaintext = 0x140242f195ef2ef7f6ee23574c071311\n  , ciphertext = 0x3c6d4ffafde866f1e994480c47d20a04\n  },\n\n  { key = 0xeab2328937619138b7a279875c0548cf\n  , plaintext = 0x3c6d4ffafde866f1e994480c47d20a04\n  , ciphertext = 0x1ca04a21addc38ef8bfc8989d3d6b33b\n  },\n\n  { key = 0xf61278a89abda9d73c5ef00e8fd3fbf4\n  , plaintext = 0x1ca04a21addc38ef8bfc8989d3d6b33b\n  , ciphertext = 0xbb8875ee3c3c8c0987b1c20f999028e9\n  },\n\n  { key = 0x4d9a0d46a68125debbef32011643d31d\n  , plaintext = 0xbb8875ee3c3c8c0987b1c20f999028e9\n  , ciphertext = 0x9d33724d80a76f2033a37a851403ef28\n  },\n\n  { key = 0xd0a97f0b26264afe884c488402403c35\n  , plaintext = 0x9d33724d80a76f2033a37a851403ef28\n  , ciphertext = 0x4c92fe152d16da8ea59b9f29c75f20ff\n  },\n\n  { key = 0x9c3b811e0b3090702dd7d7adc51f1cca\n  , plaintext = 0x4c92fe152d16da8ea59b9f29c75f20ff\n  , ciphertext = 0x659c76f73032b0192b281034b6a99a3f\n  },\n\n  { key = 0xf9a7f7e93b02206906ffc79973b686f5\n  , plaintext = 0x659c76f73032b0192b281034b6a99a3f\n  , ciphertext = 0x5d296637697ccad84fc77936a31c2655\n  },\n\n  { key = 0xa48e91de527eeab14938beafd0aaa0a0\n  , plaintext = 0x5d296637697ccad84fc77936a31c2655\n  , ciphertext = 0xa72a596a030d5541bc4d0fc739491d5b\n  },\n\n  { key = 0x03a4c8b45173bff0f575b168e9e3bdfb\n  , plaintext = 0xa72a596a030d5541bc4d0fc739491d5b\n  , ciphertext = 0x5f5ec53c91225717fcba470688dfa364\n  },\n\n  { key = 0x5cfa0d88c051e8e709cff66e613c1e9f\n  , plaintext = 0x5f5ec53c91225717fcba470688dfa364\n  , ciphertext = 0x5719cb14eba820c0d51109a0c7a4154f\n  },\n\n  { key = 0x0be3c69c2bf9c827dcdeffcea6980bd0\n  , plaintext = 0x5719cb14eba820c0d51109a0c7a4154f\n  , ciphertext = 0x3abd186712a9def73b6312b5300f02af\n  },\n\n  { key = 0x315edefb395016d0e7bded7b9697097f\n  , plaintext = 0x3abd186712a9def73b6312b5300f02af\n  , ciphertext = 0xb1e90c8c0d4c9651a6de7f52a63ac456\n  },\n\n  { key = 0x80b7d277341c80814163922930adcd29\n  , plaintext = 0xb1e90c8c0d4c9651a6de7f52a63ac456\n  , ciphertext = 0x5d26e33aae1441554034c77bde451679\n  },\n\n  { key = 0xdd91314d9a08c1d401575552eee8db50\n  , plaintext = 0x5d26e33aae1441554034c77bde451679\n  , ciphertext = 0x93e44cdce14803544a53bc5b520c156f\n  },\n\n  { key = 0x4e757d917b40c2804b04e909bce4ce3f\n  , plaintext = 0x93e44cdce14803544a53bc5b520c156f\n  , ciphertext = 0x8ee3b6fd953b441043f69f3747e4cf63\n  },\n\n  { key = 0xc096cb6cee7b869008f2763efb00015c\n  , plaintext = 0x8ee3b6fd953b441043f69f3747e4cf63\n  , ciphertext = 0xcb2f545970200630e5145f817a013807\n  },\n\n  { key = 0x0bb99f359e5b80a0ede629bf8101395b\n  , plaintext = 0xcb2f545970200630e5145f817a013807\n  , ciphertext = 0x50047276451ce19cb14d8d2ef0b3851b\n  },\n\n  { key = 0x5bbded43db47613c5caba49171b2bc40\n  , plaintext = 0x50047276451ce19cb14d8d2ef0b3851b\n  , ciphertext = 0xd243791dde33c2a4333ef4dcbcadbd3a\n  },\n\n  { key = 0x89fe945e0574a3986f95504dcd1f017a\n  , plaintext = 0xd243791dde33c2a4333ef4dcbcadbd3a\n  , ciphertext = 0x343181860092a5e33c2e1c441a9f6804\n  },\n\n  { key = 0xbdcf15d805e6067b53bb4c09d780697e\n  , plaintext = 0x343181860092a5e33c2e1c441a9f6804\n  , ciphertext = 0x4e7cdd553d732909e25a13a521e04078\n  },\n\n  { key = 0xf3b3c88d38952f72b1e15facf6602906\n  , plaintext = 0x4e7cdd553d732909e25a13a521e04078\n  , ciphertext = 0x9c16f3fda49bb6a2b6d76a6696bd768f\n  },\n\n  { key = 0x6fa53b709c0e99d0073635ca60dd5f89\n  , plaintext = 0x9c16f3fda49bb6a2b6d76a6696bd768f\n  , ciphertext = 0x9eb63f9099123591a4ca7aa0fff55a49\n  },\n\n  { key = 0xf11304e0051cac41a3fc4f6a9f2805c0\n  , plaintext = 0x9eb63f9099123591a4ca7aa0fff55a49\n  , ciphertext = 0xaa6a9e40aad692550b7c87b92b205af0\n  },\n\n  { key = 0x5b799aa0afca3e14a880c8d3b4085f30\n  , plaintext = 0xaa6a9e40aad692550b7c87b92b205af0\n  , ciphertext = 0xae92c267f38b9b4623df36523bb739b6\n  },\n\n  { key = 0xf5eb58c75c41a5528b5ffe818fbf6686\n  , plaintext = 0xae92c267f38b9b4623df36523bb739b6\n  , ciphertext = 0x39c0de843767dfa2d563c0632405d595\n  },\n\n  { key = 0xcc2b86436b267af05e3c3ee2abbab313\n  , plaintext = 0x39c0de843767dfa2d563c0632405d595\n  , ciphertext = 0x80a9445be75373b07476608feb1f1c7b\n  },\n\n  { key = 0x4c82c2188c7509402a4a5e6d40a5af68\n  , plaintext = 0x80a9445be75373b07476608feb1f1c7b\n  , ciphertext = 0x5306f5a77e42d9f4cee8f134ba1448c6\n  },\n\n  { key = 0x1f8437bff237d0b4e4a2af59fab1e7ae\n  , plaintext = 0x5306f5a77e42d9f4cee8f134ba1448c6\n  , ciphertext = 0x8db0c3fba7dc797cd175d97503759260\n  },\n\n  { key = 0x9234f44455eba9c835d7762cf9c475ce\n  , plaintext = 0x8db0c3fba7dc797cd175d97503759260\n  , ciphertext = 0x04fcb0c77ae0c98d2afb178ab2c2b02d\n  },\n\n  { key = 0x96c844832f0b60451f2c61a64b06c5e3\n  , plaintext = 0x04fcb0c77ae0c98d2afb178ab2c2b02d\n  , ciphertext = 0x1a156581b3557078971cc6877a3d9339\n  },\n\n  { key = 0x8cdd21029c5e103d8830a721313b56da\n  , plaintext = 0x1a156581b3557078971cc6877a3d9339\n  , ciphertext = 0xe47087289290fa2b6734eeaab2fc815d\n  },\n\n  { key = 0x68ada62a0eceea16ef04498b83c7d787\n  , plaintext = 0xe47087289290fa2b6734eeaab2fc815d\n  , ciphertext = 0x00ce641525020d35244e2227287b2a20\n  },\n\n  { key = 0x6863c23f2bcce723cb4a6bacabbcfda7\n  , plaintext = 0x00ce641525020d35244e2227287b2a20\n  , ciphertext = 0xecf623cef1e420d0994070c078592c97\n  },\n\n  { key = 0x8495e1f1da28c7f3520a1b6cd3e5d130\n  , plaintext = 0xecf623cef1e420d0994070c078592c97\n  , ciphertext = 0x256c8f28df4a286fb05514fcfa8cbcaf\n  },\n\n  { key = 0xa1f96ed90562ef9ce25f0f9029696d9f\n  , plaintext = 0x256c8f28df4a286fb05514fcfa8cbcaf\n  , ciphertext = 0xfd4aed4b5a2b8edefe3cc2aef6ecd298\n  },\n\n  { key = 0x5cb383925f4961421c63cd3edf85bf07\n  , plaintext = 0xfd4aed4b5a2b8edefe3cc2aef6ecd298\n  , ciphertext = 0xdfe0e571f77f0b46c52f003e774918ac\n  },\n\n  { key = 0x835366e3a8366a04d94ccd00a8cca7ab\n  , plaintext = 0xdfe0e571f77f0b46c52f003e774918ac\n  , ciphertext = 0xe421fbeb4c23745b97578162f89e68fc\n  },\n\n  { key = 0x67729d08e4151e5f4e1b4c625052cf57\n  , plaintext = 0xe421fbeb4c23745b97578162f89e68fc\n  , ciphertext = 0xc38c0bbde031d1a79438f79ff7cc68a5\n  },\n\n  { key = 0xa4fe96b50424cff8da23bbfda79ea7f2\n  , plaintext = 0xc38c0bbde031d1a79438f79ff7cc68a5\n  , ciphertext = 0x86113133968aa3052709875bf033d804\n  },\n\n  { key = 0x22efa78692ae6cfdfd2a3ca657ad7ff6\n  , plaintext = 0x86113133968aa3052709875bf033d804\n  , ciphertext = 0xfd706bef1bf30c8d1e95543b75629e02\n  },\n\n  { key = 0xdf9fcc69895d6070e3bf689d22cfe1f4\n  , plaintext = 0xfd706bef1bf30c8d1e95543b75629e02\n  , ciphertext = 0x9a5bbb6125152f1352b10e1c1a172aa6\n  },\n\n  { key = 0x45c47708ac484f63b10e668138d8cb52\n  , plaintext = 0x9a5bbb6125152f1352b10e1c1a172aa6\n  , ciphertext = 0x3ee69736488c51fa72784aa263618f45\n  },\n\n  { key = 0x7b22e03ee4c41e99c3762c235bb94417\n  , plaintext = 0x3ee69736488c51fa72784aa263618f45\n  , ciphertext = 0xfc66daa246ebcc320c7c89b599014633\n  },\n\n  { key = 0x87443a9ca22fd2abcf0aa596c2b80224\n  , plaintext = 0xfc66daa246ebcc320c7c89b599014633\n  , ciphertext = 0x35645885ed205d67e5caeff26646c38c\n  },\n\n  { key = 0xb22062194f0f8fcc2ac04a64a4fec1a8\n  , plaintext = 0x35645885ed205d67e5caeff26646c38c\n  , ciphertext = 0xdaeaa866aa4eacdb752caccb2c0ae6c1\n  },\n\n  { key = 0x68caca7fe54123175fece6af88f42769\n  , plaintext = 0xdaeaa866aa4eacdb752caccb2c0ae6c1\n  , ciphertext = 0x29e88b1ae615fcd06b09e767459d6089\n  },\n\n  { key = 0x412241650354dfc734e501c8cd6947e0\n  , plaintext = 0x29e88b1ae615fcd06b09e767459d6089\n  , ciphertext = 0x63470bff052e7f5c7a735cc2e6eb61ac\n  },\n\n  { key = 0x22654a9a067aa09b4e965d0a2b82264c\n  , plaintext = 0x63470bff052e7f5c7a735cc2e6eb61ac\n  , ciphertext = 0xf4fa6a3549cd2b33af9cac134d7b1402\n  },\n\n  { key = 0xd69f20af4fb78ba8e10af11966f9324e\n  , plaintext = 0xf4fa6a3549cd2b33af9cac134d7b1402\n  , ciphertext = 0x5b22a82ccbae9b9c75f797e74e6da53d\n  },\n\n  { key = 0x8dbd88838419103494fd66fe28949773\n  , plaintext = 0x5b22a82ccbae9b9c75f797e74e6da53d\n  , ciphertext = 0x87b51692f8f28743bd8dc843276f351a\n  },\n\n  { key = 0x0a089e117ceb97772970aebd0ffba269\n  , plaintext = 0x87b51692f8f28743bd8dc843276f351a\n  , ciphertext = 0x150fb2180704a7623a1fab8bf17fba18\n  },\n\n  { key = 0x1f072c097bef3015136f0536fe841871\n  , plaintext = 0x150fb2180704a7623a1fab8bf17fba18\n  , ciphertext = 0x8088874e7f3f09a98fd3f0a59f2a0b4b\n  },\n\n  { key = 0x9f8fab4704d039bc9cbcf59361ae133a\n  , plaintext = 0x8088874e7f3f09a98fd3f0a59f2a0b4b\n  , ciphertext = 0x08e02c091057d81c05d917ea5c07cdd0\n  },\n\n  { key = 0x976f874e1487e1a09965e2793da9deea\n  , plaintext = 0x08e02c091057d81c05d917ea5c07cdd0\n  , ciphertext = 0xb9636b3e2752694c3685872fd0a9a0ea\n  },\n\n  { key = 0x2e0cec7033d588ecafe06556ed007e00\n  , plaintext = 0xb9636b3e2752694c3685872fd0a9a0ea\n  , ciphertext = 0x2610dae2b64d74a8cbb4f43fa2d0a603\n  },\n\n  { key = 0x081c36928598fc44645491694fd0d803\n  , plaintext = 0x2610dae2b64d74a8cbb4f43fa2d0a603\n  , ciphertext = 0x9cc994eda697fb5545eaa502b2a30fd3\n  },\n\n  { key = 0x94d5a27f230f071121be346bfd73d7d0\n  , plaintext = 0x9cc994eda697fb5545eaa502b2a30fd3\n  , ciphertext = 0xfb2649694783b551eacd9d5db6126d47\n  }]\n\n\naes128_MCT_decrypt_test_vectors : [100](AESTestVector 128)\naes128_MCT_decrypt_test_vectors =\n [{ key = 0x0c60e7bf20ada9baa9e1ddf0d1540726\n  , ciphertext = 0xb08a29b11a500ea3aca42c36675b9785\n  , plaintext = 0xb613b87085fed1bb87f07a574e6d2879\n  },\n\n  { key = 0xba735fcfa55378012e11a7a79f392f5f\n  , ciphertext = 0xb613b87085fed1bb87f07a574e6d2879\n  , plaintext = 0x5541d7bf6d25c55c0c2296acba756e9e\n  },\n\n  { key = 0xef328870c876bd5d2233310b254c41c1\n  , ciphertext = 0x5541d7bf6d25c55c0c2296acba756e9e\n  , plaintext = 0x4c138198d55d0d87d43cdb92fb0b5fc0\n  },\n\n  { key = 0xa32109e81d2bb0daf60fea99de471e01\n  , ciphertext = 0x4c138198d55d0d87d43cdb92fb0b5fc0\n  , plaintext = 0x257c07bdcba57aff1643de90b63c0a88\n  },\n\n  { key = 0x865d0e55d68eca25e04c3409687b1489\n  , ciphertext = 0x257c07bdcba57aff1643de90b63c0a88\n  , plaintext = 0x8039be4e65d218d3e640f88309d01c6f\n  },\n\n  { key = 0x0664b01bb35cd2f6060ccc8a61ab08e6\n  , ciphertext = 0x8039be4e65d218d3e640f88309d01c6f\n  , plaintext = 0x0115dcd390855bf5ce32e946a6d5ad38\n  },\n\n  { key = 0x07716cc823d98903c83e25ccc77ea5de\n  , ciphertext = 0x0115dcd390855bf5ce32e946a6d5ad38\n  , plaintext = 0x71741ccb723348c7f3f9e4a397977bdb\n  },\n\n  { key = 0x7605700351eac1c43bc7c16f50e9de05\n  , ciphertext = 0x71741ccb723348c7f3f9e4a397977bdb\n  , plaintext = 0x668c9f3dc9e154bd16d61364a99f635d\n  },\n\n  { key = 0x1089ef3e980b95792d11d20bf976bd58\n  , ciphertext = 0x668c9f3dc9e154bd16d61364a99f635d\n  , plaintext = 0x124b19b2501a540066ddf7943417cba3\n  },\n\n  { key = 0x02c2f68cc811c1794bcc259fcd6176fb\n  , ciphertext = 0x124b19b2501a540066ddf7943417cba3\n  , plaintext = 0x23e7c95f7ed9017af339c234b7a8fcc4\n  },\n\n  { key = 0x21253fd3b6c8c003b8f5e7ab7ac98a3f\n  , ciphertext = 0x23e7c95f7ed9017af339c234b7a8fcc4\n  , plaintext = 0x7b0e1e1afe46c1e50785efb939f8ade3\n  },\n\n  { key = 0x5a2b21c9488e01e6bf700812433127dc\n  , ciphertext = 0x7b0e1e1afe46c1e50785efb939f8ade3\n  , plaintext = 0xc166aeebf5182c96d1f3c92cece9d714\n  },\n\n  { key = 0x9b4d8f22bd962d706e83c13eafd8f0c8\n  , ciphertext = 0xc166aeebf5182c96d1f3c92cece9d714\n  , plaintext = 0x71968762dc1b41bebd9ee8b2396b87be\n  },\n\n  { key = 0xeadb0840618d6cced31d298c96b37776\n  , ciphertext = 0x71968762dc1b41bebd9ee8b2396b87be\n  , plaintext = 0x77b0aa88222a785282352bb861ea0cd2\n  },\n\n  { key = 0x9d6ba2c843a7149c51280234f7597ba4\n  , ciphertext = 0x77b0aa88222a785282352bb861ea0cd2\n  , plaintext = 0xe65c461cba6957fe5b5ee5014c899e65\n  },\n\n  { key = 0x7b37e4d4f9ce43620a76e735bbd0e5c1\n  , ciphertext = 0xe65c461cba6957fe5b5ee5014c899e65\n  , plaintext = 0xa799870cee001551f3494bdf3c27bd94\n  },\n\n  { key = 0xdcae63d817ce5633f93facea87f75855\n  , ciphertext = 0xa799870cee001551f3494bdf3c27bd94\n  , plaintext = 0xf54697576153f97d9fb1a4d164a8538e\n  },\n\n  { key = 0x29e8f48f769daf4e668e083be35f0bdb\n  , ciphertext = 0xf54697576153f97d9fb1a4d164a8538e\n  , plaintext = 0xf3f1f964b98b3498898c3032e44a308c\n  },\n\n  { key = 0xda190debcf169bd6ef02380907153b57\n  , ciphertext = 0xf3f1f964b98b3498898c3032e44a308c\n  , plaintext = 0x40ccc3a26141900280a3a7b62d4ed8b6\n  },\n\n  { key = 0x9ad5ce49ae570bd46fa19fbf2a5be3e1\n  , ciphertext = 0x40ccc3a26141900280a3a7b62d4ed8b6\n  , plaintext = 0x7fcf64bd75808be6199f3fac0881d4d4\n  },\n\n  { key = 0xe51aaaf4dbd78032763ea01322da3735\n  , ciphertext = 0x7fcf64bd75808be6199f3fac0881d4d4\n  , plaintext = 0x11ca970c169315ff0b54ecdb00ba4547\n  },\n\n  { key = 0xf4d03df8cd4495cd7d6a4cc822607272\n  , ciphertext = 0x11ca970c169315ff0b54ecdb00ba4547\n  , plaintext = 0xbc02615754b58eb975c26190a3583d28\n  },\n\n  { key = 0x48d25caf99f11b7408a82d5881384f5a\n  , ciphertext = 0xbc02615754b58eb975c26190a3583d28\n  , plaintext = 0x5b12925c7f72aaafbae6834a6e9d5af9\n  },\n\n  { key = 0x13c0cef3e683b1dbb24eae12efa515a3\n  , ciphertext = 0x5b12925c7f72aaafbae6834a6e9d5af9\n  , plaintext = 0x7950ffe2537235bfaa38101c2a9e6d42\n  },\n\n  { key = 0x6a903111b5f184641876be0ec53b78e1\n  , ciphertext = 0x7950ffe2537235bfaa38101c2a9e6d42\n  , plaintext = 0xcdf5c997d8ddcc1de7cc47ecc47d0819\n  },\n\n  { key = 0xa765f8866d2c4879ffbaf9e2014670f8\n  , ciphertext = 0xcdf5c997d8ddcc1de7cc47ecc47d0819\n  , plaintext = 0x8f4d77bccc4858016b28c2e8f84dd9a3\n  },\n\n  { key = 0x28288f3aa164107894923b0af90ba95b\n  , ciphertext = 0x8f4d77bccc4858016b28c2e8f84dd9a3\n  , plaintext = 0x561d95847869cccc81df7df65d70808d\n  },\n\n  { key = 0x7e351abed90ddcb4154d46fca47b29d6\n  , ciphertext = 0x561d95847869cccc81df7df65d70808d\n  , plaintext = 0x17b9e6f86ec1cff22cc6f8e14072bb0f\n  },\n\n  { key = 0x698cfc46b7cc1346398bbe1de40992d9\n  , ciphertext = 0x17b9e6f86ec1cff22cc6f8e14072bb0f\n  , plaintext = 0x8f959f24fae93418c2262ec73c6c8e1d\n  },\n\n  { key = 0xe61963624d25275efbad90dad8651cc4\n  , ciphertext = 0x8f959f24fae93418c2262ec73c6c8e1d\n  , plaintext = 0x2876f3a90b7a60168869d9de1e455836\n  },\n\n  { key = 0xce6f90cb465f474873c44904c62044f2\n  , ciphertext = 0x2876f3a90b7a60168869d9de1e455836\n  , plaintext = 0x5c609c0acdf2e389f19b3e0657706c9c\n  },\n\n  { key = 0x920f0cc18bada4c1825f77029150286e\n  , ciphertext = 0x5c609c0acdf2e389f19b3e0657706c9c\n  , plaintext = 0x88f537f67481490d20b713ff48b079e5\n  },\n\n  { key = 0x1afa3b37ff2cedcca2e864fdd9e0518b\n  , ciphertext = 0x88f537f67481490d20b713ff48b079e5\n  , plaintext = 0x0b1878fc9406b6c5f2c0085e8c9e0dd9\n  },\n\n  { key = 0x11e243cb6b2a5b0950286ca3557e5c52\n  , ciphertext = 0x0b1878fc9406b6c5f2c0085e8c9e0dd9\n  , plaintext = 0x594b9df3bad040afa14e63298945068d\n  },\n\n  { key = 0x48a9de38d1fa1ba6f1660f8adc3b5adf\n  , ciphertext = 0x594b9df3bad040afa14e63298945068d\n  , plaintext = 0xfcf5ffafacc372e641b1520fe76d16c7\n  },\n\n  { key = 0xb45c21977d396940b0d75d853b564c18\n  , ciphertext = 0xfcf5ffafacc372e641b1520fe76d16c7\n  , plaintext = 0x67319b7ab394937244b93977ba06c1ee\n  },\n\n  { key = 0xd36dbaedceadfa32f46e64f281508df6\n  , ciphertext = 0x67319b7ab394937244b93977ba06c1ee\n  , plaintext = 0xd956a31188a667eea44c93582d6aed6f\n  },\n\n  { key = 0x0a3b19fc460b9ddc5022f7aaac3a6099\n  , ciphertext = 0xd956a31188a667eea44c93582d6aed6f\n  , plaintext = 0x04f18289308787f3d936dd2a45c49e22\n  },\n\n  { key = 0x0eca9b75768c1a2f89142a80e9fefebb\n  , ciphertext = 0x04f18289308787f3d936dd2a45c49e22\n  , plaintext = 0xc925df60f455b0e27852efcf9fddc3d0\n  },\n\n  { key = 0xc7ef441582d9aacdf146c54f76233d6b\n  , ciphertext = 0xc925df60f455b0e27852efcf9fddc3d0\n  , plaintext = 0x14c3bcf83483de973d975dbf249c505e\n  },\n\n  { key = 0xd32cf8edb65a745accd198f052bf6d35\n  , ciphertext = 0x14c3bcf83483de973d975dbf249c505e\n  , plaintext = 0xa5f3f4afd0d01b9f4999d27e6386e925\n  },\n\n  { key = 0x76df0c42668a6fc585484a8e31398410\n  , ciphertext = 0xa5f3f4afd0d01b9f4999d27e6386e925\n  , plaintext = 0xd94451374478c1bdb4b94eb6908a205e\n  },\n\n  { key = 0xaf9b5d7522f2ae7831f10438a1b3a44e\n  , ciphertext = 0xd94451374478c1bdb4b94eb6908a205e\n  , plaintext = 0x9f3c6ed40a32c89d4ee8d4b87c8298c7\n  },\n\n  { key = 0x30a733a128c066e57f19d080dd313c89\n  , ciphertext = 0x9f3c6ed40a32c89d4ee8d4b87c8298c7\n  , plaintext = 0x54aa57cf75650cf6b7ccbd7202469bf7\n  },\n\n  { key = 0x640d646e5da56a13c8d56df2df77a77e\n  , ciphertext = 0x54aa57cf75650cf6b7ccbd7202469bf7\n  , plaintext = 0x11bc0be20465848934c0fd7d7ced8bd1\n  },\n\n  { key = 0x75b16f8c59c0ee9afc15908fa39a2caf\n  , ciphertext = 0x11bc0be20465848934c0fd7d7ced8bd1\n  , plaintext = 0x69d48f1ca39977f1c05f8cabd5f7e4ac\n  },\n\n  { key = 0x1c65e090fa59996b3c4a1c24766dc803\n  , ciphertext = 0x69d48f1ca39977f1c05f8cabd5f7e4ac\n  , plaintext = 0x2e447e6121162382c182b3efb27b2d5a\n  },\n\n  { key = 0x32219ef1db4fbae9fdc8afcbc416e559\n  , ciphertext = 0x2e447e6121162382c182b3efb27b2d5a\n  , plaintext = 0x3d99d0dff0891c38bec01551b4040e55\n  },\n\n  { key = 0x0fb84e2e2bc6a6d14308ba9a7012eb0c\n  , ciphertext = 0x3d99d0dff0891c38bec01551b4040e55\n  , plaintext = 0x92294ba363ed5b750c066cb6708620ee\n  },\n\n  { key = 0x9d91058d482bfda44f0ed62c0094cbe2\n  , ciphertext = 0x92294ba363ed5b750c066cb6708620ee\n  , plaintext = 0xcb674decffaae472d3d0710935b02aae\n  },\n\n  { key = 0x56f64861b78119d69cdea7253524e14c\n  , ciphertext = 0xcb674decffaae472d3d0710935b02aae\n  , plaintext = 0x47cd6a4b2f9b3d610d2bd3fe39feec91\n  },\n\n  { key = 0x113b222a981a24b791f574db0cda0ddd\n  , ciphertext = 0x47cd6a4b2f9b3d610d2bd3fe39feec91\n  , plaintext = 0x65b0b926a5b5b67f6895af42441f106b\n  },\n\n  { key = 0x748b9b0c3daf92c8f960db9948c51db6\n  , ciphertext = 0x65b0b926a5b5b67f6895af42441f106b\n  , plaintext = 0x3642fd59024efb3dc4e5bb268dd9de04\n  },\n\n  { key = 0x42c966553fe169f53d8560bfc51cc3b2\n  , ciphertext = 0x3642fd59024efb3dc4e5bb268dd9de04\n  , plaintext = 0x4e5d32a0e40dd9b830af0c2904518906\n  },\n\n  { key = 0x0c9454f5dbecb04d0d2a6c96c14d4ab4\n  , ciphertext = 0x4e5d32a0e40dd9b830af0c2904518906\n  , plaintext = 0x40a7ff6a6d0ea135245d5b24a0004466\n  },\n\n  { key = 0x4c33ab9fb6e21178297737b2614d0ed2\n  , ciphertext = 0x40a7ff6a6d0ea135245d5b24a0004466\n  , plaintext = 0xb18e6d37f5292acd1eaeee742930952a\n  },\n\n  { key = 0xfdbdc6a843cb3bb537d9d9c6487d9bf8\n  , ciphertext = 0xb18e6d37f5292acd1eaeee742930952a\n  , plaintext = 0x42df9c23bfbc90b787c5cb0dc08e80dc\n  },\n\n  { key = 0xbf625a8bfc77ab02b01c12cb88f31b24\n  , ciphertext = 0x42df9c23bfbc90b787c5cb0dc08e80dc\n  , plaintext = 0x589af99abbba45318106d2c1ca7b82b0\n  },\n\n  { key = 0xe7f8a31147cdee33311ac00a42889994\n  , ciphertext = 0x589af99abbba45318106d2c1ca7b82b0\n  , plaintext = 0x96f54a5bacec995c0263226cd443f2c6\n  },\n\n  { key = 0x710de94aeb21776f3379e26696cb6b52\n  , ciphertext = 0x96f54a5bacec995c0263226cd443f2c6\n  , plaintext = 0x84e07ce717c747cb924e42cdf6ec6524\n  },\n\n  { key = 0xf5ed95adfce630a4a137a0ab60270e76\n  , ciphertext = 0x84e07ce717c747cb924e42cdf6ec6524\n  , plaintext = 0x5140a66d02867ddfa8bb014f75d53b83\n  },\n\n  { key = 0xa4ad33c0fe604d7b098ca1e415f235f5\n  , ciphertext = 0x5140a66d02867ddfa8bb014f75d53b83\n  , plaintext = 0xa1570dc8605d7d68f0a2416aa2c3536a\n  },\n\n  { key = 0x05fa3e089e3d3013f92ee08eb731669f\n  , ciphertext = 0xa1570dc8605d7d68f0a2416aa2c3536a\n  , plaintext = 0x96ab8bd9091a703a6e6d1a2190f0b5c9\n  },\n\n  { key = 0x9351b5d1972740299743faaf27c1d356\n  , ciphertext = 0x96ab8bd9091a703a6e6d1a2190f0b5c9\n  , plaintext = 0x8418c2cec9d7cc3825152790f120488f\n  },\n\n  { key = 0x1749771f5ef08c11b256dd3fd6e19bd9\n  , ciphertext = 0x8418c2cec9d7cc3825152790f120488f\n  , plaintext = 0x7973673755c8201ec52bdec30a86191f\n  },\n\n  { key = 0x6e3a10280b38ac0f777d03fcdc6782c6\n  , ciphertext = 0x7973673755c8201ec52bdec30a86191f\n  , plaintext = 0x2a92ba991755f3c6ad1ef58681ac3a12\n  },\n\n  { key = 0x44a8aab11c6d5fc9da63f67a5dcbb8d4\n  , ciphertext = 0x2a92ba991755f3c6ad1ef58681ac3a12\n  , plaintext = 0xe3daa0cfe79594311762ca0d39985da2\n  },\n\n  { key = 0xa7720a7efbf8cbf8cd013c776453e576\n  , ciphertext = 0xe3daa0cfe79594311762ca0d39985da2\n  , plaintext = 0x5c2ea8b0b4bd7b50b48abd7df8e716f2\n  },\n\n  { key = 0xfb5ca2ce4f45b0a8798b810a9cb4f384\n  , ciphertext = 0x5c2ea8b0b4bd7b50b48abd7df8e716f2\n  , plaintext = 0xf15e39a11ed397378b6de3d62bde10c2\n  },\n\n  { key = 0x0a029b6f5196279ff2e662dcb76ae346\n  , ciphertext = 0xf15e39a11ed397378b6de3d62bde10c2\n  , plaintext = 0xd16879ee2fe2c07703e7eba3e093e911\n  },\n\n  { key = 0xdb6ae2817e74e7e8f101897f57f90a57\n  , ciphertext = 0xd16879ee2fe2c07703e7eba3e093e911\n  , plaintext = 0x57aac9d12da681f1ef4fc3d07269e159\n  },\n\n  { key = 0x8cc02b5053d266191e4e4aaf2590eb0e\n  , ciphertext = 0x57aac9d12da681f1ef4fc3d07269e159\n  , plaintext = 0xf6472d8a7d288db2262d826ff2f806ee\n  },\n\n  { key = 0x7a8706da2efaebab3863c8c0d768ede0\n  , ciphertext = 0xf6472d8a7d288db2262d826ff2f806ee\n  , plaintext = 0xd3ec20ae3257192d51f2ce4e73f87e53\n  },\n\n  { key = 0xa96b26741cadf2866991068ea49093b3\n  , ciphertext = 0xd3ec20ae3257192d51f2ce4e73f87e53\n  , plaintext = 0xd99891b245282641fb9e91681fce7ee1\n  },\n\n  { key = 0x70f3b7c65985d4c7920f97e6bb5eed52\n  , ciphertext = 0xd99891b245282641fb9e91681fce7ee1\n  , plaintext = 0x8f2fa0031baacb388ed7da3e7fd62828\n  },\n\n  { key = 0xffdc17c5422f1fff1cd84dd8c488c57a\n  , ciphertext = 0x8f2fa0031baacb388ed7da3e7fd62828\n  , plaintext = 0x80bed13ad5aebb0783629b03af2f6897\n  },\n\n  { key = 0x7f62c6ff9781a4f89fbad6db6ba7aded\n  , ciphertext = 0x80bed13ad5aebb0783629b03af2f6897\n  , plaintext = 0xfac43dfa16d393580f130b8a955339a6\n  },\n\n  { key = 0x85a6fb05815237a090a9dd51fef4944b\n  , ciphertext = 0xfac43dfa16d393580f130b8a955339a6\n  , plaintext = 0x60aa3f3683346b09466f1c4c11b376f5\n  },\n\n  { key = 0xe50cc43302665ca9d6c6c11def47e2be\n  , ciphertext = 0x60aa3f3683346b09466f1c4c11b376f5\n  , plaintext = 0xe93ac158da113797bce2472240c4d7bb\n  },\n\n  { key = 0x0c36056bd8776b3e6a24863faf833505\n  , ciphertext = 0xe93ac158da113797bce2472240c4d7bb\n  , plaintext = 0xe96e8432e2eea1de7e0cceadfe5e1623\n  },\n\n  { key = 0xe55881593a99cae01428489251dd2326\n  , ciphertext = 0xe96e8432e2eea1de7e0cceadfe5e1623\n  , plaintext = 0xd99630cb34f06a3a02e9803a029980a2\n  },\n\n  { key = 0x3cceb1920e69a0da16c1c8a85344a384\n  , ciphertext = 0xd99630cb34f06a3a02e9803a029980a2\n  , plaintext = 0xe5a14b334430768edf5dd7863ee30678\n  },\n\n  { key = 0xd96ffaa14a59d654c99c1f2e6da7a5fc\n  , ciphertext = 0xe5a14b334430768edf5dd7863ee30678\n  , plaintext = 0x49dab0bc5fb8c387ea9c557d3a35e659\n  },\n\n  { key = 0x90b54a1d15e115d323004a53579243a5\n  , ciphertext = 0x49dab0bc5fb8c387ea9c557d3a35e659\n  , plaintext = 0x6867e956763a7377a15a4248ab91c829\n  },\n\n  { key = 0xf8d2a34b63db66a4825a081bfc038b8c\n  , ciphertext = 0x6867e956763a7377a15a4248ab91c829\n  , plaintext = 0x4f536383ba4e258dd3ab764027a66e39\n  },\n\n  { key = 0xb781c0c8d995432951f17e5bdba5e5b5\n  , ciphertext = 0x4f536383ba4e258dd3ab764027a66e39\n  , plaintext = 0xe9b6abc089286834eb9421e71fe98517\n  },\n\n  { key = 0x5e376b0850bd2b1dba655fbcc44c60a2\n  , ciphertext = 0xe9b6abc089286834eb9421e71fe98517\n  , plaintext = 0x256121dead70e6675ad631dd0527fb1a\n  },\n\n  { key = 0x7b564ad6fdcdcd7ae0b36e61c16b9bb8\n  , ciphertext = 0x256121dead70e6675ad631dd0527fb1a\n  , plaintext = 0x6bdbcc94ec6497445e4024acb601741b\n  },\n\n  { key = 0x108d864211a95a3ebef34acd776aefa3\n  , ciphertext = 0x6bdbcc94ec6497445e4024acb601741b\n  , plaintext = 0x44e86f9d48c6699554a3538eb6f55479\n  },\n\n  { key = 0x5465e9df596f33abea501943c19fbbda\n  , ciphertext = 0x44e86f9d48c6699554a3538eb6f55479\n  , plaintext = 0xc7c622fee00a180f3131a57a82acf7a9\n  },\n\n  { key = 0x93a3cb21b9652ba4db61bc3943334c73\n  , ciphertext = 0xc7c622fee00a180f3131a57a82acf7a9\n  , plaintext = 0xe096b0406e6e8abb6ced353f1be40693\n  },\n\n  { key = 0x73357b61d70ba11fb78c890658d74ae0\n  , ciphertext = 0xe096b0406e6e8abb6ced353f1be40693\n  , plaintext = 0x73326251dbd89c23b37caee2ee6d2d9e\n  },\n\n  { key = 0x000719300cd33d3c04f027e4b6ba677e\n  , ciphertext = 0x73326251dbd89c23b37caee2ee6d2d9e\n  , plaintext = 0x7b2c687d460054af03709645056407c6\n  },\n\n  { key = 0x7b2b714d4ad369930780b1a1b3de60b8\n  , ciphertext = 0x7b2c687d460054af03709645056407c6\n  , plaintext = 0x8bb9f381438145a96714e238a8864e0b\n  },\n\n  { key = 0xf09282cc09522c3a609453991b582eb3\n  , ciphertext = 0x8bb9f381438145a96714e238a8864e0b\n  , plaintext = 0xd59509d08bcfc30e20344b1c4c53f726\n  },\n\n  { key = 0x25078b1c829def3440a01885570bd995\n  , ciphertext = 0xd59509d08bcfc30e20344b1c4c53f726\n  , plaintext = 0x02e6077d01a352637899d6ce626782ac\n  },\n\n  { key = 0x27e18c61833ebd573839ce4b356c5b39\n  , ciphertext = 0x02e6077d01a352637899d6ce626782ac\n  , plaintext = 0xed01d9601145c11662986b0827e403ec\n  },\n\n  { key = 0xcae05501927b7c415aa1a543128858d5\n  , ciphertext = 0xed01d9601145c11662986b0827e403ec\n  , plaintext = 0x7d5b1ca06884b5a55e9035fe7d77d4a7\n  },\n\n  { key = 0xb7bb49a1faffc9e4043190bd6fff8c72\n  , ciphertext = 0x7d5b1ca06884b5a55e9035fe7d77d4a7\n  , plaintext = 0x1a23d371b97e1056e8bc9545c56cab9e\n  },\n\n  { key = 0xad989ad04381d9b2ec8d05f8aa9327ec\n  , ciphertext = 0x1a23d371b97e1056e8bc9545c56cab9e\n  , plaintext = 0xd1d2bfdc58ffcad2341b095bce55221e\n  }]\n\n\nmct_ecb_encrypt_192 : [192] -> [128] -> [100](AESTestVector 192)\nmct_ecb_encrypt_192 initialKey initialPt = vs\n  where\n  vs@i = { key = keys@i, plaintext=pts@(i*1000), ciphertext=cts@(i*1000 + 999) }\n\n  pts : [100*1000][128]\n  pts = [initialPt] # take cts\n\n  cts : [100*1000][128]\n  cts@i = aesEncryptBlock (schedules@(i\/1000)) (pts@i)\n\n  keys : [100][192]\n  keys = [initialKey] # [ k ^ ((drop`{64} (xs!1)) # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} cts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESEncryptKeySchedule AES192)\n  schedules = map aes192EncryptSchedule keys\n\nmct_ecb_decrypt_192 : [192] -> [128] -> [100](AESTestVector 192)\nmct_ecb_decrypt_192 initialKey initialCt = vs\n  where\n  vs@i = { key = keys@i, ciphertext=cts@(i*1000), plaintext=pts@(i*1000 + 999) }\n\n  cts : [100*1000][128]\n  cts = [initialCt] # take pts\n\n  pts : [100*1000][128]\n  pts@i = aesDecryptBlock (schedules@(i\/1000)) (cts@i)\n\n  keys : [100][192]\n  keys = [initialKey] # [ k ^ ((drop`{64} (xs!1)) # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} pts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESDecryptKeySchedule AES192)\n  schedules = map aes192DecryptSchedule keys\n\nmct_ecb_encrypt_256 : [256] -> [128] -> [100](AESTestVector 256)\nmct_ecb_encrypt_256 initialKey initialPt = vs\n  where\n  vs@i = { key = keys@i, plaintext=pts@(i*1000), ciphertext=cts@(i*1000 + 999) }\n\n  pts : [100*1000][128]\n  pts = [initialPt] # take cts\n\n  cts : [100*1000][128]\n  cts@i = aesEncryptBlock (schedules@(i\/1000)) (pts@i)\n\n  keys : [100][256]\n  keys = [initialKey] # [ k ^ (xs!1 # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} cts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESEncryptKeySchedule AES256)\n  schedules = map aes256EncryptSchedule keys\n\nmct_ecb_decrypt_256 : [256] -> [128] -> [100](AESTestVector 256)\nmct_ecb_decrypt_256 initialKey initialCt = vs\n  where\n  vs@i = { key = keys@i, ciphertext=cts@(i*1000), plaintext=pts@(i*1000 + 999) }\n\n  cts : [100*1000][128]\n  cts = [initialCt] # take pts\n\n  pts : [100*1000][128]\n  pts@i = aesDecryptBlock (schedules@(i\/1000)) (cts@i)\n\n  keys : [100][256]\n  keys = [initialKey] # [ k ^ (xs!1 # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} pts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESDecryptKeySchedule AES256)\n  schedules = map aes256DecryptSchedule keys\n\n\n\nproperty aes192_MCT_vectors_encrypt_correct =\n aes192_MCT_encrypt_test_vectors ==\n mct_ecb_encrypt_192\n   0xb9a63e09e1dfc42e93a90d9bad739e5967aef672eedd5da9 \n   0x85a1f7a58167b389cddc8a9ff175ee26\n\nproperty aes192_MCT_vectors_decrypt_correct =\n aes192_MCT_decrypt_test_vectors ==\n mct_ecb_decrypt_192\n   0x4b97585701c03fbebdfa8555024f589f1482c58a00fdd9fd\n   0xd0bd0e02ded155e4516be83f42d347a4\n\naes192_MCT_encrypt_test_vectors : [100](AESTestVector 192)\naes192_MCT_encrypt_test_vectors =\n \/\/ Vectors from ECBMCT192.rsp\n [{ key = 0xb9a63e09e1dfc42e93a90d9bad739e5967aef672eedd5da9\n  , plaintext = 0x85a1f7a58167b389cddc8a9ff175ee26\n  , ciphertext = 0xee83d85279e022d2048031abeefbc4a4\n  },\n\n  { key = 0x3aaa458160ee54c97d2ad5c9d493bc8b632ec7d90026990d\n  , plaintext = 0xee83d85279e022d2048031abeefbc4a4\n  , ciphertext = 0xa8f99517b4bd14a16c26bae901417498\n  },\n\n  { key = 0x1d17d1bcc74a8584d5d340de602ea82a0f087d300167ed95\n  , plaintext = 0xa8f99517b4bd14a16c26bae901417498\n  , ciphertext = 0x80286e71937334fd6e90c706abbaf0ff\n  },\n\n  { key = 0xc0025cd0eb1f23c055fb2eaff35d9cd76198ba36aadd1d6a\n  , plaintext = 0x80286e71937334fd6e90c706abbaf0ff\n  , ciphertext = 0xc8b8c153bcb231e9424d65f37bff75b8\n  },\n\n  { key = 0xafb45c1097553d589d43effc4fefad3e23d5dfc5d12268d2\n  , plaintext = 0xc8b8c153bcb231e9424d65f37bff75b8\n  , ciphertext = 0x8108fbfde1cff0d94b88b1073114c657\n  },\n\n  { key = 0x8b81e2418f676a5b1c4b1401ae205de7685d6ec2e036ae85\n  , plaintext = 0x8108fbfde1cff0d94b88b1073114c657\n  , ciphertext = 0x79af44f2490efc90d217af55dd10fd2e\n  },\n\n  { key = 0x43463bbf9528c3bc65e450f3e72ea177ba4ac1973d2653ab\n  , plaintext = 0x79af44f2490efc90d217af55dd10fd2e\n  , ciphertext = 0xd0c2da3860c367e1fd68cf04bb6b41cd\n  },\n\n  { key = 0x0e3efca8ca3fd45bb5268acb87edc69647220e93864d1266\n  , plaintext = 0xd0c2da3860c367e1fd68cf04bb6b41cd\n  , ciphertext = 0xe5d39a5d7ca8c4f4aafd3d851c40c016\n  },\n\n  { key = 0x2908445968d0a18f50f51096fb450262eddf33169a0dd270\n  , plaintext = 0xe5d39a5d7ca8c4f4aafd3d851c40c016\n  , ciphertext = 0x98657051b23c69741b2ab506f818fd3f\n  },\n\n  { key = 0x00feb8bffd6b4bcbc89060c749796b16f6f5861062152f4f\n  , plaintext = 0x98657051b23c69741b2ab506f818fd3f\n  , ciphertext = 0xc9b6e95fb54b540adc1faa8cece00286\n  },\n\n  { key = 0xbe96e16fffe0a2db01268998fc323f1c2aea2c9c8ef52dc9\n  , plaintext = 0xc9b6e95fb54b540adc1faa8cece00286\n  , ciphertext = 0x5cf9f61a3dd3a2f76d571384c831ae88\n  },\n\n  { key = 0x41baf817490bf49c5ddf7f82c1e19deb47bd3f1846c48341\n  , plaintext = 0x5cf9f61a3dd3a2f76d571384c831ae88\n  , ciphertext = 0xdc6e6c13679958963b8648457eb8a415\n  },\n\n  { key = 0xa4afa1ac957b31fe81b11391a678c57d7c3b775d387c2754\n  , plaintext = 0xdc6e6c13679958963b8648457eb8a415\n  , ciphertext = 0x033f2b7189ec7f2ef0c496a83f5c5051\n  },\n\n  { key = 0x6a5b44860a26a4ff828e38e02f94ba538cffe1f507207705\n  , plaintext = 0x033f2b7189ec7f2ef0c496a83f5c5051\n  , ciphertext = 0x032727204d9b169679eff2ffe5f71efb\n  },\n\n  { key = 0xc80d5ebc48693fdc81a91fc0620facc5f510130ae2d769fe\n  , plaintext = 0x032727204d9b169679eff2ffe5f71efb\n  , ciphertext = 0xd19884aaae710c5861fff7251ea143c8\n  },\n\n  { key = 0xb9d36290d5324a8350319b6acc7ea09d94efe42ffc762a36\n  , plaintext = 0xd19884aaae710c5861fff7251ea143c8\n  , ciphertext = 0x3097d32245163fcf4c578e5a7dd2349a\n  },\n\n  { key = 0x3d00403bc3a0ff5b60a6484889689f52d8b86a7581a41eac\n  , plaintext = 0x3097d32245163fcf4c578e5a7dd2349a\n  , ciphertext = 0x39b6615b1e047b9469b3cfd7251987c9\n  },\n\n  { key = 0xbb85f657f0d5241659102913976ce4c6b10ba5a2a4bd9965\n  , plaintext = 0x39b6615b1e047b9469b3cfd7251987c9\n  , ciphertext = 0x868194c44a68d8b48e0ed4dbacded128\n  },\n\n  { key = 0x7db3635bf7d52f66df91bdd7dd043c723f0571790863484d\n  , plaintext = 0x868194c44a68d8b48e0ed4dbacded128\n  , ciphertext = 0xd324fd7db1cfaa86511280dafa5340e6\n  },\n\n  { key = 0x1449e32d51b3680f0cb540aa6ccb96f46e17f1a3f23008ab\n  , plaintext = 0xd324fd7db1cfaa86511280dafa5340e6\n  , ciphertext = 0x409aa25dcb51d8831a2f5627746c2bc9\n  },\n\n  { key = 0x63d4b33e24bf3f7c4c2fe2f7a79a4e777438a784865c2362\n  , plaintext = 0x409aa25dcb51d8831a2f5627746c2bc9\n  , ciphertext = 0xbfa0348398b9bc4e07eb1739c589b225\n  },\n\n  { key = 0x03f21169aad21af3f38fd6743f23f23973d3b0bd43d59147\n  , plaintext = 0xbfa0348398b9bc4e07eb1739c589b225\n  , ciphertext = 0x13582b4881e6b7f6398f41b57d617201\n  },\n\n  { key = 0x541879f8770ad35de0d7fd3cbec545cf4a5cf1083eb4e346\n  , plaintext = 0x13582b4881e6b7f6398f41b57d617201\n  , ciphertext = 0xd9d58082c3a976852a350ba551862362\n  },\n\n  { key = 0xd0c6100d7f8fdd8739027dbe7d6c334a6069faad6f32c024\n  , plaintext = 0xd9d58082c3a976852a350ba551862362\n  , ciphertext = 0x3cafa17506a92359c23600404ad61513\n  },\n\n  { key = 0x05345651ac0d23b305addccb7bc51013a25ffaed25e4d537\n  , plaintext = 0x3cafa17506a92359c23600404ad61513\n  , ciphertext = 0xa4a3041803fe9bf7d355b34d21293ecf\n  },\n\n  { key = 0x4ce9e1102ccba488a10ed8d3783b8be4710a49a004cdebf8\n  , plaintext = 0xa4a3041803fe9bf7d355b34d21293ecf\n  , ciphertext = 0xcfa674aba22c17036da437832c635b30\n  },\n\n  { key = 0x08fed0e9350ac7386ea8ac78da179ce71cae7e2328aeb0c8\n  , plaintext = 0xcfa674aba22c17036da437832c635b30\n  , ciphertext = 0xf4de164a6ca93e96dfc91426d636e481\n  },\n\n  { key = 0xcc5643ba704f961c9a76ba32b6bea271c3676a05fe985449\n  , plaintext = 0xf4de164a6ca93e96dfc91426d636e481\n  , ciphertext = 0x1deb553ac91ec346201154dbbdac9b14\n  },\n\n  { key = 0xd413a379439b2caf879def087fa06137e3763ede4334cf5d\n  , plaintext = 0x1deb553ac91ec346201154dbbdac9b14\n  , ciphertext = 0x52372415208849a222acf6f27e145f75\n  },\n\n  { key = 0x575a3e57736fe96dd5aacb1d5f282895c1dac82c3d209028\n  , plaintext = 0x52372415208849a222acf6f27e145f75\n  , ciphertext = 0x710f708e402325c6763ca461f6f855e0\n  },\n\n  { key = 0x7d593f399f198b9da4a5bb931f0b0d53b7e66c4dcbd8c5c8\n  , plaintext = 0x710f708e402325c6763ca461f6f855e0\n  , ciphertext = 0x8fae56699e3af53b86d484be2463b602\n  },\n\n  { key = 0x401e3d459d7254a82b0bedfa8131f8683132e8f3efbb73ca\n  , plaintext = 0x8fae56699e3af53b86d484be2463b602\n  , ciphertext = 0xaa44678efb43326727d5204edc942fe2\n  },\n\n  { key = 0x996d36de694dc3cb814f8a747a72ca0f16e7c8bd332f5c28\n  , plaintext = 0xaa44678efb43326727d5204edc942fe2\n  , ciphertext = 0xfb04caba312e387528a355d39db15db6\n  },\n\n  { key = 0xbba2ddbf7cc063957a4b40ce4b5cf27a3e449d6eae9e019e\n  , plaintext = 0xfb04caba312e387528a355d39db15db6\n  , ciphertext = 0x5d8156335210cc39885ab652d8ccfd33\n  },\n\n  { key = 0x5fdbf5f7b3b389c727ca16fd194c3e43b61e2b3c7652fcad\n  , plaintext = 0x5d8156335210cc39885ab652d8ccfd33\n  , ciphertext = 0x8b8d3455188ad9615a2c3a34c4bfb8df\n  },\n\n  { key = 0xfa876ec64e22b16bac4722a801c6e722ec321108b2ed4472\n  , plaintext = 0x8b8d3455188ad9615a2c3a34c4bfb8df\n  , ciphertext = 0x1c5bab7b91032ffac3a8e4d41a3a5338\n  },\n\n  { key = 0xceeda64221ae37d3b01c89d390c5c8d82f9af5dca8d7174a\n  , plaintext = 0x1c5bab7b91032ffac3a8e4d41a3a5338\n  , ciphertext = 0xad98def9c24e9d0de0e6a9541c86c34c\n  },\n\n  { key = 0xb2b6b9074795f6501d84572a528b55d5cf7c5c88b451d406\n  , plaintext = 0xad98def9c24e9d0de0e6a9541c86c34c\n  , ciphertext = 0xee54a410d2e410e721bf9b12f9a8bb04\n  },\n\n  { key = 0x42e6927395e5d3dbf3d0f33a806f4532eec3c79a4df96f02\n  , plaintext = 0xee54a410d2e410e721bf9b12f9a8bb04\n  , ciphertext = 0x7b894a4e5514249029af1118576093cc\n  },\n\n  { key = 0x07373c871002daaf8859b974d57b61a2c76cd6821a99fcce\n  , plaintext = 0x7b894a4e5514249029af1118576093cc\n  , ciphertext = 0xf555d93e38137c9b931b4583de367ff2\n  },\n\n  { key = 0x8eebc322f66630687d0c604aed681d3954779301c4af833c\n  , plaintext = 0xf555d93e38137c9b931b4583de367ff2\n  , ciphertext = 0xf5adbb37c99646913d1670ccd8203c04\n  },\n\n  { key = 0x56d70f07f90e11ab88a1db7d24fe5ba86961e3cd1c8fbf38\n  , plaintext = 0xf5adbb37c99646913d1670ccd8203c04\n  , ciphertext = 0x122f214900ffcfd59652c1af64b10c71\n  },\n\n  { key = 0xcf4ec9b7f52cd2d99a8efa342401947dff332262783eb349\n  , plaintext = 0x122f214900ffcfd59652c1af64b10c71\n  , ciphertext = 0xbe1b5d5ac7b61b73c479d7b1fc65ea35\n  },\n\n  { key = 0x8ca5b0fe1053b3982495a76ee3b78f0e3b4af5d3845b597c\n  , plaintext = 0xbe1b5d5ac7b61b73c479d7b1fc65ea35\n  , ciphertext = 0xf9868b44c1ce21b040b8fff3716b011a\n  },\n\n  { key = 0x34f2ce0dbb3fa2d2dd132c2a2279aebe7bf20a20f5305866\n  , plaintext = 0xf9868b44c1ce21b040b8fff3716b011a\n  , ciphertext = 0x9cac4efb170dc8ded3fc6a309fd7aca7\n  },\n\n  { key = 0x603bbb7bf54b365d41bf62d135746660a80e60106ae7f4c1\n  , plaintext = 0x9cac4efb170dc8ded3fc6a309fd7aca7\n  , ciphertext = 0xe52a42e78048c6dda63f98fc6c5f47f9\n  },\n\n  { key = 0xa146ac000cb1f14ba4952036b53ca0bd0e31f8ec06b8b338\n  , plaintext = 0xe52a42e78048c6dda63f98fc6c5f47f9\n  , ciphertext = 0x826af473c60d61bd746a8d8bda3b410c\n  },\n\n  { key = 0x979e0246f75d08e226ffd4457331c1007a5b7567dc83f234\n  , plaintext = 0x826af473c60d61bd746a8d8bda3b410c\n  , ciphertext = 0x9fa4ebdccace9033a56e3a5aace74dba\n  },\n\n  { key = 0x3c34cf05821c9d17b95b3f99b9ff5133df354f3d7064bf8e\n  , plaintext = 0x9fa4ebdccace9033a56e3a5aace74dba\n  , ciphertext = 0xe0ac5dee9d6247d50b379589c2415444\n  },\n\n  { key = 0x3e42ac26f6c0977a59f76277249d16e6d402dab4b225ebca\n  , plaintext = 0xe0ac5dee9d6247d50b379589c2415444\n  , ciphertext = 0x462562da72ea6b5c371530c716879dcd\n  },\n\n  { key = 0xed7edff15890f7841fd200ad56777dbae317ea73a4a27607\n  , plaintext = 0x462562da72ea6b5c371530c716879dcd\n  , ciphertext = 0x78a040009e18ef207253ef992e7e2c91\n  },\n\n  { key = 0x4140882041912162677240adc86f929a914405ea8adc5a96\n  , plaintext = 0x78a040009e18ef207253ef992e7e2c91\n  , ciphertext = 0xf8c7a79f10c92ec49e1ec59b08498d64\n  },\n\n  { key = 0x2cbc00f60f66695a9fb5e732d8a6bc5e0f5ac0718295d7f2\n  , plaintext = 0xf8c7a79f10c92ec49e1ec59b08498d64\n  , ciphertext = 0x2f9a5f2cfd515a6878ecd923c36b1b4e\n  },\n\n  { key = 0xce9854aa7b6e184ab02fb81e25f7e63677b6195241feccbc\n  , plaintext = 0x2f9a5f2cfd515a6878ecd923c36b1b4e\n  , ciphertext = 0xf7d3b3758ecf5359ab523beaa17a0306\n  },\n\n  { key = 0x93163ae28f22570b47fc0b6bab38b56fdce422b8e084cfba\n  , plaintext = 0xf7d3b3758ecf5359ab523beaa17a0306\n  , ciphertext = 0x6c9dd076750bd1d2c0b8f203ca14ee1e\n  },\n\n  { key = 0xca2a7882db1cb3b52b61db1dde3364bd1c5cd0bb2a9021a4\n  , plaintext = 0x6c9dd076750bd1d2c0b8f203ca14ee1e\n  , ciphertext = 0x289cf1ab3b9eac26cdd02df244412d4e\n  },\n\n  { key = 0x90dc3a02ba5b5f2b03fd2ab6e5adc89bd18cfd496ed10cea\n  , plaintext = 0x289cf1ab3b9eac26cdd02df244412d4e\n  , ciphertext = 0x8ee4ca3c6c9cc5f27ddb79ae7cfcc47e\n  },\n\n  { key = 0x11b26d4f3eb77d218d19e08a89310d69ac5784e7122dc894\n  , plaintext = 0x8ee4ca3c6c9cc5f27ddb79ae7cfcc47e\n  , ciphertext = 0x6cbf94fcdcadfd9a39d4c4f702d7b101\n  },\n\n  { key = 0x7159cd8684c28039e1a67476559cf0f39583401010fa7995\n  , plaintext = 0x6cbf94fcdcadfd9a39d4c4f702d7b101\n  , ciphertext = 0x5047270db233f75e84c734b5cb56f765\n  },\n\n  { key = 0x76bbdc75f530ec0ab1e1537be7af07ad114474a5dbac8ef0\n  , plaintext = 0x5047270db233f75e84c734b5cb56f765\n  , ciphertext = 0xb82602cd22e7821be62e5ff67cb193c6\n  },\n\n  { key = 0x306a4720867eca7009c751b6c54885b6f76a2b53a71d1d36\n  , plaintext = 0xb82602cd22e7821be62e5ff67cb193c6\n  , ciphertext = 0x5a241fbcb4a0f769c37408abe658da25\n  },\n\n  { key = 0x306323bbf53bd84f53e34e0a71e872df341e23f84145c713\n  , plaintext = 0x5a241fbcb4a0f769c37408abe658da25\n  , ciphertext = 0x9a63d956a9c719465e30cdc160991042\n  },\n\n  { key = 0x897b6f11ecb97862c980975cd82f6b996a2eee3921dcd751\n  , plaintext = 0x9a63d956a9c719465e30cdc160991042\n  , ciphertext = 0x2a733f407d8080470c5f22a6cf8358cd\n  },\n\n  { key = 0x14fa0e9978672ad5e3f3a81ca5afebde6671cc9fee5f8f9c\n  , plaintext = 0x2a733f407d8080470c5f22a6cf8358cd\n  , ciphertext = 0x24db9f77f61060accf6d41e7639c1ec6\n  },\n\n  { key = 0xc1125a27a85e3826c728376b53bf8b72a91c8d788dc3915a\n  , plaintext = 0x24db9f77f61060accf6d41e7639c1ec6\n  , ciphertext = 0xa89eccce6ee8c9d4d34cf5ba8b29cba7\n  },\n\n  { key = 0x1ce385ac9c70d4e26fb6fba53d5742a67a5078c206ea5afd\n  , plaintext = 0xa89eccce6ee8c9d4d34cf5ba8b29cba7\n  , ciphertext = 0xe4ef08e86141940ef87d6b385d19108c\n  },\n\n  { key = 0x9a3967a8ff01d35f8b59f34d5c16d6a8822d13fa5bf34a71\n  , plaintext = 0xe4ef08e86141940ef87d6b385d19108c\n  , ciphertext = 0x1039c441007d6805551a87e820c63dca\n  },\n\n  { key = 0x7d0af1cd0d641f209b60370c5c6bbeadd73794127b3577bb\n  , plaintext = 0x1039c441007d6805551a87e820c63dca\n  , ciphertext = 0x2584b55b214a94ee9894b104178a6dd5\n  },\n\n  { key = 0x3f78d295449908e6bee482577d212a434fa325166cbf1a6e\n  , plaintext = 0x2584b55b214a94ee9894b104178a6dd5\n  , ciphertext = 0x9d32bd6357551091ca659f7bd4509fc2\n  },\n\n  { key = 0x9cd28f265a13556123d63f342a743ad285c6ba6db8ef85ac\n  , plaintext = 0x9d32bd6357551091ca659f7bd4509fc2\n  , ciphertext = 0x9ac46eb8e253bb37304394ff0042d306\n  },\n\n  { key = 0x34caf580014164d4b912518cc82781e5b5852e92b8ad56aa\n  , plaintext = 0x9ac46eb8e253bb37304394ff0042d306\n  , ciphertext = 0x3b899f1f2d93e3890418763fdd35943a\n  },\n\n  { key = 0x7c19a50fa9360041829bce93e5b4626cb19d58ad6598c290\n  , plaintext = 0x3b899f1f2d93e3890418763fdd35943a\n  , ciphertext = 0xea89d4537784f253eae2d6cebdd63a4c\n  },\n\n  { key = 0x2109b2880479bb4f68121ac09230903f5b7f8e63d84ef8dc\n  , plaintext = 0xea89d4537784f253eae2d6cebdd63a4c\n  , ciphertext = 0x80711a42f6687a62590a8a0d165b2fb8\n  },\n\n  { key = 0x83fe682b1fcdb57be86300826458ea5d0275046ece15d764\n  , plaintext = 0x80711a42f6687a62590a8a0d165b2fb8\n  , ciphertext = 0xb2174ffab755e3e0c666cecb075256ec\n  },\n\n  { key = 0x63434f6c69c041735a744f78d30d09bdc413caa5c9478188\n  , plaintext = 0xb2174ffab755e3e0c666cecb075256ec\n  , ciphertext = 0x57120386bd566d31807a6fe7b0e78041\n  },\n\n  { key = 0xdfa4b3f99eda96420d664cfe6e5b648c4469a54279a001c9\n  , plaintext = 0x57120386bd566d31807a6fe7b0e78041\n  , ciphertext = 0x3b128fcdb7bb4252b5e5e00df5629508\n  },\n\n  { key = 0x24fa37bb6d70bd943674c333d9e026def18c454f8cc294c1\n  , plaintext = 0x3b128fcdb7bb4252b5e5e00df5629508\n  , ciphertext = 0x4826cf69d83c7f475230679b61ca8e0a\n  },\n\n  { key = 0x246a7408f739d1d37e520c5a01dc5999a3bc22d4ed081acb\n  , plaintext = 0x4826cf69d83c7f475230679b61ca8e0a\n  , ciphertext = 0x25a23c7fb798a50f5929e90e743da11c\n  },\n\n  { key = 0x9f1827be83518dbc5bf03025b644fc96fa95cbda9935bbd7\n  , plaintext = 0x25a23c7fb798a50f5929e90e743da11c\n  , ciphertext = 0x7639e9f902d65feb6bc5cbc44b5e12ed\n  },\n\n  { key = 0xfda6b0d164b7fd982dc9d9dcb492a37d9150001ed26ba93a\n  , plaintext = 0x7639e9f902d65feb6bc5cbc44b5e12ed\n  , ciphertext = 0x85a71ee457e94fc85cb9ac461fff1c4f\n  },\n\n  { key = 0x0755b86a470bb93aa86ec738e37becb5cde9ac58cd94b575\n  , plaintext = 0x85a71ee457e94fc85cb9ac461fff1c4f\n  , ciphertext = 0xc9ef84a268877ecef88bb554ea63c336\n  },\n\n  { key = 0x8f13f2d9085091816181439a8bfc927b3562190c27f77643\n  , plaintext = 0xc9ef84a268877ecef88bb554ea63c336\n  , ciphertext = 0x260dd6bf1366c029b5fd64e72853d2d7\n  },\n\n  { key = 0xfdd71c524c374345478c9525989a5252809f7deb0fa4a494\n  , plaintext = 0x260dd6bf1366c029b5fd64e72853d2d7\n  , ciphertext = 0x39cc3e224738efaaf45fab525fc13127\n  },\n\n  { key = 0x8bd43e3f448778ea7e40ab07dfa2bdf874c0d6b9506595b3\n  , plaintext = 0x39cc3e224738efaaf45fab525fc13127\n  , ciphertext = 0x4d5ac8506c0a13b1c2092731c6fe5fbc\n  },\n\n  { key = 0x69b7449dc811b19c331a6357b3a8ae49b6c9f188969bca0f\n  , plaintext = 0x4d5ac8506c0a13b1c2092731c6fe5fbc\n  , ciphertext = 0xede69bd80f879d57640c77bc1312f064\n  },\n\n  { key = 0x40e1692d44e3b441defcf88fbc2f331ed2c5863485893a6b\n  , plaintext = 0xede69bd80f879d57640c77bc1312f064\n  , ciphertext = 0x31dc854d8552e6684904bc6502682434\n  },\n\n  { key = 0xc1de7d9285751138ef207dc2397dd5769bc13a5187e11e5f\n  , plaintext = 0x31dc854d8552e6684904bc6502682434\n  , ciphertext = 0xc7bdc57aaa445e489655154b25d3906d\n  },\n\n  { key = 0xd8689fdcc9b77227289db8b893398b3e0d942f1aa2328e32\n  , plaintext = 0xc7bdc57aaa445e489655154b25d3906d\n  , ciphertext = 0xc4b498470a24113b6b182674c0366131\n  },\n\n  { key = 0x8293a998633a405dec2920ff991d9a05668c096e6204ef03\n  , plaintext = 0xc4b498470a24113b6b182674c0366131\n  , ciphertext = 0x7575104da6d5b4e0fb21d682f93d0d24\n  },\n\n  { key = 0xe71e9c0918c908ae995c30b23fc82ee59daddfec9b39e227\n  , plaintext = 0x7575104da6d5b4e0fb21d682f93d0d24\n  , ciphertext = 0xc5acdc318353c4ef3f6f45bf4a84c659\n  },\n\n  { key = 0xa5f19f392eb2afd15cf0ec83bc9bea0aa2c29a53d1bd247e\n  , plaintext = 0xc5acdc318353c4ef3f6f45bf4a84c659\n  , ciphertext = 0xaf6a60f60fc085656e305a4c050cc9c3\n  },\n\n  { key = 0x180b05bff13a1ad3f39a8c75b35b6f6fccf2c01fd4b1edbd\n  , plaintext = 0xaf6a60f60fc085656e305a4c050cc9c3\n  , ciphertext = 0x9d5f30e488c3243ad20767b39ec9ee4e\n  },\n\n  { key = 0x1fb7ff20cab8a5186ec5bc913b984b551ef5a7ac4a7803f3\n  , plaintext = 0x9d5f30e488c3243ad20767b39ec9ee4e\n  , ciphertext = 0x5c3a1d144e5efe7cede88e21dcbc2777\n  },\n\n  { key = 0x3e999761c9d15f3932ffa18575c6b529f31d298d96c42484\n  , plaintext = 0x5c3a1d144e5efe7cede88e21dcbc2777\n  , ciphertext = 0x4f163c25a6d545ccffc54511b2a5605d\n  },\n\n  { key = 0x8bc1e531e9d3f84f7de99da0d313f0e50cd86c9c246144d9\n  , plaintext = 0x4f163c25a6d545ccffc54511b2a5605d\n  , ciphertext = 0x3eed65dab0bd7ae8c8b115fa185e310a\n  },\n\n  { key = 0x4efaae2e7ecadcd24304f87a63ae8a0dc46979663c3f75d3\n  , plaintext = 0x3eed65dab0bd7ae8c8b115fa185e310a\n  , ciphertext = 0xfefce0da5af3885d022636f19adab9b8\n  },\n\n  { key = 0x44e1224d08476e9cbdf818a0395d0250c64f4f97a6e5cc6b\n  , plaintext = 0xfefce0da5af3885d022636f19adab9b8\n  , ciphertext = 0x3a0c3d806aff32fde868343b0b58c77a\n  },\n\n  { key = 0xef93ffb9eb0b9f1787f4252053a230ad2e277bacadbd0b11\n  , plaintext = 0x3a0c3d806aff32fde868343b0b58c77a\n  , ciphertext = 0x6610ee19970ee606083968e523af2370\n  },\n\n  { key = 0xfc7c2c3d27519036e1e4cb39c4acd6ab261e13498e122861\n  , plaintext = 0x6610ee19970ee606083968e523af2370\n  , ciphertext = 0x2f714ddbd4adf8327dc93c723aebfffa\n  },\n\n  { key = 0xf2f8a8247724e289ce9586e210012e995bd72f3bb4f9d79b\n  , plaintext = 0x2f714ddbd4adf8327dc93c723aebfffa\n  , ciphertext = 0x5d1196da8f184975e240949a25104554\n  }]\n\n\naes192_MCT_decrypt_test_vectors : [100](AESTestVector 192)\naes192_MCT_decrypt_test_vectors =\n [{ key = 0x4b97585701c03fbebdfa8555024f589f1482c58a00fdd9fd\n  , ciphertext = 0xd0bd0e02ded155e4516be83f42d347a4\n  , plaintext = 0xc7b6581ccc88f7fc26d15d2731e7251b\n  },\n\n  { key = 0x3c98c80336e0f13f7a4cdd49cec7af63325398ad311afce6\n  , ciphertext = 0xc7b6581ccc88f7fc26d15d2731e7251b\n  , plaintext = 0x01aa957b12c596511484ed7705766c67\n  },\n\n  { key = 0x825349971b370dc47be64832dc02393226d775da346c9081\n  , ciphertext = 0x01aa957b12c596511484ed7705766c67\n  , plaintext = 0xf98c15d93f5daef6047c2760c5df5540\n  },\n\n  { key = 0xebb9611cf25685c3826a5debe35f97c422ab52baf1b3c5c1\n  , ciphertext = 0xf98c15d93f5daef6047c2760c5df5540\n  , plaintext = 0x5c86395c6b3ed7d30d5e3ce3331fb3ed\n  },\n\n  { key = 0xd8d6d591e30f4e77deec64b7886140172ff56e59c2ac762c\n  , ciphertext = 0x5c86395c6b3ed7d30d5e3ce3331fb3ed\n  , plaintext = 0x8e8cb768b31e65d054e9db8d19862084\n  },\n\n  { key = 0x775a6f9a0e4733e45060d3df3b7f25c77b1cb5d4db2a56a8\n  , ciphertext = 0x8e8cb768b31e65d054e9db8d19862084\n  , plaintext = 0x96cab38070ea8e37c3d437a091e9e74c\n  },\n\n  { key = 0x511e536ea113429bc6aa605f4b95abf0b8c882744ac3b1e4\n  , ciphertext = 0x96cab38070ea8e37c3d437a091e9e74c\n  , plaintext = 0xf8356cfe486b2375c2e2e4138b285ce7\n  },\n\n  { key = 0xc3f94c74f86b59723e9f0ca103fe88857a2a6667c1ebed03\n  , ciphertext = 0xf8356cfe486b2375c2e2e4138b285ce7\n  , plaintext = 0x6a15770b29960c063395a70dc3cf7575\n  },\n\n  { key = 0xa220f197ee7db5a2548a7baa2a68848349bfc16a02249876\n  , ciphertext = 0x6a15770b29960c063395a70dc3cf7575\n  , plaintext = 0xd16463745da38ef8997e20e102fb8573\n  },\n\n  { key = 0x187bc771e567fb1285ee18de77cb0a7bd0c1e18b00df1d05\n  , ciphertext = 0xd16463745da38ef8997e20e102fb8573\n  , plaintext = 0x98ea16875a9e3006de150e93be9585b8\n  },\n\n  { key = 0x432ab1057033bb041d040e592d553a7d0ed4ef18be4a98bd\n  , ciphertext = 0x98ea16875a9e3006de150e93be9585b8\n  , plaintext = 0x9d4c05cb0c5cb543515cfd05a4b90004\n  },\n\n  { key = 0x64a7f543e2e2a60780480b9221098f3e5f88121d1af398b9\n  , ciphertext = 0x9d4c05cb0c5cb543515cfd05a4b90004\n  , plaintext = 0x93c4638f0f76b0a42481c030314ca594\n  },\n\n  { key = 0x755c48e6e44a956f138c681d2e7f3f9a7b09d22d2bbf3d2d\n  , ciphertext = 0x93c4638f0f76b0a42481c030314ca594\n  , plaintext = 0x8ad1d144144c8530218c0edf3119aa82\n  },\n\n  { key = 0x4ff1466b9e9939af995db9593a33baaa5a85dcf21aa697af\n  , ciphertext = 0x8ad1d144144c8530218c0edf3119aa82\n  , plaintext = 0xa46e11cca3b2f98e9f7360d33d236189\n  },\n\n  { key = 0xb2e265f13266035a3d33a89599814324c5f6bc212785f626\n  , ciphertext = 0xa46e11cca3b2f98e9f7360d33d236189\n  , plaintext = 0x9ece35fb84957574fd353cfac1608943\n  },\n\n  { key = 0x102d9afa0e70b1daa3fd9d6e1d14365038c380dbe6e57f65\n  , ciphertext = 0x9ece35fb84957574fd353cfac1608943\n  , plaintext = 0x225ce2f6987392afd1921c5eecd6ba17\n  },\n\n  { key = 0xc772081227697cc081a17f988567a4ffe9519c850a33c572\n  , ciphertext = 0x225ce2f6987392afd1921c5eecd6ba17\n  , plaintext = 0x85fd494bfd5127cff96088e0b130ef04\n  },\n\n  { key = 0xc306028aea2e8f1c045c36d37836833010311465bb032a76\n  , ciphertext = 0x85fd494bfd5127cff96088e0b130ef04\n  , plaintext = 0x1e693009be7a868db9e6a495c2e238f3\n  },\n\n  { key = 0x7a646ea7ab6a11101a3506dac64c05bda9d7b0f079e11285\n  , ciphertext = 0x1e693009be7a868db9e6a495c2e238f3\n  , plaintext = 0x49f55237f9a66050b7e04e66a0b4bf24\n  },\n\n  { key = 0xddbe30e84a14077953c054ed3fea65ed1e37fe96d955ada1\n  , ciphertext = 0x49f55237f9a66050b7e04e66a0b4bf24\n  , plaintext = 0xb966ec6748bd876046be2be11abff82a\n  },\n\n  { key = 0x55e1472be2e1739aeaa6b88a7757e28d5889d577c3ea558b\n  , ciphertext = 0xb966ec6748bd876046be2be11abff82a\n  , plaintext = 0x0f6a78ac23e6ea2d9f4232e8568cea97\n  },\n\n  { key = 0x38750e9c7a729e09e5ccc02654b108a0c7cbe79f9566bf1c\n  , ciphertext = 0x0f6a78ac23e6ea2d9f4232e8568cea97\n  , plaintext = 0xc80bfbe58fb9b00cd4858fd769e3cd1d\n  },\n\n  { key = 0xe45ace33a0f7494c2dc73bc3db08b8ac134e6848fc857201\n  , ciphertext = 0xc80bfbe58fb9b00cd4858fd769e3cd1d\n  , plaintext = 0x918e28b7a7ad8a370d2f260f9f7a5fec\n  },\n\n  { key = 0xd2a3b2ca9419501abc4913747ca5329b1e614e4763ff2ded\n  , ciphertext = 0x918e28b7a7ad8a370d2f260f9f7a5fec\n  , plaintext = 0x59d1732fc2452e53eeda0790b80a244a\n  },\n\n  { key = 0x9dae1b9eaa53bdfce598605bbee01cc8f0bb49d7dbf509a7\n  , ciphertext = 0x59d1732fc2452e53eeda0790b80a244a\n  , plaintext = 0xe74d820249410cd1a39287dc536ed5fc\n  },\n\n  { key = 0xe74268a3d42edb8702d5e259f7a110195329ce0b889bdc5b\n  , ciphertext = 0xe74d820249410cd1a39287dc536ed5fc\n  , plaintext = 0x27ca67828485be98a6cd22d724af53b9\n  },\n\n  { key = 0x0d793e8f7e0ea82d251f85db7324ae81f5e4ecdcac348fe2\n  , ciphertext = 0x27ca67828485be98a6cd22d724af53b9\n  , plaintext = 0x4927ab19552102414e39126b8a91c675\n  },\n\n  { key = 0xc99788fd8dc7a7246c382ec22605acc0bbddfeb726a54997\n  , ciphertext = 0x4927ab19552102414e39126b8a91c675\n  , plaintext = 0x99ea6ccf100d06243b45998d68c9b6bc\n  },\n\n  { key = 0x733425872bb717edf5d2420d3608aae48098673a4e6cff2b\n  , ciphertext = 0x99ea6ccf100d06243b45998d68c9b6bc\n  , plaintext = 0xf029e59925e67de178b5cb9fd187f2c6\n  },\n\n  { key = 0xfc02106517299a1e05fba79413eed705f82daca59feb0ded\n  , ciphertext = 0xf029e59925e67de178b5cb9fd187f2c6\n  , plaintext = 0x5f9da95aa424d5a65f1ff3d99769522d\n  },\n\n  { key = 0x9b0efe0e5f4f4e395a660eceb7ca02a3a7325f7c08825fc0\n  , ciphertext = 0x5f9da95aa424d5a65f1ff3d99769522d\n  , plaintext = 0xa20f232bb355370df27f55bb53469b40\n  },\n\n  { key = 0x502b270205133d51f8692de5049f35ae554d0ac75bc4c480\n  , ciphertext = 0xa20f232bb355370df27f55bb53469b40\n  , plaintext = 0x32e5d13e44b2e67952d8ef98af19a4d3\n  },\n\n  { key = 0xd1cac8a82a2e3ab3ca8cfcdb402dd3d70795e55ff4dd6053\n  , ciphertext = 0x32e5d13e44b2e67952d8ef98af19a4d3\n  , plaintext = 0x688ab3ed2b373467bc547be2bf519846\n  },\n\n  { key = 0x7e4af6629efd55dfa2064f366b1ae7b0bbc19ebd4b8cf815\n  , ciphertext = 0x688ab3ed2b373467bc547be2bf519846\n  , plaintext = 0x1a88d45de26cab118e86fe7089d818d0\n  },\n\n  { key = 0x216cd4ed3d38e68cb88e9b6b89764ca1354760cdc254e0c5\n  , ciphertext = 0x1a88d45de26cab118e86fe7089d818d0\n  , plaintext = 0x8d154a7ebc0e6fd2d6d7686d9b9492ad\n  },\n\n  { key = 0xedf6f3e4f323dc91359bd11535782373e39008a059c07268\n  , ciphertext = 0x8d154a7ebc0e6fd2d6d7686d9b9492ad\n  , plaintext = 0xbe46ead5f431ee2c6d1795f852558ed7\n  },\n\n  { key = 0x94afb2de656daf688bdd3bc0c149cd5f8e879d580b95fcbf\n  , ciphertext = 0xbe46ead5f431ee2c6d1795f852558ed7\n  , plaintext = 0x9f1ecd9839abd6abbecba89a71405c76\n  },\n\n  { key = 0x70bea40807c903c714c3f658f8e21bf4304c35c27ad5a0c9\n  , ciphertext = 0x9f1ecd9839abd6abbecba89a71405c76\n  , plaintext = 0xf5f335142d71d35a4723bbece7a39c43\n  },\n\n  { key = 0xb32369cb5a1611d7e130c34cd593c8ae776f8e2e9d763c8a\n  , ciphertext = 0xf5f335142d71d35a4723bbece7a39c43\n  , plaintext = 0x55ace2aa461af10d10436e529a2d8d85\n  },\n\n  { key = 0xf6412cbd1f98e445b49c21e6938939a3672ce07c075bb10f\n  , ciphertext = 0x55ace2aa461af10d10436e529a2d8d85\n  , plaintext = 0xf6670a6576aa2d20b63482aab26f7c82\n  },\n\n  { key = 0xea7cf55a9e0fcb0d42fb2b83e5231483d11862d6b534cd8d\n  , ciphertext = 0xf6670a6576aa2d20b63482aab26f7c82\n  , plaintext = 0x93e81b9866979a0adc573d380065f18e\n  },\n\n  { key = 0x1a5d1de4468ed5e5d113301b83b48e890d4f5feeb5513c03\n  , ciphertext = 0x93e81b9866979a0adc573d380065f18e\n  , plaintext = 0x324024007edad9a3e4b435b212bfec88\n  },\n\n  { key = 0x8ed3c18837593af6e353141bfd6e572ae9fb6a5ca7eed08b\n  , ciphertext = 0x324024007edad9a3e4b435b212bfec88\n  , plaintext = 0x5eb5e71f06992c1998ae0cf03dbc9dce\n  },\n\n  { key = 0xe5d6d1566d3c9a17bde6f304fbf77b33715566ac9a524d45\n  , ciphertext = 0x5eb5e71f06992c1998ae0cf03dbc9dce\n  , plaintext = 0xa83fe8f226ad5ee5b358fac03a092882\n  },\n\n  { key = 0xd5ec4f5df302bfa515d91bf6dd5a25d6c20d9c6ca05b65c7\n  , ciphertext = 0xa83fe8f226ad5ee5b358fac03a092882\n  , plaintext = 0x72360b4fcd1293a36ed0bb44213da8b9\n  },\n\n  { key = 0x50257306e757d76567ef10b91048b675acdd27288166cd7e\n  , ciphertext = 0x72360b4fcd1293a36ed0bb44213da8b9\n  , plaintext = 0x982119600a3e73dff33583558134bcf0\n  },\n\n  { key = 0x64b394f798415fbcffce09d91a76c5aa5fe8a47d0052718e\n  , ciphertext = 0x982119600a3e73dff33583558134bcf0\n  , plaintext = 0x0c33669b84d714959785b37d586bb355\n  },\n\n  { key = 0xcbaf8d92f18efe87f3fd6f429ea1d13fc86d17005839c2db\n  , ciphertext = 0x0c33669b84d714959785b37d586bb355\n  , plaintext = 0x9fc2fd51bbefd70fe7ce0c13af3d2ace\n  },\n\n  { key = 0x80bb745fb5b9cb616c3f9213254e06302fa31b13f704e815\n  , ciphertext = 0x9fc2fd51bbefd70fe7ce0c13af3d2ace\n  , plaintext = 0xaf4a4566e556a7f2dd3477a53c094498\n  },\n\n  { key = 0xb5d94340d5852f04c375d775c018a1c2f2976cb6cb0dac8d\n  , ciphertext = 0xaf4a4566e556a7f2dd3477a53c094498\n  , plaintext = 0x8107ca3fc833fee74501f2a42f088401\n  },\n\n  { key = 0x23341a3b649010c942721d4a082b5f25b7969e12e405288c\n  , ciphertext = 0x8107ca3fc833fee74501f2a42f088401\n  , plaintext = 0x714341183a67b95abcf9bc992d1aa290\n  },\n\n  { key = 0x955075d16664498333315c52324ce67f0b6f228bc91f8a1c\n  , ciphertext = 0x714341183a67b95abcf9bc992d1aa290\n  , plaintext = 0x564289f3ac30d6e27dde4308ee5637ab\n  },\n\n  { key = 0x9e5493cf59a7d0e76573d5a19e7c309d76b161832749bdb7\n  , ciphertext = 0x564289f3ac30d6e27dde4308ee5637ab\n  , plaintext = 0x805424be37b7f0b5498ab5bf8904f468\n  },\n\n  { key = 0x0e8dd0538bcfa448e527f11fa9cbc0283f3bd43cae4d49df\n  , ciphertext = 0x805424be37b7f0b5498ab5bf8904f468\n  , plaintext = 0x793554c1cc565f00f9f2122bd06672aa\n  },\n\n  { key = 0xf253723471590c249c12a5de659d9f28c6c9c6177e2b3b75\n  , ciphertext = 0x793554c1cc565f00f9f2122bd06672aa\n  , plaintext = 0xb89feee17d71a452b46e4683cfddc0ba\n  },\n\n  { key = 0x14781c9f73227825248d4b3f18ec3b7a72a78094b1f6fbcf\n  , ciphertext = 0xb89feee17d71a452b46e4683cfddc0ba\n  , plaintext = 0x737c418d35812556f6d26ebf91028ad7\n  },\n\n  { key = 0xc4706d6414a3594657f10ab22d6d1e2c8475ee2b20f47118\n  , ciphertext = 0x737c418d35812556f6d26ebf91028ad7\n  , plaintext = 0xc2e352ec712b84fa74f98254740d0847\n  },\n\n  { key = 0x74fabaf96545e7199512585e5c469ad6f08c6c7f54f9795f\n  , ciphertext = 0xc2e352ec712b84fa74f98254740d0847\n  , plaintext = 0xe09f8d7cc0e4d7f4efb65e10529592e5\n  },\n\n  { key = 0xdbfa75aad7f1ad19758dd5229ca24d221f3a326f066cebba\n  , ciphertext = 0xe09f8d7cc0e4d7f4efb65e10529592e5\n  , plaintext = 0x8a8911579e11d858bd4e336b8125fa6f\n  },\n\n  { key = 0xad8ea306bb3eb77bff04c47502b3957aa2740104874911d5\n  , ciphertext = 0x8a8911579e11d858bd4e336b8125fa6f\n  , plaintext = 0x3b1f396eae6ae53926e9607fb4b6e1d6\n  },\n\n  { key = 0x2b204520b1389d5bc41bfd1bacd97043849d617b33fff003\n  , ciphertext = 0x3b1f396eae6ae53926e9607fb4b6e1d6\n  , plaintext = 0x6d06fe256d84ab0112119425d70d5aa6\n  },\n\n  { key = 0x86d761e020a46b76a91d033ec15ddb42968cf55ee4f2aaa5\n  , ciphertext = 0x6d06fe256d84ab0112119425d70d5aa6\n  , plaintext = 0x537dd3000fdff67107362da65c95f101\n  },\n\n  { key = 0xbee0861f51136bd0fa60d03ece822d3391bad8f8b8675ba4\n  , ciphertext = 0x537dd3000fdff67107362da65c95f101\n  , plaintext = 0x2843b7b7107b1390be393137e3e266c9\n  },\n\n  { key = 0x8706a8a8fab02e3dd2236789def93ea32f83e9cf5b853d6d\n  , ciphertext = 0x2843b7b7107b1390be393137e3e266c9\n  , plaintext = 0xd5fae73a8940ec3c1bebe8a5e4fa0423\n  },\n\n  { key = 0x43ab0c1509505c7407d980b357b9d29f3468016abf7f394e\n  , ciphertext = 0xd5fae73a8940ec3c1bebe8a5e4fa0423\n  , plaintext = 0x63a9a8c99a6a8984dc6975772dd0beac\n  },\n\n  { key = 0xfb0dbb8cab3b89b16470287acdd35b1be801741d92af87e2\n  , ciphertext = 0x63a9a8c99a6a8984dc6975772dd0beac\n  , plaintext = 0x4c7b28c69c39c7eea1359ba2c167266a\n  },\n\n  { key = 0x1abc6031a84a5908280b00bc51ea9cf54934efbf53c8a188\n  , ciphertext = 0x4c7b28c69c39c7eea1359ba2c167266a\n  , plaintext = 0x076024c11bf696874d791813887685e7\n  },\n\n  { key = 0x746718f146cad3d92f6b247d4a1c0a72044df7acdbbe246f\n  , ciphertext = 0x076024c11bf696874d791813887685e7\n  , plaintext = 0xb413f148dc94e0525ad4800fb53dfc64\n  },\n\n  { key = 0x65a422dccc0f07779b78d5359688ea205e9977a36e83d80b\n  , ciphertext = 0xb413f148dc94e0525ad4800fb53dfc64\n  , plaintext = 0xbd94776297b168e862d3afd0669a2668\n  },\n\n  { key = 0x6d9fc6a3839c401426eca257013982c83c4ad8730819fe63\n  , ciphertext = 0xbd94776297b168e862d3afd0669a2668\n  , plaintext = 0xa383eb812e9d2ad7d04ef05beebc663c\n  },\n\n  { key = 0x31e8ba40171be0cc856f49d62fa4a81fec042828e6a5985f\n  , ciphertext = 0xa383eb812e9d2ad7d04ef05beebc663c\n  , plaintext = 0x125833c5a964733d24ca84ae573e537e\n  },\n\n  { key = 0xa1bd656677244e3597377a1386c0db22c8ceac86b19bcb21\n  , ciphertext = 0x125833c5a964733d24ca84ae573e537e\n  , plaintext = 0xd6597fe3687c9dc2f6087ad48bb2ab18\n  },\n\n  { key = 0x9467df27c2b90ca7416e05f0eebc46e03ec6d6523a296039\n  , ciphertext = 0xd6597fe3687c9dc2f6087ad48bb2ab18\n  , plaintext = 0xfd6abdb2793f849bedea160e34ab1a9d\n  },\n\n  { key = 0x1ee8f6b4187a87f0bc04b8429783c27bd32cc05c0e827aa4\n  , ciphertext = 0xfd6abdb2793f849bedea160e34ab1a9d\n  , plaintext = 0xfd2ccba255e74b16864ac2ff80894ebb\n  },\n\n  { key = 0x3f23c25c52d6454c412873e0c264896d556602a38e0b341f\n  , ciphertext = 0xfd2ccba255e74b16864ac2ff80894ebb\n  , plaintext = 0x4571abacb8faa74007702258220b3e19\n  },\n\n  { key = 0x4eedfc725f3901b80459d84c7a9e2e2d521620fbac000a06\n  , ciphertext = 0x4571abacb8faa74007702258220b3e19\n  , plaintext = 0x941b069f7545d16d24e69a309794a259\n  },\n\n  { key = 0xad8b4cd042b874d09042ded30fdbff4076f0bacb3b94a85f\n  , ciphertext = 0x941b069f7545d16d24e69a309794a259\n  , plaintext = 0x515ab9b50447ea30e5ab92ddd1498d69\n  },\n\n  { key = 0xc085e9fde0a60664c11867660b9c1570935b2816eadd2536\n  , ciphertext = 0x515ab9b50447ea30e5ab92ddd1498d69\n  , plaintext = 0x872c0d54b1382c095b1a475fee114cd5\n  },\n\n  { key = 0x4790a2b2ee108fbb46346a32baa43979c8416f4904cc69e3\n  , ciphertext = 0x872c0d54b1382c095b1a475fee114cd5\n  , plaintext = 0x6aa4b9e4559d2c1de4f59dafbaf0909e\n  },\n\n  { key = 0x56880340e6eaf2472c90d3d6ef3915642cb4f2e6be3cf97d\n  , ciphertext = 0x6aa4b9e4559d2c1de4f59dafbaf0909e\n  , plaintext = 0xc4ce24dd760b44799d00ce4c5ffdb8c5\n  },\n\n  { key = 0xd321a216923e2c1de85ef70b9932511db1b43caae1c141b8\n  , ciphertext = 0xc4ce24dd760b44799d00ce4c5ffdb8c5\n  , plaintext = 0xd73e44ee7f75c2fb6696aaba64af9925\n  },\n\n  { key = 0xa80125606ef3f3953f60b3e5e64793e6d7229610856ed89d\n  , ciphertext = 0xd73e44ee7f75c2fb6696aaba64af9925\n  , plaintext = 0x1add98acb3a31733b3e0a32da14a71cf\n  },\n\n  { key = 0xfd54730799c76e1e25bd2b4955e484d564c2353d2424a952\n  , ciphertext = 0x1add98acb3a31733b3e0a32da14a71cf\n  , plaintext = 0x6d2201f6268f7c126e4d57375f5ac97b\n  },\n\n  { key = 0xb07e344619df38e5489f2abf736bf8c70a8f620a7b7e6029\n  , ciphertext = 0x6d2201f6268f7c126e4d57375f5ac97b\n  , plaintext = 0x349daafd5a9676a0bf5e015319a5083b\n  },\n\n  { key = 0xf66e7702379bbeac7c02804229fd8e67b5d1635962db6812\n  , ciphertext = 0x349daafd5a9676a0bf5e015319a5083b\n  , plaintext = 0xfd6cd698388a46f696da48543a327e10\n  },\n\n  { key = 0x1aab1a249cb5fa91816e56da1177c891230b2b0d58e91602\n  , ciphertext = 0xfd6cd698388a46f696da48543a327e10\n  , plaintext = 0xbaa9b8a3f9ffa86241bb5abe04b7eea5\n  },\n\n  { key = 0xdd881f3432073d253bc7ee79e88860f362b071b35c5ef8a7\n  , ciphertext = 0xbaa9b8a3f9ffa86241bb5abe04b7eea5\n  , plaintext = 0x19ad5a0619f1b5eed38fb5fbbbbe1247\n  },\n\n  { key = 0xd4088261dda8dfc1226ab47ff179d51db13fc448e7e0eae0\n  , ciphertext = 0x19ad5a0619f1b5eed38fb5fbbbbe1247\n  , plaintext = 0x832e01274c6a59b148dc6de3e6ccc037\n  },\n\n  { key = 0x0ff97f22bdef4005a144b558bd138cacf9e3a9ab012c2ad7\n  , ciphertext = 0x832e01274c6a59b148dc6de3e6ccc037\n  , plaintext = 0x9853ba4a0880449a6344fd0dabfc9e74\n  },\n\n  { key = 0xa2f2351138f53ed639170f12b593c8369aa754a6aad0b4a3\n  , ciphertext = 0x9853ba4a0880449a6344fd0dabfc9e74\n  , plaintext = 0x89ebc090e07d36670f48a32074c9ca18\n  },\n\n  { key = 0xb7c564161c5e5061b0fccf8255eefe5195eff786de197ebb\n  , ciphertext = 0x89ebc090e07d36670f48a32074c9ca18\n  , plaintext = 0x5695154c14aeb5d09a516ca802d7fb21\n  },\n\n  { key = 0x95aa68a5ba0d346be669dace41404b810fbe9b2edcce859a\n  , ciphertext = 0x5695154c14aeb5d09a516ca802d7fb21\n  , plaintext = 0xf49c9100c165c22f16661c23bf46520e\n  },\n\n  { key = 0x028f06458b3a50ce12f54bce802589ae19d8870d6388d794\n  , ciphertext = 0xf49c9100c165c22f16661c23bf46520e\n  , plaintext = 0x1aec4f3ade3b41dd3d5448dc7e577e67\n  },\n\n  { key = 0xe0b75db3cfb1e3f6081904f45e1ec873248ccfd11ddfa9f3\n  , ciphertext = 0x1aec4f3ade3b41dd3d5448dc7e577e67\n  , plaintext = 0x5c75fbcaa893326641aa343f40f6ee31\n  },\n\n  { key = 0xe51161c0ee3bf4fe546cff3ef68dfa156526fbee5d2947c2\n  , ciphertext = 0x5c75fbcaa893326641aa343f40f6ee31\n  , plaintext = 0xa2c953d404212d5da4e98f31d8cc0a5b\n  },\n\n  { key = 0x1f13dd6e77477337f6a5aceaf2acd748c1cf74df85e54d99\n  , ciphertext = 0xa2c953d404212d5da4e98f31d8cc0a5b\n  , plaintext = 0x17ea5bd0c139ce391240ff701085b060\n  },\n\n  { key = 0x547e1d3ba5988327e14ff73a33951971d38f8baf9560fdf9\n  , ciphertext = 0x17ea5bd0c139ce391240ff701085b060\n  , plaintext = 0x98d87acaeb843ccf7b6e92a1889ff129\n  },\n\n  { key = 0xd140d82958fb4d8979978df0d81125bea8e1190e1dff0cd0\n  , ciphertext = 0x98d87acaeb843ccf7b6e92a1889ff129\n  , plaintext = 0x0c2132942034442ea6eb14d23ccdf868\n  },\n\n  { key = 0xf311ab46bba28f9a75b6bf64f82561900e0a0ddc2132f4b8\n  , ciphertext = 0x0c2132942034442ea6eb14d23ccdf868\n  , plaintext = 0x91341b217d521168251ad3778171e5ba\n  },\n\n  { key = 0x0abea37884946aa1e482a445857770f82b10deaba0431102\n  , ciphertext = 0x91341b217d521168251ad3778171e5ba\n  , plaintext = 0xb63ef1b79507a62eba3dafcec54a6328\n  }]\n\n\nproperty aes256_MCT_vectors_encrypt_correct =\n  aes256_MCT_encrypt_test_vectors ==\n  mct_ecb_encrypt_256\n    0xf9e8389f5b80712e3886cc1fa2d28a3b8c9cd88a2d4a54c6aa86ce0fef944be0\n    0xb379777f9050e2a818f2940cbbd9aba4\n\n\nproperty aes256_MCT_vectors_decrypt_correct =\n  aes256_MCT_decrypt_test_vectors ==\n  mct_ecb_decrypt_256\n    0x2b09ba39b834062b9e93f48373b8dd018dedf1e5ba1b8af831ebbacbc92a2643\n    0x89649bd0115f30bd878567610223a59d\n\n\naes256_MCT_encrypt_test_vectors : [100](AESTestVector 256)\naes256_MCT_encrypt_test_vectors =\n \/\/ Vectors from ECBMCT256.rsp\n [{ key = 0xf9e8389f5b80712e3886cc1fa2d28a3b8c9cd88a2d4a54c6aa86ce0fef944be0\n  , plaintext = 0xb379777f9050e2a818f2940cbbd9aba4\n  , ciphertext = 0x6893ebaf0a1fccc704326529fdfb60db\n  },\n\n  { key = 0xdb9ea5a2284fa17fb63e13bf891c8e42e40f332527559801aeb4ab26126f2b3b\n  , plaintext = 0x6893ebaf0a1fccc704326529fdfb60db\n  , ciphertext = 0xf3c78a5e85e5439bf26d5818718157d6\n  },\n\n  { key = 0x7099ed88e82744228a5303ae2ef6c0d017c8b97ba2b0db9a5cd9f33e63ee7ced\n  , plaintext = 0xf3c78a5e85e5439bf26d5818718157d6\n  , ciphertext = 0x2326b958b00b3050697eedb08cc20504\n  },\n\n  { key = 0x5e9e65ea96e78dd4fb78ea1184f6ebde34ee002312bbebca35a71e8eef2c79e9\n  , plaintext = 0x2326b958b00b3050697eedb08cc20504\n  , ciphertext = 0xec4332d5e3cebd3e0f5fc51452f4560d\n  },\n\n  { key = 0x33acf1cafc822646dc869e905bd26f9ad8ad32f6f17556f43af8db9abdd82fe4\n  , plaintext = 0xec4332d5e3cebd3e0f5fc51452f4560d\n  , ciphertext = 0x5da58b5ef2076340d555f861c3449a77\n  },\n\n  { key = 0xeb0ae85c1b44d5db4729d268f49be2a08508b9a8037235b4efad23fb7e9cb593\n  , plaintext = 0x5da58b5ef2076340d555f861c3449a77\n  , ciphertext = 0x307d50c18a0b6a08402ff131d72cb7ec\n  },\n\n  { key = 0xfac93b561a9b6a0e809d71ecdb980afab575e96989795fbcaf82d2caa9b0027f\n  , plaintext = 0x307d50c18a0b6a08402ff131d72cb7ec\n  , ciphertext = 0x92c34165a2963e77e05e2d6fc2d931d5\n  },\n\n  { key = 0xa0559e41d58af36174a67246df87541b27b6a80c2bef61cb4fdcffa56b6933aa\n  , plaintext = 0x92c34165a2963e77e05e2d6fc2d931d5\n  , ciphertext = 0xcb33d519a1fdb1d5fbb185c47870c1ed\n  },\n\n  { key = 0xe48824d6c2251d3a27f38fb543c31fc1ec857d158a12d01eb46d7a611319f247\n  , plaintext = 0xcb33d519a1fdb1d5fbb185c47870c1ed\n  , ciphertext = 0x78fb452f384c8f870e572890588f3728\n  },\n\n  { key = 0x7a33440ad7c69d583355c745e5c88c47947e383ab25e5f99ba3a52f14b96c56f\n  , plaintext = 0x78fb452f384c8f870e572890588f3728\n  , ciphertext = 0x12375e02a8bbc84b00feaab54a66db43\n  },\n\n  { key = 0x0e6877c7fdc234efb9afcd96b4ebdb83864966381ae597d2bac4f84401f01e2c\n  , plaintext = 0x12375e02a8bbc84b00feaab54a66db43\n  , ciphertext = 0xeab1606610b55c857f2b4bf1cf3feba0\n  },\n\n  { key = 0xec91d3550c79ab4914a26987725ab1396cf8065e0a50cb57c5efb3b5cecff58c\n  , plaintext = 0xeab1606610b55c857f2b4bf1cf3feba0\n  , ciphertext = 0x6c73381147de97961cc26ad26602a45a\n  },\n\n  { key = 0x83caed5a49579b3a55a71e5ece5966e5008b3e4f4d8e5cc1d92dd967a8cd51d6\n  , plaintext = 0x6c73381147de97961cc26ad26602a45a\n  , ciphertext = 0xe76c08fd29bf015352003c636fee5ff9\n  },\n\n  { key = 0x91b9b50908968361dcd8f4ba236fa199e7e736b264315d928b2de504c7230e2f\n  , plaintext = 0xe76c08fd29bf015352003c636fee5ff9\n  , ciphertext = 0x6f26b8191a2b059dcdeb3dbabc437c29\n  },\n\n  { key = 0x94fc46213c870f7965b88773afe93b1388c18eab7e1a580f46c6d8be7b607206\n  , plaintext = 0x6f26b8191a2b059dcdeb3dbabc437c29\n  , ciphertext = 0xe91e2fcef14dd4251caec97c45223fef\n  },\n\n  { key = 0xb0deff009aff61f65763b0b9fdd39a9061dfa1658f578c2a5a6811c23e424de9\n  , plaintext = 0xe91e2fcef14dd4251caec97c45223fef\n  , ciphertext = 0x98fb2122912360f07916e4802c0ea1e5\n  },\n\n  { key = 0x968f3c88d27f1be8decb00c4d464d369f92480471e74ecda237ef542124cec0c\n  , plaintext = 0x98fb2122912360f07916e4802c0ea1e5\n  , ciphertext = 0xb4a15c59976b39da50da8ed393f27a62\n  },\n\n  { key = 0x35fe06a60309581565a97232140668464d85dc1e891fd50073a47b9181be966e\n  , plaintext = 0xb4a15c59976b39da50da8ed393f27a62\n  , ciphertext = 0xd8b57d7a72ef92409c51d40bb8c4cbc5\n  },\n\n  { key = 0x4739043d7750bcf4a6f269a3d54083ca9530a164fbf04740eff5af9a397a5dab\n  , plaintext = 0xd8b57d7a72ef92409c51d40bb8c4cbc5\n  , ciphertext = 0x548cc893e80caf5a601c2381517f8c5b\n  },\n\n  { key = 0x4b065b5195f2ddf6f5d0aed72ff7a1e3c1bc69f713fce81a8fe98c1b6805d1f0\n  , plaintext = 0x548cc893e80caf5a601c2381517f8c5b\n  , ciphertext = 0x1c2238c560d678d40b48cc8034add0c4\n  },\n\n  { key = 0x1a949129e14c5963d997c86a6352ea53dd9e5132732a90ce84a1409b5ca80134\n  , plaintext = 0x1c2238c560d678d40b48cc8034add0c4\n  , ciphertext = 0x2771ff806e061df8ad4aa877717bf309\n  },\n\n  { key = 0x91cd3e48f4b42c432bed9848583e6dc7faefaeb21d2c8d3629ebe8ec2dd3f23d\n  , plaintext = 0x2771ff806e061df8ad4aa877717bf309\n  , ciphertext = 0x065593fa1fcdb481bb27f334505543f5\n  },\n\n  { key = 0x42d6f7b585a0a0d356c59be3d07d4d41fcba3d4802e139b792cc1bd87d86b1c8\n  , plaintext = 0x065593fa1fcdb481bb27f334505543f5\n  , ciphertext = 0xd3f309c0039b15d14eb8b739a94b94fa\n  },\n\n  { key = 0x72900f0ecbf90fa058805deb430815072f493488017a2c66dc74ace1d4cd2532\n  , plaintext = 0xd3f309c0039b15d14eb8b739a94b94fa\n  , ciphertext = 0x4e441a3fb277d6fbe0ed7c6e080d9a9f\n  },\n\n  { key = 0x12ef8789b91a8e35fd0ac79457a906f0610d2eb7b30dfa9d3c99d08fdcc0bfad\n  , plaintext = 0x4e441a3fb277d6fbe0ed7c6e080d9a9f\n  , ciphertext = 0xcb9241bc964cbc9823531f68e3a03b7c\n  },\n\n  { key = 0x2cbe5980ad54c5dbf2ee3db1e9875733aa9f6f0b254146051fcacfe73f6084d1\n  , plaintext = 0xcb9241bc964cbc9823531f68e3a03b7c\n  , ciphertext = 0x70b17c3e869aca6076617a2cf75e9f4a\n  },\n\n  { key = 0xdc4da3812736a2a603bcc6390763c5c5da2e1335a3db8c6569abb5cbc83e1b9b\n  , plaintext = 0x70b17c3e869aca6076617a2cf75e9f4a\n  , ciphertext = 0xf4b8a6ed6d6d72aff59484314f210bb9\n  },\n\n  { key = 0x2e4e21a6eb77bb39a1cb5cd20cc5fd3b2e96b5d8ceb6feca9c3f31fa871f1022\n  , plaintext = 0xf4b8a6ed6d6d72aff59484314f210bb9\n  , ciphertext = 0xf56a4597beaeafc0c14ee73988bcbee8\n  },\n\n  { key = 0x54d5c037e61fd09e5cf57fd34c5e0192dbfcf04f7018510a5d71d6c30fa3aeca\n  , plaintext = 0xf56a4597beaeafc0c14ee73988bcbee8\n  , ciphertext = 0x04333079d5352236e1c79213f3f38dbe\n  },\n\n  { key = 0x3a5da203e03fa399caeb1fac63679b56dfcfc036a52d733cbcb644d0fc502374\n  , plaintext = 0x04333079d5352236e1c79213f3f38dbe\n  , ciphertext = 0x22c97ecdf4af830f94b11951f41e4d29\n  },\n\n  { key = 0x5c84147d6ab2051b56b0993a7cbfa306fd06befb5182f03328075d81084e6e5d\n  , plaintext = 0x22c97ecdf4af830f94b11951f41e4d29\n  , ciphertext = 0xdef46a3b39c8048431d2491d97daa6ea\n  },\n\n  { key = 0x7af77aa155a33f658283ebc3e9eb708923f2d4c0684af4b719d5149c9f94c8b7\n  , plaintext = 0xdef46a3b39c8048431d2491d97daa6ea\n  , ciphertext = 0x4c6367ad8a2190366c3d730fe5eeb6ee\n  },\n\n  { key = 0xedabba9dc9d87357bb91da6931c743e16f91b36de26b648175e867937a7a7e59\n  , plaintext = 0x4c6367ad8a2190366c3d730fe5eeb6ee\n  , ciphertext = 0x90bd09b4eb0f7d8397c0026cefea8fb3\n  },\n\n  { key = 0xab7ef1b4a1e43771de88e158ad26a419ff2cbad909641902e22865ff9590f1ea\n  , plaintext = 0x90bd09b4eb0f7d8397c0026cefea8fb3\n  , ciphertext = 0x25aefcfa6ec98fae81b93afad7761711\n  },\n\n  { key = 0x6b0145c6cbeaae320be86c2909c8d643da82462367ad96ac63915f0542e6e6fb\n  , plaintext = 0x25aefcfa6ec98fae81b93afad7761711\n  , ciphertext = 0x607b26f4eb3585e3e886e75c0f3a01cf\n  },\n\n  { key = 0xb46d28c20a614b6d986e92795258631cbaf960d78c98134f8b17b8594ddce734\n  , plaintext = 0x607b26f4eb3585e3e886e75c0f3a01cf\n  , ciphertext = 0xfe35fe16a3290042c28c021ee9ede73f\n  },\n\n  { key = 0x93c5c8403410764717e547e3d07b0ec344cc9ec12fb1130d499bba47a431000b\n  , plaintext = 0xfe35fe16a3290042c28c021ee9ede73f\n  , ciphertext = 0x0141871c357a00ad37ae65597830cac8\n  },\n\n  { key = 0xcf85ea60e0c94e611fedba48e19e9693458d19dd1acb13a07e35df1edc01cac3\n  , plaintext = 0x0141871c357a00ad37ae65597830cac8\n  , ciphertext = 0xdf8bc7782ae10eb2c1bdfdc8887e4907\n  },\n\n  { key = 0xd40735932ea269aeb51fa3caf0c176d89a06dea5302a1d12bf8822d6547f83c4\n  , plaintext = 0xdf8bc7782ae10eb2c1bdfdc8887e4907\n  , ciphertext = 0x1ac65c65b6cd8ab751f1d908ebd962ab\n  },\n\n  { key = 0x9a7120341819fe54fc8a750d17ecf20f80c082c086e797a5ee79fbdebfa6e16f\n  , plaintext = 0x1ac65c65b6cd8ab751f1d908ebd962ab\n  , ciphertext = 0x9f10b53fb6adf7189e277d04e351aa9d\n  },\n\n  { key = 0x8c19642c172cdb804059f751b3f25cff1fd037ff304a60bd705e86da5cf74bf2\n  , plaintext = 0x9f10b53fb6adf7189e277d04e351aa9d\n  , ciphertext = 0xc94ecc943ddc8d1eeafadd173cf73fdc\n  },\n\n  { key = 0xe1cc9575e51d6a8240e6f3cd8958e1a6d69efb6b0d96eda39aa45bcd6000742e\n  , plaintext = 0xc94ecc943ddc8d1eeafadd173cf73fdc\n  , ciphertext = 0x5dd513d74b72f9d46b06b4b96a94c3bd\n  },\n\n  { key = 0xce41ff2d70b2169fad6a5f9ead4471e88b4be8bc46e41477f1a2ef740a94b793\n  , plaintext = 0x5dd513d74b72f9d46b06b4b96a94c3bd\n  , ciphertext = 0x1594a31cc22cdbaf2011a9a317538608\n  },\n\n  { key = 0x7b467b87180772677903a043bc63c3ef9edf4ba084c8cfd8d1b346d71dc7319b\n  , plaintext = 0x1594a31cc22cdbaf2011a9a317538608\n  , ciphertext = 0x4d5e8d6fa3e2ea343b5afb77124529aa\n  },\n\n  { key = 0xca068b3afc717d1f6e8dc7e4eca0f56fd381c6cf272a25eceae9bda00f821831\n  , plaintext = 0x4d5e8d6fa3e2ea343b5afb77124529aa\n  , ciphertext = 0x1bbf651cf61c295c96e73a210483d7a1\n  },\n\n  { key = 0xd04d80998a971ec52d5390fa7eaf78eac83ea3d3d1360cb07c0e87810b01cf90\n  , plaintext = 0x1bbf651cf61c295c96e73a210483d7a1\n  , ciphertext = 0x84b42f75c3b62bbf21707ba66cca399f\n  },\n\n  { key = 0x2cfb1c71e8cac872e6a6dc90b0195acf4c8a8ca61280270f5d7efc2767cbf60f\n  , plaintext = 0x84b42f75c3b62bbf21707ba66cca399f\n  , ciphertext = 0xa0c514e1e6a9c659f605eff4cf4951a0\n  },\n\n  { key = 0x405bc450a19e6dae76847b8eac858c8bec4f9847f429e156ab7b13d3a882a7af\n  , plaintext = 0xa0c514e1e6a9c659f605eff4cf4951a0\n  , ciphertext = 0x1dcc38307c6b3c31e25f868b279b3711\n  },\n\n  { key = 0x35755fe97d9aeb1e67c1f4ca5a40ce1ff183a0778842dd67492495588f1990be\n  , plaintext = 0x1dcc38307c6b3c31e25f868b279b3711\n  , ciphertext = 0xcdd744574664be7b221d7a2921b4f0b2\n  },\n\n  { key = 0x7e9d8b4bbd2aad70d229247d5880a0cb3c54e420ce26631c6b39ef71aead600c\n  , plaintext = 0xcdd744574664be7b221d7a2921b4f0b2\n  , ciphertext = 0xe602ef85184ad4a86ed339e9403f541c\n  },\n\n  { key = 0x73be0bb5b74a8f6324f8a5f0acbf5faada560ba5d66cb7b405ead698ee923410\n  , plaintext = 0xe602ef85184ad4a86ed339e9403f541c\n  , ciphertext = 0x7c227f03e605ff14c42fb9f8e8786e84\n  },\n\n  { key = 0xc82e22faeca51a38045f2a3a04a0e6e2a67474a6306948a0c1c56f6006ea5a94\n  , plaintext = 0x7c227f03e605ff14c42fb9f8e8786e84\n  , ciphertext = 0x94c0466b27aa4d361b19c250329c14a0\n  },\n\n  { key = 0x7c1dd42bdff414e3733b846cbb00c43432b432cd17c30596dadcad3034764e34\n  , plaintext = 0x94c0466b27aa4d361b19c250329c14a0\n  , ciphertext = 0xfd6b281c93c1fd8e9b83b69ecf722f3b\n  },\n\n  { key = 0xaa7ec003efbca86fe5ad028d0571cf3acfdf1ad18402f818415f1baefb04610f\n  , plaintext = 0xfd6b281c93c1fd8e9b83b69ecf722f3b\n  , ciphertext = 0xa75b28be92dc53de9d44714918e3c541\n  },\n\n  { key = 0x14ba26bafb6c8410104d70ec23876db56884326f16deabc6dc1b6ae7e3e7a44e\n  , plaintext = 0xa75b28be92dc53de9d44714918e3c541\n  , ciphertext = 0x48693025ba68f3fa3515e7112b6e32aa\n  },\n\n  { key = 0x33b40738b39ebe39118938c6461ebd7820ed024aacb6583ce90e8df6c88996e4\n  , plaintext = 0x48693025ba68f3fa3515e7112b6e32aa\n  , ciphertext = 0x6bfa37cc5ed6e5d4ddf40b1301957f73\n  },\n\n  { key = 0x0d16eab1b56e2a468bf1ba1035129d574b173586f260bde834fa86e5c91ce997\n  , plaintext = 0x6bfa37cc5ed6e5d4ddf40b1301957f73\n  , ciphertext = 0xca18b89c3225877e02e21042af9836a8\n  },\n\n  { key = 0x44b55514a5b4a5a4294f3cf8e75ff73c810f8d1ac0453a96361896a76684df3f\n  , plaintext = 0xca18b89c3225877e02e21042af9836a8\n  , ciphertext = 0xc3ebc08368be58f8f514cfbd5f98ed52\n  },\n\n  { key = 0x265f1a7a53151bc51526fe476e8c63ad42e44d99a8fb626ec30c591a391c326d\n  , plaintext = 0xc3ebc08368be58f8f514cfbd5f98ed52\n  , ciphertext = 0x788552397ddf2d5841dbc0e73dd11150\n  },\n\n  { key = 0x23fa4630937015585ac065e6a7bd93023a611fa0d5244f3682d799fd04cd233d\n  , plaintext = 0x788552397ddf2d5841dbc0e73dd11150\n  , ciphertext = 0xe9d728bc19b50809bc1245552091d0b2\n  },\n\n  { key = 0x9dd3a2408e5694fced28964c7f442e6ed3b6371ccc91473f3ec5dca8245cf38f\n  , plaintext = 0xe9d728bc19b50809bc1245552091d0b2\n  , ciphertext = 0xce08d78b58179b7957eeab6f74ddb10f\n  },\n\n  { key = 0x055d53ef574a63f77c0b3a88e7e7cdb01dbee0979486dc46692b77c750814280\n  , plaintext = 0xce08d78b58179b7957eeab6f74ddb10f\n  , ciphertext = 0x33ce33e80fcc262e9e862f5ac50c14df\n  },\n\n  { key = 0xc1a90cdef5d5daaf7b182d6b409940e62e70d37f9b4afa68f7ad589d958d565f\n  , plaintext = 0x33ce33e80fcc262e9e862f5ac50c14df\n  , ciphertext = 0x5c4d21e6045f11f9f91a8cef130304e0\n  },\n\n  { key = 0x6a257a4f65bdd7d882ff45ffbb9541e5723df2999f15eb910eb7d472868e52bf\n  , plaintext = 0x5c4d21e6045f11f9f91a8cef130304e0\n  , ciphertext = 0x4f50679c2dbfa63b5e55d031afacd44b\n  },\n\n  { key = 0x5843bf4d6afc64273d328e1baf7821b03d6d9505b2aa4daa50e20443292286f4\n  , plaintext = 0x4f50679c2dbfa63b5e55d031afacd44b\n  , ciphertext = 0x29f64e79de48f3d3d5dff92aa0b1783b\n  },\n\n  { key = 0x8915060a33758a300c053d365c304d4e149bdb7c6ce2be79853dfd698993fecf\n  , plaintext = 0x29f64e79de48f3d3d5dff92aa0b1783b\n  , ciphertext = 0x8c5bf92515a92449846593a3bdbe521b\n  },\n\n  { key = 0xbe2b2a41b3491511c181508b66ec96f798c02259794b9a3001586eca342dacd4\n  , plaintext = 0x8c5bf92515a92449846593a3bdbe521b\n  , ciphertext = 0x5511fef7a2238277aaa9e25f1d097c19\n  },\n\n  { key = 0x4d6f38935317ffa0cb29bdfa8a43cd19cdd1dcaedb681847abf18c952924d0cd\n  , plaintext = 0x5511fef7a2238277aaa9e25f1d097c19\n  , ciphertext = 0x2ecd75c6a5eace1c541e12db150a2143\n  },\n\n  { key = 0x1549ea3d167152c85223b0a603d1fa61e31ca9687e82d65bffef9e4e3c2ef18e\n  , plaintext = 0x2ecd75c6a5eace1c541e12db150a2143\n  , ciphertext = 0x6a4cfcb9e8dae9610df99509daac7be0\n  },\n\n  { key = 0xba593f6731f70edab83f5cdf02527436895055d196583f3af2160b47e6828a6e\n  , plaintext = 0x6a4cfcb9e8dae9610df99509daac7be0\n  , ciphertext = 0x185772deff51807147ac5350249b3e1a\n  },\n\n  { key = 0x7126a05712f987f1c9249bf9a7c17b4f9107270f6909bf4bb5ba5817c219b474\n  , plaintext = 0x185772deff51807147ac5350249b3e1a\n  , ciphertext = 0xbfb1ce7df706bc972e1b8306d44aa135\n  },\n\n  { key = 0x3d0fa3983ebc8a3f64c4135d7cd3195e2eb6e9729e0f03dc9ba1db1116531541\n  , plaintext = 0xbfb1ce7df706bc972e1b8306d44aa135\n  , ciphertext = 0xf21df1e99a781dba4a68ff3491848f99\n  },\n\n  { key = 0x88c88ec4d63eb481cd8d6e8e8d2e2715dcab189b04771e66d1c9242587d79ad8\n  , plaintext = 0xf21df1e99a781dba4a68ff3491848f99\n  , ciphertext = 0xe4e8c9e4963a44f5cf27767e4e42fa61\n  },\n\n  { key = 0x989b9545625a4025f7725d63847213883843d17f924d5a931eee525bc99560b9\n  , plaintext = 0xe4e8c9e4963a44f5cf27767e4e42fa61\n  , ciphertext = 0x27475121d0e3367d0e0c2d9fb39cfe95\n  },\n\n  { key = 0xf49b61f190f982aa866d5c8f2e5749781f04805e42ae6cee10e27fc47a099e2c\n  , plaintext = 0x27475121d0e3367d0e0c2d9fb39cfe95\n  , ciphertext = 0xc2990626cb34c5d7fafe0430650ed907\n  },\n\n  { key = 0x101537d5f633ad8dc7e8cc058ce7fe20dd9d8678899aa939ea1c7bf41f07472b\n  , plaintext = 0xc2990626cb34c5d7fafe0430650ed907\n  , ciphertext = 0x1c5d0cca2845b66c371c1760f81e024a\n  },\n\n  { key = 0x1f6acaa66674733d28dfec92c43c7e76c1c08ab2a1df1f55dd006c94e7194561\n  , plaintext = 0x1c5d0cca2845b66c371c1760f81e024a\n  , ciphertext = 0x6f5a53addd93c9a136401a804a710419\n  },\n\n  { key = 0xb55bdefe370646699012062df748b6aaae9ad91f7c4cd6f4eb407614ad684178\n  , plaintext = 0x6f5a53addd93c9a136401a804a710419\n  , ciphertext = 0x8e0c070be7109ead0e8cc0aa0bf95e61\n  },\n\n  { key = 0xde09c34a85d56a2748559c309f04eb722096de149b5c4859e5ccb6bea6911f19\n  , plaintext = 0x8e0c070be7109ead0e8cc0aa0bf95e61\n  , ciphertext = 0xdb53b5306561db899a635a56c56e7239\n  },\n\n  { key = 0x2650ecd133a5df3825072a4df2d95d15fbc56b24fe3d93d07fafece863ff6d20\n  , plaintext = 0xdb53b5306561db899a635a56c56e7239\n  , ciphertext = 0x72e5ac05990d3f5508295f95f8973313\n  },\n\n  { key = 0xa8599f0edd6446b4bb9371e380bf33488920c7216730ac857786b37d9b685e33\n  , plaintext = 0x72e5ac05990d3f5508295f95f8973313\n  , ciphertext = 0x86a8332f16f997bc02af5271c64e7e0f\n  },\n\n  { key = 0x672e7b0d497458e260084662c566394e0f88f40e71c93b397529e10c5d26203c\n  , plaintext = 0x86a8332f16f997bc02af5271c64e7e0f\n  , ciphertext = 0x8e53858ce7ad0d25410f886eeeca1e0e\n  },\n\n  { key = 0x73ea41a50cdd5a98644e6f8d974af21381db71829664361c34266962b3ec3e32\n  , plaintext = 0x8e53858ce7ad0d25410f886eeeca1e0e\n  , ciphertext = 0xc6a1d493d607d2cef6aef29ee878c434\n  },\n\n  { key = 0x14969b3ff78ccdd66c53b8027a79563e477aa5114063e4d2c2889bfc5b94fa06\n  , plaintext = 0xc6a1d493d607d2cef6aef29ee878c434\n  , ciphertext = 0xa4973e0cfaf8d6ac6758615fc81e06df\n  },\n\n  { key = 0xd09e2741b9480c2166c9c1832654763de3ed9b1dba9b327ea5d0faa3938afcd9\n  , plaintext = 0xa4973e0cfaf8d6ac6758615fc81e06df\n  , ciphertext = 0x67e3243d8bc81887517708a29a5d9ae5\n  },\n\n  { key = 0x22c65ead303a0395cc9c065ada930ddd840ebf2031532af9f4a7f20109d7663c\n  , plaintext = 0x67e3243d8bc81887517708a29a5d9ae5\n  , ciphertext = 0xde2f35df51644cf5d79984be6c17c14c\n  },\n\n  { key = 0x8679ef0357516245ec489386419646bc5a218aff6037660c233e76bf65c0a770\n  , plaintext = 0xde2f35df51644cf5d79984be6c17c14c\n  , ciphertext = 0x9eaedabb3bd046ec27a2bdafabdbc861\n  },\n\n  { key = 0x6043902c115f107639e7c92ba4952301c48f50445be720e0049ccb10ce1b6f11\n  , plaintext = 0x9eaedabb3bd046ec27a2bdafabdbc861\n  , ciphertext = 0x0cde7e6c1aecbbe996865bf30b178de7\n  },\n\n  { key = 0xaca443a9e31033ea73b1eeda6e7d6ca1c8512e28410b9b09921a90e3c50ce2f6\n  , plaintext = 0x0cde7e6c1aecbbe996865bf30b178de7\n  , ciphertext = 0xba25bf5be1e4c099b9e45eedd7369cb5\n  },\n\n  { key = 0x60362e2b0bf998c875c087c370c4ca4772749173a0ef5b902bfece0e123a7e43\n  , plaintext = 0xba25bf5be1e4c099b9e45eedd7369cb5\n  , ciphertext = 0x805be62789549ce6af74966467f41135\n  },\n\n  { key = 0x6d7f0f7584162a1fa4dd6764548f355af22f775429bbc776848a586a75ce6f76\n  , plaintext = 0x805be62789549ce6af74966467f41135\n  , ciphertext = 0xab6001c6c4c56e8ca393c5fd173505ba\n  },\n\n  { key = 0xd8ecc39ac1d00c53216f6e64e826a7a9594f7692ed7ea9fa27199d9762fb6acc\n  , plaintext = 0xab6001c6c4c56e8ca393c5fd173505ba\n  , ciphertext = 0x3ba3673f4f495dd1541d47c22b7921c5\n  },\n\n  { key = 0x493108f91caedf714652149a2b2030fe62ec11ada237f42b7304da5549824b09\n  , plaintext = 0x3ba3673f4f495dd1541d47c22b7921c5\n  , ciphertext = 0xb24fe17cdc5c8cfa4260c38691b57bfa\n  },\n\n  { key = 0x446af6dd5f58755aeaa0a1226d8c584fd0a3f0d17e6b78d1316419d3d83730f3\n  , plaintext = 0xb24fe17cdc5c8cfa4260c38691b57bfa\n  , ciphertext = 0x86d999a63b96f6c9d9aaf3be6202977b\n  },\n\n  { key = 0x65f92d4e1723d5e58aeb350c79df28de567a697745fd8e18e8ceea6dba35a788\n  , plaintext = 0x86d999a63b96f6c9d9aaf3be6202977b\n  , ciphertext = 0xc4712aa733f9737f91e4ed61609e02f1\n  },\n\n  { key = 0x915cee6af4ea95623f7122acda5e9040920b43d07604fd67792a070cdaaba579\n  , plaintext = 0xc4712aa733f9737f91e4ed61609e02f1\n  , ciphertext = 0x0e8c1a77b280f4c753682768fd6f3b23\n  },\n\n  { key = 0x8e9bb2887fe60d42db4d827f00ba68ff9c8759a7c48409a02a42206427c49e5a\n  , plaintext = 0x0e8c1a77b280f4c753682768fd6f3b23\n  , ciphertext = 0xdccb684d47c480cc1317dcaa451234c0\n  },\n\n  { key = 0xcbf85a6645469e5df882fe840776b6aa404c31ea8340896c3955fcce62d6aa9a\n  , plaintext = 0xdccb684d47c480cc1317dcaa451234c0\n  , ciphertext = 0x9a2c4f07489c14265e33ac031d02b3d8\n  },\n\n  { key = 0x3ea3c33d7439ab3c478c01907f13cda7da607eedcbdc9d4a676650cd7fd41942\n  , plaintext = 0x9a2c4f07489c14265e33ac031d02b3d8\n  , ciphertext = 0x5c8e622ddbd32ee79c17572e8b3ee61c\n  },\n\n  { key = 0x312c5b43263c1af8d1e35c0f24d1004386ee1cc0100fb3adfb7107e3f4eaff5e\n  , plaintext = 0x5c8e622ddbd32ee79c17572e8b3ee61c\n  , ciphertext = 0xc5d2cb3d5b7ff0e23e308967ee074825\n  }]\n\n\naes256_MCT_decrypt_test_vectors : [100](AESTestVector 256)\naes256_MCT_decrypt_test_vectors =\n \/\/ Vectors from ECBMCT256.rsp\n [{ key = 0x2b09ba39b834062b9e93f48373b8dd018dedf1e5ba1b8af831ebbacbc92a2643\n  , ciphertext = 0x89649bd0115f30bd878567610223a59d\n  , plaintext = 0x1f9b9b213f1884fa98b62dd6639fd33b\n  },\n\n  { key = 0x58ac71619fdc3ac73a17f285319e1cd492766ac485030e02a95d971daab5f578\n  , ciphertext = 0x1f9b9b213f1884fa98b62dd6639fd33b\n  , plaintext = 0xaecd334ef8fb0c51b6896ae065d8be28\n  },\n\n  { key = 0xf6e3cca2cd628c10625c62cf08b385743cbb598a7df802531fd4fdfdcf6d4b50\n  , ciphertext = 0xaecd334ef8fb0c51b6896ae065d8be28\n  , plaintext = 0xf1938dd245c055e9c380336ff8450d9d\n  },\n\n  { key = 0xa9ae3bd7d454f19d69289875ff009d16cd28d458383857badc54ce92372846cd\n  , ciphertext = 0xf1938dd245c055e9c380336ff8450d9d\n  , plaintext = 0x42d5c4a13b748800ebfe0f67781dcff1\n  },\n\n  { key = 0xe3bc6232865f0476149be7162ef8fc4b8ffd10f9034cdfba37aac1f54f35893c\n  , ciphertext = 0x42d5c4a13b748800ebfe0f67781dcff1\n  , plaintext = 0x469968a00226f0aae7acfda02b2ce0ae\n  },\n\n  { key = 0x451fbfba7f09b625540822fac8c8e30bc9647859016a2f10d0063c5564196992\n  , ciphertext = 0x469968a00226f0aae7acfda02b2ce0ae\n  , plaintext = 0xeab144d6f80ccfd2fae95d16784718ac\n  },\n\n  { key = 0xf53e21e46a0ec97c980d49d6f4b81ec423d53c8ff966e0c22aef61431c5e713e\n  , ciphertext = 0xeab144d6f80ccfd2fae95d16784718ac\n  , plaintext = 0xe04b91c3f084d733d3d0c1c7c152695a\n  },\n\n  { key = 0x5fb3a2cbdbe6971fcd345961bdcba5f6c39ead4c09e237f1f93fa084dd0c1864\n  , ciphertext = 0xe04b91c3f084d733d3d0c1c7c152695a\n  , plaintext = 0xe47db9b8c7fcc9459fa0a7fc84047b5b\n  },\n\n  { key = 0x6b145436c5ae0dcb2477f94f5bdb037927e314f4ce1efeb4669f07785908633f\n  , ciphertext = 0xe47db9b8c7fcc9459fa0a7fc84047b5b\n  , plaintext = 0xf617d26b55da999d65b2d236358b2e60\n  },\n\n  { key = 0x126752da3d7f9a0ffc1a46ccaa8a3925d1f4c69f9bc46729032dd54e6c834d5f\n  , ciphertext = 0xf617d26b55da999d65b2d236358b2e60\n  , plaintext = 0x066ffea799ad5f09d03cb868deb1591e\n  },\n\n  { key = 0xaa3daafbcd647f0a9eaa027146ab7aded79b383802693820d3116d26b2321441\n  , ciphertext = 0x066ffea799ad5f09d03cb868deb1591e\n  , plaintext = 0x6d28dbb55fb10c1c3226609997a4fb38\n  },\n\n  { key = 0xfed7b5c1f84d3dc185222da3fffac7a1bab3e38d5dd8343ce1370dbf2596ef79\n  , ciphertext = 0x6d28dbb55fb10c1c3226609997a4fb38\n  , plaintext = 0x9dd78987562c9c099d67ccc927fcec13\n  },\n\n  { key = 0xc36db4af0bee11dad6ea59679cfb988c27646a0a0bf4a8357c50c176026a036a\n  , ciphertext = 0x9dd78987562c9c099d67ccc927fcec13\n  , plaintext = 0xb5cc780ec75b8d8c5128c4d26fa520ea\n  },\n\n  { key = 0x7b5aebe66f96867504ee9efd2bd56bda92a81204ccaf25b92d7805a46dcf2380\n  , ciphertext = 0xb5cc780ec75b8d8c5128c4d26fa520ea\n  , plaintext = 0xc715bd2f23b98c66bf56e5680c6037f7\n  },\n\n  { key = 0x81a73bfcacc994f47aeec0d655e0485055bdaf2bef16a9df922ee0cc61af1477\n  , ciphertext = 0xc715bd2f23b98c66bf56e5680c6037f7\n  , plaintext = 0xe00984f9d93551e95ae85cfe4a829b82\n  },\n\n  { key = 0x2678e4ccda2eb6ad7f0e2843020da2d8b5b42bd23623f836c8c6bc322b2d8ff5\n  , ciphertext = 0xe00984f9d93551e95ae85cfe4a829b82\n  , plaintext = 0xbfa487fcb2331afe3ad82e59064b4aae\n  },\n\n  { key = 0x03565af5c267a62e0d2500ead06bc7d90a10ac2e8410e2c8f21e926b2d66c55b\n  , ciphertext = 0xbfa487fcb2331afe3ad82e59064b4aae\n  , plaintext = 0x4c278ca418fd1c5718883da0ba4a066f\n  },\n\n  { key = 0xec719a4ed851c36f806fbc78183026cc4637208a9cedfe9fea96afcb972cc334\n  , ciphertext = 0x4c278ca418fd1c5718883da0ba4a066f\n  , plaintext = 0xceed1c8b96d84951cadf809d3ea1b397\n  },\n\n  { key = 0xf138ad912201beecd15ebe2049f980e588da3c010a35b7ce20492f56a98d70a3\n  , ciphertext = 0xceed1c8b96d84951cadf809d3ea1b397\n  , plaintext = 0xf88aed84bca42a06647d6504a5c48379\n  },\n\n  { key = 0x8da22644e1267212742200dbf6b0ba947050d185b6919dc844344a520c49f3da\n  , ciphertext = 0xf88aed84bca42a06647d6504a5c48379\n  , plaintext = 0xc451b75375d0fec1cc1825eefbcc1372\n  },\n\n  { key = 0x5104213aabaccafe44129632f67cf2dab40166d6c3416309882c6fbcf785e0a8\n  , ciphertext = 0xc451b75375d0fec1cc1825eefbcc1372\n  , plaintext = 0x9a54dfd56bff41ea17bcf08d3761e95b\n  },\n\n  { key = 0x4c7c62be3f5a9d09934940284565e9c92e55b903a8be22e39f909f31c0e409f3\n  , ciphertext = 0x9a54dfd56bff41ea17bcf08d3761e95b\n  , plaintext = 0x76e074c587f112f3ffd17b390fa8cffc\n  },\n\n  { key = 0x9871765871b1dae363fca3961224414a58b5cdc62f4f30106041e408cf4cc60f\n  , ciphertext = 0x76e074c587f112f3ffd17b390fa8cffc\n  , plaintext = 0x5b14fd4c40a127733c20cd84648ec287\n  },\n\n  { key = 0x58e044758e5e4f300eb08f8b6ccd967203a1308a6fee17635c61298cabc20488\n  , ciphertext = 0x5b14fd4c40a127733c20cd84648ec287\n  , plaintext = 0x01c234e2392f42831b1172352f322286\n  },\n\n  { key = 0xffbb7104e110fdfe689f68ffa48b79590263046856c155e047705bb984f0260e\n  , ciphertext = 0x01c234e2392f42831b1172352f322286\n  , plaintext = 0xab142165cb093648938660fd800d8896\n  },\n\n  { key = 0x91aefec30a79b2524b19a611c0c4952da977250d9dc863a8d4f63b4404fdae98\n  , ciphertext = 0xab142165cb093648938660fd800d8896\n  , plaintext = 0x5c28ad9b5721edadc30e09b4541fd724\n  },\n\n  { key = 0x00d0f69c36671a9efeb7b8637e22af38f55f8896cae98e0517f832f050e279bc\n  , ciphertext = 0x5c28ad9b5721edadc30e09b4541fd724\n  , plaintext = 0x5a9ad24fe456f4f766e839a8101373c3\n  },\n\n  { key = 0xb22571c62ee4e0b4ebd7d776703c1345afc55ad92ebf7af271100b5840f10a7f\n  , ciphertext = 0x5a9ad24fe456f4f766e839a8101373c3\n  , plaintext = 0xa30e9a7730628b560c71967bdb35efce\n  },\n\n  { key = 0x1431d01006510179dd13e2a83e1b8b7b0ccbc0ae1eddf1a47d619d239bc4e5b1\n  , ciphertext = 0xa30e9a7730628b560c71967bdb35efce\n  , plaintext = 0x7118cc8a057df7ea9b7fb096decf05d9\n  },\n\n  { key = 0x06104531e2d000fff0cc8336b62e9bb87dd30c241ba0064ee61e2db5450be068\n  , ciphertext = 0x7118cc8a057df7ea9b7fb096decf05d9\n  , plaintext = 0xc550ff93a36fbb8e9a505682e07fb981\n  },\n\n  { key = 0x8e5ebd5c9bf858f3379bfb88c7c75319b883f3b7b8cfbdc07c4e7b37a57459e9\n  , ciphertext = 0xc550ff93a36fbb8e9a505682e07fb981\n  , plaintext = 0x1375e7b4164adc861bbb77c50aba445c\n  },\n\n  { key = 0xccc9445c3aab1c03ec8027593d370664abf61403ae85614667f50cf2afce1db5\n  , ciphertext = 0x1375e7b4164adc861bbb77c50aba445c\n  , plaintext = 0x5bc8b411c0fae92bad54b4e5c3a8826e\n  },\n\n  { key = 0xb804994228d618a9b7a3e0c3d8d2d373f03ea0126e7f886dcaa1b8176c669fdb\n  , ciphertext = 0x5bc8b411c0fae92bad54b4e5c3a8826e\n  , plaintext = 0x36c9de7c01298ff06c5e3ecf12507cd6\n  },\n\n  { key = 0x8a784f32cdd7e2ed19e85faf04de2015c6f77e6e6f56079da6ff86d87e36e30d\n  , ciphertext = 0x36c9de7c01298ff06c5e3ecf12507cd6\n  , plaintext = 0x35d814c0f6c07ae72bbe7cd1751d7527\n  },\n\n  { key = 0x71e3cc0f60a2eafd83c3a455eefc4c9cf32f6aae99967d7a8d41fa090b2b962a\n  , ciphertext = 0x35d814c0f6c07ae72bbe7cd1751d7527\n  , plaintext = 0x73c39ce5ea1b5eab18c9c15221e258d1\n  },\n\n  { key = 0x71bef3d2beffa17d37c6c3b28ef2928280ecf64b738d23d195883b5b2ac9cefb\n  , ciphertext = 0x73c39ce5ea1b5eab18c9c15221e258d1\n  , plaintext = 0xac67508a8bcab69f96ead29121718cd7\n  },\n\n  { key = 0x9aa1ffa9e175f03a6bcc71fc2aea3a522c8ba6c1f847954e0362e9ca0bb8422c\n  , ciphertext = 0xac67508a8bcab69f96ead29121718cd7\n  , plaintext = 0x49d2cac2ca39a3b66302e5f3650e71d7\n  },\n\n  { key = 0x4e480b73ab5c659538354b2474c9367b65596c03327e36f860600c396eb633fb\n  , ciphertext = 0x49d2cac2ca39a3b66302e5f3650e71d7\n  , plaintext = 0xe54638674ea0b3e837772a2866723753\n  },\n\n  { key = 0xaeecd55c38bef76367a21469d08721d2801f54647cde85105717261108c404a8\n  , ciphertext = 0xe54638674ea0b3e837772a2866723753\n  , plaintext = 0x074d933018e9e0558b416e39548994ff\n  },\n\n  { key = 0xe36c6a30f734a679ab7af2f9ff767cfe8752c75464376545dc5648285c4d9057\n  , ciphertext = 0x074d933018e9e0558b416e39548994ff\n  , plaintext = 0x04825a9ba20646acadb2cbdbd23530c0\n  },\n\n  { key = 0x124806708fc5fc73a1e50c61e5a76b8783d09dcfc63123e971e483f38e78a097\n  , ciphertext = 0x04825a9ba20646acadb2cbdbd23530c0\n  , plaintext = 0x25b98d2837580f9f3da8f2593f7b1d72\n  },\n\n  { key = 0x560afb5529a8b433738348a296408cada66910e7f1692c764c4c71aab103bde5\n  , ciphertext = 0x25b98d2837580f9f3da8f2593f7b1d72\n  , plaintext = 0x048b220c70d875cad6901e40f45c5b03\n  },\n\n  { key = 0x8b7c61dd007d9d0d1937cfc69b63c114a2e232eb81b159bc9adc6fea455fe6e6\n  , ciphertext = 0x048b220c70d875cad6901e40f45c5b03\n  , plaintext = 0x34e2a33412c0e682b29b26d5409d015f\n  },\n\n  { key = 0x30560ca0a31d8145228d34fbf8415683960091df9371bf3e2847493f05c2e7b9\n  , ciphertext = 0x34e2a33412c0e682b29b26d5409d015f\n  , plaintext = 0x942c057914f3b88fa0a40bb41d02b051\n  },\n\n  { key = 0x20c7e6e45c08ba0756c379b6cd4d6886022c94a6878207b188e3428b18c057e8\n  , ciphertext = 0x942c057914f3b88fa0a40bb41d02b051\n  , plaintext = 0x6f4e5c40e4135abfdf294b4d8c9304b3\n  },\n\n  { key = 0x2a6c928bf8c2b32ce82ed0be1bc954b96d62c8e663915d0e57ca09c69453535b\n  , ciphertext = 0x6f4e5c40e4135abfdf294b4d8c9304b3\n  , plaintext = 0xcac032ddc2b27443d70d0f2dfb1a1d87\n  },\n\n  { key = 0x74994d46526b2e9d5470a0a687f726f2a7a2fa3ba123294d80c706eb6f494edc\n  , ciphertext = 0xcac032ddc2b27443d70d0f2dfb1a1d87\n  , plaintext = 0x6aec33b2c1ae39237b13e86555722d1a\n  },\n\n  { key = 0x5aaec28d079eef5f1c42df377c7e80accd4ec989608d106efbd4ee8e3a3b63c6\n  , ciphertext = 0x6aec33b2c1ae39237b13e86555722d1a\n  , plaintext = 0x2df34173bbff331488b23687c755f617\n  },\n\n  { key = 0x9bfa3c08b8f8b8758f0a1f4b0ef86be4e0bd88fadb72237a7366d809fd6e95d1\n  , ciphertext = 0x2df34173bbff331488b23687c755f617\n  , plaintext = 0x07649dd5c1c7b38810cbecbad9c037ed\n  },\n\n  { key = 0x188e3a027b75fede978c76e70a853f95e7d9152f1ab590f263ad34b324aea23c\n  , ciphertext = 0x07649dd5c1c7b38810cbecbad9c037ed\n  , plaintext = 0xef3d9092321649d9bbb88f6448e3847b\n  },\n\n  { key = 0xaae2c6363be3dbb71c21f3a2d9f123f108e485bd28a3d92bd815bbd76c4d2647\n  , ciphertext = 0xef3d9092321649d9bbb88f6448e3847b\n  , plaintext = 0x1e5058b3e986d4aad80a11f909af1cca\n  },\n\n  { key = 0x85a51c6d62ba97564ac955a5409c362916b4dd0ec1250d81001faa2e65e23a8d\n  , ciphertext = 0x1e5058b3e986d4aad80a11f909af1cca\n  , plaintext = 0x9bf81052596b786b50b3f3506c009169\n  },\n\n  { key = 0x0d09600f108a86cfd58f3c211a40c38d8d4ccd5c984e75ea50ac597e09e2abe4\n  , ciphertext = 0x9bf81052596b786b50b3f3506c009169\n  , plaintext = 0x81bdaf86cf4255e5826294a51d2f9992\n  },\n\n  { key = 0x14ab478866e1d160311aa8820df354fb0cf162da570c200fd2cecddb14cd3276\n  , ciphertext = 0x81bdaf86cf4255e5826294a51d2f9992\n  , plaintext = 0x1fdc5fee9eb640ff547a98d9e1601b52\n  },\n\n  { key = 0x39f18405f0b1da647f99479e87d4d153132d3d34c9ba60f086b45502f5ad2924\n  , ciphertext = 0x1fdc5fee9eb640ff547a98d9e1601b52\n  , plaintext = 0x936609876cd6eebf31db5a6af7839844\n  },\n\n  { key = 0x85a900bc1563b16e01481e45d1125734804b34b3a56c8e4fb76f0f68022eb160\n  , ciphertext = 0x936609876cd6eebf31db5a6af7839844\n  , plaintext = 0x9ea8b6942287f470e9866a48f4dc661a\n  },\n\n  { key = 0xc43d677fc0a1becbb0214221b866f0be1ee3822787eb7a3f5ee96520f6f2d77a\n  , ciphertext = 0x9ea8b6942287f470e9866a48f4dc661a\n  , plaintext = 0x1dfc2cf82bfaa2732eb525916ef9ef13\n  },\n\n  { key = 0x584f10659c2d3c41f6a1926de4595eb2031faedfac11d84c705c40b1980b3869\n  , ciphertext = 0x1dfc2cf82bfaa2732eb525916ef9ef13\n  , plaintext = 0xa5d8d1d60281a152b9b76142e3e5a512\n  },\n\n  { key = 0x8eba336927e18b13eb3858a89709768ba6c77f09ae90791ec9eb21f37bee9d7b\n  , ciphertext = 0xa5d8d1d60281a152b9b76142e3e5a512\n  , plaintext = 0x8ac0278f2ab100a5964173d76934d732\n  },\n\n  { key = 0x13f1558dcae09062bfdccdd0037e5c432c075886842179bb5faa522412da4a49\n  , ciphertext = 0x8ac0278f2ab100a5964173d76934d732\n  , plaintext = 0x30233b70c4d6fd31b23cc77bc73559ea\n  },\n\n  { key = 0xd736669842aa88f43f1de421d38f391f1c2463f640f7848aed96955fd5ef13a3\n  , ciphertext = 0x30233b70c4d6fd31b23cc77bc73559ea\n  , plaintext = 0x766630dfd41e4146a827f55cba745b6a\n  },\n\n  { key = 0x0ca8353df90e73606588a11675bd37a76a42532994e9c5cc45b160036f9b48c9\n  , ciphertext = 0x766630dfd41e4146a827f55cba745b6a\n  , plaintext = 0x177f22d98f009c214a44b08cf40b790d\n  },\n\n  { key = 0x136ec3a1a65ee7bb0fd09af7364b66607d3d71f01be959ed0ff5d08f9b9031c4\n  , ciphertext = 0x177f22d98f009c214a44b08cf40b790d\n  , plaintext = 0xe9c916a21dec9662bdd91a0f865f8b47\n  },\n\n  { key = 0xba5c2bd413daca7866de11c11db2926694f467520605cf8fb22cca801dcfba83\n  , ciphertext = 0xe9c916a21dec9662bdd91a0f865f8b47\n  , plaintext = 0x92b3ab3e28f6c606508706e0c3d76d28\n  },\n\n  { key = 0x0fab4768fa7f104a3579f534508182920647cc6c2ef30989e2abcc60de18d7ab\n  , ciphertext = 0x92b3ab3e28f6c606508706e0c3d76d28\n  , plaintext = 0x3652053dcba591f101944fb1a5eb2b99\n  },\n\n  { key = 0xe766aa23c075deaa6fae68384f5b205e3015c951e5569878e33f83d17bf3fc32\n  , ciphertext = 0x3652053dcba591f101944fb1a5eb2b99\n  , plaintext = 0x242260d2387c6f1a415834b34e300a7e\n  },\n\n  { key = 0x9f1941442336bfffa1d6b27dce7845971437a983dd2af762a267b76235c3f64c\n  , ciphertext = 0x242260d2387c6f1a415834b34e300a7e\n  , plaintext = 0xa2a58ed050231b0d15f8cd99f5e171fb\n  },\n\n  { key = 0x429a3cdc98124fafe33156a66b4e8c2ab69227538d09ec6fb79f7afbc02287b7\n  , ciphertext = 0xa2a58ed050231b0d15f8cd99f5e171fb\n  , plaintext = 0xec6631b17e5c97193fd9651b64feffe7\n  },\n\n  { key = 0x92764a89e0de63823b9d9a5a001868035af416e2f3557b7688461fe0a4dc7850\n  , ciphertext = 0xec6631b17e5c97193fd9651b64feffe7\n  , plaintext = 0x1eef8afa419a9341085a2d611185e42c\n  },\n\n  { key = 0x0c0bf13d79d1297e137e6f5995cb0a2c441b9c18b2cfe837801c3281b5599c7c\n  , ciphertext = 0x1eef8afa419a9341085a2d611185e42c\n  , plaintext = 0xd4eb4e591cf856b816e2207264e426e4\n  },\n\n  { key = 0xde31f995867bb45813d369349cb7434290f0d241ae37be8f96fe12f3d1bdba98\n  , ciphertext = 0xd4eb4e591cf856b816e2207264e426e4\n  , plaintext = 0x401e14b126348e1aedd13662a19c23fb\n  },\n\n  { key = 0x3b1a02b5600444db09118e99765fa61dd0eec6f0880330957b2f249170219963\n  , ciphertext = 0x401e14b126348e1aedd13662a19c23fb\n  , plaintext = 0x38bfea7e1eece741eb6a9601605129dd\n  },\n\n  { key = 0x1fbcf4ffb36f76b88323f745b3152947e8512c8e96efd7d49045b2901070b0be\n  , ciphertext = 0x38bfea7e1eece741eb6a9601605129dd\n  , plaintext = 0x71cd66b3b3553b6aa632c338a307e11a\n  },\n\n  { key = 0xb963bfe1c513f0dba7e24b5cfa1535a3999c4a3d25baecbe367771a8b37751a4\n  , ciphertext = 0x71cd66b3b3553b6aa632c338a307e11a\n  , plaintext = 0x34c2972d43e59eb0c44b7b69a540e7de\n  },\n\n  { key = 0x23458e2a4332ce00e7967a438cd86448ad5edd10665f720ef23c0ac11637b67a\n  , ciphertext = 0x34c2972d43e59eb0c44b7b69a540e7de\n  , plaintext = 0x8988b878d0c6a84b6262351e033fb1b7\n  },\n\n  { key = 0xe552b8a0f474a8da502e749e3f0639b124d66568b699da45905e3fdf150807cd\n  , ciphertext = 0x8988b878d0c6a84b6262351e033fb1b7\n  , plaintext = 0x010e24d01c37edca127484c8d8137772\n  },\n\n  { key = 0x65a0645dd971bdb3b0d3a079ef96f3a925d841b8aaae378f822abb17cd1b70bf\n  , ciphertext = 0x010e24d01c37edca127484c8d8137772\n  , plaintext = 0x6c7b2e83630a8c8b6219839297d7c647\n  },\n\n  { key = 0x9867d55ae9f56a03c435f4b25f2eee2c49a36f3bc9a4bb04e03338855accb6f8\n  , ciphertext = 0x6c7b2e83630a8c8b6219839297d7c647\n  , plaintext = 0xccba81435ecf162f70d30b3163cb3858\n  },\n\n  { key = 0xe4a3addb683bbe85ed84b3ce044bcc538519ee78976bad2b90e033b439078ea0\n  , ciphertext = 0xccba81435ecf162f70d30b3163cb3858\n  , plaintext = 0xa0575bc9b8931f34cd6072e2015e7331\n  },\n\n  { key = 0x6f543088bf24577d55a685e3637d85e8254eb5b12ff8b21f5d8041563859fd91\n  , ciphertext = 0xa0575bc9b8931f34cd6072e2015e7331\n  , plaintext = 0xa44046a87574e6d3e6c6446fb3c324bc\n  },\n\n  { key = 0x5fff671ca24c3b241ddb92761f02dfe3810ef3195a8c54ccbb4605398b9ad92d\n  , ciphertext = 0xa44046a87574e6d3e6c6446fb3c324bc\n  , plaintext = 0xef6abb8ae007b730be45aa85e39f362d\n  },\n\n  { key = 0xdb897d48a317f66412a8c52111c3f3b06e644893ba8be3fc0503afbc6805ef00\n  , ciphertext = 0xef6abb8ae007b730be45aa85e39f362d\n  , plaintext = 0xe5bd2edfb7e563f6cd86da757c4c370f\n  },\n\n  { key = 0x78aec1da8e8e79007af12c05d800a18d8bd9664c0d6e800ac88575c91449d80f\n  , ciphertext = 0xe5bd2edfb7e563f6cd86da757c4c370f\n  , plaintext = 0x33caa267a64fb3cac210271bb8f25369\n  },\n\n  { key = 0x2c3e5387a51addb0b7789ef0289109b3b813c42bab2133c00a9552d2acbb8b66\n  , ciphertext = 0x33caa267a64fb3cac210271bb8f25369\n  , plaintext = 0x27bb26990ca5e12d387bd659cb7e7860\n  },\n\n  { key = 0x85685fe6996d514e5928d7196f41b5d29fa8e2b2a784d2ed32ee848b67c5f306\n  , ciphertext = 0x27bb26990ca5e12d387bd659cb7e7860\n  , plaintext = 0xd866ace71916e00c1559bba4149380a0\n  },\n\n  { key = 0x82abcc9a00bae55087cf5d87413f095547ce4e55be9232e127b73f2f735673a6\n  , ciphertext = 0xd866ace71916e00c1559bba4149380a0\n  , plaintext = 0x8a4d6a0af8488a82a0c31332db3e36de\n  },\n\n  { key = 0x81d983ce59413e84d7af4558d2e3941ccd83245f46dab86387742c1da8684578\n  , ciphertext = 0x8a4d6a0af8488a82a0c31332db3e36de\n  , plaintext = 0x05f6ff378b837cd375cddfae79ec2a9d\n  },\n\n  { key = 0xbbe6d0d13a6b146bb23db6885ba66487c875db68cd59c4b0f2b9f3b3d1846fe5\n  , ciphertext = 0x05f6ff378b837cd375cddfae79ec2a9d\n  , plaintext = 0xb706bdb4019d604cc35faa07197c318d\n  },\n\n  { key = 0x8092df6673b2b77783f2ba73c22e8d3c7f7366dcccc4a4fc31e659b4c8f85e68\n  , ciphertext = 0xb706bdb4019d604cc35faa07197c318d\n  , plaintext = 0xb26354bc77d3ce16909ca505d2381e4c\n  },\n\n  { key = 0x3118fc57b93677af8e14c1b5961b76f3cd103260bb176aeaa17afcb11ac04024\n  , ciphertext = 0xb26354bc77d3ce16909ca505d2381e4c\n  , plaintext = 0x1515ef6a25cf3943eadadc36a029194a\n  },\n\n  { key = 0xc4bde4a0c5f80329be6dd515f5bf6dabd805dd0a9ed853a94ba02087bae9596e\n  , ciphertext = 0x1515ef6a25cf3943eadadc36a029194a\n  , plaintext = 0x7b4ad946dfb59c80b1dc5cedb2fa87a0\n  },\n\n  { key = 0x80b47f9126b0b1f5ab408bb9ea5f349aa34f044c416dcf29fa7c7c6a0813dece\n  , ciphertext = 0x7b4ad946dfb59c80b1dc5cedb2fa87a0\n  , plaintext = 0xfa10a53e14cde5ef1e9a8a5692847aa5\n  },\n\n  { key = 0x86a43939c8cd243f7ff2a9658524373b595fa17255a02ac6e4e6f63c9a97a46b\n  , ciphertext = 0xfa10a53e14cde5ef1e9a8a5692847aa5\n  , plaintext = 0x4c9bed07308abcd0b09265b5efbe301c\n  },\n\n  { key = 0x74a8f02a15285153e0ae160fbddcf6bf15c44c75652a96165474938975299477\n  , ciphertext = 0x4c9bed07308abcd0b09265b5efbe301c\n  , plaintext = 0x75b7496c42809a3a592acbd8e069269e\n  },\n\n  { key = 0x293b40a2f70cc2c4262554663fb6f0986073051927aa0c2c0d5e58519540b2e9\n  , ciphertext = 0x75b7496c42809a3a592acbd8e069269e\n  , plaintext = 0x2dbc01185af7e084d90578468b6b10ef\n  },\n\n  { key = 0xb04d4f4eb708eef86c5b6b8e08a665084dcf04017d5deca8d45b20171e2ba206\n  , ciphertext = 0x2dbc01185af7e084d90578468b6b10ef\n  , plaintext = 0xc95b3a9f689c9dce4995c24f72dd5162\n  },\n\n  { key = 0x7cb9f7211815e0cb48b71286f84f80a184943e9e15c171669dcee2586cf6f364\n  , ciphertext = 0xc95b3a9f689c9dce4995c24f72dd5162\n  , plaintext = 0x616e55c3bf113e2c18cae3c61b7eb7d1\n  },\n\n  { key = 0xb3cdb46cf92aa0b96e87212bc650d5e5e5fa6b5daad04f4a8504019e778844b5\n  , ciphertext = 0x616e55c3bf113e2c18cae3c61b7eb7d1\n  , plaintext = 0x87e8b80767ebbdbad75cb94f4cb54f3b\n  },\n\n  { key = 0x512c2a3821eb53af613141c71e1076656212d35acd3bf2f05258b8d13b3d0b8e\n  , ciphertext = 0x87e8b80767ebbdbad75cb94f4cb54f3b\n  , plaintext = 0xc83e20e18f2b1457788954b49fd84307\n  },\n\n  { key = 0x9977c985745bc33954a2ce898bc8febdaa2cf3bb4210e6a72ad1ec65a4e54889\n  , ciphertext = 0xc83e20e18f2b1457788954b49fd84307\n  , plaintext = 0xe3d3868f578caf34e36445bf14cefc68\n  }]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/twinmult.cry","filetype":"cry","content":"import PrimeEC\n\nzro : ProjectivePoint 7\nzro = { x = 1, y = 1, z = 0 }\n\nproperty twin_mult_zro j k =\n  ec_equal`{7} (ec_twin_mult j zro k zro) zro\n\nproperty twin_mult_zro1 j k S =\n  ec_equal`{7} (ec_twin_mult j zro k S) (ec_mult k S)\n\nproperty twin_mult_zro2 j k S =\n  ec_equal`{7} (ec_twin_mult j S k zro) (ec_mult j S)\n\nproperty twin_mult_same j k S =\n  ec_equal`{7} (ec_twin_mult j S k S) (ec_add (ec_mult j S) (ec_mult k S))\n\nproperty twin_mult_neg j k S =\n  ec_equal`{7} (ec_twin_mult j S k (ec_negate S)) (ec_sub (ec_mult j S) (ec_mult k S))\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/word-update.cry","filetype":"cry","content":"property wordUpdate (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> update x y b == if b then x || msk else x && ~msk\n\n where\n msk = 0b1000000000000000 >> y\n\nproperty wordUpdate2 (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> update x y b == x'\n\n where\n x' = [ if i == y then b else x@i | i <- [0 .. 15] ]\n\nproperty wordUpdateEnd (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> updateEnd x y b == if b then x || msk else x && ~msk\n\n where\n msk = 0b0000000000000001 << y\n\nproperty wordUpdateEnd2 (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> updateEnd x y b == x'\n\n where\n x' = [ if i == y then b else x!i | i <- reverse [0 .. 15] ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/f2polytest.cry","filetype":"cry","content":"import Cryptol::Reference as Ref\n\npmult_equiv : {u, v} (fin u, fin v) => [1+u] -> [1+v] -> Bit\npmult_equiv x y = pmult x y == Ref::pmult x y\n\npdiv_equiv : {u, v} (fin u, fin v) => [u] -> [v] -> Bit\npdiv_equiv x y = y == 0 \\\/ pdiv x y == Ref::pdiv x y\n\npmod_equiv : {u, v} (fin u, fin v) => [u] -> [1+v] -> Bit\npmod_equiv x y = y == 0 \\\/ pmod x y == Ref::pmod x y\n\n\/\/ an arbitrary collection of test sizes\n\nproperty mult3_9   = pmult_equiv`{3,9}\nproperty mult9_3   = pmult_equiv`{9,3}\nproperty mult8_8   = pmult_equiv`{8,8}\nproperty mult28_11 = pmult_equiv`{28,11}\nproperty mult32_32 = pmult_equiv`{32,32}\nproperty mult64_64 = pmult_equiv`{64,64}\n\nproperty div3_9   = pdiv_equiv`{3,9}\nproperty div9_3   = pdiv_equiv`{9,3}\nproperty div8_8   = pdiv_equiv`{8,8}\nproperty div28_11 = pdiv_equiv`{28,11}\nproperty div32_32 = pdiv_equiv`{32,32}\nproperty div64_64 = pdiv_equiv`{64,64}\n\nproperty mod3_9   = pmod_equiv`{3,9}\nproperty mod9_3   = pmod_equiv`{9,3}\nproperty mod8_8   = pmod_equiv`{8,8}\nproperty mod28_11 = pmod_equiv`{28,11}\nproperty mod32_32 = pmod_equiv`{32,32}\nproperty mod64_64 = pmod_equiv`{64,64}\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/r01.cry","filetype":"cry","content":"any : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = [ f x | x <- xs ] != zero\n\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = [ f x | x <- xs ] == ~zero\n\n\/\/ all ltTen [0 .. 9] where ltTen x = x < 10\n\/\/ all ltTen [0 .. 10] where ltTen x = x < 10\n\/\/ any ltTen [100 .. 10] where ltTen x = x < 10\n\/\/ any ltTen [100 .. 9] where ltTen x = x < 10\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/r05.cry","filetype":"cry","content":"unflatten : {r, w}\n            (fin r, 5 * w >= r, fin w)\n            => [r] -> [w][5]\nunflatten p = groupBy`{5}(p # zero)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/check22.cry","filetype":"cry","content":"irred : [8]\nirred = 0x1b\nxtimes a = (if a ! (length a - 1) then a' ^ irred else a')\n  where a' = a << 1\n\ngtimes : ([8], [8]) -> [8]\ngtimes (a, b)\n  = (if b == 0 then 0 else xtimes (gtimes (a, b >> 1)) ^ a')\n    \/\/ endianness difference from Cryptol-1 test:\n  where a' = if b ! 0 then a else 0\n\ncheck22 = [ gtimes (13, x) | x <- [ 1, 12, 192 ] ] == [ 13, 92, 183 ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/regression\/check23.cry","filetype":"cry","content":"pad : {msgLen, padding, contentLen, chunks}\n    ( fin msgLen\n    , fin padding\n    , contentLen == msgLen + 65\n    , chunks == (contentLen + 511) \/ 512\n    , 64 >= width msgLen\n    , padding == (512 - contentLen % 512) % 512\n    ) => [msgLen] -> [chunks * 512]\npad msg = msg # [True] # (zero:[padding]) # sz  \/\/or: (`msgLen:[64])\n      where  sz : [64]\n             sz = (length msg):[64]\n\ntmsg : [4]\ntmsg = 13\nout : [512]\nout = 0xd8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004\ncheck23 = pad tmsg == out\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/check09.cry","filetype":"cry","content":"initS : [1][32]\ninitL : [1][32]\ninitS = [0]\ninitL = [0]\nss = [ (s + a + b) <<< 3   | s <- initS # ss\n\t                       | a <- [1] # ss\n\t                       | b <- [0] # ls ]\nls = [ (l + a + b) <<< (a + b)\n                        | l <- initL # ls\n\t\t                | a <- ss\n\t\t                | b <- [0] # ls ]\n\ncheck9a = (ss @@ [0 .. 3] == [ 0x00000008, 0x00004080, 0x00068c00, 0x00a22800 ])\n       && (ls @@ [0 .. 3] == [ 0x00000800, 0x00005080, 0x00072d00, 0x00b08200 ])\n\nkeyX : [4][8] -> [7][32]\nkeyX key = ss @@ [ 0 .. 6 ]\n  where\n    initS : [1][32]\n    initL : [1][32]\n    initS = [0]\n    initL = split (join key)\n    ss = [ (s + a + b) <<< 3\n                    | s <- initS # ss\n\t\t\t\t    | a <- [1] # ss\n\t\t\t\t    | b <- [0] # ls ]\n    ls = [ (l + a + b) <<< (a + b)\n                    | l <- initL # ls\n\t\t\t\t    | a <- ss\n\t\t\t\t    | b <- [0] # ls ]\n\n\/\/ NOTE different endianness from Cryptol 1 test\ncheck9b = keyX (reverse \"abcd\") ==\n\t    [0x00000008, 0x1b134ba3, 0x11ae69b1, 0xb7b3f42f,\n             0xc9eb1fdc, 0x008b5f36, 0x8991bc8c]\n\ncheck9 = check9a && check9b\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/regression\/check21.cry","filetype":"cry","content":"irred : [8]\nirred = 0x1b\n\/\/ endianness difference from Cryptol-1 test\nxtimes a = (if a ! (length a - 1) then a' ^ irred else a')\n  where a' = a << 1\n\ncheck21 = [ xtimes y | y <- [ 1, 12, 192 ] ] == [ 2, 24, 155 ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/check20.cry","filetype":"cry","content":"check20 = [ [ [ 1, 2 ], [ 3, 4 ] ] ]\n        + [ [ [ 5, 6 ], [ 7, 8 ] ] ]\n       == [ [ [ 6, 8 ], [ 10, 12 ] ] ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/check08.cry","filetype":"cry","content":"qq = [ s + a + b | s <- [0] # qq\n\t          | a <- [1] # qq\n\t          | b <- [0] # zs ]\nzs : [inf][32]\nzs = [0...]\n\ncheck8 = qq @@ [0 .. 4] == [1, 2, 5, 12, 27]\n\nproperty prefix = qq @@ [0 .. 4] == [1, 2, 5, 12, 27]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/regression\/reference.cry","filetype":"cry","content":"import Cryptol::Reference as Ref\n\n\/\/ NB, using subtraction here because is is not commutative or associative\n\nproperty foldl_eq (z:Integer) (xs:[10]Integer) =\n  foldl (-) z xs == Ref::foldl (-) z xs\n\nproperty scanl_eq (z:Integer) (xs:[10]Integer) =\n  scanl (-) z xs == Ref::scanl (-) z xs\n\nproperty iterate_eq (z:Integer) (i:[8]) =\n  (iterate (\\x -> x + 1) z)@i == (Ref::iterate (\\x -> x + 1) z)@i\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/rec-update.cry","filetype":"cry","content":"type T = { x : [8], y : Bool }\n\nf1 = { x = 2, y = True } : T\nf2 = { f1 | x = 3 }\nf3 = { f2 | x = 4, y = False }\nf4 = { f3 | x -> x + 1 }\nf5 = [f1,f2,f3,f4]\nf6 = { f5 | x = [7,8,9,10] }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/check24.cry","filetype":"cry","content":"xor : {a} ([a], [a]) -> [a]\nxor (xs, ys) = [ x != y | x <- xs | y <- ys ]\n\ncheck24 = [ xor`{4} (x, y) == (x ^ y) | x <- [ 0 .. 15 ], y <- [ 0 .. 15 ] ] == ~zero\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/primes.cry","filetype":"cry","content":"z1prime : {n} (prime n) => Z n\nz1prime = 1\n\nz1_2 = z1prime`{2}\nz1_3 = z1prime`{3}\nz1_17 = z1prime`{17}\nz1_2_17m1 = z1prime`{2^^17 - 1}\n\n\ntype p192 = 6277101735386680763835789423207666416083908700390324961279\ntype p224 = 26959946667150639794667015087019630673557916260026308143510066298881\ntype p256 = 115792089210356248762697446949407573530086143415290314195533631308867097853951\ntype p384 = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\ntype p521 = 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151\n\nrecip_correct : {p} (prime p) => Z p -> Bool\nrecip_correct x = x == 0 \\\/ x * recip x == 1\n\nproperty recip_correct_17   = recip_correct`{17}\nproperty recip_correct_1021 = recip_correct`{1021}\nproperty recip_correct_p192 = recip_correct`{p192}\nproperty recip_correct_p224 = recip_correct`{p224}\nproperty recip_correct_p256 = recip_correct`{p256}\nproperty recip_correct_p384 = recip_correct`{p384}\nproperty recip_correct_p521 = recip_correct`{p521}\n\nmoddiv_eq : {p} (prime p, p >= 3) => Z p -> Z p -> Bool\nmoddiv_eq x y = y == 0 \\\/ (x \/. y) * y == x\n\nproperty moddiv_eq17   = moddiv_eq`{17}\nproperty moddiv_eq1021 = moddiv_eq`{1021}\n\nproperty moddiv_eq_p192 = moddiv_eq`{p192}\nproperty moddiv_eq_p224 = moddiv_eq`{p224}\nproperty moddiv_eq_p256 = moddiv_eq`{p256}\nproperty moddiv_eq_p384 = moddiv_eq`{p384}\nproperty moddiv_eq_p521 = moddiv_eq`{p521}\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/bitshift.cry","filetype":"cry","content":"shift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n          fills = [bit]#(take fill)\n\nshift_alt : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift_alt fill bit = fills\n\twhere\n\t  fills = [bit]#(drop`{1} (fill >> 1))\n\ninfZero : [inf]Bit\ninfZero = [False] # infZero\n\nproperty shift_eq a b c d e = shift (take`{10} ([a,b,c,d]#infZero)) e\n                           == shift_alt (take`{10} ([a,b,c,d]#infZero)) e\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/regression\/check27.cry","filetype":"cry","content":"zeroBit : Bit\nzeroBit = zero\n\nzeroTuple : ([8], [32])\nzeroTuple = zero\nzeroTuple3 : ([8], [32], [256])\nzeroTuple3 = zero\n\nzeroFun : [8] -> [16]\nzeroFun = zero\n\ncheck27 = (zeroBit == False)\n\t&& (zeroTuple == (0, 0)) && (zeroTuple3 == (0, 0, 0))\n\t&& ((0, 0) == zeroTuple) && ((0, 0, 0) == zeroTuple3)\n\t&& (zeroFun 13 == 0)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/check26.cry","filetype":"cry","content":"fst (x, y) = x\nsnd (x, y) = y\nxy = (13, 21)\ncheck26a = (fst xy == xy.0) && (snd xy == xy.1) &&\n\t   (fst xy == 13) && (snd xy == 21)\n\nxys = [ (x, y) | x <- [ 1 .. 10 ], y <- [ 2 .. 5 ] ]\ncheck26b = [ fst ixy | ixy <- xys ] ==\n\t   [ x | x <- [ 1 .. 10 ], y <- [ 2 .. 5 ] ]\n\/\/ endianness difference\ncheck26c = [ fst ixy == snd ixy | ixy <- xys ] == reverse 0x0000084210\n\ncheck26 = check26a && check26b && check26c\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/check03.cry","filetype":"cry","content":"nats : [32] -> [inf][32]\nnats n = [n] # nats (n + 1)\n\ncheck3 = (nats 0 @ 45 == 45) && (nats 45 @ 0 == 45)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/rational_properties.cry","filetype":"cry","content":"\/\/ == Q is a commutative ring ==\n\nproperty QaddUnit (x : Rational) =\n  x + 0 == x\n\nproperty QaddComm (x:Rational) (y:Rational) =\n  x + y == y + x\n\nproperty QaddAssoc (x:Rational) (y:Rational) (z:Rational) =\n  x + (y + z) == (x + y) + z\n\nproperty Qneg (x: Rational) = x + negate x == 0\n\nproperty QmulUnit (x : Rational) =\n  x * 1 == x\n\nproperty QmulComm (x:Rational) (y:Rational) =\n  x * y == y * x\n\nproperty QmulAssoc (x:Rational) (y:Rational) (z:Rational) =\n  x * (y * z) == (x * y) * z\n\n\/\/ Distributivity in Q\nproperty Qdistrib (x:Rational) (y:Rational) (z:Rational) =\n  x * (y + z) == x*y + x*z\n\n\/\/ == Q is a field ==\n\nproperty Qrecip (x: Rational) = x == 0 \\\/ x * recip x == 1\n\nproperty QdivisionEquiv (x : Rational) (y : Rational) =\n  y == 0 \\\/ x \/. y == x * (recip y)\n\n\/\/ == Q is a total order ==\n\nproperty QordEquiv1 (x : Rational) (y : Rational) =\n  (x <= y) == ~(y < x)\n\nproperty QordEquiv2 (x : Rational) (y : Rational) =\n  (x <= y) == (x == y \\\/ x < y)\n\nproperty QordTrans (x : Rational) (y : Rational) (z : Rational) =\n  x < y ==> y < z ==> x < z\n\nproperty QordIrreflexive (x : Rational) =\n  ~(x < x)\n\nproperty QordExclusive (x : Rational) (y:Rational) =\n  ~(x < y) || ~(y < x) \n\nproperty Qtrichotomy (x : Rational) (y : Rational) =\n  x < y \\\/ x == y \\\/ x > y\n\n\n\/\/  == Q is an ordered field\n\nproperty QordCompatible (x : Rational) (y : Rational) (z:Rational) =\n  x < y ==> x+z < y+z\n\nproperty QordPositive (x : Rational) (y : Rational) =\n  0 < x ==> 0 < y ==> 0 < x*y\n\n\/\/ == Q is a dense total order ==\nproperty Qdense (x : Rational) (y : Rational) = x < y ==> x < mid \/\\ mid < y\n  where\n  mid = (x + y) \/. 2\n\n\n\/\/ == Integer division rounds down ==\nproperty intDivDown (x : Integer) (y:Integer) =\n  y == 0 \\\/ fromInteger (x \/ y) <= ratio x y\n\n\n\/\/ == correctness of floor and ceiling\n\n\/\/ floor(x) is an integer below x\nproperty floorCorrect1 (x:Rational) =\n  fromInteger (floor x) <= x\n\n\/\/ floor(x) is the largest integer below x\nproperty floorCorrect2 (x:Rational) (y:Integer) =\n  fromInteger y <= x ==>\n  y <= floor x\n  \n\/\/ ceiling(x) is an integer above x\nproperty ceilingCorrect1 (x:Rational) =\n  fromInteger (ceiling x) >= x\n\n\/\/ ceiling(x) is the smallest integer above x\nproperty ceilingCorrect2 (x:Rational) (y:Integer) =\n  fromInteger y >= x ==>\n  y >= ceiling x\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/bvdiv.cry","filetype":"cry","content":"\/\/ unsigned division properties\n\nbvdiv_euc : {n} (fin n) => [n] -> [n] -> Bit\nbvdiv_euc x y = y != 0 ==> (x\/y)*y + x%y == x\n\nbvdiv_char : {n} (fin n) => [n] -> [n] -> Bit\nbvdiv_char x y = y != 0 ==> floor r == toInteger (x \/ y)\n  where\n    r = ratio (toInteger x) (toInteger y)\n\nbvdiv_mod : {n} (fin n) => [n] -> [n] -> Bit\nbvdiv_mod x y = y != 0 ==> (0 <= m \/\\ m < y)\n  where\n    m = x%y\n\n\n\/\/ some utility definitions\n\nsabs : {n} (fin n, n>=1) => [n] -> [n]\nsabs x = if x <=$ 0 then negate x else x\n\ntoSignedInteger : {n} (fin n, n >=1 ) => [n] -> Integer\ntoSignedInteger x = if x <=$ 0 then negate (toInteger (negate x)) else toInteger x\n\nminint : {n} (fin n, n >= 1) => [n]\nminint = 0b1 # zero\n\nmaxint : {n} (fin n, n >= 1) => [n]\nmaxint = ~minint\n\n\n\/\/ signed division properties\n\nbvsdiv_euc : {n} (fin n, n>=1) => [n] -> [n] -> Bit\nbvsdiv_euc x y = y != 0 ==> (x\/$y)*y + x%$y == x\n\nbvsdiv_char : {n} (fin n, n>=1) => [n] -> [n] -> Bit\nbvsdiv_char x y = y != 0 ==> overflow \\\/ trunc r == toSignedInteger (x \/$ y)\n  where\n    overflow = x == minint \/\\ y == (-1)\n    r = ratio (toSignedInteger x) (toSignedInteger y)\n\nbvsdiv_mod : {n} (fin n, n>=1) => [n] -> [n] -> Bit\nbvsdiv_mod x y = y != 0 ==> (0 <= m \/\\ m < sabs y)\n  where\n    m = sabs (x%$y)\n\nbvsdiv_mod_sign : {n} (fin n, n>=1) => [n] -> [n] -> Bit\nbvsdiv_mod_sign x y =\n  y != 0 ==>\n    if x >=$ 0 then x%$y >=$ 0 else x%$y <=$ 0\n\nbvsdiv_doc_properties : {n} (fin n, n>=1) => [n] -> [n] -> Bit\nbvsdiv_doc_properties x y =\n  y != 0 ==>\n    (x %$ y == x - (x \/$ y) * y) \/\\\n    (x >=$ 0 ==> x%$y >=$ 0) \/\\\n    (x <=$ 0 ==> x%$y <=$ 0)\n\n\/\/ property instances to check\n\nproperty d1 = bvdiv_euc`{8}\nproperty c1 = bvdiv_char`{8}\nproperty m1 = bvdiv_mod`{8}\n\nproperty d2 = bvsdiv_euc`{8}\nproperty c2 = bvsdiv_char`{8}\nproperty m2 = bvsdiv_mod`{8}\nproperty m3 = bvsdiv_mod_sign`{8}\nproperty sdiv = bvsdiv_doc_properties`{8}\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol\/tests\/regression\/check28.cry","filetype":"cry","content":"xs = [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7)]\ncheck28 = [ x==y | (x,y) <- xs ] == ~zero\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/regression\/check14.cry","filetype":"cry","content":"swab xxs = [ [d, c, b, a]\n           | [a, b, c, d] <- xxs\n           ]\n\ncheck14 = swab [[0, 1, 2, 3], [4, 5, 6, 7]] == [[3, 2, 1, 0], [7, 6, 5, 4]]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/regression\/check11.cry","filetype":"cry","content":"check11 = zz == ww\n  where\n    zz = [0 .. 99]\n    qq = zz @@ ([0 .. 0xffffffff] : [_][32])\n    ww = qq @@ [0 .. 99]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/FloatTests.cry","filetype":"cry","content":"module FloatTests where\n\nimport Float\n\nsection : {n} fin n => [n][8] -> [78][8]\nsection x = \"-- \" # take`{min 60 n} x # repeat '-'\n\ntype Small  = Float 3 2\ntype Medium = Float64\ntype Large  = Float 60 5000\n\nproperty roundTrip x  = fpFromBits (fpToBits x) =.= x\n\nroundTrip2 : {e : #, p : #} (fin e, fin p, ValidFloat e p) => [e + p] -> Bool\nproperty roundTrip2 x = fpToBits num == x \\\/ num =.= fpNaN\n                          where num = fpFromBits x : Float e p\nproperty eqRefl1 x    = x =.= x\nproperty eqRefl2 x    = x == x \\\/ x =.= fpNaN\nproperty eqProp x y   = ~(x == y) \\\/\n                         (x =.= y \\\/ x =.= fpNaN\n                                  \\\/ y =.= fpNaN\n                                  \\\/ (x =.=  0.0 \/\\ y =.= -0.0)\n                                  \\\/ (x =.= -0.0 \/\\ y =.=  0.0)\n                         )\nproperty leqRefl x    = x <= x \\\/ x =.= fpNaN\n\n\nroundTripRational : {e,p} (fin e, fin p, ValidFloat e p) => Float e p -> Bool\nproperty roundTripRational x =\n  ~(fpIsFinite x) \\\/\n  (fpFromRational rne (fpToRational x) =.= x) \\\/\n  (x =.= fpNegZero)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/specialize.cry","filetype":"cry","content":"module specialize where\n\ntop (x, y) = f`{Bit,Bit} (x, y)\n\nf : {a, b} (a, b) -> (a, b)\nf (x, y) = (x, y)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/poly.cry","filetype":"cry","content":"\/\/ n-degree polynomials over a\nnewtype Poly n a = { coeffs : [n+1]a }\n\nevalPoly : {n, a} (fin n, Ring a) => Poly n a -> a -> a\nevalPoly p x = foldl (+) zero terms\n  where\n    terms = [ c*a | c <- p.coeffs | a <- xs ]\n    xs    = [fromInteger 1]#[ x*a | a <- xs ]\n\npolyConst : {n, a} (fin n, Ring a) => a -> Poly n a\npolyConst a = Poly { coeffs = [a]#zero }\n\npolyAdd : {n, a} (fin n, Ring a) => Poly n a -> Poly n a -> Poly n a\npolyAdd p1 p2 = Poly { coeffs = zipWith (+) p1.coeffs p2.coeffs }\n\npolyMul : {n1, n2, a} (fin n1, fin n2, Ring a) =>\n  Poly n1 a -> Poly n2 a -> Poly (n1+n2) a\npolyMul p1 p2 = foldl polyAdd (polyConst zero) ps\n  where\n    ps : [n1+1](Poly (n1+n2) a)\n    ps@i = Poly{ coeffs = scaleAndShift i }\n\n    scaleAndShift i =\n      ([ p1.coeffs@i * c | c <- p2.coeffs ] # zero) >> i\n\nproperty polySquare (x:Integer) =\n  evalPoly (Poly { coeffs = [0,0,1] }) x == x * x\n\nproperty polyAddEval x (p1:Poly 5 Integer) (p2:Poly 5 Integer) =\n  evalPoly (polyAdd p1 p2) x == evalPoly p1 x + evalPoly p2 x\n\nproperty polyMulEval x (p1:Poly 5 Integer) (p2:Poly 5 Integer) =\n  evalPoly (polyMul p1 p2) x == evalPoly p1 x * evalPoly p2 x\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/regression\/check12.cry","filetype":"cry","content":"sums xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\ncheck12 = sums ([0 .. 9] : [_][32]) == [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/regression\/check06.cry","filetype":"cry","content":"onetwos = [1] # twoones\ntwoones = [2] # onetwos\nonesytwosy = [ [one, two] | one <- onetwos | two <- twoones ]\n\ncheck6 = onesytwosy @@ [0 .. 3] == [ [1, 2], [2, 1], [1, 2], [2, 1] ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/check07.cry","filetype":"cry","content":"shiftls1 = [ 0x12345678 << i | i <- [ 0 .. 32 ] ]\nshiftls2 = [ 0x12345678 << i | i <- [ 32 .. 64 ] ]\nshiftls3 = [ 0x12345678 << i | i <- [ 0x80000000 .. 0x8000000f ] ]\nshiftrs1 = [ 0x12345678 >> i | i <- [ 0 .. 32 ] ]\nshiftrs2 = [ 0x12345678 >> i | i <- [ 32 .. 64 ] ]\nshiftlbig1 : [48][48]\nshiftlbig1 = [ 0x12345678abcd << i | i <- [ 0 .. 47 ] ]\nshiftlbig1' : [48][48]\nshiftlbig1' = [ 0x12345678abcd * 2^^i | i <- [ 0 .. 47 ] ]\n\ncheck7a = shiftls3 == [ 0, 0 ... ] @@ [ 0 .. 0xf ]\ncheck7b = shiftlbig1 == shiftlbig1'\ncheck7c = (1:[1]) << 1 == 0\ncheck7 = check7a && check7b && check7c\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol\/tests\/regression\/check13.cry","filetype":"cry","content":"ick : [1][8] -> [8]\nick [x] = x\n\nuck : [8][1] -> [8]\nuck [a, b, c, d, e, f, g, h] = a # b # c # d # e # f # g # h\n\ncheck13 = (ick (split 150) == 150) && (uck (split 150) == 150)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/regression\/allsat.cry","filetype":"cry","content":"f : (Integer, Integer, Integer) -> Bit\nf (x, y, z) =  inRange x && inRange y && inRange z\n  where inRange v = (1 <= v) && (v <= 15)\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/regression\/negshift.cry","filetype":"cry","content":"negLeftShift : {n, a} (fin n, Zero a, Cmp a) => [n]a -> Integer -> Bit\nnegLeftShift xs i = xs << i == xs >> (negate i)\n\nnegRightShift : {n, a} (fin n, Zero a, Cmp a) => [n]a -> Integer -> Bit\nnegRightShift xs i = xs >> i == xs << (negate i)\n\nnegLeftRotate : {n, a} (fin n, Cmp a) => [n]a -> Integer -> Bit\nnegLeftRotate xs i = xs <<< i == xs >>> (negate i)\n\nnegRightRotate : {n, a} (fin n, Cmp a) => [n]a -> Integer -> Bit\nnegRightRotate xs i = xs >>> i == xs <<< (negate i)\n\nnegSshr : {n} (fin n, n >= 1) => [n] -> Integer -> Bit\nnegSshr xs i = i < 0 ==> xs >>$ i == xs << (negate i)\n\nproperty nls1 = negLeftShift`{8, Bit}\nproperty nls2 = negLeftShift`{32, Bit}\nproperty nls3 = negLeftShift`{8, Integer}\nproperty nls4 = negLeftShift`{8, [32]}\n\nproperty nrs1 = negRightShift`{8, Bit}\nproperty nrs2 = negRightShift`{32, Bit}\nproperty nrs3 = negRightShift`{8, Integer}\nproperty nrs4 = negRightShift`{8, [32]}\n\nproperty nlr1 = negLeftRotate`{8, Bit}\nproperty nlr2 = negLeftRotate`{32, Bit}\nproperty nlr3 = negLeftRotate`{8, Integer}\nproperty nlr4 = negLeftRotate`{8, [32]}\n\nproperty nrr1 = negRightRotate`{8, Bit}\nproperty nrr2 = negRightRotate`{32, Bit}\nproperty nrr3 = negRightRotate`{8, Integer}\nproperty nrr4 = negRightRotate`{8, [32]}\n\nproperty nsshr1 = negSshr`{8}\nproperty nsshr2 = negSshr`{32}\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/docstrings\/T06.cry","filetype":"cry","content":"module T06 where\n\ninterface submodule I where\n  type N : #\n\nsubmodule N1 where\n  type N = 1\n\nsubmodule C where\n  import interface submodule I\n\n  \/**\n   * ```repl\n   * let x = lost\n   * ```\n   *\/\n  lost = ()\n\nsubmodule B where\n  import interface submodule I\n  submodule C_ = submodule C { submodule N1 }\n\nsubmodule A = submodule B { submodule N1 }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/docstrings\/T10.cry","filetype":"cry","content":"\/**\n```\n:check\n```\n*\/\nmodule T10 where\n\np : Bit\nproperty p = True\n\nsubmodule M where\n  q : Bit\n  property q = True\n\n  private\n    r : Bit\n    property r = True\n\nsubmodule F where\n  parameter\n    type N : #\n\n  s : Bit\n  property s = True\n\n  private\n    t : Bit\n    property t = True\n\nsubmodule F1 = submodule F where type N = 1\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/docstrings\/T02.cry","filetype":"cry","content":"module T02 where\n\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n, n >= 2)\n\n  \/**\n    * ```\n    * :check c == 1\n    * ```\n    *\/\n  private\n    c : Z n\n    c = 1\n\n    \/**\n   Longer code block delimiters are supported\n   ````repl\n   :exhaust p\n   ````\n   *\/\n  p x = c + x == x + c\n\nsubmodule F7 = submodule F where\n  type n = 7\n\n\/**\n ** ```repl\n ** let y = 20\n **\n ** :check f 10 \\\n **          == 20\n ** ``` *\/\nf : Integer -> Integer\nf x = x + x\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/issue1191.cry","filetype":"cry","content":"xs : [32]\nxs = 0xdeadbeef\n\nf : [32] -> [32]\nf zs = zs <<< ( [True,False,False]:[3] )\n\nq0 = f xs\nq1 = f (rnf (xs @@ [0..31]))\nq2 = f      (xs @@ [0..31])\n\n\nys : [1][32]\nys = [ 0xdeadbeef ]\n\ng : [1][32] -> [32]\ng zs = (zs@0) <<< ( [True,False,False]:[3] )\n\nr0 = g ys\nr1 = g (split (rnf (join ys)))\nr2 = g (split      (join ys))\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol\/tests\/issues\/issue314.cry","filetype":"cry","content":"f : {a} (fin a, a>=2) => [a][8] -> [8]\nf xs = ys!0\n where\n  ys : [a\/2][8]\n  ys = zero\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1796.cry","filetype":"cry","content":"exhaustive1 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1 x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n\nexhaustive1Reordered1: {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1Reordered1 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n\nexhaustive1Reordered2 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1Reordered2 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n\n\/\/ Note that `(2 ^^ w) >= 1`, which means that there is no need for a\n\/\/ `(2 ^^ w) < 1` guard below.\nexhaustive2 : {w} [2 ^^ w] -> [2 ^^ w]\nexhaustive2 x\n  | (2 ^^ w) == 1 => ~ x\n  | (2 ^^ w) > 1 => x\n\nexhaustive3 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive3 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/issue670.cry","filetype":"cry","content":"type x +++ y = x-y\n\ng : [6 +++ 2 +++ 1]\ng = 2\n\nh : [6 +++ (2 +++ 1)]\nh = 9\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue116.cry","filetype":"cry","content":"t = (0x1, { key = 4, value = \"goodbye\"})\n\nbug116fixed = (t.1.value == t.1.value) \/\\ (t.1.key == t.1.key)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue128.cry","filetype":"cry","content":"copy : [inf] -> [inf]\ncopy ([b] # x) = if b then [True] # copy x else [False] # copy x\n\nproperty ok = copy ([True] # zero) @ 0\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue850.cry","filetype":"cry","content":"type T = [2]Rational\n\nfoo: T->T->(T,T)\nfoo p q = ([0,1], zipWith (-) p q)\n\nbar: T -> T -> T\nbar p q = s1 where\n  tuples = [(p, p, q, [0,1])] # map (baz q) tuples\n  (p1,p2,s1,s2) = tuples@2\n\nbaz m (p1, p2, s1, s2) =\n  if p2@0 == 0 \n  then (p1, p2, s1, s2)\n  else ( (p2, r, s2, zipWith (-) s1 q) where (q,r) = foo p1 p2)\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol\/tests\/issues\/T1439.cry","filetype":"cry","content":"module T where\n  \/\/ sanity check: functions outside submodule each load\n  f : {n} [1][n] -> [n]\n  f [x] = x\n\n  p : {a,b} (a,b) -> a\n  p (x,_) = x\n\n  interface submodule I where\n    type n : #\n\n  submodule F where\n    import interface submodule I\n\n    h : [1][n] -> [n]\n    h [x] = x\n\n    g : {m} [1][m] -> [m]\n    g [x] = x\n\n    q, q1, q2 : {b} (b,_) -> b\n    q (x,_) = x\n\n    q1 x = x.0\n    q2 x = y\n      where\n      (y,z) = x\n\n  submodule P1 where\n    type n = 1\n\n  submodule S = submodule F { submodule P1 }\n\n  import submodule S\n\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/issue058.cry","filetype":"cry","content":"\/\/ None of these should typecheck without fin constraints.\n\nsome : {n} [n] -> Bit\nsome x = x != 0\n\nlast : {n, a} (n >= 1) => [n]a -> a\nlast xs = xs ! 0\n\npad : {n} [n] -> [inf]\npad x = x # zero\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/issue312.cry","filetype":"cry","content":"f : [16] -> [16]\nf x = 3 * x\n\ng : [16] -> [16]\ng x = x + x + x\n\nproperty f_g = (f === g)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue662.cry","filetype":"cry","content":"type Q = (Integer, Integer)\n\ntoQ : Integer -> Integer -> Q\ntoQ a b =\n  if b == 0 then error \"divide by 0\" else\n  if b < 0 then (negate a, negate b) else (a, b)\n\nleQ : Q -> Q -> Bit\nleQ (a,b) (c,d) = a*d <= b*c\n\nintToQ : Integer -> Q\nintToQ x = (x, 1)\n\nabs : Integer -> Integer\nabs x = if x < 0 then negate x else x\n\nproperty divRoundsDown (x : Integer) (y : Integer) =\n  y == 0 \\\/ leQ (intToQ ( x \/ y )) (toQ x y)\n\nproperty divEuclidean (x : Integer) (y : Integer) =\n  y == 0 \\\/ y * (x \/ y) + x % y == x\n\nproperty modAbs (x : Integer) (y : Integer) =\n  y == 0 \\\/ abs (x % y) < abs y\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue78.cry","filetype":"cry","content":"unique : {a,b} (fin a, fin b, a>=1) => [a][b] -> Bit\nunique xs = [ exist x (i+1) | x <- xs | i <- [0..(a-1)] ] == 0\n  where exist : [b] -> [width a] -> Bit\n        exist x i = if(i>=`a) then False\n                    else if(x==(xs@i)) then True\n                    else exist x (i+1)\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/issue138.cry","filetype":"cry","content":"dwn: [16][4]\ndwn = [ 1+d | d <- tail dwn ] # [0]\n\ndwn': [16][4]\ndwn' = [ 1+(dwn' @ i) | i <- [1 .. 15] ] # [0]\n\ntake_some: {n,k,t} (n>=k) => [n]t -> [k]t\ntake_some xs = takes where takes = [ x | x <- xs | _ <- takes ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/issue851.cry","filetype":"cry","content":"type base t = { zero: t }\n\nB: base Bool\nB = { zero = False }\n\nfoo: {t,k} (fin k) => base t -> [k]t\nfoo b = repeat b.zero\n\nbar: {t,k} (fin k, k>=1) => [k]t -> [k]t -> [k]t -> [k]t\nbar p q m = p\n\nbaz: {k,t} (fin k, k >= 1) => [k]t -> [k]t -> [k]t\nbaz p q = q\n\nproperty problem p =\n  p != foo B ==> bar p (baz p 0x03) 0x03 == foo B\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1590.cry","filetype":"cry","content":"module Main where\n\nsubmodule F where\n  parameter\n    x : Bit\n  newtype T = { bit : Bit }\n  type U = T\n\nsubmodule M = submodule F where x = False\n\nimport submodule M\n\nfoo : U\nfoo = T { bit = True }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1802.cry","filetype":"cry","content":"\/\/ A regression test for #1802.\nmodule T1802 where\n\nparameter\n  type loglogw : #\n  type constraint (loglogw >= 1, loglogw <= 3)\n\ntype logw = 2^^loglogw\ntype w = 2^^logw\n\ncsum : [32][logw] -> [logw+5]\ncsum msg = sum [`w - 1 - zext msgi | msgi <- msg]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue962a.cry","filetype":"cry","content":"f : {a, b} (fin a) => [a]b -> (Bit, [a]b)\nf x = (True, x)\n\ng : {a,b} (fin a) => [a]b -> [a]b\ng x = (f`{a=a} x).1\n\nh = f.1\n\ni : {a} (fin a) => [a] -> [a]\ni = f`{a=a}.1\n\nj : {a} (fin a) => [a]{ fld : Integer } -> [a]Integer\nj = f`{a=a,b={fld : Integer}}.1.fld\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/issue160.cry","filetype":"cry","content":"thm1 : [16] -> Bit\nproperty thm1 x = (x <<< 16 == x) && (x >>> 16 == x)\n\nthm2 : [16] -> [16] -> Bit\nproperty thm2 x i = x >>> i == x >>> (i && 0x000f)\n\nthm3 : [15] -> [8] -> Bit\nproperty thm3 x i = x <<< i == x <<< (i % 15)\n\nthm4 : [15] -> [15] -> Bit\nproperty thm4 x i = x <<< i >>> i == x\n\nthm5 : [15] -> [3] -> Bit\nproperty thm5 x i = x <<< i >>> i == x\n\nthm6 : [8] -> [4] -> [4] -> Bit\nproperty thm6 x i j = x <<< i >>> j == x <<< (i - j)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue148.cry","filetype":"cry","content":"Salsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(k, n) = z\n  where\n    [s0, s1, s2, s3] = if (`a == 2) then split(\"expand 32-byte k\")\n                                    else split(\"expand 16-byte k\")\n    k1 = take`{16}(k#zero)\n    k2 = drop`{16}(zero#k)\n    x = s0 # k1 # s1 # n # s2 # k2 # s3\n    z = x\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue389.cry","filetype":"cry","content":"pad : {n, m, b} (64>=width(n), b==512-((n+65)%512), m==65+n+b) => [n]->[m]\npad message = (message#[True])#(0:[b])#sz\n     where\n                sz : [64]\n                sz = length message\n\ntest = pad\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue962b.cry","filetype":"cry","content":"type Fld = [4]\n\ntype v1 = 36\ntype o1 = 32\ntype o2 = 32\n\ntype nn = v1 + o1 + o2\n\nnats : {n} (fin n) => [n][width n]\nnats = take`{n} [0 .. n]\n\nvzero : {n} (fin n, n > 0) => [n]Fld\nvzero = [ zero | _ <- nats`{n=n} ]\n\nbuild1item : [width nn] -> [width nn] -> Fld\nbuild1item i j =\n  if i == j then\n    1\n  else        \n    0\n\nbuild2 : [v1][v1]Fld -> [v1][o1]Fld -> [v1][o2]Fld ->\n         [o1][o1]Fld -> [o1][o2]Fld -> [nn][nn]Fld\nbuild2 a11 a12 a13 a22 a23 =\n  map (build2row a11 a12 a13 a22 a23) (nats`{n=nn})\n\nbuild2row : [v1][v1]Fld -> [v1][o1]Fld -> [v1][o2]Fld ->\n            [o1][o1]Fld -> [o1][o2]Fld  -> [width nn] -> [nn]Fld\nbuild2row a11 a12 a13 a22 a23 i =\n  if i < `v1 then\n    a11 @ i # a12 @ i # a13 @ i\n  else if i < `{v1 + o1} then\n    \/*    vzero`{n=v1} # a22 @ (i - `v1) # a23 @ (i - `v1) *\/\n    vzero`{n=v1} # vzero`{n=o1} # vzero`{n=o2}\n  else\n    map (build1item i) (nats`{n=nn})\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol\/tests\/issues\/issue177.cry","filetype":"cry","content":"module issue177 where\n\nimport issue177A\nimport issue177B as B\nimport issue177C as C\n\ntype Byte = [8]\n\nw : Byte\nw = zero\n\nx : Word16\nx = zero\n\ny : B::Word32\ny = zero\n\nz = C::z\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1744-2.cry","filetype":"cry","content":"module Bug where\n\nimport Array\n\ntype Widget = [3]\ntype Wombat = [4]\ntype Key = [5]\nnewtype Info = {\n   stuff: Array [5] [6]\n}\n\nonce: Info -> Key -> Widget -> Wombat -> Info\nonce info key widget = info'\n   where\n      info' = Info {\n         stuff = arrayUpdate info.stuff key 0\n      }\n\niter: {n} n < 10 => Info -> Key -> [n] (Widget, Wombat) -> Info\niter info key entries = infos ! 0\n   where\n      infos = [info] # [once info' key widget wombat\n                           | info' <- infos\n                           | (widget, wombat) <- entries]\n\nprocess: {n} n < 10 => Info -> [n] (Widget, Wombat) -> Info\nprocess info entries = iter info 0 entries","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue485a.cry","filetype":"cry","content":"module issue485a where\n\nimport Float\n\nprivate type A = [8] -> [8]\n\nprivate type ByteFun t = [8] -> t\n\nfoo : RoundingMode\nfoo = 0\n\nbar : A\nbar x = x\n\nbaz : ByteFun (ByteFun [8])\nbaz = (+)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1324.cry","filetype":"cry","content":"type T = { a: [8] }\ntype S = { a: [16] }\n\nf : T -> ()\nf _ = ()\n\ng : S -> ()\ng = f \n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/trac289.cry","filetype":"cry","content":"average33 : [32] -> [32] -> [32]\naverage33 x y = drop`{1}(z'\/2)\n    where\n          z' : [33]\n          z' = (0b0 # x) + (0b0 # y)\n\naverage1 : [32] -> [32] -> [32]\naverage1 x y = (x + y)\/2\n\naverage2 : [32] -> [32] -> [32]\naverage2 x y = x\/2 + y\/2 + (x%2 && y%2)\n\naverage3 : [32] -> [32] -> [32]\naverage3 x y = (x + y) >> 1\n\naverage4 : [32] -> [32] -> [32]\naverage4 x y =    (x >> 1) + (y >> 1) + (x && y && 1)\n\naverage5 : [32] -> [32] -> [32]\naverage5 x y = lo + ((hi - lo)>>1) where\n    lo = min x y\n    hi = max x y\n\nproperty av1 x y = average33 x y == average1 x y\nproperty av2 x y = average33 x y == average2 x y\nproperty av3 x y = average33 x y == average3 x y\nproperty av4 x y = average33 x y == average4 x y\nproperty av5 x y = average33 x y == average5 x y\n\nproperty applesOranges x y = average4 x y == average5 x y\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue214.cry","filetype":"cry","content":"bm : {r} (fin r, r >= 1) => [2*r] -> [2*r]\nbm B = (B @@ [0,2..2*r-2]) # (B @@ [1,3..2*r-1])\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue614.cry","filetype":"cry","content":"f : {m, n, k} (n == max 2 m k == m + 1) => [m] -> [k][n]\nf x = zero\n\n\ng : {n, k} (fin n, fin k, 0 < n <= k) => [n] -> [k]\ng x = sext x\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue416.cry","filetype":"cry","content":"f : {n} (fin n, 3 >= width n) => [lengthFromThenTo 1 n 7][3]\nf = [1, n .. 7]\n\ng : {n} (fin n, 3 >= width n) => [_][3]\ng = [1, n .. 7]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue364.cry","filetype":"cry","content":"x : [64]\nx = random 123\n\nx_val : [64]\nx_val = 0xe4f7c1740def67df\n\nproperty x_eval = x == x_val\nproperty x_distinct = ~ (x == zero)\n\nproperty moderately_bogus_property (seed:[8]) =\n  ~(random (zero#seed) == (0:[64]))\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue826.cry","filetype":"cry","content":"WStep:\n    {n}\n    (fin n, n >= 2) ->\n    ([128] -> [128]) -> [n][64] -> [64] -> [n][64]\nWStep CIPHk ([A] # Rs) t = [A'] # Rs'\n  where\n    [MSB, LSB] = split (CIPHk (A # head Rs))\n    A'         = MSB ^ t\n    Rs'        = tail Rs # [LSB]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue212.cry","filetype":"cry","content":"\/\/ TMD: I am using this issue for a range of regressions or short-comings with the new type checker.\n\/\/ Let me know if you'd like separate github issue numbers.\n\n\/\/ Want: exact width values is nice (width x == const ==> width x >= const)\n\/\/ Issue: Cryptol wants 'width x >= const'\n\/\/ width_eq_geq : {n} (32 == width n, n >= 1, 32 >= width n, fin n) => [n]Bit\nwidth_eq_geq : {n} (32 == width n, n >= 1) => [n]Bit\nwidth_eq_geq = [True | _ <- [1..n] : [_][32] ]\n\n\/\/ Want: const >= width (x+1) ==> const > width x\n\/\/ or any monotonic function, not just addition.\n\/\/\n\/\/ Also Want: const >= width n     ==> fin n\n\/\/\n\/\/ Issue: Cryptol wants '64 >= width n' and 'fin n'\n\/\/ can_not_width : {n} (64 >= width (8*(n+1)), 64 >= width n, fin n) => [64]\ncan_not_width : {n} (64 >= width (8*(n+1))) => [64]\ncan_not_width = zero # (`n : [width n])\n\n\/\/ Want: Honestly, I don't know what's going on here.  It seems to relate to some of our regressions though.\n\/\/ Tell me if there should be another ticket - probably one that already exists. -TMD\n\/\/ Issue: Cryptol 2.3 wants 'n == 4 + (?a3 - n % 4)'\ntake_knows_no_bounds : {n} (fin n, n >= 4) => [n][8] -> [4 - (n%4)][8]\ntake_knows_no_bounds ns = foo\n where\n foo = take `{4 - (n%4)} ns\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/issue1024b.cry","filetype":"cry","content":"type constraint PredSyn (a : *) (p:Prop) = (Zero a, Cmp a, p)\n\nsomeFunc : {a} (PredSyn a (Logic a)) => a\nsomeFunc = ~zero\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/T1440.cry","filetype":"cry","content":"module T1440 where\n\nimport interface submodule X\n\nimport submodule Y\n\ninterface submodule I where\n  type n : #\n\nsubmodule M where\n  import interface submodule I\n\nsubmodule N where\n  x = 2\n\nsubmodule M1 = submodule M { submodule U1 }\nsubmodule M2 = submodule U2 { submodule N }\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1503.cry","filetype":"cry","content":"add_mul_lemma : Integer -> Integer -> Integer -> Integer -> Bit\nadd_mul_lemma m n p q =\n  (0 <= m \/\\ 0 <= n \/\\ 0 <= p \/\\ 0 <= q \/\\ n < q \/\\ p < m) ==>\n  (m * n + p < m * q)\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol\/tests\/issues\/issue368.cry","filetype":"cry","content":"myFun : [8] -> [8] -> [8]\nmyFun a b = 0\n\nx + y = myFun x y\nx * y = myFun x y\nx - y = myFun x y\nx ~ y = myFun x y\nx ^^ y = myFun x y\nx ++ y = myFun x y\nx .+ y = myFun x y\nx +. y = myFun x y\nx !+ y = myFun x y\nx +! y = myFun x y\nx .! y = myFun x y\nx :+ y = myFun x y\nx =+ y = myFun x y\nx .: y = myFun x y\nx :+: y = myFun x y\nx +:: y = myFun x y\nx ^^^ y = myFun x y\nx .... y = myFun x y\nx +\/\/+ y = myFun x y\nx .","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/T146.cry","filetype":"cry","content":"mk_curve_ops f = undefined\n  where\n    c = { field = f\n        , v1    = ec_v1 f\n        , v2    = ec_v2 c\n        }\n\nec_v1 : {fv} { v0: fv } -> fv\nec_v1 = undefined\n\nec_v2 : {fv} _ -> fv\nec_v2 p = p.field.v0\n  where _ = p.field.v0\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1024a.cry","filetype":"cry","content":"type Funny (f : # -> *) = Integer\ntype Strange (f : Prop) = Integer\n\nfunnyFunc : { i : #, f : # -> *, g : * } Integer\nfunnyFunc = zero\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue184.cry","filetype":"cry","content":"keyWS seed = xs\n  where\n  xs = seed # [ i | i    <- [ 0xff ... ]\n                  | prev <- drop `{4 - 1} xs\n                  | old  <- xs\n                  ]\n\ntester = take`{10} (keyWS [1,2,3,4])\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol\/tests\/issues\/issue225.cry","filetype":"cry","content":"module EnigmaBroke where\n\ntype Rotor       = [26](Char, Bit)\n\nmkRotor : {a} (fin a) => ([26]Char,[a]) -> Rotor\nmkRotor (_,_) = zero\n\nscramble : (Bit, Char, Rotor) -> (Bit, Char, Rotor)\nscramble (_,_,_) = zero\n\njoinRotors : {n} (fin n) => ([n]Rotor, Char) -> ([n]Rotor, Char)\njoinRotors (rotors, inputChar) = (rotors', outputChar)\n  where\n    initRotor = mkRotor (['A' .. 'Z'], [])\n    \/\/ ncrs : [n+1](Bit, [8], Rotor)\n    ncrs = [(True, inputChar, initRotor)]\n               # [ scramble (notch, char, r)\n                 | r <- rotors\n                 | (notch, char, rotor') <- ncrs\n                 ]\n    rotors' = tail [ r | (_, _, r) <- ncrs ]\n    (_, outputChar, _) = ncrs ! 0\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/Issue796.cry","filetype":"cry","content":"module Issue796 = Issue796_Sig where\n\nparameter\n  type _k: #\n\ntype Key = [8 * _k]\ntype Block = [64]\ntype RoundKey = [64]\n\naux : RoundKey -> Block -> Block\naux RK P = zero\n\n\/\/ key_schedule : Key -> RoundKey\nkey_schedule K = zero\n  where\n    _ = [ groupBy`{4} K ]\n\n\/\/ encrypt_block : Key -> Block -> Block\nencrypt_block key pt = aux (key_schedule key) pt\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/issue581.cry","filetype":"cry","content":"foo : {i, j} (fin i, fin j, j >= 1) => [i \/^ j][32]\nfoo = take [0...]\n\nbar : {i, j} (fin i, fin j, j >= 1) => [i %^ j][32]\nbar = take [0...]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue185.cry","filetype":"cry","content":"group : {perGroup, a, b, c} (fin perGroup, c == perGroup * a)\n    => [c]b -> [a][perGroup]b\ngroup xs = split`{each=perGroup}xs\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue187.cry","filetype":"cry","content":"\/\/ Helper synonyms:\n\/\/ type Char        = [8]\nmodule Enigma where\n\nenigmaLoop : {n}(fin n) => [n]\nenigmaLoop = undefined\n\n\/\/ Encryption\/Decryption\nenigma : {n, m} (fin n, fin m) => ([n], [m]) -> [m]\nenigma (m, pt) = tail [ True | _ <- rcs ]\n  where rcs = [ (m, True)] #\n              [ (enigmaLoop, True)\n              | _     <- pt\n              | (_,_) <- rcs\n              ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1511.cry","filetype":"cry","content":"module M where\n\nv: [1]\nv = MOOD.SAD.value\n\nnewtype MOOD_t = { value: [1] }\n\nMOOD = { HAPPY = MOOD_t { value = 0b1 }\n       , SAD   = MOOD_t { value = 0b0 }\n       }\n\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/trac133.cry","filetype":"cry","content":"example1 : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]\nexample1 k = drop`{16} ((zero : [16*(2 - a)][8]) #k)\n\nexample2 : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]\nexample2 k = drop`{16} (zero # k)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue877.cry","filetype":"cry","content":"a = []\n\nxs : [_] Integer\nxs = [1,2,3]\n\nb = xs @@ []\nc = xs @@ (map trunc [])\nd = xs @@ (map (\\x -> [x]) [])\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue_1812.cry","filetype":"cry","content":"f : {h} (fin h) => [2^^h + (2^^h - 2^^h)]\nf = g`{h}\n\ng : {h} (fin h) => [2^^h]\ng = zero\n\n\/\/ See if Cryptol knows that (2^^h + 2^^h) - 2^^h == 2^^h\n\nff : {h} (fin h) => [(2^^h + 2^^h) - 2^^h]\nff = gg`{h}\n\ngg : {h} (fin h) => [2^^h]\ngg = zero\n\njj : {h} (fin h) => [2 ^^ (1 + h) - 1]\njj = kk`{h}\n\nkk : {h} (fin h, 2 ^^ (1 + h) - 1 >= 2 ^^ h - 1) => [2 ^^ h - 1 + 2 ^^ h]\nkk = zero","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue268.cry","filetype":"cry","content":"xs : [10]([8],[8])\nxs = take `{10} zs\n  where\n  zs : [inf]([8],[8])\n  zs = [(0,0)] # [ (0, z) | (z,_) <- drop `{1} zs]\n\nvs : [10]([8],[8])\nvs = take `{10} zs where zs = [ (0, z) | (z,_) <- zs]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/issue731.cry","filetype":"cry","content":"module issue731 where\n\ntype constraint T n = (fin n, n >= 1)\n\ntype constraint Both p q = (p, q)\n\ntype constraint Fin2 i j = Both (fin i) (fin j)\n\ntype constraint i <=> j = (i <= j, i >= j)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1562.cry","filetype":"cry","content":"interface submodule I where\n  type Zp = [8]\n\nsubmodule F where\n  import interface submodule I\n\nsubmodule M where\n  \/\/ this is unused, but just here because syntactically we cannot have an empty\n  \/\/ module\n  type Empty = Bit\n\nsubmodule F1 = submodule F { submodule M }\nsubmodule F2 = submodule F { submodule M }\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/issue1210.cry","filetype":"cry","content":"mwe : [2] -> [2][1] -> Bit\nproperty mwe i r = r@0 == (r@0) << 0*i\n\nmwe' : [2] -> [1] -> Bit\nproperty mwe' i r = r == (r << 0*i)\n\nmwe'' : Bit\nproperty mwe'' = r == (r << i)\n where r = 1:[1]\n       i = 0:[2]\n\nbitget : [12] -> [436][8] -> Bit\nproperty bitget i r = i < 3488 ==> bit_gf == if bit_bit then 0x0001 else 0x0000\n  where bit_gf = (zext (((r@(i\/8)) >> (i%8) ) && 1))\n        bit_bit = (join (map reverse r))@i","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue108.cry","filetype":"cry","content":"sum : {a,b} (fin a, fin b) => [a][b] -> [b]\nsum xs = ss ! 0\n  where\n    ss = [0] # [ s + x | x <- xs | s <- ss ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue130.cry","filetype":"cry","content":"parity xs = ys!0\n  where ys = [False] # [y ^ x | x <- xs | y <- ys ]\n\nfoldl1 f xs = ys!0\n  where ys = [xs@0] # [ f y x | y <- ys | x <- tail xs ]\n\npar = foldl1 (^)\n\nparOK : {n} (fin n) => [n+1] -> Bit\nproperty parOK x = par x == parity x\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1798.cry","filetype":"cry","content":"exhaustive1 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1 x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n\nexhaustive2 : {w} [2 ^^ w] -> [2 ^^ w]\nexhaustive2 x\n  | (2 ^^ w) == 1 => ~ x","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue093.cry","filetype":"cry","content":"property t0 = True\nproperty t1 x = x == (x : [32])\nproperty t2 x y = if (x : [32]) < (y : [32]) then y != zero else True\nnot_a_prop = True\nproperty f0 = False\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue723.cry","filetype":"cry","content":"f : {n} (fin n) => [n] -> [n]\nf x = g x\n  where\n    m1 = x\n\n    g : {k} (fin k) => [k] -> [k]\n    g m0 = m0 ^ m1\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue494.cry","filetype":"cry","content":"gt_words : {a} (fin a) => [a][32] -> [a][32] -> Bit\ngt_words l0 l1 = ss!0\n  where\n    ss = [ False ] # [ s \\\/ (i > j) | i <- l0 | j <- l1 | s <- ss ]\n\ngt_words' l0 l1 = ss!0\n  where\n    ss = [ False ] # [ s \\\/ (i > j) | i <- l0 | j <- l1 | s <- ss ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue734.cry","filetype":"cry","content":"f : {a} (fin a) => [2^^a - 1] -> [3*(2^^a - 1)]\nf x = x # x # x\n\nasdf1 : {r} (fin r, width (2^^r)==r+1) => [r+1]\nasdf1 = `(2^^r)\n\nasdf2 : {r} (fin r, width(2^^r-1)==r) => [r]\nasdf2 = `(2^^r-1)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/Issue883_A.cry","filetype":"cry","content":"module Issue883_A where\nparameter\n    type c : #\n    type constraint ( fin c, c >= 1, 64 >= width (c-1) )\n\ndumbHash : {n} (fin n, 64 >= width n) => [n] -> [128]\ndumbHash msg = zero\n\nasdf : {n} (64 >= width (n+192), 64 >= width (128 * c), fin n) => [n] -> [128]\nasdf msg = dumbHash (join (drop`{1} ys))\n where\n   ys : [c+1][128]\n   ys = zero\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue640.cry","filetype":"cry","content":"f : [1] -> [2]\nf x = out\n  where out = x # [out@0]\n\ng : [1] -> [2]\ng x = out\n  where out = x # (take out)\n\nh : [1] [8] -> [2] [8]\nh x = out\n  where out = x # take out\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/constraint-guards\/mergesort.cry","filetype":"cry","content":"sort : {n,a} Cmp a => (fin n) => [n]a -> [n]a\nsort xs\n  | n <= 1 => xs\n  | ()     => merge (sort left) (sort right)\n              where (left : [n\/2] _) # right = xs\n\nmerge : {m,n,a} Cmp a => [m]a -> [n]a -> [m+n]a\nmerge xs ys\n  | m == 0  => ys\n  | n == 0  => xs\n  | (m > 0, n > 0) => if x <= y \n                        then [x] # merge restX ys\n                        else [y] # merge xs restY\n                      where\n                      [x] # restX = xs\n                      [y] # restY = ys\n\n\nproperty sort_correct =\n  (sort [] == []) &&\n  (sort [0] == [0]) &&\n  (sort [-6, 1, 9, -3, -9, 2, 4] == [-9, -6, -3, 1, 2, 4, 9]) &&\n  (sort [4, -8, -1, -7, -5, 9, 8, 8] == [-8, -7, -5, -1, 4, 8, 8, 9]) &&\n  (sort [1, -1, -2, -3, -2, 7, 5] == [-3, -2, -2, -1, 1, 5, 7]) &&\n  (sort [9, 9, 8, -3, 1, 1, -6, -6, -8] == [-8, -6, -6, -3, 1, 1, 8, 9, 9]) &&\n  (sort [9, 1, 5, 0] == [0, 1, 5, 9]) &&\n  (sort [8, 3, 3] == [3, 3, 8]) &&\n  (sort [-7, 8] == [-7, 8])","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/constraint-guards\/nestFun.cry","filetype":"cry","content":"submodule A where\n\n  parameter\n    type n : #\n\n  f : Bool\n  f | n == 0 => True\n    | n > 0  => False\n\nimport submodule A as Two where\n  type n = 2\n\nimport submodule A as Zero where\n  type n = 0\n\n\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/constraint-guards\/constant.cry","filetype":"cry","content":"isZero : {n : #} Bit\nisZero | n == 0 => True\n       | ()     => False\n\nproperty isZero_correct =\n  ~isZero `{inf} &&\n   isZero `{  0}   &&\n  ~isZero `{  1}   &&\n  ~isZero `{  2}   &&\n  ~isZero `{  4}   &&\n  ~isZero `{  8}   &&\n  ~isZero `{ 16}\n\nisFin : {n : #} Bit\nisFin | fin n => True\n      | ()    => False\n\nproperty isFin_correct =\n  ~isFin `{inf} &&\n   isFin `{  0}   &&\n   isFin `{  1}   &&\n   isFin `{  2}   &&\n   isFin `{  4}   &&\n   isFin `{  8}   &&\n   isFin `{ 16}\n\nidTypeNum : {n : #} Integer \nidTypeNum | fin n => `n\n\nproperty idTypeNum_correct =\n  (idTypeNum `{ 0}  ==  0) &&\n  (idTypeNum `{ 1}  ==  1) &&\n  (idTypeNum `{ 2}  ==  2) &&\n  (idTypeNum `{ 4}  ==  4) &&\n  (idTypeNum `{ 8}  ==  8) &&\n  (idTypeNum `{16}  == 16)\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/constraint-guards\/insert.cry","filetype":"cry","content":"\/\/ assumes that `xs` is sorted\ninsert : {n, a} (fin n, Cmp a) => a -> [n]a -> [n+1]a\ninsert x' xs \n  | n == 0         => [x']\n  | n == 1         => if x' <= x then [x', x] else [x, x']\n                      where [x] = xs\n  | ( n % 2 == 0\n    , n     >  1 ) => if x' <= x \n                        then insert x' (xs1 # [x]) # xs2 \n                        else xs1 # [x] # insert x' xs2\n                      where (xs1 : [n\/2 - 1]_) # [x] # (xs2 : [n\/2]_) = xs\n  | ( n % 2 == 1\n    , n     >  1 ) => if x' <= x \n                        then insert x' (xs1 # [x]) # xs2\n                        else xs1 # [x] # insert x' xs2\n                      where (xs1 : [n\/2]_) # [x] # (xs2 : [n\/2]_) = xs\n\nproperty insert_correct =\n  (insert 0 [  1,2,3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 1 [0,  2,3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 2 [0,1,  3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 3 [0,1,2,  4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 4 [0,1,2,3,  5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 5 [0,1,2,3,4,  6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 6 [0,1,2,3,4,5,  7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 7 [0,1,2,3,4,5,6,  8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 8 [0,1,2,3,4,5,6,7,  9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 9 [0,1,2,3,4,5,6,7,8  ] == [0,1,2,3,4,5,6,7,8,9])\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/constraint-guards\/len.cry","filetype":"cry","content":"len : {n,a} (fin n) => [n] a -> Integer\nlen x\n  | (n == 0) => 0\n  | (n >  0) => 1 + len (drop`{1} x)\n\n\nproperty \n  len_correct = and\n    [ len l == length l where l = []\n    , len l == length l where l = [1]\n    , len l == length l where l = [1,2]\n    , len l == length l where l = [1,2,3]\n    , len l == length l where l = [1,2,3,4,5]\n    , len l == length l where l = [1,2,3,4,5,6]\n    , len l == length l where l = [1,2,3,4,5,6,7]\n    , len l == length l where l = [1,2,3,4,5,6,7,8]\n    ]","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/constraint-guards\/tail.cry","filetype":"cry","content":"tail : {n, a} (fin n) => [n]a -> [(max n 1) - 1]a\ntail xs | n == 0 => xs\n        | n >= 1 => drop `{1} xs\n\nproperty tail_correct =\n  (tail [] == []) &&\n  (tail [1] == []) &&\n  (tail [1,2] == [2]) &&\n  (tail [1,2,3] == [2,3]) &&\n  (tail [1,2,3,4] == [2,3,4])\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/constraint-guards\/inits.cry","filetype":"cry","content":"\/\/ ys      | zs      | acc\n\/\/ \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013+\u2013-\u2013\u2013\u2013\u2013\u2013\u2013\u2013+\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\n\/\/ [1,2,3] | []      | []\n\/\/ [2,3]   | [1]     | [1]\n\/\/ [3]     | [1,2]   | [1,1,2]\n\/\/ []      | [1,2,3] | [1,1,2,1,2,3]\n\ninits : {n, a} (fin n) => [n]a -> [(n * (n+1))\/2]a\ninits xs\n  | n == 0 => []\n  | n >  0 => initsLoop xs' x []\n    where\n      (x : [1]_) # xs' = xs\n\ninitsLoop : {n, l, m, a} (fin l, fin m, l + m == n, m >= 1) =>\n        [l]a -> [m]a ->\n        [((m-1) * ((m-1)+1))\/2]a ->\n        [(n * (n+1))\/2]a\ninitsLoop ys zs acc\n  | l == 0 => acc # zs\n  | l >  0 => initsLoop ys' (zs # y) (acc # zs)\n   where (y : [1]_) # ys' = ys\n\n\nproperty inits_correct =\n  (inits [] == []) &&\n  (inits [1] == [1]) &&\n  (inits [1,2] == [1,1,2]) &&\n  (inits [1,2,3] == [1,1,2,1,2,3]) &&\n  (inits [1,2,3,4] == [1,1,2,1,2,3,1,2,3,4]) &&\n  (inits [1,2,3,4,5] == [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5])\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/T11\/A.cry","filetype":"cry","content":"module T11::A where\n\nparameter\n  type X : #\n  type Y : #\n\ntype T = ([X],[Y])\n\nf : T -> [X]\nf (x,_) = x\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T038.cry","filetype":"cry","content":"module T038 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  import submodule F { submodule Q }\n  x = 11\n\nsubmodule Q where\n  x = 11\n\ninterface submodule J where\n  import submodule F { submodule P }\n  x : [8]\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T011.cry","filetype":"cry","content":"\/\/ Test importing in a signature\n\n\nsubmodule A where\n  type T = [8]\n\ninterface submodule S where\n  import submodule A\n  x : T\n\nsubmodule F where\n  import interface submodule S\n\n  y = 2 * x\n\nsubmodule I where\n  x = 28\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T005.cry","filetype":"cry","content":"interface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A as X\n  import interface submodule A as Y\n\n  interface constraint (X::n == Y::n)\n\n  y : [X::n]\n  y = X::x + Y::x\n\n\nsubmodule I where\n  type n = 8\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule J where\n  type n = 9\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule M = submodule F { X = submodule I, Y = submodule J }\n\nimport submodule M as M\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T006.cry","filetype":"cry","content":"interface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A as X\n\n  interface constraint (X::n >= 3)\n\n  submodule G where\n    import interface submodule A\n    interface constraint (X::n == n)\n\n    y : [n]\n    y = 5 * X::x + x\n\n  y : [X::n]\n  y = 5 * X::x\n\n\nsubmodule I where\n  type n = 8\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n\nsubmodule N = submodule M::G { submodule I }\n\nimport submodule N as N\n\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T012.cry","filetype":"cry","content":"\/\/ Test importing in a signature\n\ninterface submodule S where\n  import T012_M\n  x : T\n\nsubmodule F where\n  import interface submodule S\n\n  y = 2 * x\n\nsubmodule I where\n  x = 28\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T002.cry","filetype":"cry","content":"interface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 8\n  x = 2 : [n]\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T003.cry","filetype":"cry","content":"interface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} Literal 42 a => a\n  x = 42\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T001.cry","filetype":"cry","content":"interface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 0\n  x = x : [n]\n\nsubmodule M = submodule F { submodule I }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T028.cry","filetype":"cry","content":"interface submodule S where\n  x : [8]\n\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\nsubmodule F where\n  import interface submodule S\n  import submodule G { interface S }\n  z = x + y\n\nimport submodule F where\n  x = 5\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T027.cry","filetype":"cry","content":"interface submodule S where\n  x : [8]\n\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\nsubmodule F where\n  import interface submodule S as A\n\n  submodule H where\n    import interface submodule S as A\n    import submodule G { interface A }\n    z = A::x + y\n\nimport submodule F where\n  x = 5\n\nimport submodule H where\n  x = 6\n\n\n\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T037.cry","filetype":"cry","content":"module T037 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  x = 11\n\nsubmodule X where\n  submodule M = submodule F { submodule P }\n  import submodule M\n\n  z = y\n\nimport submodule X\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T012_M.cry","filetype":"cry","content":"module T012_M where\n\ntype T = [8]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T022.cry","filetype":"cry","content":"interface submodule S where\n  type n : #\n  type constraint (fin n)\n  x : [n]\n\nsubmodule F where\n  import interface submodule S as A\n\n  z = A::x + A::x\n\nimport submodule F where\n  type n = 8\n  x = 2\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T008.cry","filetype":"cry","content":"submodule F where\n  parameter\n    type n : #\n    type constraint (fin n, n >= 2)\n\n  x : [n]\n  x = 2\n\n\nsubmodule M = submodule F where\n  type n = 2\n\nimport submodule M as M\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T035.cry","filetype":"cry","content":"submodule A where\n  newtype T = { x : Integer }\n\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n)\n\n  newtype X = { x : [n] }\n  f : X -> X\n  f x = x\n\nsubmodule M = submodule F { _ }\nsubmodule N = submodule F { _ }\n\nimport submodule M as M\nimport submodule N as N\n\n\/\/ This is a type error because currently F's instantiation is generative\n\/\/ If we make it applicative, then we should change this test\nx = M::f (N::X { x = 0 })\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/functors\/T040.cry","filetype":"cry","content":"submodule F where\n  parameter\n    type T : *\n\n  newtype NT = { field : T -> () }\n\n  nt : NT\n  nt = NT { field = \\_ -> () }\n\nimport submodule F where\n  type T = [32]\n\n\nx = nt.field 10\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/modsys\/nested\/T14.cry","filetype":"cry","content":"module T14 where\n\nsubmodule A where\n  x = 0x1\n\n  submodule B where\n    y = 0x2\n\n    submodule C where\n      z = 0x3\n\nimport submodule A::B\nimport submodule C as D\n\noutput = { ex1 = A::x\n         , ex2 = A::B::y\n         , ex3 = A::B::C::z\n         , ex4 = y\n         , ex5 = D::z\n         }\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-type-errors.cry","filetype":"cry","content":"import Float\n\nforeign badWordSizes : [65] -> [128]\nforeign badFloatSizes : Float16 -> Float128\nforeign badArrayTypes : {n} (fin n) =>\n  [n]Bit -> [n]([16], [16]) -> [n][4][8]{a : [n], b : [2]}\nforeign notFunction : [32]\nforeign badKind : {t} t -> [32]\nforeign noFin : {n} [n][32] -> [n * 2][32]\nforeign infSeq : [inf][32] -> Bit\nforeign wildcard : { x : [8], y : Float32 } -> _\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-fallback.cry","filetype":"cry","content":"foreign foreignAndCryptol : [8] -> [8]\n\/\/ cryptol implementation is intentionally different,\n\/\/ so we can test which is being used\nforeignAndCryptol x = x\n\nforeign foreignAndNoCryptol : [8] -> [8]\n\nforeign noForeignAndCryptol : [8] -> [8]\nnoForeignAndCryptol x = x + 3\n\nforeign noForeignAndNoCryptol : [8] -> [8]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/test-ffi.cry","filetype":"cry","content":"import Float\n\n\/\/ Basic integral types\nforeign add8 : [8] -> [8] -> [8]\nforeign sub16 : [16] -> [16] -> [16]\nforeign mul32 : [32] -> [32] -> [32]\nforeign div64 : [64] -> [64] -> [64]\n\n\/\/ Non-machine integer sizes\nforeign extendInput : [3] -> [8]\nforeign maskOutput : [8] -> [3]\nforeign noBits : [0] -> [0]\n\n\/\/ Bit\nforeign not : Bit -> Bit\n\n\/\/ Float\nforeign addFloat32 : Float32 -> Float32 -> Float32\nforeign subFloat64 : Float64 -> Float64 -> Float64\nforeign specialFloats : [2] -> Float32\n\n\/\/ Type synonyms\ntype Word32 = [32]\ntype MyFunc = Word32 -> Float32 -> Bit\nforeign usesTypeSynonym : MyFunc\n\n\/\/ Sequences\nforeign sum10 : [10]Word32 -> Word32\nforeign reverse5 : [5]Float64 -> [5]Float64\n\n\/\/ Tuples and records\nforeign compoundTypes : ([32], { x : [10], y : [3][20] }) -> { z : [5][20] }\n  -> { a : ([16], [16]), b : { c : [8][20], d : [5], e : [5] } }\n\n\/\/ Polymorphic sizes\nforeign typeToValue : {n} (fin n) => () -> [64]\nforeign sumPoly : {n} (fin n) => [n]Word32 -> Word32\nforeign inits : {n} (fin n) => [n][8] -> [n * (n + 1) \/ 2][8]\nforeign zipMul3 : {n, m, p} (fin n, fin m, fin p) =>\n  [n]Float32 -> [m]Float32 -> [p]Float32 -> [min n (min m p)]Float32\n\n\/\/ Nested sequences\nforeign nestedSeq : {n, m, p} (fin n, fin m, fin p, n * m * p == 4 * 3 * 2) =>\n  [n][m][p][8] -> [4][3][2][8]\n\n\/\/ Integers, Rationals, Z\nforeign i2Q   : Integer -> Rational\nforeign i2Qs  : Integer -> [2]Rational\nforeign iQ2Qi : (Integer,Rational) -> (Rational,Integer)\nforeign i2Z5  : Integer -> Z 5\nforeign i2Z   : {n} (fin n, n >= 1) => Integer -> Z n\n\n\/\/ In a nested module\nsubmodule A where\n  foreign nested : () -> [8]\n\n\n\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/tests\/issues\/issue1489\/issue1489.cry","filetype":"cry","content":"module ID where\n\nid : {k} (fin k, k > 0) => [2^^k] -> [2^^k]\nid x = join(split`{2,2^^(k-1)}x)\n\ntype q = 3329\n\nct_butterfly :\n    {m, hm}\n    (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n    [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\nct_butterfly v z = new_v\n  where\n    halflen = 2^^`hm\n    lower, upper : [2^^hm](Z q)\n    lower@x = v@x + z * v@(x + halflen)\n    upper@x = v@x - z * v@(x + halflen)\n    new_v = lower # upper\n\nzeta_expc  : [128](Z q)\nzeta_expc = [ 1, 1729, 2580, 3289, 2642, 630, 1897, 848,\n              1062, 1919, 193, 797, 2786, 3260, 569, 1746,\n              296, 2447, 1339, 1476, 3046, 56, 2240, 1333,\n              1426, 2094, 535, 2882, 2393, 2879, 1974, 821,\n              289, 331, 3253, 1756, 1197, 2304, 2277, 2055,\n              650, 1977, 2513, 632, 2865, 33, 1320, 1915,\n              2319, 1435, 807, 452, 1438, 2868, 1534, 2402,\n              2647, 2617, 1481, 648, 2474, 3110, 1227, 910,\n              17, 2761, 583, 2649, 1637, 723, 2288, 1100,\n              1409, 2662, 3281, 233, 756, 2156, 3015, 3050,\n              1703, 1651, 2789, 1789, 1847, 952, 1461, 2687,\n              939, 2308, 2437, 2388, 733, 2337, 268, 641,\n              1584, 2298, 2037, 3220, 375, 2549, 2090, 1645,\n              1063, 319, 2773, 757, 2099, 561, 2466, 2594,\n              2804, 1092, 403, 1026, 1143, 2150, 2775, 886,\n              1722, 1212, 1874, 1029, 2110, 2935, 885, 2154 ]\n\nfast_nttl :\n    {lv}  \/\/ Length of v is a member of {256,128,64,32,16,8,4}\n    (lv >= 2, lv <= 8) =>\n    [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\nfast_nttl v k\n  \/\/ Base case. lv==2 so just compute the butterfly and return\n  | lv == 2 => ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n  \/\/ Recursive case. Butterfly what we have, then recurse on each half,\n  \/\/ concatenate the results and return. As above, we need coerceSize\n  \/\/ here (twice) to satisfy the type checker.\n  | lv  > 2 => (fast_nttl`{lv-1} s0 (k * 2)) #\n                           (fast_nttl`{lv-1} s1 (k * 2 + 1))\n                where\n                  t = ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n                                    [s0, s1] = split t","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1561\/G.cry","filetype":"cry","content":"module G where\n\nimport interface I as J\nimport interface I as K\n\nja = J::x + 1\njb = J::y + 2\n\nka = K::x + 1\nkb = K::y + 2\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1560\/T4.cry","filetype":"cry","content":"module T3 where\n\ninterface submodule I1 where\n  type x: #\n  type constraint (x >= 1, x <= 3)\n\ninterface submodule I2 where\n  type x: #\n  type constraint (x >= 1, x <= 4)\n\n\n\nsubmodule F where\n  import interface submodule I1 as I\n\n  y: [I::x]\n  y = 1\n\n  submodule G where\n    import interface submodule I2 as I\n    import interface submodule I2 as J\n\n    csum : [I::x]\n    csum = y\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/tests\/issues\/issue1560\/T2.cry","filetype":"cry","content":"module T2 where\n\nparameter\n  type n: #\n  type constraint (fin n)\n\na:[n]\na = a\n\nsubmodule F where\n  parameter\n    type n: #\n\n  b: {m} [n] -> [m]\n  b _ = a\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/ticket141.cry","filetype":"cry","content":"type Char = [8]\ntype Permutation = String 26\n\ninvSubst : (String 26, Char) -> Char\ninvSubst (key, c) = candidates ! 0\n    where candidates = [0] # [ if c == k then a else p\n                             | k <- key\n                             | a <- ['A' .. 'Z']\n                             | p <- candidates\n                             ]\n\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Finite.cry","filetype":"cry","content":"xs = [ 1 .. 100 ]\n\nsumInf xs = iterSums\n    where\n        sums = [ 0 ] # [ x + y | x <- xs\n                               | y <- sums ]\n        iterSums = [ x + y | x <- sums\n                           | y <- [ 1 ...] ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Enigma.cry","filetype":"cry","content":"\/\/ Helper synonyms:\n\/\/ type Char        = [8]\nmodule Enigma where\n\ntype Permutation = String 26\n\n\/\/ Enigma components:\ntype Plugboard   = Permutation\ntype Rotor       = [26](Char, Bit)\ntype Reflector   = Permutation\n\n\/\/ An enigma machine with n rotors:\ntype Enigma n    = { plugboard : Plugboard,\n                     rotors    : [n]Rotor,\n                     reflector : Reflector\n                   }\n\n\/\/ Check membership in a sequence:\nelem : {a, b} (fin 0, fin a, Cmp b) => (b, [a]b) -> Bit\nelem (x, xs) = matches ! 0\n  where matches = [False] # [ m || (x == e)  | e <- xs\n                                             | m <- matches\n                            ]\n\/\/ Inverting a permutation lookup:\nprivate\n  invSubst : (Permutation, Char) -> Char\n  invSubst (key, c) = candidates ! 0\n    where candidates = [0] # [ if c == k then a else p\n                             | k <- key\n                             | a <- ['A' .. 'Z']\n                             | p <- candidates\n                             ]\n\n\/\/ Constructing a rotor\nmkRotor : {n} (fin n) => (Permutation, String n) -> Rotor\nmkRotor (perm, notchLocations) = [ (p, elem (p, notchLocations))\n                                 | p <- perm\n                                 ]\n\n\/\/ Action of a single rotor on a character\n\/\/ Note that we encrypt and then rotate, if necessary\nscramble : (Bit, Char, Rotor) -> (Bit, Char, Rotor)\nscramble (rotate, c, rotor) = (notch, c', rotor')\n  where \n    (c', _)    = rotor @ (c - 'A')\n    (_, notch) = rotor @ 0\n    rotor'     = if rotate then rotor <<< 1 else rotor\n\n\/\/ Connecting rotors in a sequence\njoinRotors : {n} (fin n) => ([n]Rotor, Char) -> ([n]Rotor, Char)\njoinRotors (rotors, inputChar) = (rotors', outputChar)\n  where \n    initRotor = mkRotor (['A' .. 'Z'], [])\n    ncrs : [n+1](Bit, [8], Rotor)\n    ncrs = [(True, inputChar, initRotor)] \n               # [ scramble (notch, char, r)\n                 | r <- rotors\n                 | (notch, char, rotor') <- ncrs\n                 ]\n    rotors' = tail [ r | (_, _, r) <- ncrs ]\n    (_, outputChar, _) = ncrs ! 0\n\n\/\/ Following the signal through a single rotor, forward and backward\nsubstFwd, substBwd : (Permutation, Char) -> Char\nsubstFwd (perm, c) = perm @ (c - 'A')\nsubstBwd (perm, c) = invSubst (perm, c)\n\n\/\/ Route the signal back from the reflector, chase through rotors\nbackSignal : {n} (fin n) => ([n]Rotor, Char) -> Char\nbackSignal (rotors, inputChar) = cs ! 0\n  where   cs = [inputChar] # [ substBwd ([ p | (p, _) <- r ], c)\n                             | r <- reverse rotors\n                             | c <- cs\n                             ]\n\n\/\/ The full enigma loop, from keyboard to lamps:\n\/\/ The signal goes through the plugboard, rotors, and the reflector,\n\/\/ then goes back through the sequence in reverse, out of the\n\/\/ plugboard and to the lamps\nenigmaLoop : {n} (fin n) => (Plugboard, [n]Rotor, Reflector, Char) -> ([n]Rotor, Char)\nenigmaLoop (pboard, rotors, refl, c0) = (rotors', c5)\n  where\n    c1 = substFwd (pboard, c0)\n    (rotors', c2) = joinRotors (rotors, c1)\n    c3 = substFwd (refl, c2)\n    c4 = backSignal(rotors, c3)\n    c5 = substBwd (pboard, c4)\n\n\/\/ Construct a machine out of parts\nmkEnigma : {n} (Plugboard, [n]Rotor, Reflector, [n]Char) -> Enigma n\nmkEnigma (pboard, rs, refl, startingPositions) =\n    { plugboard  = pboard\n    , rotors     = [ r <<< (s - 'A')\n                   | r <- rs\n                   | s <- startingPositions\n                   ]\n    , reflector  = refl\n    }\n\n\/\/ Encryption\/Decryption\nenigma : {n, m} (fin n, fin m) => (Enigma n, String m) -> String m\nenigma (m, pt) = tail [ c | (_, c) <- rcs ]\n  where rcs = [(m.rotors, '*')] # \n              [ enigmaLoop (m.plugboard, r, m.reflector, c)\n              | c      <- pt\n              | (r, _) <- rcs\n              ]\n\n\/\/ Decryption is the same as encryption:\n\/\/ dEnigma : {n, m} (fin n, fin m) => (Enigma n, String m) -> String m\ndEnigma = enigma\n\n\n\/\/ Build an example enigma machine:\nplugboard : Plugboard\nplugboard = \"HBGDEFCAIJKOWNLPXRSVYTMQUZ\"\n\nrotor1, rotor2, rotor3 : Rotor\nrotor1 = mkRotor (\"RJICAWVQZODLUPYFEHXSMTKNGB\", \"IO\")\nrotor2 = mkRotor (\"DWYOLETKNVQPHURZJMSFIGXCBA\", \"B\")\nrotor3 = mkRotor (\"FGKMAJWUOVNRYIZETDPSHBLCQX\", \"CK\")\n\nreflector : Reflector\nreflector = \"FEIPBATSCYVUWZQDOXHGLKMRJN\"\n\nmodelEnigma : Enigma 3\nmodelEnigma = mkEnigma (plugboard, [rotor1, rotor2, rotor3], reflector, \"GCR\")\n\n\/* Example run:\n\n   cryptol> :set ascii=on\n   cryptol> enigma  (modelEnigma, \"ENIGMAWASAREALLYCOOLMACHINE\")\n   UPEKTBSDROBVTUJGNCEHHGBXGTF\n   cryptol> dEnigma (modelEnigma, \"UPEKTBSDROBVTUJGNCEHHGBXGTF\")\n   ENIGMAWASAREALLYCOOLMACHINE\n*\/\n\nall: {a, n} (fin n) => (a->Bit) -> [n]a -> Bit\nall fn xs = folds ! 0 where\n    folds = [True] # [ fn x && p | x <- xs\n                                 | p <- folds]\ncheckReflectorFwdBwd : Reflector -> Bit\ncheckReflectorFwdBwd refl = all check ['A' .. 'Z']\n    where check c = substFwd (refl, c) == substBwd (refl, c)\n\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Simple.cry","filetype":"cry","content":"type Char = [8]\ntype Permutation = String 26\n\ninvSubst : (Permutation, Char) -> Char\ninvSubst (key, c) = candidates ! 0\n  where candidates = [0] # [ if c == k then a else p\n                           | k <- key\n                           | a <- ['A' .. 'Z']\n                           | p <- candidates\n                           ]\n\nmyrev : {n,a} (fin n) => [n+1][a] -> [n+1][a]\nmyrev xs = [ xs!i | i <- [ 0 .. n] ]\n\nsumAll xs = ys ! 0\n    where ys = [0] # [x+y | x <- xs | y <- ys]\n\n\/*\nsimpleRec : {n,a} (fin n) => [n]a -> a\nsimpleRec xs = ret\n    where\n        (_,ret) = iters ! 0\n        iters = [ (1,xs@0) ] #\n                    [ (i,x) | x <- xs\n                            | (i, _) <- iters ]\n\njoinRotors : {n} (fin n) => [n]() -> [n]()\njoinRotors rotors = rotors'\n  where\n    ncrs = [(True, ())]\n               # [ (notch, r)\n                 | r <- rotors\n                 | (notch, _) <- ncrs\n                 ]\n    rotors' = tail [ r | (_, r) <- ncrs ]\n\n*\/\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/funstuff\/FoxChickenCorn.cry","filetype":"cry","content":"module FoxChickenCorn where\n\ntype OneBank = [4]\ntype BankState =\n    {left : OneBank\n    ,right: OneBank\n    }\n\nstartState      = { left = farmer || chicken || corn || fox, right = 0x0}\ndoneState       = { left = 0x0, right = farmer || chicken || corn || fox}\n\nfarmer  = 0x1\nchicken = 0x2\ncorn    = 0x4\nfox     = 0x8\n\n\/\/ To see this work, try:\n\/\/ :sat solutionInNmoves : [6]BankState -> Bit\n\nsolutionInNmoves : {n} (fin n) => [n] BankState -> Bit\nproperty solutionInNmoves states = validMoveSequence ([startState] # states # [doneState])\n\nvalidMoveSequence : {n} (fin n, n >= 1) => [n] BankState -> Bit\nvalidMoveSequence states = all [validMove a b\n                               | a <- states\n                               | b <- drop`{1} states]\n\n\/\/ Two states represent a valid move if they are both valid states (no carnage)\n\/\/ and that whatever moved followed the rules\nvalidMove : BankState -> BankState -> Bit\nvalidMove b b' = validState b && validState b'\n                 && stuffOnlyMovedWithFarmer b b'\n\nstuffOnlyMovedWithFarmer : BankState -> BankState -> Bit\nstuffOnlyMovedWithFarmer b b' =\n    if farmerHere b.left\n    then farmerHere b'.right && moveFollowsRules b.left b'.right (b'.right - b.right)\n    else farmerHere b'.left  && moveFollowsRules b.right b'.left (b'.left - b.left)\n\n\/\/ things can't move without the farmer, and the farmer can carry at most one thing\nmoveFollowsRules fromBank toBank whatMoved = farmerMoved && atMostOneObjectMoved where\n    farmerMoved = (whatMoved && farmer) == farmer\n    atMostOneObjectMoved = popCount (whatMoved && ~farmer) <= 1\n\n\/\/ \"conservation of items\" rule - nothing spontaneously disappears\ncompleteState : BankState -> Bit\ncompleteState b = (b.left ^ b.right) == 0xf\n\n\/\/ both banks are \"carnage-free\"\nvalidState : BankState -> Bit\nvalidState bs = completeState bs && validBank bs.left\n                && validBank bs.right && completeState bs\n\nvalidBank : OneBank -> Bit\nvalidBank b = farmerHere b || (~(foxWithChicken b) && ~(chickenWithCorn b))\n\nfarmerHere : OneBank -> Bit\nfarmerHere b = (b && farmer) > 0\n\nchickenWithCorn : OneBank -> Bit\nchickenWithCorn b = (b && (corn || chicken)) == (corn || chicken)\n\nfoxWithChicken : OneBank -> Bit\nfoxWithChicken b = (b && (fox || chicken)) == (fox || chicken)\n\nall : {n} (fin n) => [n] -> Bit\nall xs = xs == ~zero\n\n\/\/ \"population count\" - how many bits are on\npopCount : {a} (fin a, a >= 1) => [a] -> [width a]\npopCount bs = ic ! 0 where\n    ic = [0] # [ if elt then prev + 1 else prev | elt <- bs | prev <- ic]\n\ntype StringRep = [7][8]\ntype DirRep = [5][8]\nfarmerString  = \"farmer \"\nchickenString = \"chicken\"\ncornString    = \"corn   \"\nfoxString     = \"fox    \"\nnoString      = \"       \"\n\nppArray = [farmerString, chickenString, cornString, foxString]\n\nppBits : [4] -> [4]StringRep\nppBits s =  [ if b then ppArray!i else noString\n            | b <- s\n            | i <- [0 ...]:[_][4] ]\n\n\/\/ takes a sequence of states and derives what moved, and in which direction for each transition\nextractMoves : {a} [a+1]BankState -> [a](DirRep, [4]StringRep)\nextractMoves bankStates = [ getMove b b' | b <- bankStates | b' <- drop`{1} bankStates ] where\n    getMove start end = ( dirString, thingsString thingsMoved ) where\n        dirString = if farmerHere start.left then \" --> \" else \" <-- \"\n        thingsMoved = if farmerHere start.left\n                      then end.right - start.right\n                      else end.left - start.left\n        thingsString bits = ppBits bits\n\n\/\/ fcc> :sat solutionInNmoves : [6]BankState -> Bit\n\/\/ solutionInNmoves : [6]BankState -> Bit [{left = 12, right = 3},\n\/\/                                      {left = 13, right = 2}, {left = 4, right = 11},\n\/\/                                      {left = 7, right = 8}, {left = 2, right = 13},\n\/\/                                      {left = 3, right = 12}] = True\n\n\/\/ pretty printing: extractMoves ([startState] # [{left = 12, right = 3},{left = 13, right = 2}, {left = 4, right = 11}, {left =     7, right = 8}, {left = 2, right = 13}, {left = 3, right = 12}] # [doneState])\n\/\/ [(\" --> \", [\"       \", \"       \", \"chicken\", \"farmer \"]), \/\/ the farmer takes the chicken right\n\/\/  (\" <-- \", [\"       \", \"       \", \"       \", \"farmer \"]), \/\/ farmer goes back alone\n\/\/  (\" --> \", [\"fox    \", \"       \", \"       \", \"farmer \"]), \/\/ farmer takes the fox across\n\/\/  (\" <-- \", [\"       \", \"       \", \"chicken\", \"farmer \"]), \/\/ brings the chicken back\n\/\/  (\" --> \", [\"       \", \"corn   \", \"       \", \"farmer \"]), \/\/ takes the corn over\n\/\/  (\" <-- \", [\"       \", \"       \", \"       \", \"farmer \"]), \/\/ goes back alone\n\/\/  (\" --> \", [\"       \", \"       \", \"chicken\", \"farmer \"])] \/\/ brings the chicken over, all done\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/funstuff\/Coins.cry","filetype":"cry","content":"\/\/ The puzzle goes like this:\n\/\/ You've got 30 coins that add up to $1.09 - what are they?\ncoinPuzzle : [10] -> [10] -> [10] -> [10] -> Bit\ncoinPuzzle a b c d = (coinCount a b c d 30) \/\\ (coinSum a b c d 109)\n\ncoinSum : [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinSum   a b c d s = (a + 5 * b + 10 * c + 25 * d) == s\n\ncoinCount : [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinCount a b c d s = (((a + b + c + d) == s) \/\\                        (a <= s \/\\ b <= s \/\\ c <= s \/\\ d <= s)) \/\/ run it like this:\n\/\/ :set satNum = all\n\/\/ :sat coinPuzzle\n\/\/ coinPuzzle 19 7 3 1 = True\n\/\/ coinPuzzle 24 1 3 2 = True\n\/\/ coinPuzzle 14 13 3 0 = True\n\/\/ coinPuzzle 19 4 7 0 = True\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/funstuff\/marble.cry","filetype":"cry","content":"\/\/ The classic \"marble jumping\" puzzle\n\/\/ see: http:\/\/en.wikipedia.org\/wiki\/Peg_solitaire\n\/\/ this is the \"European\" variation\n\ntype Board = [7][7]Bit\n\nall : {n} (fin n) => [n] -> Bit\nall xs = xs == ~zero\n\npopCount : {a} (fin a, a >= 1) => [a] -> [width a]\npopCount bs = ic ! 0 where\n    ic = [0] # [ if elt then prev + 1 else prev | elt <- bs | prev <- ic]\n\nposns : Board\nposns = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nstart : Board\nstart = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,False,True,True,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nfirst : Board\nfirst = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,False,False,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nsecond : Board\nsecond = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,False,True],\n         [True,True,True,True,False,True,True],\n         [False,True,True,True,False,True,False],\n         [False,False,True,True,True,False,False]]\n\ngoal : Board\ngoal = [[False,False,False,False,False,False,False],\n        [False,False,False,True,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False]]\n\nvalidBoard : Board -> Bit\nvalidBoard b = join (b && ~posns) == zero\n\nvalidRowJump : Board -> Board -> Bit\nvalidRowJump a a' = validBoard a\n                 \/\\ validBoard a'\n                 \/\\ validRowMove (differentRow a a')\n\ndifferentRow : Board -> Board -> ([7], [7])\ndifferentRow a a' = rows ! 0\n    where rows = [(0b0000000,0b0000000)]\n               # [ if row != row' then (row,row') else old\n                 | row <- a\n                 | row' <- a'\n                 | old <- rows ]\n\nvalidRowMove : ([7], [7]) -> Bit\nvalidRowMove (r, r') = (xors == 0b0000111 \\\/\n                        xors == 0b0001110 \\\/\n                        xors == 0b0011100 \\\/\n                        xors == 0b0111000 \\\/\n                        xors == 0b1110000)\n                      \/\\ (\n                        rxors == 0b0000011 \\\/\n                        rxors == 0b0000110 \\\/\n                        rxors == 0b0001100 \\\/\n                        rxors == 0b0011000 \\\/\n                        rxors == 0b0110000 \\\/\n                        rxors == 0b1100000)\n    where xors = r ^ r'\n          rxors = r && rxors\n\nvalidColJump : Board -> Board -> Bit\nvalidColJump a a' = validRowJump (transpose a) (transpose a')\n\nvalidMove : Board -> Board -> Bit\nvalidMove a a' = validRowJump a a' \\\/ validColJump a a'\n\nvalidMoveSequence : {n} (fin n, n >= 1) => [n] Board -> Bit\nvalidMoveSequence moves = all [validMove a b | a <- moves | b <- drop`{1} moves]\n\nsolutionInNmoves : {n} (fin n) => [n] Board -> Bit\nproperty solutionInNmoves ms = validMoveSequence ([start] # ms # [second])\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/SuiteB_FFI\/SuiteB_FFI.cry","filetype":"cry","content":"module SuiteB_FFI where\n\nimport SuiteB as SB\n\n\/***** AES ******\/\n\n\/**\n * Key schedule parameter setting for AES-128\n *\/\ntype AES128 = SB::AES128\n\n\/**\n * Key schedule parameter setting for AES-192\n *\/\ntype AES192 = SB::AES192\n\n\/**\n * Key schedule parameter setting for AES-256\n *\/\ntype AES256 = SB::AES256\n\n\/**\n * Element of an AES key schedule for use in a particular round\n *\/\ntype AESRoundKey = SB::AESRoundKey\n\n\/**\n * Expanded encryption key schedule for AES\n *\/\ntype AESEncryptKeySchedule k = SB::AESEncryptKeySchedule k\n\n\/**\n * Expanded decryption key schedule for AES\n *\/\ntype AESDecryptKeySchedule k = SB::AESDecryptKeySchedule k\n\n\/**\n * Encryption key expansion for AES-128.\n *   See FIPS 197, section 5.2.\n *\/\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt128 (split key)\n    else SB::aes128EncryptSchedule\n\n\/**\n * Decryption key expansion for AES-128, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt128 (split key)\n    else SB::aes128DecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-128.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt128 (split key)\n    else SB::aes128Schedules\n\n\/**\n * Encryption key expansion for AES-192.\n *   See FIPS 197, section 5.2.\n *\/\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt192 (split key)\n    else SB::aes192EncryptSchedule\n\n\/**\n * Decryption key expansion for AES-192, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt192 (split key)\n    else SB::aes192DecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-192.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt192 (split key)\n    else SB::aes192Schedules\n\n\n\/**\n * Encryption key expansion for AES-256.\n *   See FIPS 197, section 5.2\n *\/\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt256 (split key)\n    else SB::aes256EncryptSchedule\n\n\/**\n * Decryption key expansion for AES-256, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt256 (split key)\n    else SB::aes256DecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-256.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt256 (split key)\n    else SB::aes256Schedules\n\n\/**\n * AES block encryption algorithm.\n *   See FIPS 197, section 5.1.\n *\/\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock =\n  if aesniSupported\n    then \\schedule plaintext -> join (aesniEncryptBlock schedule (split plaintext))\n    else SB::aesEncryptBlock\n\n\/**\n * AES block decryption algorithm, via the \"equivalent inverse cypher\".\n *   See FIPS 197, section 5.3.5.\n *\/\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock =\n  if aesniSupported\n    then \\schedule ciphertext -> join (aesniDecryptBlock schedule (split ciphertext))\n    else SB::aesDecryptBlock\n\nprivate\n  foreign checkAESNISupported : () -> Bit\n  foreign aesniExpandEncrypt128 : [16][8] -> AESEncryptKeySchedule AES128\n  foreign aesniExpandDecrypt128 : [16][8] -> AESDecryptKeySchedule AES128\n  foreign aesniExpandEncryptDecrypt128 : [16][8]\n    -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\n  foreign aesniExpandEncrypt192 : [24][8] -> AESEncryptKeySchedule AES192\n  foreign aesniExpandDecrypt192 : [24][8] -> AESDecryptKeySchedule AES192\n  foreign aesniExpandEncryptDecrypt192 : [24][8]\n    -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\n  foreign aesniExpandEncrypt256 : [32][8] -> AESEncryptKeySchedule AES256\n  foreign aesniExpandDecrypt256 : [32][8] -> AESDecryptKeySchedule AES256\n  foreign aesniExpandEncryptDecrypt256 : [32][8]\n    -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\n  foreign aesniEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [16][8] -> [16][8]\n  foreign aesniDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [16][8] -> [16][8]\n\n  aesniSupported = checkAESNISupported ()\n\n\n\/***** SHA2 *****\/\n\n\/**\n * The SHA-224 secure hash algorithm.  See FIPS 180-4, section 6.3.\n *\/\nsha224 = SB::sha224\n\n\/**\n * The SHA-256 secure hash algorithm.  See FIPS 180-4, section 6.2.2.\n *\/\nsha256 = SB::sha256\n\n\/**\n * The SHA-384 secure hash algorithm.  See FIPS 180-4, section 6.5.\n *\/\nsha384 = SB::sha384\n\n\/**\n * The SHA-512 secure hash algorithm.  See FIPS 180-4, section 6.4.\n *\/\nsha512 = SB::sha512\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/contrib\/mkrand.cry","filetype":"cry","content":"module MKRAND where\n\ntype Seg   = [0x80]\ntype Field = [0x80]Seg\n\n\/* Canonical seed - a segment with a single True bit in the center *\/\nseedUnit:Seg\nseedUnit = (0 :[63]) # (1:[1]) # (0:[64])\n\n\n\/*\n *  Field - Unfold an application of Rule 30 to a seed\n *\/\nfield: Seg -> [inf]Seg\nfield s = new\n  where\n    new = [s] # [ rule30 row | row <- new]\n    rule30 r = [ a ^ (b || c) | a <- r >>> 1\n                              | b <- r\n                              | c <- r <<< 1\n               ]\n\n\n\/* SHA30 - Use the input segment as the seed, generate two square fields,\n * keep the center column of the second.\n *\/\nsha30: Seg -> Seg\nsha30 s = take`{0x80} (drop`{0x80} [ r @ ((((length r) \/ 2)-1):[8]) | r <- field s])\n\n\n\/*\n * RAND - Seed XOR (SHA30 Seed)\n *\/\nrands : Seg -> [inf]Seg\nrands s = rest\n  where\n     rand p = p ^ (sha30 p)\n     rest = [rand s] # [rand x | x <- rest]\n\n\n\/* Break segments into bytes *\/\nrandBytes : Seg -> [inf][8]\nrandBytes s = groupBy`{8} (join (rands s))\n\n\n\/* XOR a byte string into a random byte string, using the given seed *\/\nrandXOR : {n} Seg ->  String n -> String n\nrandXOR seed src = [s ^ r | s <- src\n                          | r <- randBytes seed\n                   ]\n\n\/* OTP example *\/\n\nproperty otp_encdec =\n     randXOR seedUnit \"Deus Ex Machina\" == c\n  \/\\ randXOR seedUnit c == \"Deus Ex Machina\"\n  where c = [ 0x28, 0x2b, 0x2c, 0xfa\n            , 0x92, 0xca, 0xb3, 0xcb\n            , 0xed, 0x50, 0xc2, 0x1b\n            , 0x11, 0x0e, 0x70]\n\notp_involutive : {len} (fin len) => String len -> Bit\notp_involutive msg = randXOR seedUnit (randXOR seedUnit msg) == msg\n\nproperty otp_involutive_32 msg = otp_involutive (msg : String 32)","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/contrib\/EvenMansour.cry","filetype":"cry","content":"\/*\n  Author : Sean Weaver <saweave@tycho.ncsc.mil>\n  This is a rough Cryptol specification of Even-Mansour:\n\n  Even, S., Mansour, Y.: A Construction of a Cipher from a Single\n  Pseudorandom Permutation. J. Cryptology 10 (3) (1997) 151\u2013162\n*\/\n\n\/** Pick some permutation F (here we select one at random) *\/\nF = (generate_random_permutation 1942611697)\n\nproperty is_a_permutation a = (unique a) \/\\ (leq a (length(a)-1))\n\/\/ Main> is_a_permutation (F:[10][4])\n\/\/ True\n\n\/** Calculate F inverse *\/\nF' = inverse_permutation F\n\nproperty is_inverse_permutation x a a' = ((x@@a)@@a') == x\n\/\/ Main> is_inverse_permutation ([0..9]:[_][4]) (F:[10]_) (F':[10]_)\n\/\/ True\n\n\/**\n * The encryption (or cryptogram) E_K(M) of a message M in {0,1}^n by\n * the key K = <K_1, K_2>, is performed by E\n *\/\nE : {n} (fin n, n >= 1, width n >= width(n-1)) => ([n], [n]) -> [n] -> [n]\nE (K1, K2) M =  (M^K1)@@F ^ K2\n\n\/**\n * The decryption of a cryptogram C in {0,1}^n, is performed by D\n *\/\nD : {n} (fin n, n >= 1, width n >= width(n-1)) => ([n], [n]) -> [n] -> [n]\nD (K1, K2) C =  (C^K2)@@F' ^ K1\n\n\/**\n * It is easy to verify that for every M in {0,1}^n and K in {0,1}^2n,\n * the following identity holds D_K(E_K(M)) = M, i.e. D_K decrypts\n * messages that were encrypted using E_K.\n *\/\nproperty E_and_D_are_inverses K M = (D K (E K M)) == M\n\n\n\/******* Utilities *******\/\n\nswap : {a, b} (fin a, a >= 1) => [a]b -> [width(a-1)] -> [width(a-1)] -> [a]b\nswap xs a b = [ if(i == a) then xs@b\n                 |(i == b) then xs@a\n                else xs@i\n              | i <- [0 .. a-1] ]\n\ngenerate_random_permutation : {a} (fin a, a >= 1, width a >= width(a-1)) => [256] -> [a][width(a-1)]\ngenerate_random_permutation seed = pss!0\n  where\n    indices = [ take `{width(a-1)} (b % `a) | b <- (random seed) : [a][width a] ]\n    pss = [ [0 .. a-1] ] # [ swap ps a b | ps <- pss | a <- [0 .. a-1] | b <- indices ]\n\nunique : {a, b} (fin a, fin b, a>=1) => [a][b] -> Bit\nunique xs = [ exist x (i+1) | x <- xs | i <- [0...] ] == 0\n  where exist : [b] -> [width a] -> Bit\n        exist x i = if(i>=`a) then False\n                    else if(x==(xs@i)) then True\n                    else exist x (i+1)\n\nleq xs a = [ x <= a | x <- xs ] == ~0\n\nindex_of : {a, b} (fin a, a>=1, Cmp b) => [a]b -> b -> [width(a-1)]\nindex_of xs a = (ret!0).1\n  where ret = [(False, 0)] # [ if(xs@i == a) then (True, i) else r\n                             | i <- [0 .. a-1 ]\n                             | r <- ret ]\n\ninverse_permutation : {a} (fin a, a >= 1) => [a][width(a-1)] -> [a][width(a-1)]\ninverse_permutation perm = [ index_of perm i | i <- [0 .. a-1 ] ]","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/contrib\/A51.cry","filetype":"cry","content":"A51_stream : [19] -> [22] -> [23] -> [inf]\nA51_stream R1 R2 R3 = R1s ^ R2s ^ R3s\n  where\n    (R1s, R1f) = lfsrki <| x^^19 + x^^18 + x^^17 + x^^14 + 1 |>  R1c R1\n    (R2s, R2f) = lfsrki <| x^^22 + x^^21 + 1 |>                  R2c R2\n    (R3s, R3f) = lfsrki <| x^^23 + x^^22 + x^^21 + x^^8 + 1 |>   R3c R3\n    majvs = [ majv (r1@8) (r2@10) (r3@10) | r1 <- R1f | r2 <- R2f | r3 <- R3f ]\n    R1c = [ r1@8 == m | r1 <- R1f | m <- majvs ]\n    R2c = [ r2@10 == m | r2 <- R2f | m <- majvs ]\n    R3c = [ r3@10 == m | r3 <- R3f | m <- majvs ]\n\ntype N = 128\nA51 : ([19], [22], [23]) -> [N]Bit\nA51(reg1, reg2, reg3) = keystream\n  where\n    keystream = take`{N} (A51_stream reg1 reg2 reg3)\n\nlfsrki_step : {d} (fin d, d >=1) => [d+1] -> Bit -> [d] -> [d]\nlfsrki_step poly cond fill = fill'\n where\n   feedback_bit = if(poly@0) then prefix (^) (reverse([False]#fill) && poly)\n                             else error \"polynomial does not have high-bit set.\"\n   fill' = if cond then [feedback_bit]#(take fill) else fill\n\nlfsrki : {d} (fin d, d >=1) => [d+1] -> [inf] -> [d] -> ([inf], [inf][d])\nlfsrki poly conds init = (stream, fills)\n  where\n    lfsrki' = lfsrki_step poly\n    fills = [init] # [ lfsrki' c f | c <- conds | f <- fills]\n    stream = [ f!0 | f <- fills ]\n\n\nprefix f xs = ys!0\n  where ys = [xs@0] # [ f y x | y <- ys | x <- tail xs ]\n\nmajv a b c = (a && b) || (a && c) || (b && c)\n\n\/***********************************************************************\/\n\niv1 = 0b1010111011101011101\niv2 = 0b1010111011101010101110\niv3 = 0b10100000111100110011011\n\ntest_keystream = 0b00100100111010001110101110101100010100110111110101000101110000011101000111110101010000010011001111110101110001011010100000010001\n\nproperty A51_correct = (A51(iv1, iv2, iv3)) == test_keystream\nproperty A51_search x y z = A51(x,y,z) == test_keystream\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/contrib\/RC4.cry","filetype":"cry","content":"swap : [256][8] -> [8] -> [8] -> [256][8]\nswap s i j = [ s @ (if n == i then j else\n                    if n == j then i else\n                    n)\n             | n <- [0..255]\n             ]\n\nksa_step : [inf][8] -> [8] -> [8] -> [256][8] -> ([8],[256][8])\nksa_step key i j s = (j', swap s i j')\n where j' = j + s@i + key@i\n\nksa : [inf][8] -> [256][8]\nksa key = (go ! 0).1 where\n go : [257]([8],[256][8])\n go = [(0,[0..255])] # [ ksa_step key i j s\n                       | i <- [0..255]\n                       | (j,s) <- go\n                       ]\n\nks_step : [8] -> [8] -> [256][8] -> ([8],[256][8],[8])\nks_step i j s = (j',s',s@(s@i + s@j'))\n where j' = j + s@i\n       s' = swap s i j'\n\nks key = [ k | (_,_,k) <- drop`{1} go ] where\n go = [(0,ksa key',0)] # [ ks_step i j s\n                         | i <- loop\n                         | (j,s,k) <- go\n                         ]\n key' = key # key'\n loop = [1..255] # [0] # loop\n\n\/\/\/\/\/\/\/\n\/\/ \"Test vectors\" from wikipedia\n\nproperty test1 = take (ks \"Key\") == [0xEB,0x9F,0x77,0x81,0xB7,0x34,0xCA,0x72,0xA7,0x19]\nproperty test2 = take (ks \"Wiki\") == [0x60,0x44,0xDB,0x6D,0x41,0xB7]\nproperty test3 = take (ks \"Secret\") == [0x04,0xD4,0x6B,0x05,0x3C,0xA8,0x7B,0x59]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/contrib\/MISTY1.cry","filetype":"cry","content":"\/*\n * Cryptol spec of the MISTY1 cipher. Based on RFC 2994, available at\n * https:\/\/tools.ietf.org\/rfc\/rfc2994.txt\n *\n * Author: Adrian Herrera\n *\/\n\nmodule MISTY1 where\n\n\/\/\n\/\/ Key scheduling part\n\/\/\n\nkeySchedule : [16][8] -> [32][16]\nkeySchedule K = EK_1 # EK_2 # EK_3 # EK_4\n    where EK_1 = split (join K)\n          EK_2 = [ FI ek_1 ek_1_shifted\n                 | ek_1         <- EK_1\n                 | ek_1_shifted <- EK_1 <<< 1\n                 ]\n          EK_3 = [extend (drop`{7} ek_2) | ek_2 <- EK_2]\n          EK_4 = [extend (take`{7} ek_2) | ek_2 <- EK_2]\n\n\/\/\n\/\/ Data randomizing part\n\/\/\n\nFO : [32] -> [8] -> [32][16] -> [32]\nFO FO_IN k EK = (FO_OUT ! 0).1 # (FO_OUT ! 0).0\n    where FO_OUT = [(take FO_IN, drop FO_IN)] # [ f t0 t1\n                                                | f        <- funcs\n                                                | (t0, t1) <- FO_OUT\n                                                ]\n          \/\/ t0, t1 as 16-bit integers\n          funcs : [_]([16] -> [16] -> ([16], [16]))\n          funcs = [\\t0 t1 -> (t0 ^ (EK @ k), t1),\n                   \\t0 t1 -> (FI t0 (EK @ ((k + 5) % 8 + 8)), t1),\n                   \\t0 t1 -> (t0 ^ t1, t1),\n                   \\t0 t1 -> (t0, t1 ^ (EK @ ((k + 2) % 8))),\n                   \\t0 t1 -> (t0, FI t1 (EK @ ((k + 1) % 8 + 8))),\n                   \\t0 t1 -> (t0, t1 ^ t0),\n                   \\t0 t1 -> (t0 ^ EK @ ((k + 7) % 8), t1),\n                   \\t0 t1 -> (FI t0 (EK @ ((k + 3) % 8 + 8)), t1),\n                   \\t0 t1 -> (t0 ^ t1, t1),\n                   \\t0 t1 -> (t0, t1 ^ EK @ ((k + 4) % 8))\n                  ]\n\nFI : [16] -> [16] -> [16]\nFI FI_IN FI_KEY = (FI_OUT ! 0).1 # (FI_OUT ! 0).0\n    where FI_OUT = [(take FI_IN, drop FI_IN)] # [ f d9 d7\n                                                | f        <- funcs\n                                                | (d9, d7) <- FI_OUT\n                                                ]\n          \/\/ d9 as 9-bit integer\n          \/\/ d7 as 7-bit integer\n          funcs : [_]([9] -> [7] -> ([9], [7]))\n          funcs = [\\d9 d7 -> ((S9 @ d9) ^ (extend d7), d7),\n                   \\d9 d7 -> (d9, drop (extend (S7 @ d7) ^ d9)),\n                   \\d9 d7 -> (d9, d7 ^ drop (FI_KEY >> 9)),\n                   \\d9 d7 -> (d9 ^ drop FI_KEY, d7),\n                   \\d9 d7 -> ((S9 @ d9) ^ (extend d7), d7)\n                  ]\n\nS7 : [_][7]\nS7 = [27,  50,  51,  90,  59,  16,  23,  84,  91,  26, 114, 115, 107,\n      44, 102,  73,  31,  36,  19, 108,  55,  46,  63,  74,  93,  15,\n      64,  86,  37,  81,  28,   4,  11,  70,  32,  13, 123,  53,  68,\n      66,  43,  30,  65,  20,  75, 121,  21, 111,  14,  85,   9,  54,\n     116,  12, 103,  83,  40,  10, 126,  56,   2,   7,  96,  41,  25,\n      18, 101,  47,  48,  57,   8, 104,  95, 120,  42,  76, 100,  69,\n     117,  61,  89,  72,   3,  87, 124,  79,  98,  60,  29,  33,  94,\n      39, 106, 112,  77,  58,   1, 109, 110,  99,  24, 119,  35,   5,\n      38, 118,   0,  49,  45, 122, 127,  97,  80,  34,  17,   6,  71,\n      22,  82,  78, 113,  62, 105,  67,  52,  92,  88, 125]\n\nS9 : [_][9]\nS9 = [451, 203, 339, 415, 483, 233, 251,  53, 385, 185, 279, 491, 307,\n        9,  45, 211, 199, 330,  55, 126, 235, 356, 403, 472, 163, 286,\n       85,  44,  29, 418, 355, 280, 331, 338, 466,  15,  43,  48, 314,\n      229, 273, 312, 398,  99, 227, 200, 500,  27,   1, 157, 248, 416,\n      365, 499,  28, 326, 125, 209, 130, 490, 387, 301, 244, 414, 467,\n      221, 482, 296, 480, 236,  89, 145,  17, 303,  38, 220, 176, 396,\n      271, 503, 231, 364, 182, 249, 216, 337, 257, 332, 259, 184, 340,\n      299, 430,  23, 113,  12,  71,  88, 127, 420, 308, 297, 132, 349,\n      413, 434, 419,  72, 124,  81, 458,  35, 317, 423, 357,  59,  66,\n      218, 402, 206, 193, 107, 159, 497, 300, 388, 250, 406, 481, 361,\n      381,  49, 384, 266, 148, 474, 390, 318, 284,  96, 373, 463, 103,\n      281, 101, 104, 153, 336,   8,   7, 380, 183,  36,  25, 222, 295,\n      219, 228, 425,  82, 265, 144, 412, 449,  40, 435, 309, 362, 374,\n      223, 485, 392, 197, 366, 478, 433, 195, 479,  54, 238, 494, 240,\n      147,  73, 154, 438, 105, 129, 293,  11,  94, 180, 329, 455, 372,\n       62, 315, 439, 142, 454, 174,  16, 149, 495,  78, 242, 509, 133,\n      253, 246, 160, 367, 131, 138, 342, 155, 316, 263, 359, 152, 464,\n      489,   3, 510, 189, 290, 137, 210, 399,  18,  51, 106, 322, 237,\n      368, 283, 226, 335, 344, 305, 327,  93, 275, 461, 121, 353, 421,\n      377, 158, 436, 204,  34, 306,  26, 232,   4, 391, 493, 407,  57,\n      447, 471,  39, 395, 198, 156, 208, 334, 108,  52, 498, 110, 202,\n       37, 186, 401, 254,  19, 262,  47, 429, 370, 475, 192, 267, 470,\n      245, 492, 269, 118, 276, 427, 117, 268, 484, 345,  84, 287,  75,\n      196, 446, 247,  41, 164,  14, 496, 119,  77, 378, 134, 139, 179,\n      369, 191, 270, 260, 151, 347, 352, 360, 215, 187, 102, 462, 252,\n      146, 453, 111,  22,  74, 161, 313, 175, 241, 400,  10, 426, 323,\n      379,  86, 397, 358, 212, 507, 333, 404, 410, 135, 504, 291, 167,\n      440, 321,  60, 505, 320,  42, 341, 282, 417, 408, 213, 294, 431,\n       97, 302, 343, 476, 114, 394, 170, 150, 277, 239,  69, 123, 141,\n      325,  83,  95, 376, 178,  46,  32, 469,  63, 457, 487, 428,  68,\n       56,  20, 177, 363, 171, 181,  90, 386, 456, 468,  24, 375, 100,\n      207, 109, 256, 409, 304, 346,   5, 288, 443, 445, 224,  79, 214,\n      319, 452, 298,  21,   6, 255, 411, 166,  67, 136,  80, 351, 488,\n      289, 115, 382, 188, 194, 201, 371, 393, 501, 116, 460, 486, 424,\n      405,  31,  65,  13, 442,  50,  61, 465, 128, 168,  87, 441, 354,\n      328, 217, 261,  98, 122,  33, 511, 274, 264, 448, 169, 285, 432,\n      422, 205, 243,  92, 258,  91, 473, 324, 502, 173, 165,  58, 459,\n      310, 383,  70, 225,  30, 477, 230, 311, 506, 389, 140, 143,  64,\n      437, 190, 120,   0, 172, 272, 350, 292,   2, 444, 162, 234, 112,\n      508, 278, 348,  76, 450]\n\nFL : [32] -> [8] -> [32][16] -> [32]\nFL FL_IN k EK =\n    if isEven k then\n        d0_even # d1_even\n        where d1_even = d1 ^ (d0 && (EK @ (k \/ 2)))\n              d0_even = d0 ^ (d1_even || (EK @ ((k \/ 2 + 6) % 8 + 8)))\n    else\n        d0_odd # d1_odd\n        where d1_odd = d1 ^ (d0 && (EK @ (((k - 1) \/ 2 + 2) % 8 + 8)))\n              d0_odd = d0 ^ (d1_odd || (EK @ (((k - 1) \/ 2 + 4) % 8)))\n    where \/\/ d0 as 16-bit integer\n        d0 : [16]\n        d0 = take FL_IN\n        \/\/ d1 as 16-bit integer\n        d1 : [16]\n        d1 = drop FL_IN\n\nFLINV : [32] -> [8] -> [32][16] -> [32]\nFLINV FL_IN k EK =\n    if isEven k then\n        d0_even # d1_even\n        where d0_even = d0 ^ (d1 || (EK @ ((k \/ 2 + 6) % 8 + 8)))\n              d1_even = d1 ^ (d0_even && (EK @ (k \/ 2)))\n    else\n        d0_odd # d1_odd\n        where d0_odd = d0 ^ (d1 || (EK @ (((k - 1) \/ 2 + 4) % 8)))\n              d1_odd = d1 ^ (d0_odd && (EK @ (((k - 1) \/ 2 + 2) % 8 + 8)))\n    where \/\/ d0 as 16-bit integer\n        d0 : [16]\n        d0 = take FL_IN\n        \/\/ d1 as 16-bit integer\n        d1 : [16]\n        d1 = drop FL_IN\n\n\/\/\n\/\/ Encrypt\/decrypt\n\/\/\n\nmisty1Encrypt : [64] -> [32][16] -> [64]\nmisty1Encrypt P EK = (C ! 0).1 # (C ! 0).0\n    where\n        \/\/ 64-bit plaintext P is divided into the leftmost 32-bit D0 and the\n        \/\/ rightmost 32-bit D1\n        C = [(take P, drop P)] # [ f D0 D1\n                                 | f        <- funcs\n                                 | (D0, D1) <- C\n                                 ]\n        funcs : [_]([32] -> [32] -> ([32], [32]))\n        funcs = [                 \\D0 D1 -> (FL D0 0 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 1 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 0 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 1 EK), D1),\n                                  \\D0 D1 -> (FL D0 2 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 3 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 2 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 3 EK), D1),\n                                  \\D0 D1 -> (FL D0 4 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 5 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 4 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 5 EK), D1),\n                 \/\/ 6 round\n                 \\D0 D1 -> (FL D0 6 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 7 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 6 EK)),\n                 \/\/ 7 round\n                 \\D0 D1 -> (D0 ^ (FO D1 7 EK), D1),\n                 \/\/ final\n                 \\D0 D1 -> (FL D0 8 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 9 EK)\n                ]\n\nmisty1Decrypt : [64] -> [32][16] -> [64]\nmisty1Decrypt C EK = (P ! 0).0 # (P ! 0).1\n    where P = [(drop C, take C)] # [ f D0 D1\n                                   | f        <- funcs\n                                   | (D0, D1) <- P\n                                   ]\n          funcs : [_]([32] -> [32] -> ([32], [32]))\n          funcs = [\\D0 D1 -> (FLINV D0 8 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 9 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 7 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 6 EK)),\n                   \\D0 D1 -> (FLINV D0 6 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 7 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 5 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 4 EK)),\n                   \\D0 D1 -> (FLINV D0 4 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 5 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 3 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 2 EK)),\n                   \\D0 D1 -> (FLINV D0 2 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 3 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 1 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 0 EK)),\n                   \\D0 D1 -> (FLINV D0 0 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 1 EK)\n                  ]\n\n\/\/\n\/\/ Helper functions\n\/\/\n\nextend : {total, n} (fin total, fin n, total >= n) => [n] -> [total]\nextend n = zero # n\n\nisEven : {a} (fin a) => [a] -> Bool\nisEven n = ~(n ! 0)\n\n\/\/\n\/\/ Examples\n\/\/\n\nproperty testMisty1Encrypt = [ misty1Encrypt block EK\n                             | block <- plaintext\n                             ] == ciphertext\n    where EK         = keySchedule key\n          key        = [0x00, 0x11 .. 0xff]\n          plaintext  = [0x0123456789abcdef, 0xfedcba9876543210]\n          ciphertext = [0x8b1da5f56ab3d07c, 0x04b68240b13be95d]\n\nproperty misty1Correct pt key = misty1Decrypt (misty1Encrypt pt EK) EK == pt\n    where EK = keySchedule key\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/MiniLock\/Keys.cry","filetype":"cry","content":"module Keys where\n\nimport CfrgCurves\nimport Blake2s\nimport SCrypt\nimport Base58\n\ntype MinilockID = [46][8]\n\n\/\/ Given a public key compute the ASCII ID\nencodeID : Public25519 -> MinilockID\nencodeID pub = base58enc (join (pub # [h]))\n  where\n  h = blake2s `{nn=1} pub : [8]\n\ndecodeID : MinilockID -> (Bit,Public25519)\ndecodeID ident = (hComp == hRecv, key)\n where\n  bs    = split (base58dec ident)  : [33][8]\n  hRecv = bs ! 0\n  hComp = blake2s `{nn=1} key      : [8]\n  key   = take bs                  : [32][8]\n\n\/\/ Accept a possibly-short key (base58 is value dependent encoding)\n\/\/ and expand it to the full, fixed, size.\nmkFullLengthID : {n} (46 >= n, n>= 1) => [n][8] -> MinilockID\nmkFullLengthID n = drop (['1' | _ <- [0..45] : [_][8]]  # n)\n\nmkID : {passBytes, saltBytes}\n       ( fin passBytes, fin saltBytes\n       , 64 >= width passBytes\n       , 32 >= width (4*saltBytes)\n       )\n    => [passBytes][8] -> [saltBytes][8] -> (MinilockID,Private25519)\nmkID pw email = (encodeID pub,priv)\n  where\n  \/\/ XXX wait for cryptol 2.3: priv = SCrypt `{N=2^^17,r=8} (split (blake2s `{nn=32} pw)) email\n  priv : Private25519\n  priv = SCrypt `{N=2^^1,r=8} (split (blake2s `{nn=32} pw)) email\n  \/\/ XXX we can't interpret N=2^^17 so this N value is a place holder...\n  pub  = Curve25519 priv basePoint25519\n\n\/\/ XXX we can not run these tests in the cryptol interpreter, SCrypt is too expensive.\ntestPass = \"some bears eat all the honey in the jar\"\ntestEmail = \"example@example.com\"\n\ntestID : MinilockID\ntestID = mkFullLengthID \"28ZvW9rqRqvqpFTtHnusUntRqrxb4qqZAaNAd3QsqjSsXq\"\n\ntestID_computed = \"28ZvW9rqRqvqpFTtHnusUntRqrxb4qqZAaNAd3QsqjSsXq\"  \/\/ Computed on deathstar\ntestPriv_computed =\n  [0x12, 0x86, 0xe0, 0x18, 0xc6, 0x68, 0x34, 0x96, 0x09, 0x2e, 0x53,\n   0x32, 0x37, 0x76, 0x80, 0x3c, 0x30, 0xb4, 0x75, 0x2d, 0xd7, 0x70,\n   0xea, 0xa9, 0x6f, 0x0d, 0xda, 0x25, 0xc7, 0xfe, 0x28, 0x1f]\n\n\/\/ Deathstar results:\n\/\/ ([0x32, 0x38, 0x5a, 0x76, 0x57, 0x39, 0x72, 0x71, 0x52, 0x71, 0x76,\n\/\/   0x71, 0x70, 0x46, 0x54, 0x74, 0x48, 0x6e, 0x75, 0x73, 0x55, 0x6e,\n\/\/   0x74, 0x52, 0x71, 0x72, 0x78, 0x62, 0x34, 0x71, 0x71, 0x5a, 0x41,\n\/\/   0x61, 0x4e, 0x41, 0x64, 0x33, 0x51, 0x73, 0x71, 0x6a, 0x53, 0x73,\n\/\/   0x58, 0x71],\n\/\/  [0x12, 0x86, 0xe0, 0x18, 0xc6, 0x68, 0x34, 0x96, 0x09, 0x2e, 0x53,\n\/\/   0x32, 0x37, 0x76, 0x80, 0x3c, 0x30, 0xb4, 0x75, 0x2d, 0xd7, 0x70,\n\/\/   0xea, 0xa9, 0x6f, 0x0d, 0xda, 0x25, 0xc7, 0xfe, 0x28, 0x1f])\n\n\ntestPriv = [0x12, 0x86, 0xe0, 0x18, 0xc6, 0x68, 0x34, 0x96, 0x09, 0x2e, 0x53, 0x32, 0x37, 0x76, 0x80, 0x3c, 0x30, 0xb4, 0x75, 0x2d, 0xd7, 0x70,0xea, 0xa9, 0x6f, 0x0d, 0xda, 0x25, 0xc7, 0xfe, 0x28, 0x1f]\n\ntestPub = Curve25519 testPriv basePoint25519\nproperty kat_pub_id_eq = testPub == (decodeID testID).1 \/\\ encodeID testPub == testID \/\\ testID == testID_computed \/\\ testPriv == testPriv_computed\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/param_modules\/AES.cry","filetype":"cry","content":"module AES where\n\nimport AES::Algorithm as AES where\n  type Mode = m\n  encRound = AESRound\n  decRound = AESInvRound\n\nimport AES::ExpandKey where\n  type Nk = AES::Nk\n  type Nr = AES::Nr\n\nimport AES::TBox\n\nparameter\n  \/** 0: AES128, 1: AES192, 2: AES256 *\/\n  type m : #\n  type k : #\n  type constraint (k == 128 + m * 64, 2 >= m)\n\ntype EncKey = AES::KeySchedule\ntype DecKey = AES::KeySchedule\n\n\nencrypt : [k] -> [128] -> [128]\nencrypt k = encryptWithSchedule (expandKeyEnc k)\n\ndecrypt : [k] -> [128] -> [128]\ndecrypt k = decryptWithSchedule (expandKeyDec k)\n\n\nexpandKeyEnc : [k] -> EncKey\nexpandKeyEnc = expandKey\n\nencryptWithSchedule : EncKey -> [128] -> [128]\nencryptWithSchedule = AES::encrypt\n\n\n\nexpandKeyDec : [k] -> EncKey\nexpandKeyDec k = makeDecKey (expandKey k)\n\ndecryptWithSchedule : DecKey -> [128] -> [128]\ndecryptWithSchedule = AES::decrypt\n\n\nproperty test k pt = decrypt k (encrypt k pt) == pt\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/param_modules\/AES_GCM_SIV_Test.cry","filetype":"cry","content":"import Common::AES_GCM_SIV as AES_GCM_SIV_0_56 where\n  type Mode = 0\n  type AAD = 56\n\nproperty test0 =\n  AES_GCM_SIV_0_56::aes_gcm_siv\n    { key   = 0xee8e1ed9ff2540ae8f2ba9f50bc2f27c\n    , nonce = 0x752abad3e0afb5f434dc4310\n    , aad   = join \"example\"\n    , msg   = join \"Hello world\"\n    }\n  ==\n  0x5d349ead175ef6b1def6fd #\n  0x4fbcdeb7e4793f4a1d7e4faa70100af1\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_0 where\n  type Mode = 0\n  type AAD = 0\n\nproperty test1 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = []\n    }\n  ==\n  0xdc20e2d83f25705bb49e439eca56de25\n\nproperty test2 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x0100000000000000\n    }\n  ==\n  0xb5d839330ac7b786578782fff6013b81 #\n  0x5b287c22493a364c\n\nproperty test3 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x010000000000000000000000\n    }\n  ==\n  0x7323ea61d05932260047d942a4978db3 #\n  0x57391a0bc4fdec8b0d106639\n\nproperty test4 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000\n    }\n  ==\n  0x743f7c8077ab25f8624e2e948579cf77 #\n  0x303aaf90f6fe21199c6068577437a0c4\n\nproperty test5 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000\n    }\n  ==\n  0x84e07e62ba83a6585417245d7ec413a9 #\n  0xfe427d6315c09b57ce45f2e3936a9445 #\n  0x1a8e45dcd4578c667cd86847bf6155ff\n\nproperty test6 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000\n    }\n  ==\n  0x3fd24ce1f5a67b75bf2351f181a475c7 #\n  0xb800a5b4d3dcf70106b1eea82fa1d64d #\n  0xf42bf7226122fa92e17a40eeaac1201b #\n  0x5e6e311dbf395d35b0fe39c2714388f8\n\nproperty test7 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000\n    }\n  ==\n  0x2433668f1058190f6d43e360f4f35cd8 #\n  0xe475127cfca7028ea8ab5c20f7ab2af0 #\n  0x2516a2bdcbc08d521be37ff28c152bba #\n  0x36697f25b4cd169c6590d1dd39566d3f #\n  0x8a263dd317aa88d56bdf3936dba75bb8\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_8 where\n  type Mode = 0\n  type AAD = 8\n\nproperty test8 =\n AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x0200000000000000\n    }\n  ==\n  0x1e6daba35669f4273b0a1a2560969cdf #\n  0x790d99759abd1508\n\nproperty test9 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x020000000000000000000000\n    }\n  ==\n  0x296c7889fd99f41917f4462008299c51 #\n  0x02745aaa3a0c469fad9e075a\n\nproperty test10 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000\n    }\n  ==\n  0xe2b0c5da79a901c1745f700525cb335b #\n  0x8f8936ec039e4e4bb97ebd8c4457441f\n\nproperty test11 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000\n    }\n  ==\n  0x620048ef3c1e73e57e02bb8562c416a3 #\n  0x19e73e4caac8e96a1ecb2933145a1d71 #\n  0xe6af6a7f87287da059a71684ed3498e1\n\nproperty test12 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000\n    }\n  ==\n  0x50c8303ea93925d64090d07bd109dfd9 #\n  0x515a5a33431019c17d93465999a8b005 #\n  0x3201d723120a8562b838cdff25bf9d1e #\n  0x6a8cc3865f76897c2e4b245cf31c51f2\n\nproperty test13 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000 #\n              0x05000000000000000000000000000000\n    }\n  ==\n  0x2f5c64059db55ee0fb847ed513003746 #\n  0xaca4e61c711b5de2e7a77ffd02da42fe #\n  0xec601910d3467bb8b36ebbaebce5fba3 #\n  0x0d36c95f48a3e7980f0e7ac299332a80 #\n  0xcdc46ae475563de037001ef84ae21744\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_96 where\n  type Mode = 0\n  type AAD = 96\n\nproperty test14 =\n  AES_GCM_SIV_0_96::aes_gcm_siv\n    { msg = 0x02000000\n    , aad = 0x010000000000000000000000\n    , key = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0xa8fe3e8707eb1f84fb28f8cb73de8e99 #\n  0xe2f48a14\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_144 where\n  type Mode = 0\n  type AAD = 144\n\nproperty test15 =\n  AES_GCM_SIV_0_144::aes_gcm_siv\n    { msg = 0x03000000000000000000000000000000 #\n            0x04000000\n    , aad = 0x01000000000000000000000000000000 #\n            0x0200\n    , key = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0x6bb0fecf5ded9b77f902c7d5da236a43 #\n  0x91dd029724afc9805e976f451e6d87f6 #\n  0xfe106514\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_160 where\n  type Mode = 0\n  type AAD = 160\n\nproperty test16 =\n  AES_GCM_SIV_0_160::aes_gcm_siv\n    { msg =   0x03000000000000000000000000000000 #\n              0x0400\n    , aad   = 0x01000000000000000000000000000000 #\n              0x02000000\n    , key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0x44d0aaf6fb2f1f34add5e8064e83e12a #\n  0x2adabff9b2ef00fb47920cc72a0c0f13 #\n  0xb9fd\n\n\nproperty test16' =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0xe66021d5eb8e4f4066d4adb9c33560e4\n   , nonce = 0xf46e44bb3da0015c94f70887\n   }\n   == 0xa4194b79071b01a87d65f706e3949578\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_40 where\n  type Mode = 0\n  type AAD = 40\n\nproperty test17 =\n  AES_GCM_SIV_0_40::aes_gcm_siv\n   { msg = 0x7a806c\n   , aad = 0x46bb91c3c5\n   , key = 0x36864200e0eaf5284d884a0e77d31646\n   , nonce = 0xbae8e37fc83441b16034566b\n   }\n   == 0xaf60eb711bd85bc1e4d3e0a462e074ee #\n      0xa428a8\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_80 where\n  type Mode = 0\n  type AAD = 80\n\nproperty test18 =\n  AES_GCM_SIV_0_80::aes_gcm_siv\n   { msg = 0xbdc66f146545\n   , aad = 0xfc880c94a95198874296\n   , key = 0xaedb64a6c590bc84d1a5e269e4b47801\n   , nonce = 0xafc0577e34699b9e671fdd4f\n   }\n   == 0xbb93a3e34d3cd6a9c45545cfc11f03ad #\n      0x743dba20f966\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_120 where\n  type Mode = 0\n  type AAD = 120\n\nproperty test19 =\n  AES_GCM_SIV_0_120::aes_gcm_siv\n   { msg = 0x1177441f195495860f\n   , aad = 0x046787f3ea22c127aaf195d1894728\n   , key = 0xd5cc1fd161320b6920ce07787f86743b\n   , nonce = 0x275d1ab32f6d1f0434d8848c\n   }\n   == 0x4f37281f7ad12949d01d02fd0cd174c8 #\n      0x4fc5dae2f60f52fd2b\n\n\nproperty test20 =\n  AES_GCM_SIV_0_160::aes_gcm_siv\n   { msg = 0x9f572c614b4745914474e7c7\n   , aad = 0xc9882e5386fd9f92ec489c8fde2be2cf #\n           0x97e74e93\n   , key = 0xb3fed1473c528b8426a582995929a149\n   , nonce = 0x9e9ad8780c8d63d0ab4149c0\n   }\n   == 0xf54673c5ddf710c745641c8bc1dc2f87 #\n      0x1fb7561da1286e655e24b7b0\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_200 where\n  type Mode = 0\n  type AAD = 200\n\nproperty test21 =\n  AES_GCM_SIV_0_200::aes_gcm_siv\n   { msg = 0x0d8c8451178082355c9e940fea2f58\n   , aad = 0x2950a70d5a1db2316fd568378da107b5 #\n           0x2b0da55210cc1c1b0a\n   , key = 0x2d4ed87da44102952ef94b02b805249b\n   , nonce = 0xac80e6f61455bfac8308a2d4\n   }\n   == 0xc9ff545e07b88a015f05b274540aa183 #\n           0xb3449b9f39552de99dc214a1190b0b\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_240 where\n  type Mode = 0\n  type AAD = 240\n\nproperty test22 =\n  AES_GCM_SIV_0_240::aes_gcm_siv\n   { msg = 0x6b3db4da3d57aa94842b9803a96e07fb #\n           0x6de7\n   , aad = 0x1860f762ebfbd08284e421702de0de18 #\n           0xbaa9c9596291b08466f37de21c7f\n   , key = 0xbde3b2f204d1e9f8b06bc47f9745b3d1\n   , nonce = 0xae06556fb6aa7890bebc18fe\n   }\n   == 0x6298b296e24e8cc35dce0bed484b7f30 #\n           0xd5803e377094f04709f64d7b985310a4 #\n           0xdb84\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_280 where\n  type Mode = 0\n  type AAD = 280\n\nproperty test23 =\n  AES_GCM_SIV_0_280::aes_gcm_siv\n   { msg = 0xe42a3c02c25b64869e146d7b233987bd #\n           0xdfc240871d\n   , aad = 0x7576f7028ec6eb5ea7e298342a94d4b2 #\n           0x02b370ef9768ec6561c4fe6b7e7296fa #\n           0x859c21\n   , key = 0xf901cfe8a69615a93fdf7a98cad48179\n   , nonce = 0x6245709fb18853f68d833640\n   }\n   == 0x391cc328d484a4f46406181bcd62efd9 #\n      0xb3ee197d052d15506c84a9edd65e13e9 #\n      0xd24a2a6e70\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_0 where\n  type Mode = 1\n  type AAD = 0\n\nproperty test24 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x07f5f4169bbf55a8400cd47ea6fd400f\n\nproperty test25 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x0100000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc2ef328e5c71c83b843122130f7364b7 #\n      0x61e0b97427e3df28\n\nproperty test26 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x010000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x9aab2aeb3faa0a34aea8e2b18ca50da9 #\n      0xae6559e48fd10f6e5c9ca17e\n\nproperty test27 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x85a01b63025ba19b7fd3ddfc033b3e76 #\n      0xc9eac6fa700942702e90862383c6c366\n\nproperty test28 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x4a6a9db4c8c6549201b9edb53006cba8 #\n      0x21ec9cf850948a7c86c68ac7539d027f #\n      0xe819e63abcd020b006a976397632eb5d\n\nproperty test29 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n\n   == 0xc00d121893a9fa603f48ccc1ca3c57ce #\n      0x7499245ea0046db16c53c7c66fe717e3 #\n      0x9cf6c748837b61f6ee3adcee17534ed5 #\n      0x790bc96880a99ba804bd12c0e6a22cc4\n\nproperty test30 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc2d5160a1f8683834910acdafc41fbb1 #\n      0x632d4a353e8b905ec9a5499ac34f96c7 #\n      0xe1049eb080883891a4db8caaa1f99dd0 #\n      0x04d80487540735234e3744512c6f90ce #\n      0x112864c269fc0d9d88c61fa47e39aa08\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_8 where\n  type Mode = 1\n  type AAD = 8\n\nproperty test31 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x0200000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x1de22967237a813291213f267e3b452f #\n      0x02d01ae33e4ec854\n\nproperty test32 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x020000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x163d6f9cc1b346cd453a2e4cc1a4a19a #\n      0xe800941ccdc57cc8413c277f\n\nproperty test33 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc91545823cc24f17dbb0e9e807d5ec17 #\n      0xb292d28ff61189e8e49f3875ef91aff7\n\nproperty test34 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x07dad364bfc2b9da89116d7bef6daaaf #\n      0x6f255510aa654f920ac81b94e8bad365 #\n      0xaea1bad12702e1965604374aab96dbbc\n\nproperty test35 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc67a1f0f567a5198aa1fcc8e3f213143 #\n      0x36f7f51ca8b1af61feac35a86416fa47 #\n      0xfbca3b5f749cdf564527f2314f42fe25 #\n      0x03332742b228c647173616cfd44c54eb\n\nproperty test36 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000 #\n           0x05000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x67fd45e126bfb9a79930c43aad2d3696 #\n      0x7d3f0e4d217c1e551f59727870beefc9 #\n      0x8cb933a8fce9de887b1e40799988db1f #\n      0xc3f91880ed405b2dd298318858467c89 #\n      0x5bde0285037c5de81e5b570a049b62a0\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_96 where\n  type Mode = 1\n  type AAD = 96\n\nproperty test37 =\n  AES_GCM_SIV_1_96::aes_gcm_siv\n   { msg = 0x02000000\n   , aad = 0x010000000000000000000000\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x22b3f4cd1835e517741dfddccfa07fa4 #\n      0x661b74cf\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_144 where\n  type Mode = 1\n  type AAD = 144\n\nproperty test38 =\n  AES_GCM_SIV_1_144::aes_gcm_siv\n   { msg = 0x03000000000000000000000000000000 #\n           0x04000000\n   , aad = 0x01000000000000000000000000000000 #\n           0x0200\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x43dd0163cdb48f9fe3212bf61b201976 #\n      0x067f342bb879ad976d8242acc188ab59 #\n      0xcabfe307\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_160 where\n  type Mode = 1\n  type AAD = 160\n\nproperty test39 =\n  AES_GCM_SIV_1_160::aes_gcm_siv\n   { msg = 0x03000000000000000000000000000000 #\n           0x0400\n   , aad = 0x01000000000000000000000000000000 #\n           0x02000000\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x462401724b5ce6588d5a54aae5375513 #\n      0xa075cfcdf5042112aa29685c912fc205 #\n      0x6543\n\n\nproperty test40 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0xe66021d5eb8e4f4066d4adb9c33560e4 #\n           0xf46e44bb3da0015c94f7088736864200\n   , nonce = 0xe0eaf5284d884a0e77d31646\n   }\n   == 0x169fbb2fbf389a995f6390af22228a62\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_40 where\n  type Mode = 1\n  type AAD = 40\n\nproperty test41 =\n  AES_GCM_SIV_1_40::aes_gcm_siv\n   { msg = 0x671fdd\n   , aad = 0x4fbdc66f14\n   , key = 0xbae8e37fc83441b16034566b7a806c46 #\n           0xbb91c3c5aedb64a6c590bc84d1a5e269\n   , nonce = 0xe4b47801afc0577e34699b9e\n   }\n   == 0x0eaccb93da9bb81333aee0c785b240d3 #\n      0x19719d\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_80 where\n  type Mode = 1\n  type AAD = 80\n\nproperty test42 =\n  AES_GCM_SIV_1_80::aes_gcm_siv\n   { msg = 0x195495860f04\n   , aad = 0x6787f3ea22c127aaf195\n   , key = 0x6545fc880c94a95198874296d5cc1fd1 #\n           0x61320b6920ce07787f86743b275d1ab3\n   , nonce = 0x2f6d1f0434d8848c1177441f\n   }\n   == 0xa254dad4f3f96b62b84dc40c84636a5e #\n      0xc12020ec8c2c\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_120 where\n  type Mode = 1\n  type AAD = 120\n\nproperty test43 =\n  AES_GCM_SIV_1_120::aes_gcm_siv\n   { msg = 0xc9882e5386fd9f92ec\n   , aad = 0x489c8fde2be2cf97e74e932d4ed87d\n   , key = 0xd1894728b3fed1473c528b8426a58299 #\n           0x5929a1499e9ad8780c8d63d0ab4149c0\n   , nonce = 0x9f572c614b4745914474e7c7\n   }\n   == 0x0df9e308678244c44bc0fd3dc6628dfe #\n      0x55ebb0b9fb2295c8c2\n\n\nproperty test44 =\n  AES_GCM_SIV_1_160::aes_gcm_siv\n   { msg = 0x1db2316fd568378da107b52b\n   , aad = 0x0da55210cc1c1b0abde3b2f204d1e9f8 #\n           0xb06bc47f\n   , key = 0xa44102952ef94b02b805249bac80e6f6 #\n           0x1455bfac8308a2d40d8c845117808235\n   , nonce = 0x5c9e940fea2f582950a70d5a\n   }\n   == 0x8dbeb9f7255bf5769dd56692404099c2 #\n      0x587f64979f21826706d497d5\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_200 where\n  type Mode = 1\n  type AAD = 200\n\nproperty test45 =\n  AES_GCM_SIV_1_200::aes_gcm_siv\n   { msg = 0x21702de0de18baa9c9596291b08466\n   , aad = 0xf37de21c7ff901cfe8a69615a93fdf7a #\n           0x98cad481796245709f\n   , key = 0x9745b3d1ae06556fb6aa7890bebc18fe #\n           0x6b3db4da3d57aa94842b9803a96e07fb\n   , nonce = 0x6de71860f762ebfbd08284e4\n   }\n   == 0x793576dfa5c0f88729a7ed3c2f1bffb3 #\n      0x080d28f6ebb5d3648ce97bd5ba67fd\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_240 where\n  type Mode = 1\n  type AAD = 240\n\nproperty test46 =\n  AES_GCM_SIV_1_240::aes_gcm_siv\n   { msg = 0xb202b370ef9768ec6561c4fe6b7e7296 #\n           0xfa85\n   , aad = 0x9c2159058b1f0fe91433a5bdc20e214e #\n           0xab7fecef4454a10ef0657df21ac7\n   , key = 0xb18853f68d833640e42a3c02c25b6486 #\n           0x9e146d7b233987bddfc240871d7576f7\n   , nonce = 0x028ec6eb5ea7e298342a94d4\n   }\n   == 0x857e16a64915a787637687db4a951963 #\n      0x5cdd454fc2a154fea91f8363a39fec7d #\n      0x0a49\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_280 where\n  type Mode = 1\n  type AAD = 280\n\nproperty test47 =\n  AES_GCM_SIV_1_280::aes_gcm_siv\n   { msg = 0xced532ce4159b035277d4dfbb7db6296 #\n           0x8b13cd4eec\n   , aad = 0x734320ccc9d9bbbb19cb81b2af4ecbc3 #\n           0xe72834321f7aa0f70b7282b4f33df23f #\n           0x167541\n   , key = 0x3c535de192eaed3822a2fbbe2ca9dfc8 #\n           0x8255e14a661b8aa82cc54236093bbc23\n   , nonce = 0x688089e55540db1872504e1c\n   }\n   == 0x626660c26ea6612fb17ad91e8e767639 #\n      0xedd6c9faee9d6c7029675b89eaf4ba1d #\n      0xed1a286594\n\n\nproperty test48 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x00000000000000000000000000000000 #\n           0x4db923dc793ee6497c76dcc03a98e108\n   , aad = []\n   , key = 0x00000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x000000000000000000000000\n   }\n   == 0xf3f80f2cf0cb2dd9c5984fcda908456c #\n      0xc537703b5ba70324a6793a7bf218d3ea #\n      0xffffffff000000000000000000000000\n\nproperty test49 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0xeb3640277c7ffd1303c7a542d02d3e4c #\n           0x0000000000000000\n   , aad = []\n   , key = 0x00000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x000000000000000000000000\n   }\n   == 0x18ce4f0b8cb4d0cac65fea8f79257b20 #\n      0x888e53e72299e56dffffffff00000000 #\n      0x0000000000000000\n\n\n\nproperty test50 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { msg = 0x01000000000000000000000000000000 #\n            0x02000000000000000000000000000000 #\n            0x03000000000000000000000000000000 #\n            0x04000000000000000000000000000000 #\n            0x05000000000000000000000000000000 #\n            0x06000000000000000000000000000000 #\n            0x07000000000000000000000000000000 #\n            0x08000000000000000000000000000000 #\n            0x09000000000000000000000000000000 #\n            0x0a000000000000000000000000000000 #\n            0x0b000000000000000000000000000000 #\n            0x0c000000000000000000000000000000 #\n            0x0d000000000000000000000000000000 #\n            0x0e000000000000000000000000000000 #\n            0x0f000000000000000000000000000000 #\n            0x10000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , key = 0x01000000000000000000000000000000\n    , aad = []\n    }\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/param_modules\/GCM_AES_Tests.cry","filetype":"cry","content":"module GCM_AES_Tests where\n\nimport AES as AES128 where\n  type m = 0\n  type k = 128\n\nimport AES as AES192 where\n  type m = 1\n  type k = 192\n\nimport AES as AES256 where\n  type m = 2\n  type k = 256\n\n\nimport Common::GCM as GCM_128_96_0_128 where\n  type K = 128\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES128::encrypt\n\nproperty test1 =\n  GCM_128_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000\n    , pt  = []\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = []\n  , tag = 0x58e2fccefa7e3061367f1d57a4e7455a\n  }\n\nproperty test2 =\n  GCM_128_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = 0x0388dace60b6a392f328c2b971b2fe78\n  , tag = 0xab6e47d42cec13bdf53a67b21257bddf\n  }\n\nproperty test3 =\n  GCM_128_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct = 0x42831ec2217774244b7221b784d0d49c #\n         0xe3aa212f2c02a4e035c17e2329aca12e #\n         0x21d514b25466931c7d8f6a5aac84aa05 #\n         0x1ba30b396a0aac973d58e091473f5985\n  , tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4\n  }\n\n\nimport Common::GCM as GCM_128_96_160_128 where\n  type K = 128\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test4 =\n  GCM_128_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct = 0x42831ec2217774244b7221b784d0d49c #\n         0xe3aa212f2c02a4e035c17e2329aca12e #\n         0x21d514b25466931c7d8f6a5aac84aa05 #\n         0x1ba30b396a0aac973d58e091\n  , tag = 0x5bc94fbc3221a5db94fae95ae7121a47\n  }\n\n\nimport Common::GCM as GCM_128_64_160_128 where\n  type K = 128\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test5 =\n  GCM_128_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbad\n    }\n  ==\n  { ct = 0x61353b4c2806934a777ff51fa22a4755 #\n         0x699b2a714fcdc6f83766e5f97b6c7423 #\n         0x73806900e49f24b22b097544d4896b42 #\n         0x4989b5e1ebac0f07c23f4598\n  , tag = 0x3612d2e79e3b0785561be14aaca2fccb\n  }\n\n\nimport Common::GCM as GCM_128_480_160_128 where\n  type K = 128\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test6 =\n  GCM_128_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0x9313225df88406e555909c5aff5269aa #\n            0x6a7a9538534f7da1e4c303d2a318a728 #\n            0xc3c0c95156809539fcf0e2429a6b5254 #\n            0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct = 0x8ce24998625615b603a033aca13fb894 #\n         0xbe9112a5c3a211a8ba262a3cca7e2ca7 #\n         0x01e4a9a4fba43c90ccdcb281d48c7c6f #\n         0xd62875d2aca417034c34aee5\n  , tag = 0x619cc5aefffe0bfa462af43c1699d050\n  }\n\n\nimport Common::GCM as GCM_192_96_0_128 where\n  type K = 192\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES192::encrypt\n\nproperty test7 =\n  GCM_192_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x0000000000000000\n    , pt  = []\n    , aad = []\n    , iv  = 0x000000000000000000000000\n    }\n  ==\n  { ct = []\n  , tag = 0xcd33b28ac773f74ba00ed1f312572435\n  }\n\nproperty test8 =\n  GCM_192_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x0000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct = 0x98e7247c07f0fe411c267e4384b0f600\n  , tag = 0x2ff58d80033927ab8ef4d4587514f0fb\n  }\n\nproperty test9 =\n  GCM_192_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv  = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct =  0x3980ca0b3c00e841eb06fac4872a2757 #\n          0x859e1ceaa6efd984628593b40ca1e19c #\n          0x7d773d00c144c525ac619d18c84a3f47 #\n          0x18e2448b2fe324d9ccda2710acade256\n  , tag = 0x9924a7c8587336bfb118024db8674a14\n  }\n\n\nimport Common::GCM as GCM_192_96_160_128 where\n  type K = 192\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test10 =\n  GCM_192_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct  = 0x3980ca0b3c00e841eb06fac4872a2757 #\n          0x859e1ceaa6efd984628593b40ca1e19c #\n          0x7d773d00c144c525ac619d18c84a3f47 #\n          0x18e2448b2fe324d9ccda2710\n  , tag = 0x2519498e80f1478f37ba55bd6d27618c\n  }\n\n\nimport Common::GCM as GCM_192_64_160_128 where\n  type K = 192\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test11 =\n  GCM_192_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbad\n    }\n  ==\n  { ct  = 0x0f10f599ae14a154ed24b36e25324db8 #\n          0xc566632ef2bbb34f8347280fc4507057 #\n          0xfddc29df9a471f75c66541d4d4dad1c9 #\n          0xe93a19a58e8b473fa0f062f7\n  , tag = 0x65dcc57fcf623a24094fcca40d3533f8\n  }\n\n\nimport Common::GCM as GCM_192_480_160_128 where\n  type K = 192\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test12 =\n  GCM_192_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0x9313225df88406e555909c5aff5269aa #\n            0x6a7a9538534f7da1e4c303d2a318a728 #\n            0xc3c0c95156809539fcf0e2429a6b5254 #\n            0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct  = 0xd27e88681ce3243c4830165a8fdcf9ff #\n          0x1de9a1d8e6b447ef6ef7b79828666e45 #\n          0x81e79012af34ddd9e2f037589b292db3 #\n          0xe67c036745fa22e7e9b7373b\n  , tag = 0xdcf566ff291c25bbb8568fc3d376a6d9\n  }\n\n\nimport Common::GCM as GCM_256_96_0_128 where\n  type K = 256\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES256::encrypt\n\nproperty test13 =\n  GCM_256_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x00000000000000000000000000000000\n    , pt  = []\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = []\n  , tag = 0x530f8afbc74536b9a963b4f1c4cb738b\n  }\n\nproperty test14 =\n  GCM_256_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x00000000000000000000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = 0xcea7403d4d606b6e074ec5d3baf39d18\n  , tag = 0xd0d1c8a799996bf0265b98b5d48ab919\n  }\n\nproperty test15 =\n  GCM_256_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct  = 0x522dc1f099567d07f47f37a32a84427d #\n          0x643a8cdcbfe5c0c97598a2bd2555d1aa #\n          0x8cb08e48590dbb3da7b08b1056828838 #\n          0xc5f61e6393ba7a0abcc9f662898015ad\n  , tag = 0xb094dac5d93471bdec1a502270e3cc6c\n  }\n\n\nimport Common::GCM as GCM_256_96_160_128 where\n  type K = 256\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test16 =\n  GCM_256_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct  = 0x522dc1f099567d07f47f37a32a84427d #\n          0x643a8cdcbfe5c0c97598a2bd2555d1aa #\n          0x8cb08e48590dbb3da7b08b1056828838 #\n          0xc5f61e6393ba7a0abcc9f662\n  , tag = 0x76fc6ece0f4e1768cddf8853bb2d551b\n  }\n\n\nimport Common::GCM as GCM_256_64_160_128 where\n  type K = 256\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test17 =\n  GCM_256_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0xcafebabefacedbad\n    }\n  ==\n  { ct  = 0xc3762df1ca787d32ae47c13bf19844cb #\n          0xaf1ae14d0b976afac52ff7d79bba9de0 #\n          0xfeb582d33934a4f0954cc2363bc73f78 #\n          0x62ac430e64abe499f47c9b1f\n  , tag = 0x3a337dbf46a792c45e454913fe2ea8f2\n  }\n\n\nimport Common::GCM as GCM_256_480_160_128 where\n  type K = 256\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test18 =\n  GCM_256_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0x9313225df88406e555909c5aff5269aa #\n           0x6a7a9538534f7da1e4c303d2a318a728 #\n           0xc3c0c95156809539fcf0e2429a6b5254 #\n           0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct  = 0x5a8def2f0c9e53f1f75d7853659e2a20 #\n          0xeeb2b22aafde6419a058ab4f6f746bf4 #\n          0x0fc0c3b780f244452da3ebf1c5d82cde #\n          0xa2418997200ef82e44ae7e3f\n  , tag = 0xa44a8266ee1c8eb0c8b5d4cf5ae9f19a\n  }\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/param_modules\/SHA.cry","filetype":"cry","content":"module SHA where\n\nimport SHA256 as SHA256\n\nsha256 : {n} (64 >= width n) => [n] -> [256]\nsha256 = SHA256::sha\n\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- sha256tests ]\n\n\nsha256tests =\n  [ (go \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    ,   0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1\n    )\n\n  , (go \"\"\n    ,   0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n    )\n\n    , (go \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n      , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1\n      )\n\n    ]\n\n  where\n  go : {n} (64 >= width (8 * n)) => [n][8] -> [256]\n  go x = sha256 (join x)\n\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/MiniLock\/prim\/SCrypt.cry","filetype":"cry","content":"module SCrypt where\n\nimport Salsa20\nimport PBKDF2\n\n\/\/ SCrypt paper page 10: BlockMix specialized to Salsa20\nBlockMix : {r} (fin r, r >= 1) =>  [2*r][64*8] -> [2*r][64*8]\nBlockMix B = ys @@ ([0,2..2*r-2] # [1,3..2*r-1])\n where\n  rs = [B!0] # [ join (Salsa20 `{r=8} (split (X ^ bi))) | X <- rs | bi <- B ]\n  ys = drop `{1} rs\n\n\/\/ SMix with the ROMix algorithm (section 5) inlined (specialized to BlockMix)\n\/\/ N = 2^^17\nSMix : {N,r} ( fin r\n             , r >= 1\n             , N >= 1\n             , 512 >= width N\n             , 1 + width N >= width (N-1)\n             ) => [128 * 8 * r] -> [128 * 8 * r]\nSMix B = join (Xs ! 0)\n where\n  Vs = [split B] # [ BlockMix x | x <- Vs | _ <- [0..N-1] : [_][width N + 1]]\n  V  = take `{front=N} Vs\n\n  Xs : [N+1][2*r][64*8]\n  Xs = [Vs!0]    # [ (x' where\n                            j  = integerify x\n                            T  = x ^ (V@j)\n                            x' = BlockMix T)\n                        | x <- Xs | _ <- [0..N-1] : [_][width N + 1] ]\n\n  integerify w = (join (reverse (split `{each=8} (w!0)))) % `N\n\n\/\/ SCrypt paper, page 11: MFCrypt specialized to sha256 (see the 'pbkdf2' function)\n\/\/ p = 1\nMFcrypt : { pwBytes, saltBytes, dkLen, r, N }\n          ( fin dkLen\n          , 4*r >= 1\n          , 8 * dkLen >= 1\n          , 64 >= width (8 * pwBytes)\n          , 32 >= width (4 + saltBytes)\n          ,  512 >= width N, 1+width N >= width (N-1)\n          , 32 >= width ((255 + 8 * dkLen) \/ 256)\n          , 32 >= width (4 + 128 * r)\n          , N >= 1\n          )\n        => [pwBytes][8] -> [saltBytes][8] -> [dkLen][8]\nMFcrypt P S = split DK\n where\n  B  = pbkdf2 `{C=1} P S\n  B' = SMix `{N=N,r=r} B\n  DK = pbkdf2 `{dkLenBits=dkLen*8, C=1} P (split B')\n\nSCrypt : {pwBytes, saltBytes, dkBytes, r, N}\n         ( fin dkBytes, 4*r >= 1\n         , 8 * dkBytes >= 1\n         , 32 >= width ((255 + 8 * dkBytes) \/ 256)\n         , 64 >= width (8 * pwBytes)\n         , 512 >= width N, 1+width N >= width (N-1)\n         , 32 >= width (4 + saltBytes)\n         , 32 >= width (4 + 128 * r)\n         , N >= 1\n         )\n      => [pwBytes][8] -> [saltBytes][8] -> [dkBytes][8]\nSCrypt P S = MFcrypt `{r=r,N=N} P S\n\nproperty kats_pass = ~zero ==\n    [ SCrypt `{N=2^^4,r=1} \"\" \"\" ==\n            [ 0x77, 0xd6, 0x57, 0x62, 0x38, 0x65, 0x7b, 0x20\n            , 0x3b, 0x19, 0xca, 0x42, 0xc1, 0x8a, 0x04, 0x97\n            , 0xf1, 0x6b, 0x48, 0x44, 0xe3, 0x07, 0x4a, 0xe8\n            , 0xdf, 0xdf, 0xfa, 0x3f, 0xed, 0xe2, 0x14, 0x42\n            , 0xfc, 0xd0, 0x06, 0x9d, 0xed, 0x09, 0x48, 0xf8\n            , 0x32, 0x6a, 0x75, 0x3a, 0x0f, 0xc8, 0x1f, 0x17\n            , 0xe8, 0xd3, 0xe0, 0xfb, 0x2e, 0x0d, 0x36, 0x28\n            , 0xcf, 0x35, 0xe2, 0x0c, 0x38, 0xd1, 0x89, 0x06\n            ]\n    ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/MiniLock\/prim\/SHA256.cry","filetype":"cry","content":"module SHA256 where\n\n\/*\n * SHA256 Functions : Section 4.1.2\n *\/\n\nCh : [32] -> [32] -> [32] -> [32]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [32] -> [32] -> [32] -> [32]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nS0 : [32] -> [32]\nS0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nS1 : [32] -> [32]\nS1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\ns0 : [32] -> [32]\ns0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\ns1 : [32] -> [32]\ns1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n\n\/*\n * SHA256 Constants : Section 4.2.2\n *\/\n\nK : [64][32]\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n     ]\n\n\/*\n * Preprocessing (padding and parsing) for SHA256 : Section 5.1.1 and 5.2.1\n *\/\npreprocess : {msgLen}\n     ( fin msgLen\n     , 64 >= width msgLen                              \/\/ message width fits in a word\n     )\n     => [msgLen] -> [(msgLen + 65) \/^ 512][512]\npreprocess msg = split (msg # [True] # (zero:[(msgLen + 65) %^ 512]) # (`msgLen:[64]))\n\n\/*\n * SHA256 Initial Hash Value :  Section 5.3.3\n *\/\n\nH0 : [8][32]\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\n\/*\n * The SHA256 Hash computation : Section 6.2.2\n *\n * We have split the computation into a message scheduling function, corresponding\n * to step 1 in the documents loop, and a compression function, corresponding to steps 2-4.\n *\/\n\nSHA256MessageSchedule : [16][32] -> [64][32]\nSHA256MessageSchedule M = W where\n    W = M # [ s1 (W@(j-2)) + (W@(j-7)) + s0 (W@(j-15)) + (W@(j-16)) | j <- [16 .. 63]:[_][8] ]\n\nSHA256Compress : [8][32] -> [64][32] -> [8][32]\nSHA256Compress H W = [as!0 + H@0, bs!0 + H@1, cs!0 + H@2, ds!0 + H@3, es!0 + H@4, fs!0 + H@5, gs!0 + H@6, hs!0 + H@7] where\n    T1 = [h + S1 e + Ch e f g  + k + w | h <- hs | e <- es | f <- fs | g <- gs | k <- K | w <- W]\n    T2 = [S0 a  + Maj a b c  | a <- as | b <- bs | c <- cs]\n    hs = take `{65} ([H@7] # gs)\n    gs = take `{65} ([H@6] # fs)\n    fs = take `{65} ([H@5] # es)\n    es = take `{65} ([H@4] # [d + t1 | d <- ds | t1 <- T1])\n    ds = take `{65} ([H@3] # cs)\n    cs = take `{65} ([H@2] # bs)\n    bs = take `{65} ([H@1] # as)\n    as = take `{65} ([H@0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n\/*\n * The SHA256' function hashes a preprocessed sequence of blocks with the\n * compression function.  The SHA256 function hashes a sequence of bytes, and\n * is more likely the function that will be similar to those see in in an\n * implementation to be verified.\n *\/\n\nSHA256' : {a} (fin a) => [a][16][32] -> [8][32]\nSHA256' blocks = hash!0 where\n    hash = [H0] # [SHA256Compress h (SHA256MessageSchedule b) | h <- hash | b <- blocks]\n\nSHA256 : {a} (fin a, 64 >= width (8*a)) => [a][8] -> [256]\nSHA256 msg = join (SHA256' [ split x | x <- preprocess(join msg)])\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- kats ]\n\nkats = [ (SHA256 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n         , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n       , (SHA256 \"\"\n         ,0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n       , (SHA256 \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n         , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n       \/\/ , (SHA256 [0x61 | i <- [1..1000000] : [_][32]]\n       \/\/   , 0xcdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0)\n       ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/MiniLock\/prim\/HMAC.cry","filetype":"cry","content":"module HMAC where\n\nimport SHA256\n\nhmacSHA256 : {pwBytes, msgBytes}\n             (fin pwBytes, fin msgBytes\n             , 32 >= width msgBytes\n             , 64 >= width (8*pwBytes)\n             ) => [pwBytes][8] -> [msgBytes][8] -> [256]\nhmacSHA256 = hmac `{blockLength=64} SHA256 SHA256 SHA256\n\n\/\/ Due to limitations of the type system we must accept two\n\/\/ separate arguments (both aledgedly the same) for two\n\/\/ separate length inputs.\nhmac : { msgBytes, pwBytes, digest, blockLength }\n       ( fin pwBytes, fin digest, fin blockLength\n       )\n    => ([blockLength + msgBytes][8] -> [8*digest])\n    -> ([blockLength + digest][8] -> [8*digest])\n    -> ([pwBytes][8] -> [8*digest])\n    -> [pwBytes][8]\n    -> [msgBytes][8]\n    -> [digest*8]\nhmac hash hash2 hash3 key message = hash2 (okey # internal)\n where\n ks : [blockLength][8]\n ks   = if `pwBytes > (`blockLength : [max (width pwBytes) (width blockLength)])\n            then take `{blockLength} (split (hash3 key) # (zero : [blockLength][8]))\n            else take `{blockLength} (key # (zero : [blockLength][8]))\n okey = [k ^ 0x5C | k <- ks]\n ikey = [k ^ 0x36 | k <- ks]\n internal = split (hash (ikey # message))\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Blake2s.cry","filetype":"cry","content":"module Blake2s where\n\ntype Block   = [16][32]\ntype State   = [8][32]\ntype LocalState = [16][32]\ntype BCounter = [64]\n\ntype Context = { state : State, counter : BCounter }\n\nbbVal : [64]\nbbVal = 64\n\n\nIV : [8][32]\nIV = [ 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n       0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n     ]\n\nSIGMA_TABLE : [10][16][4]\nSIGMA_TABLE =\n    [  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ,  [ 11, 8,  12, 0,   5, 2,  15, 13, 10, 14,  3, 6,   7, 1,   9, 4  ]\n    ,  [  7, 9,   3, 1,  13, 12, 11, 14,  2, 6,   5, 10,  4, 0,  15, 8  ]\n    ,  [  9, 0,   5, 7,   2, 4,  10, 15, 14, 1,  11, 12,  6, 8,   3, 13 ]\n    ,  [  2, 12,  6, 10,  0, 11,  8, 3,   4, 13,  7, 5,  15, 14,  1, 9  ]\n    ,  [ 12, 5,   1, 15, 14, 13,  4, 10,  0, 7,   6, 3,   9, 2,   8, 11 ]\n    ,  [ 13, 11,  7, 14, 12, 1,   3, 9,   5, 0,  15, 4,   8, 6,   2, 10 ]\n    ,  [  6, 15, 14, 9,  11, 3,   0, 8,  12, 2,  13, 7,   1, 4,  10, 5  ]\n    ,  [ 10, 2,   8, 4,   7, 6,   1, 5,  15, 11,  9, 14,  3, 12, 13, 0  ]\n    ]\n\n\/\/ Section 2.1 constants\nR1,R2,R3,R4 : [6]\nR1 = 16\nR2 = 12\nR3 = 08\nR4 = 07\n\n\/\/ Section 3.1: Mixing function 'G'\nG : [4] -> [4] -> LocalState -> [4][6] -> Block -> [16][32]\nG r i vec abcd ms = foldl updateVector vec (zip abcd new)\n  where\n  new  = G' r i (vec @@ abcd) ms\n\nG' : [4] -> [4] -> [4][32] -> Block -> [4][32]\nG' r i vals ms = [a2, b2, c2, d2]\n  where\n  x = ms @ (SIGMA_TABLE @ r @ (2*i))\n  y = ms @ (SIGMA_TABLE @ r @ (2*i+1))\n  [a,b,c,d] = vals\n  a1 =  a + b + x\n  d1 = (d ^ a1) >>> R1\n  c1 =  c + d1\n  b1 = (b ^ c1) >>> R2\n  a2 =  a1 + b1 + y\n  d2 = (d1 ^ a2) >>> R3\n  c2 =  c1 + d2\n  b2 = (b1 ^ c2) >>> R4\n\n\/\/ Section 3.2: Compression function\nF : State -> Block -> BCounter -> Bit -> State\nF h ms t f =  h ^ (take (vs!0)) ^ (drop (vs!0))\n where\n  v   = h # IV ^ (zero # [t0,t1,f0,zero])\n  [t1,t0] = split t      : [2][32]\n  f0 = [f | _ <- [0..31] : [_][6]]\n  vs = [v] # [ round i ms v' | v' <- vs | i <- [0..9] ]\n\n\/\/ Sub-function of F (first for loop)\nround : [4] -> Block -> LocalState -> LocalState\nround r ms v = vs ! 0\n  where\n  vs = [v] # [ G r i v' ix ms\n                | v'   <- vs\n                | i    <- [0..7]\n                | ix   <- [ [0,4,8,12],  [1,5,9,13]\n                          , [2,6,10,14], [3,7,11,15]\n                          , [0,5,10,15], [1,6,11,12]\n                          , [2,7,8,13],  [3,4,9,14] ]\n              ]\n\n\/\/ Section 3.3: Padding\n\/\/ Recall kk == key bytes  (0)\n\/\/        nn == hash bytes (32)\n\/\/        ll == input bytes (ceiling $ len \/ 8)\n\/\/        bb == block bytes (64, 1024 bits)\n\/\/        dd == nr Blocks\n\nblake2s : {ll,nn} (fin ll, 32 >= nn, 64 >= width ll)\n      => [ll][8] -> [nn*8]\nblake2s m = blake2s' `{ll=ll,nn=nn} m\n\nblake2s' : {ll,dd,nn}\n         (fin ll\n         , 32  >= nn\n         , dd  == (max 1 ((ll+63)\/64)) - 1\n         , 64 >= width ll\n         )\n          => [ll][8]\n          -> [nn*8]\nblake2s' m = take `{nn*8} (blake2sFinish ({ state = (hs!0).state, counter = `ll}) lastBlock)\n where\n\n fullBlocks : [dd]Block\n fullBlocks = [mkBlock b | b <- split (join (take  `{front=64*dd,back=ll-64*dd} m))]\n\n partialBlock = drop `{front=64*dd,back=ll-64*dd} m\n\n lastBlock : Block\n lastBlock  =\n    if (`ll == (zero:[64]))\n        then zero \/\/ Special case full zero block for empty messages\n        else mkBlock ((split (join (partialBlock # (zero : [inf][8]))))@0)\n\n h : Context\n h  = { state = [IV@0 ^ `0x01010000 ^ `nn] # drop `{1} IV, counter = 0 }\n\n hs : [dd+1]Context\n hs = [h] # [blake2Update h' dX |  h' <- hs | dX <- fullBlocks]\n\nblake2Update : Context -> Block -> Context\nblake2Update ctx d = { state = newState, counter = newCount }\n  where newState = F ctx.state d newCount False\n        newCount = ctx.counter + (64 : [64])\n\npostprocess : {ll} (64 >= ll, 64 >= width ll) => BCounter -> [ll][8] -> Block\npostprocess c m =\n    if c == 0 \/\\ `ll == (zero:[64])\n        then zero\n        else split (join m # zero)\n\n\/\/ The final round of blake\nblake2sFinish : Context -> Block -> [256]\nblake2sFinish ctx b = join [ reverseBytes w | w <- F ctx.state b ctx.counter True ]\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/  Utilities\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nmkBlock x = reverse (split (reverseBytes x))\n\nreverseBytes x = join (reverse (bytes x))\n\nbytes x = split x : [_] [8]\n\n\n\/\/ XXX can probably do a cleaner merge-sort style update.\nupdateVector : {a, b, c} (c >= width (a-1), a >= 1, fin a, fin c) => [a]b -> ([c], b) -> [a]b\nupdateVector orig idxNew = vs\n where\n idx = idxNew.0\n new = idxNew.1\n vs = [if i == idx then new else orig@i | i <- [0..a-1]]\n\n\nproperty katsPass = ~zero ==\n                        [ nthKat `{0}\n                        , nthKat `{1}\n                        , nthKat `{2}\n                        , nthKat `{3}\n                        , nthKat `{4}\n                        , nthKat `{5}\n                        , nthKat `{6}\n                        , nthKat `{7}\n                        , nthKat `{8}\n                        , nthKat `{9}\n                        , nthKat `{10}\n                        , nthKat `{11}\n                        , nthKat `{12}\n                        , nthKat `{13}\n                        , nthKat `{14}\n                        , nthKat `{15}\n                        , nthKat `{16}\n                        , nthKat `{17}\n                        , nthKat `{18}\n                        , nthKat `{19}\n                        , nthKat `{20}\n                        , nthKat `{21}\n                        , nthKat `{22}\n                        , nthKat `{23}\n                        , nthKat `{24}\n                        , nthKat `{25}\n                        , nthKat `{26}\n                        , nthKat `{27}\n                        , nthKat `{28}\n                        , nthKat `{29}\n                        , nthKat `{30}\n                        , nthKat `{31}\n                        , nthKat `{32}\n                        , nthKat `{33}\n                        , nthKat `{34}\n                        , nthKat `{35}\n                        , nthKat `{36}\n                        , nthKat `{37}\n                        , nthKat `{38}\n                        , nthKat `{39}\n                        , nthKat `{40}\n                        , nthKat `{41}\n                        , nthKat `{42}\n                        , nthKat `{43}\n                        , nthKat `{44}\n                        , nthKat `{45}\n                        , nthKat `{46}\n                        , nthKat `{47}\n                        , nthKat `{48}\n                        , nthKat `{49}\n                        , nthKat `{50}\n                        , nthKat `{51}\n                        , nthKat `{52}\n                        , nthKat `{53}\n                        , nthKat `{54}\n                        , nthKat `{55}\n                        , nthKat `{56}\n                        , nthKat `{57}\n                        , nthKat `{58}\n                        , nthKat `{59}\n                        , nthKat `{60}\n                        , nthKat `{61}\n                        , nthKat `{62}\n                        , nthKat `{63}\n                        , nthKat `{64}\n                        , nthKat `{65}\n                        , nthKat `{66}\n                        , nthKat `{67}\n                        , nthKat `{68}\n                        , nthKat `{69}\n                        , nthKat `{70}\n                        , nthKat `{71}\n                        , nthKat `{72}\n                        , nthKat `{73}\n                        , nthKat `{74}\n                        , nthKat `{75}\n                        , nthKat `{76}\n                        , nthKat `{77}\n                        , nthKat `{78}\n                        , nthKat `{79}\n                        , nthKat `{80}\n                        , nthKat `{81}\n                        , nthKat `{82}\n                        , nthKat `{83}\n                        , nthKat `{84}\n                        , nthKat `{85}\n                        , nthKat `{86}\n                        , nthKat `{87}\n                        , nthKat `{88}\n                        , nthKat `{89}\n                        , nthKat `{90}\n                        , nthKat `{91}\n                        , nthKat `{92}\n                        , nthKat `{93}\n                        , nthKat `{94}\n                        , nthKat `{95}\n                        , nthKat `{96}\n                        , nthKat `{97}\n                        , nthKat `{98}\n                        , nthKat `{99}\n                        , nthKat `{100}\n                        , nthKat `{101}\n                        , nthKat `{102}\n                        , nthKat `{103}\n                        , nthKat `{104}\n                        , nthKat `{105}\n                        , nthKat `{106}\n                        , nthKat `{107}\n                        , nthKat `{108}\n                        , nthKat `{109}\n                        , nthKat `{110}\n                        , nthKat `{111}\n                        , nthKat `{112}\n                        , nthKat `{113}\n                        , nthKat `{114}\n                        , nthKat `{115}\n                        , nthKat `{116}\n                        , nthKat `{117}\n                        , nthKat `{118}\n                        , nthKat `{119}\n                        , nthKat `{120}\n                        , nthKat `{121}\n                        , nthKat `{122}\n                        , nthKat `{123}\n                        , nthKat `{124}\n                        , nthKat `{125}\n                        , nthKat `{126}\n                        , nthKat `{127}\n                        , nthKat `{128}\n                        , nthKat `{129}\n                        , nthKat `{130}\n                        , nthKat `{131}\n                        , nthKat `{132}\n                        , nthKat `{133}\n                        , nthKat `{134}\n                        , nthKat `{135}\n                        , nthKat `{136}\n                        , nthKat `{137}\n                        , nthKat `{138}\n                        , nthKat `{139}\n                        , nthKat `{140}\n                        , nthKat `{141}\n                        , nthKat `{142}\n                        , nthKat `{143}\n                        , nthKat `{144}\n                        , nthKat `{145}\n                        , nthKat `{146}\n                        , nthKat `{147}\n                        , nthKat `{148}\n                        , nthKat `{149}\n                        , nthKat `{150}\n                        , nthKat `{151}\n                        , nthKat `{152}\n                        , nthKat `{153}\n                        , nthKat `{154}\n                        , nthKat `{155}\n                        , nthKat `{156}\n                        , nthKat `{157}\n                        , nthKat `{158}\n                        , nthKat `{159}\n                        , nthKat `{160}\n                        , nthKat `{161}\n                        , nthKat `{162}\n                        , nthKat `{163}\n                        , nthKat `{164}\n                        , nthKat `{165}\n                        , nthKat `{166}\n                        , nthKat `{167}\n                        , nthKat `{168}\n                        , nthKat `{169}\n                        , nthKat `{170}\n                        , nthKat `{171}\n                        , nthKat `{172}\n                        , nthKat `{173}\n                        , nthKat `{174}\n                        , nthKat `{175}\n                        , nthKat `{176}\n                        , nthKat `{177}\n                        , nthKat `{178}\n                        , nthKat `{179}\n                        , nthKat `{180}\n                        , nthKat `{181}\n                        , nthKat `{182}\n                        , nthKat `{183}\n                        , nthKat `{184}\n                        , nthKat `{185}\n                        , nthKat `{186}\n                        , nthKat `{187}\n                        , nthKat `{188}\n                        , nthKat `{189}\n                        , nthKat `{190}\n                        , nthKat `{191}\n                        , nthKat `{192}\n                        , nthKat `{193}\n                        , nthKat `{194}\n                        , nthKat `{195}\n                        , nthKat `{196}\n                        , nthKat `{197}\n                        , nthKat `{198}\n                        , nthKat `{199}\n                        , nthKat `{200}\n                        , nthKat `{201}\n                        , nthKat `{202}\n                        , nthKat `{203}\n                        , nthKat `{204}\n                        , nthKat `{205}\n                        , nthKat `{206}\n                        , nthKat `{207}\n                        , nthKat `{208}\n                        , nthKat `{209}\n                        , nthKat `{210}\n                        , nthKat `{211}\n                        , nthKat `{212}\n                        , nthKat `{213}\n                        , nthKat `{214}\n                        , nthKat `{215}\n                        , nthKat `{216}\n                        , nthKat `{217}\n                        , nthKat `{218}\n                        , nthKat `{219}\n                        , nthKat `{220}\n                        , nthKat `{221}\n                        , nthKat `{222}\n                        , nthKat `{223}\n                        , nthKat `{224}\n                        , nthKat `{225}\n                        , nthKat `{226}\n                        , nthKat `{227}\n                        , nthKat `{228}\n                        , nthKat `{229}\n                        , nthKat `{230}\n                        , nthKat `{231}\n                        , nthKat `{232}\n                        , nthKat `{233}\n                        , nthKat `{234}\n                        , nthKat `{235}\n                        , nthKat `{236}\n                        , nthKat `{237}\n                        , nthKat `{238}\n                        , nthKat `{239}\n                        , nthKat `{240}\n                        , nthKat `{241}\n                        , nthKat `{242}\n                        , nthKat `{243}\n                        , nthKat `{244}\n                        , nthKat `{245}\n                        , nthKat `{246}\n                        , nthKat `{247}\n                        , nthKat `{248}\n                        , nthKat `{249}\n                        , nthKat `{250}\n                        , nthKat `{251}\n                        , nthKat `{252}\n                        , nthKat `{253}\n                        , nthKat `{254}\n                        , nthKat `{255}\n                        ]\n\n\nnthKat : {n} (fin n, 8 >= width n) => Bit\nnthKat = blake2s (nthKatInput `{n}) == kats @ (`n : [8])\n\nnthKatInput : {n} (fin n) => [n][8]\nnthKatInput = take ([0 ... ] : [inf][8])\n\nkats = [ 0x69217a3079908094e11121d042354a7c1f55b6482ca1a51e1b250dfd1ed0eef9\n       , 0xe34d74dbaf4ff4c6abd871cc220451d2ea2648846c7757fbaac82fe51ad64bea\n       , 0xddad9ab15dac4549ba42f49d262496bef6c0bae1dd342a8808f8ea267c6e210c\n       , 0xe8f91c6ef232a041452ab0e149070cdd7dd1769e75b3a5921be37876c45c9900\n       , 0x0cc70e00348b86ba2944d0c32038b25c55584f90df2304f55fa332af5fb01e20\n       , 0xec1964191087a4fe9df1c795342a02ffc191a5b251764856ae5b8b5769f0c6cd\n       , 0xe1fa51618d7df4eb70cf0d5a9e906f806e9d19f7f4f01e3b621288e4120405d6\n       , 0x598001fafbe8f94ec66dc827d012cfcbba2228569f448e89ea2208c8bf769293\n       , 0xc7e887b546623635e93e0495598f1726821996c2377705b93a1f636f872bfa2d\n       , 0xc315a437dd28062a770d481967136b1b5eb88b21ee53d0329c5897126e9db02c\n       , 0xbb473deddc055fea6228f207da575347bb00404cd349d38c18026307a224cbff\n       , 0x687e1873a8277591bb33d9adf9a13912efefe557cafc39a7952623e47255f16d\n       , 0x1ac7ba754d6e2f94e0e86c46bfb262abbb74f450ef456d6b4d97aa80ce6da767\n       , 0x012c97809614816b5d9494477d4b687d15b96eb69c0e8074a8516f31224b5c98\n       , 0x91ffd26cfa4da5134c7ea262f7889c329f61f6a657225cc212f40056d986b3f4\n       , 0xd97c828d8182a72180a06a78268330673f7c4e0635947c04c02323fd45c0a52d\n       , 0xefc04cdc391c7e9119bd38668a534e65fe31036d6a62112e44ebeb11f9c57080\n       , 0x992cf5c053442a5fbc4faf583e04e50bb70d2f39fbb6a503f89e56a63e18578a\n       , 0x38640e9f21983e67b539caccae5ecf615ae2764f75a09c9c59b76483c1fbc735\n       , 0x213dd34c7efe4fb27a6b35f6b4000d1fe03281af3c723e5c9f94747a5f31cd3b\n       , 0xec246eeeb9ced3f7ad33ed28660dd9bb0732513db4e2fa278b60cde3682a4ccd\n       , 0xac9b61d446648c3005d7892bf3a8719f4c8181cfdcbc2b79fef10a279b911095\n       , 0x7bf8b22959e34e3a43f7079223e83a9754617d391e213dfd808e41b9bead4ce7\n       , 0x68d4b5d4fa0e302b64ccc5af792913ac4c88ec95c07ddf40694256eb88ce9f3d\n       , 0xb2c2420f05f9abe36315919336b37e4e0fa33ff7e76a492767006fdb5d935462\n       , 0x134f61bbd0bbb69aed5343904551a3e6c1aa7dcdd77e903e7023eb7c60320aa7\n       , 0x4693f9bff7d4f3986a7d176e6e06f72ad1490d805c99e25347b8de77b4db6d9b\n       , 0x853e26f741953b0fd5bdb424e8ab9e8b3750eaa8ef61e47902c91e554e9c73b9\n       , 0xf7de536361abaa0e158156cf0ea4f63a99b5e4054f8fa4c9d45f6285cad55694\n       , 0x4c230608860a99ae8d7bd5c2cc17fa52096b9a61bedb17cb7617864ad29ca7a6\n       , 0xaeb920ea87952dadb1fb759291e3388139a872865001886ed84752e93c250c2a\n       , 0xaba4ad9b480b9df3d08ca5e87b0c2440d4e4ea21224c2eb42cbae469d089b931\n       , 0x05825607d7fdf2d82ef4c3c8c2aea961ad98d60edff7d018983e21204c0d93d1\n       , 0xa742f8b6af82d8a6ca2357c5f1cf91defbd066267d75c048b352366585025962\n       , 0x2bcac89599000b42c95ae23835a713704ed79789c84fef149a874ff733f017a2\n       , 0xac1ed07d048f105a9e5b7ab85b09a492d5baff14b8bfb0e9fd789486eea2b974\n       , 0xe48d0ecfaf497d5b27c25d99e156cb0579d440d6e31fb62473696dbf95e010e4\n       , 0x12a91fadf8b21644fd0f934f3c4a8f62ba862ffd20e8e961154c15c13884ed3d\n       , 0x7cbee96e139897dc98fbef3be81ad4d964d235cb12141fb66727e6e5df73a878\n       , 0xebf66abb597ae572a7297cb0871e355accafad8377b8e78bf164ce2a18de4baf\n       , 0x71b933b07e4ff7818ce059d008829e453c6ff02ec0a7db393fc2d870f37a7286\n       , 0x7cf7c51331220b8d3ebaed9c29398a16d98156e2613cb088f2b0e08a1be4cf4f\n       , 0x3e41a108e0f64ad276b979e1ce068279e16f7bc7e4aa1d211e17b81161df1602\n       , 0x886502a82ab47ba8d86710aa9de3d46ea65c47af6ee8de450cceb8b11b045f50\n       , 0xc021bc5f0954fee94f46ea09487e10a84840d02f64810bc08d9e551f7d416814\n       , 0x2030516e8a5fe19ae79c336fce26382a749d3fd0ec91e537d4bd2358c12dfb22\n       , 0x556698dac8317fd36dfbdf25a79cb112d5425860605cbaf507f23bf7e9f42afe\n       , 0x2f867ba67773fdc3e92fced99a6409ad39d0b880fde8f109a81730c4451d0178\n       , 0x172ec218f119dfae98896dff29dd9876c94af87417f9ae4c7014bb4e4b96afc7\n       , 0x3f85814a18195f879aa962f95d26bd82a278f2b82320218f6b3bd6f7f667a6d9\n       , 0x1b618fbaa566b3d498c12e982c9ec52e4da85a8c54f38f34c090394f23c184c1\n       , 0x0c758fb5692ffd41a3575d0af00cc7fbf2cbe5905a58323a88ae4244f6e4c993\n       , 0xa931360cad628c7f12a6c1c4b753b0f4062aef3ce65a1ae3f19369dadf3ae23d\n       , 0xcbac7d773b1e3b3c6691d7abb7e9df045c8ba19268ded153207f5e804352ec5d\n       , 0x23a196d3802ed3c1b384019a82325840d32f71950c4580b03445e0898e14053c\n       , 0xf4495470f226c8c214be08fdfad4bc4a2a9dbea9136a210df0d4b64929e6fc14\n       , 0xe290dd270b467f34ab1c002d340fa016257ff19e5833fdbbf2cb401c3b2817de\n       , 0x9fc7b5ded3c15042b2a6582dc39be016d24a682d5e61ad1eff9c63309848f706\n       , 0x8cca67a36d17d5e6341cb592fd7bef9926c9e3aa1027ea11a7d8bd260b576e04\n       , 0x409392f560f86831da4373ee5e0074260595d7bc24183b60ed700d4583d3f6f0\n       , 0x2802165de090915546f3398cd849164a19f92adbc361adc99b0f20c8ea071054\n       , 0xad839168d9f8a4be95ba9ef9a692f07256ae43fe6f9864e290691b0256ce50a9\n       , 0x75fdaa5038c284b86d6e8affe8b2807e467b86600e79af3689fbc06328cbf894\n       , 0xe57cb79487dd57902432b250733813bd96a84efce59f650fac26e6696aefafc3\n       , 0x56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e\n       , 0x1b53ee94aaf34e4b159d48de352c7f0661d0a40edff95a0b1639b4090e974472\n       , 0x05705e2a81757c14bd383ea98dda544eb10e6bc07bae435e2518dbe133525375\n       , 0xd8b2866e8a309db53e529ec32911d82f5ca16cff76216891a9676aa31aaa6c42\n       , 0xf5041c241270eb04c71ec2c95d4c38d803b1237b0f29fd4db3eb397669e88699\n       , 0x9a4ce077c349322f595e0ee79ed0da5fab66752cbfef8f87d0e9d0723c7530dd\n       , 0x657b09f3d0f52b5b8f2f97163a0edf0c04f075408a07bbeb3a4101a891990d62\n       , 0x1e3f7bd5a58fa533344aa8ed3ac122bb9e70d4ef50d004530821948f5fe6315a\n       , 0x80dccf3fd83dfd0d35aa28585922ab89d5313997673eaf905cea9c0b225c7b5f\n       , 0x8a0d0fbf6377d83bb08b514b4b1c43acc95d751714f8925645cb6bc856ca150a\n       , 0x9fa5b487738ad2844cc6348a901918f659a3b89e9c0dfeead30dd94bcf42ef8e\n       , 0x80832c4a1677f5ea2560f668e9354dd36997f03728cfa55e1b38337c0c9ef818\n       , 0xab37ddb683137e74080d026b590b96ae9bb447722f305a5ac570ec1df9b1743c\n       , 0x3ee735a694c2559b693aa68629361e15d12265ad6a3dedf488b0b00fac9754ba\n       , 0xd6fcd23219b647e4cbd5eb2d0ad01ec8838a4b2901fc325cc3701981ca6c888b\n       , 0x0520ec2f5bf7a755dacb50c6bf233e3515434763db0139ccd9faefbb8207612d\n       , 0xaff3b75f3f581264d7661662b92f5ad37c1d32bd45ff81a4ed8adc9ef30dd989\n       , 0xd0dd650befd3ba63dc25102c627c921b9cbeb0b130686935b5c927cb7ccd5e3b\n       , 0xe1149816b10a8514fb3e2cab2c08bee9f73ce76221701246a589bbb67302d8a9\n       , 0x7da3f441de9054317e72b5dbf979da01e6bceebb8478eae6a22849d90292635c\n       , 0x1230b1fc8a7d9215edc2d4a2decbdd0a6e216c924278c91fc5d10e7d60192d94\n       , 0x5750d716b4808f751febc38806ba170bf6d5199a7816be514e3f932fbe0cb871\n       , 0x6fc59b2f10feba954aa6820b3ca987ee81d5cc1da3c63ce827301c569dfb39ce\n       , 0xc7c3fe1eebdc7b5a939326e8ddb83e8bf2b780b65678cb62f208b040abdd35e2\n       , 0x0c75c1a15cf34a314ee478f4a5ce0b8a6b36528ef7a820696c3e4246c5a15864\n       , 0x216dc12a108569a3c7cdde4aed43a6c330139dda3ccc4a108905db3861899050\n       , 0xa57be6ae6756f28b02f59dadf7e0d7d8807f10fa15ced1ad3585521a1d995a89\n       , 0x816aef875953716cd7a581f732f53dd435dab66d09c361d2d6592de17755d8a8\n       , 0x9a76893226693b6ea97e6a738f9d10fb3d0b43ae0e8b7d8123ea76ce97989c7e\n       , 0x8daedb9a271529dbb7dc3b607fe5eb2d3211770758dd3b0a3593d2d7954e2d5b\n       , 0x16dbc0aa5dd2c774f505100f733786d8a175fcbbb59c43e1fbff3e1eaf31cb4a\n       , 0x8606cb899c6aeaf51b9db0fe4924a9fd5dabc19f8826f2bc1c1d7da14d2c2c99\n       , 0x8479731aeda57bd37eadb51a507e307f3bd95e69dbca94f3bc21726066ad6dfd\n       , 0x58473a9ea82efa3f3b3d8fc83ed8863127b33ae8deae6307201edb6dde61de29\n       , 0x9a9255d53af116de8ba27ce35b4c7e15640657a0fcb888c70d95431dacd8f830\n       , 0x9eb05ffba39fd8596a45493e18d2510bf3ef065c51d6e13abe66aa57e05cfdb7\n       , 0x81dcc3a505eace3f879d8f702776770f9df50e521d1428a85daf04f9ad2150e0\n       , 0xe3e3c4aa3acbbc85332af9d564bc24165e1687f6b1adcbfae77a8f03c72ac28c\n       , 0x6746c80b4eb56aea45e64e7289bba3edbf45ecf8206481ff6302122984cd526a\n       , 0x2b628e52764d7d62c0868b212357cdd12d9149822f4e9845d918a08d1ae990c0\n       , 0xe4bfe80d58c91994613909dc4b1a12496896c004af7b5701483de45d2823d78e\n       , 0xebb4ba150cef2734345b5d641bbed03a21eafae933c99e009212ef04574a8530\n       , 0x3966ec73b154acc697ac5cf5b24b40bdb0db9e398836d76d4b880e3b2af1aa27\n       , 0xef7e4831b3a84636518d6e4bfce64a43db2a5dda9cca2b44f39033bdc40d6243\n       , 0x7abf6acf5c8e549ddbb15ae8d8b388c1c197e698737c9785501ed1f94930b7d9\n       , 0x88018ded66813f0ca95def474c630692019967b9e36888dadd94124719b682f6\n       , 0x3930876b9fc7529036b008b1b8bb997522a441635a0c25ec02fb6d9026e55a97\n       , 0x0a4049d57e833b5695fac93dd1fbef3166b44b12ad11248662383ae051e15827\n       , 0x81dcc0678bb6a765e48c3209654fe90089ce44ff5618477e39ab286476df052b\n       , 0xe69b3a36a4461912dc08346b11ddcb9db796f885fd01936e662fe29297b099a4\n       , 0x5ac6503b0d8da6917646e6dcc87edc58e94245324cc204f4dd4af01563acd427\n       , 0xdf6dda21359a30bc271780971c1abd56a6ef167e480887888e73a86d3bf605e9\n       , 0xe8e6e47071e7b7df2580f225cfbbedf84ce67746626628d33097e4b7dc571107\n       , 0x53e40ead62051e19cb9ba8133e3e5c1ce00ddcad8acf342a224360b0acc14777\n       , 0x9ccd53fe80be786aa984638462fb28afdf122b34d78f4687ec632bb19de2371a\n       , 0xcbd48052c48d788466a3e8118c56c97fe146e5546faaf93e2bc3c47e45939753\n       , 0x256883b14e2af44dadb28e1b34b2ac0f0f4c91c34ec9169e29036158acaa95b9\n       , 0x4471b91ab42db7c4dd8490ab95a2ee8d04e3ef5c3d6fc71ac74b2b26914d1641\n       , 0xa5eb08038f8f1155ed86e631906fc13095f6bba41de5d4e795758ec8c8df8af1\n       , 0xdc1db64ed8b48a910e060a6b866374c578784e9ac49ab2774092ac71501934ac\n       , 0x285413b2f2ee873d34319ee0bbfbb90f32da434cc87e3db5ed121bb398ed964b\n       , 0x0216e0f81f750f26f1998bc3934e3e124c9945e685a60b25e8fbd9625ab6b599\n       , 0x38c410f5b9d4072050755b31dca89fd5395c6785eeb3d790f320ff941c5a93bf\n       , 0xf18417b39d617ab1c18fdf91ebd0fc6d5516bb34cf39364037bce81fa04cecb1\n       , 0x1fa877de67259d19863a2a34bcc6962a2b25fcbf5cbecd7ede8f1fa36688a796\n       , 0x5bd169e67c82c2c2e98ef7008bdf261f2ddf30b1c00f9e7f275bb3e8a28dc9a2\n       , 0xc80abeebb669ad5deeb5f5ec8ea6b7a05ddf7d31ec4c0a2ee20b0b98caec6746\n       , 0xe76d3fbda5ba374e6bf8e50fadc3bbb9ba5c206ebdec89a3a54cf3dd84a07016\n       , 0x7bba9dc5b5db2071d17752b1044c1eced96aaf2dd46e9b433750e8ea0dcc1870\n       , 0xf29b1b1ab9bab163018ee3da15232cca78ec52dbc34eda5b822ec1d80fc21bd0\n       , 0x9ee3e3e7e900f1e11d308c4b2b3076d272cf70124f9f51e1da60f37846cdd2f4\n       , 0x70ea3b0176927d9096a18508cd123a290325920a9d00a89b5de04273fbc76b85\n       , 0x67de25c02a4aaba23bdc973c8bb0b5796d47cc0659d43dff1f97de174963b68e\n       , 0xb2168e4e0f18b0e64100b517ed95257d73f0620df885c13d2ecf79367b384cee\n       , 0x2e7dec2428853b2c71760745541f7afe9825b5dd77df06511d8441a94bacc927\n       , 0xca9ffac4c43f0b48461dc5c263bea3f6f00611ceacabf6f895ba2b0101dbb68d\n       , 0x7410d42d8fd1d5e9d2f5815cb93417998828ef3c4230bfbd412df0a4a7a2507a\n       , 0x5010f684516dccd0b6ee0852c2512b4dc0066cf0d56f35302978db8ae32c6a81\n       , 0xacaab585f7b79b719935ceb89523ddc54827f75c56883856154a56cdcd5ee988\n       , 0x666de5d1440fee7331aaf0123a62ef2d8ba57453a0769635ac6cd01e633f7712\n       , 0xa6f98658f6eabaf902d8b3871a4b101d16196e8a4b241e1558fe29966e103e8d\n       , 0x891546a8b29f3047ddcfe5b00e45fd55756373105ea8637dfcff547b6ea9535f\n       , 0x18dfbc1ac5d25b0761137dbd22c17c829d0f0ef1d82344e9c89c286694da24e8\n       , 0xb54b9b67f8fed54bbf5a2666dbdf4b23cff1d1b6f4afc985b2e6d3305a9ff80f\n       , 0x7db442e132ba59bc1289aa98b0d3e806004f8ec12811af1e2e33c69bfde729e1\n       , 0x250f37cdc15e817d2f160d9956c71fe3eb5db74556e4adf9a4ffafba74010396\n       , 0x4ab8a3dd1ddf8ad43dab13a27f66a6544f290597fa96040e0e1db9263aa479f8\n       , 0xee61727a0766df939ccdc860334044c79a3c9b156200bc3aa32973483d8341ae\n       , 0x3f68c7ec63ac11ebb98f94b339b05c104984fda50103060144e5a2bfccc9da95\n       , 0x056f29816b8af8f56682bc4d7cf094111da7733e726cd13d6b3e8ea03e92a0d5\n       , 0xf5ec43a28acbeff1f3318a5bcac7c66ddb5230b79db2d105bcbe15f3c1148d69\n       , 0x2a6960ad1d8dd547555cfbd5e4600f1eaa1c8eda34de0374ec4a26eaaaa33b4e\n       , 0xdcc1ea7baab93384f76b796866199754742f7b96d6b4c120165c04a6c4f5ce10\n       , 0x13d5df179221379c6a78c07c793ff53487cae6bf9fe882541ab0e735e3eada3b\n       , 0x8c59e4407641a01e8ff91f9980dc236f4ecd6fcf52589a099a961633967714e1\n       , 0x833b1ac6a251fd08fd6d908fea2a4ee1e040bca93fc1a38ec3820e0c10bd82ea\n       , 0xa244f927f3b40b8f6c391570c765418f2f6e708eac9006c51a7feff4af3b2b9e\n       , 0x3d99ed9550cf1196e6c4d20c259620f858c3d703374c128ce7b590310c83046d\n       , 0x2b35c47d7b87761f0ae43ac56ac27b9f25830367b595be8c240e94600c6e3312\n       , 0x5d11ed37d24dc767305cb7e1467d87c065ac4bc8a426de38991ff59aa8735d02\n       , 0xb836478e1ca0640dce6fd910a5096272c8330990cd97864ac2bf14ef6b23914a\n       , 0x9100f946d6ccde3a597f90d39fc1215baddc7413643d85c21c3eee5d2dd32894\n       , 0xda70eedd23e663aa1a74b9766935b479222a72afba5c795158dad41a3bd77e40\n       , 0xf067ed6a0dbd43aa0a9254e69fd66bdd8acb87de936c258cfb02285f2c11fa79\n       , 0x715c99c7d57580cf9753b4c1d795e45a83fbb228c0d36fbe20faf39bdd6d4e85\n       , 0xe457d6ad1e67cb9bbd17cbd698fa6d7dae0c9b7ad6cbd6539634e32a719c8492\n       , 0xece3ea8103e02483c64a70a4bdcee8ceb6278f2533f3f48dbeedfba94531d4ae\n       , 0x388aa5d3667a97c68d3d56f8f3ee8d3d36091f17fe5d1b0d5d84c93b2ffe40bd\n       , 0x8b6b31b9ad7c3d5cd84bf98947b9cdb59df8a25ff738101013be4fd65e1dd1a3\n       , 0x066291f6bbd25f3c853db7d8b95c9a1cfb9bf1c1c99fb95a9b7869d90f1c2903\n       , 0xa707efbccdceed42967a66f5539b93ed7560d467304016c4780d7755a565d4c4\n       , 0x38c53dfb70be7e792b07a6a35b8a6a0aba02c5c5f38baf5c823fdfd9e42d657e\n       , 0xf2911386501d9ab9d720cf8ad10503d5634bf4b7d12b56dfb74fecc6e4093f68\n       , 0xc6f2bdd52b81e6e4f6595abd4d7fb31f651169d00ff326926b34947b28a83959\n       , 0x293d94b18c98bb3223366b8ce74c28fbdf28e1f84a3350b0eb2d1804a577579b\n       , 0x2c2fa5c0b51533165bc375c22e2781768270a383985d13bd6b67b6fd67f889eb\n       , 0xcaa09b82b72562e43f4b2275c091918e624d911661cc811bb5faec51f6088ef7\n       , 0x24761e45e674395379fb17729c78cb939e6f74c5dffb9c961f495982c3ed1fe3\n       , 0x55b70a82131ec94888d7ab54a7c515255c3938bb10bc784dc9b67f076e341a73\n       , 0x6ab9057b977ebc3ca4d4ce74506c25cccdc566497c450b5415a39486f8657a03\n       , 0x24066deee0ecee15a45f0a326d0f8dbc79761ebb93cf8c0377af440978fcf994\n       , 0x20000d3f66ba76860d5a950688b9aa0d76cfea59b005d859914b1a46653a939b\n       , 0xb92daa79603e3bdbc3bfe0f419e409b2ea10dc435beefe2959da16895d5dca1c\n       , 0xe947948705b206d572b0e8f62f66a6551cbd6bc305d26ce7539a12f9aadf7571\n       , 0x3d67c1b3f9b23910e3d35e6b0f2ccf44a0b540a45c18ba3c36264dd48e96af6a\n       , 0xc7558babda04bccb764d0bbf3358425141902d22391d9f8c59159fec9e49b151\n       , 0x0b732bb035675a50ff58f2c242e4710aece64670079c13044c79c9b7491f7000\n       , 0xd120b5ef6d57ebf06eaf96bc933c967b16cbe6e2bf00741c30aa1c54ba64801f\n       , 0x58d212ad6f58aef0f80116b441e57f6195bfef26b61463edec1183cdb04fe76d\n       , 0xb8836f51d1e29bdfdba325565360268b8fad627473edecef7eaefee837c74003\n       , 0xc547a3c124ae5685ffa7b8edaf96ec86f8b2d0d50cee8be3b1f0c76763069d9c\n       , 0x5d168b769a2f67853d6295f7568be40bb7a16b8d65ba87635d1978d2ab11ba2a\n       , 0xa2f675dc7302638cb60201064ca55077714d71fe096a315f2fe7401277caa5af\n       , 0xc8aab5cd0160ae78cd2e8ac5fb0e093cdb5c4b6052a0a97bb04216826fa7a437\n       , 0xff68ca4035bfeb43fbf145fddd5e43f1cea54f11f7bee13058f027329a4a5fa4\n       , 0x1d4e5487ae3c740f2ba6e541ac91bc2bfcd2999c518d807b426748803a350fd4\n       , 0x6d244e1a06ce4ef578dd0f63aff0936706735119ca9c8d22d86c801414ab9741\n       , 0xdecf7329dbcc827b8fc524c9431e8998029ece12ce93b7b2f3e769a941fb8cea\n       , 0x2fafcc0f2e63cbd07755be7b75ecea0adff9aa5ede2a52fdab4dfd0374cd483f\n       , 0xaa85010dd46a546b535ef4cf5f07d65161e89828f3a77db7b9b56f0df59aae45\n       , 0x07e8e1ee732cb0d356c9c0d1069c89d17adf6a9a334f745ec7867332548ca8e9\n       , 0x0e01e81cada8162bfd5f8a8c818a6c69fedf02ceb5208523cbe5313b89ca1053\n       , 0x6bb6c6472655084399852e00249f8cb247896d392b02d73b7f0dd818e1e29b07\n       , 0x42d4636e2060f08f41c882e76b396b112ef627cc24c43dd5f83a1d1a7ead711a\n       , 0x4858c9a188b0234fb9a8d47d0b4133650a030bd0611b87c3892e94951f8df852\n       , 0x3fab3e36988d445a51c8783e531be3a02be40cd04796cfb61d40347442d3f794\n       , 0xebabc49636bd433d2ec8f0e518732ef8fa21d4d071cc3bc46cd79fa38a28b810\n       , 0xa1d0343523b893fca84f47feb4a64d350a17d8eef5497ece697d02d79178b591\n       , 0x262ebfd9130b7d28760d08ef8bfd3b86cdd3b2113d2caef7ea951a303dfa3846\n       , 0xf76158edd50a154fa78203ed2362932fcb8253aae378903eded1e03f7021a257\n       , 0x26178e950ac722f67ae56e571b284c0207684a6334a17748a94d260bc5f55274\n       , 0xc378d1e493b40ef11fe6a15d9c2737a37809634c5abad5b33d7e393b4ae05d03\n       , 0x984bd8379101be8fd80612d8ea2959a7865ec9718523550107ae3938df32011b\n       , 0xc6f25a812a144858ac5ced37a93a9f4759ba0b1c0fdc431dce35f9ec1f1f4a99\n       , 0x924c75c94424ff75e74b8b4e94358958b027b171df5e57899ad0d4dac37353b6\n       , 0x0af35892a63f45931f6846ed190361cd073089e077165714b50b81a2e3dd9ba1\n       , 0xcc80cefb26c3b2b0daef233e606d5ffc80fa17427d18e30489673e06ef4b87f7\n       , 0xc2f8c8117447f3978b0818dcf6f70116ac56fd184dd1278494e103fc6d74a887\n       , 0xbdecf6bfc1ba0df6e862c831992207796acc797968358828c06e7a51e090098f\n       , 0x24d1a26e3dab02fe4572d2aa7dbd3ec30f0693db26f273d0ab2cb0c13b5e6451\n       , 0xec56f58b09299a300b140565d7d3e68782b6e2fbeb4b7ea97ac057989061dd3f\n       , 0x11a437c1aba3c119ddfab31b3e8c841deeeb913ef57f7e48f2c9cf5a28fa42bc\n       , 0x53c7e6114b850a2cb496c9b3c69a623eaea2cb1d33dd817e4765edaa6823c228\n       , 0x154c3e96fee5db14f8773e18af14857913509da999b46cdd3d4c169760c83ad2\n       , 0x40b9916f093e027a8786641818920620472fbcf68f701d1b680632e6996bded3\n       , 0x24c4cbba07119831a726b05305d96da02ff8b148f0da440fe233bcaa32c72f6f\n       , 0x5d201510250020b783689688abbf8ecf2594a96a08f2bfec6ce0574465dded71\n       , 0x043b97e336ee6fdbbe2b50f22af83275a4084805d2d5645962454b6c9b8053a0\n       , 0x564835cbaea774948568be36cf52fcdd83934eb0a27512dbe3e2db47b9e6635a\n       , 0xf21c33f47bde40a2a101c9cde8027aaf61a3137de2422b30035a04c270894183\n       , 0x9db0ef74e66cbb842eb0e07343a03c5c567e372b3f23b943c788a4f250f67891\n       , 0xab8d08655ff1d3fe8758d562235fd23e7cf9dcaad658872a49e5d3183b6ccebd\n       , 0x6f27f77e7bcf46a1e963ade0309733543031dccdd47caac174d7d27ce8077e8b\n       , 0xe3cd54da7e444caa6207569525a670ebae1278de4e3fe2684b3e33f5ef90cc1b\n       , 0xb2c3e33a51d22c4c08fc0989c873c9cc4150579b1e6163fa694ad51d53d712dc\n       , 0xbe7fda983e13189b4c77e0a80920b6e0e0ea80c3b84dbe7e7117d253f48112f4\n       , 0xb6008c28fae08aa427e5bd3aad36f10021f16c77cfeabed07f97cc7dc1f1284a\n       , 0x6e4e6760c538f2e97b3adbfbbcde57f8966b7ea8fcb5bf7efec913fd2a2b0c55\n       , 0x4ae51fd1834aa5bd9a6f7ec39fc663338dc5d2e20761566d90cc68b1cb875ed8\n       , 0xb673aad75ab1fdb5401abfa1bf89f3add2ebc468df3624a478f4fe859d8d55e2\n       , 0x13c9471a9855913539836660398da0f3f99ada08479c69d1b7fcaa3461dd7e59\n       , 0x2c11f4a7f99a1d23a58bb636350fe849f29cbac1b2a1112d9f1ed5bc5b313ccd\n       , 0xc7d3c0706b11ae741c05a1ef150dd65b5494d6d54c9a86e2617854e6aeeebbd9\n       , 0x194e10c93893afa064c3ac04c0dd808d791c3d4b7556e89d8d9cb225c4b33339\n       , 0x6fc4988b8f78546b1688991845908f134b6a482e6994b3d48317bf08db292185\n       , 0x5665beb8b0955525813b5981cd142ed4d03fba38a6f3e5ad268e0cc270d1cd11\n       , 0xb883d68f5fe51936431ba4256738053b1d0426d4cb64b16e83badc5e9fbe3b81\n       , 0x53e7b27ea59c2f6dbb50769e43554df35af89f4822d0466b007dd6f6deafff02\n       , 0x1f1a0229d4640f01901588d9dec22d13fc3eb34a61b32938efbf5334b2800afa\n       , 0xc2b405afa0fa6668852aee4d88040853fab800e72b57581418e5506f214c7d1f\n       , 0xc08aa1c286d709fdc7473744977188c895ba011014247e4efa8d07e78fec695c\n       , 0xf03f5789d3336b80d002d59fdf918bdb775b00956ed5528e86aa994acb38fe2d\n       ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/MiniLock\/prim\/TestHMAC.cry","filetype":"cry","content":"module TestHMAC where\n\nimport HMAC\nimport SHA256\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/MiniLock\/prim\/CryptoBox.cry","filetype":"cry","content":"module CryptoBox where\n\nimport Salsa20\nimport Poly1305\nimport CfrgCurves\n\ncrypto_box : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes)) => [msgBytes][8] -> [24][8] -> Public25519 -> Private25519 -> [msgBytes + 16][8]\ncrypto_box m n pub priv = crypto_secretbox m k n\n where\n  s          = Curve25519 priv pub\n  k          = HSalsa20_bytes `{r=20} s zero\n\ncrypto_box_open : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes)) => [msgBytes+16][8] -> [24][8] -> Public25519 -> Private25519 -> (Bit,[msgBytes][8])\ncrypto_box_open box n pub priv = crypto_secretbox_open box k n\n where\n  (tag,ct)  = splitAt `{16} box\n  s         = Curve25519 priv pub\n  k         = HSalsa20_bytes `{r=20} s zero\n\ncrypto_secretbox : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes))\n                => [msgBytes][8] -> [32][8] -> [24][8] -> [msgBytes + 16][8]\ncrypto_secretbox m k n = box\n where\n  blob       = XSalsa20_encrypt `{r=20} k n ((zero : [32][8]) # m)\n  authKey    = join (take `{32} blob)\n  ciphertext = drop `{32} blob\n  authTag    = Poly1305 authKey ciphertext\n  box        = authTag # ciphertext\n\ncrypto_secretbox_open : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes))\n                     => [msgBytes + 16][8] -> [32][8] -> [24][8] -> (Bit,[msgBytes][8])\ncrypto_secretbox_open box k n = (valid,pt)\n where\n  (tag,ct)  = splitAt `{16} box\n  blob      = XSalsa20_encrypt `{r=20} k n ((zero : [32][8]) # ct)\n  authKey   = join (take `{32} blob)\n  plaintext = drop blob                  : [msgBytes][8]\n  cTag      = Poly1305 authKey ct\n  valid     = cTag == tag\n  pt        = if valid then plaintext else zero\n\nproperty cat_in_a_box priv1 priv2 msg nonce = open == msg\n  where pub1 = Curve25519 priv1 basePoint25519\n        pub2 = Curve25519 priv2 basePoint25519\n        box  = crypto_box (msg : [100][8]) nonce pub2 priv1\n        open = (crypto_box_open box nonce pub1 priv2).1\n\nproperty hat_in_a_box k msg nonce = open == msg\n  where box  = crypto_secretbox (msg : [88][8]) k nonce\n        open = (crypto_secretbox_open box k nonce).1\n\nproperty crypto_box_kats = zero != [ katTest1 ]\n\n\/\/ KAT generated from sodium\nkatTest1 = crypto_secretbox \"hello\" zero zero == split 0xc769f9d535dc338e99ac93440502c7ceae5bd79391\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Salsa20.cry","filetype":"cry","content":"\/\/ see http:\/\/cr.yp.to\/snuffle\/spec.pdf\n\nmodule Salsa20 where\n\nimport LittleEndian\n\nquarterround : [4][32] -> [4][32]\nquarterround [y0, y1, y2, y3] = [z0, z1, z2, z3]\n  where\n    z1 = y1 ^ ((y0 + y3) <<< 0x7)\n    z2 = y2 ^ ((z1 + y0) <<< 0x9)\n    z3 = y3 ^ ((z2 + z1) <<< 0xd)\n    z0 = y0 ^ ((z3 + z2) <<< 0x12)\n\nproperty quarterround_passes_tests =\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000000] == [0x00000000, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (quarterround [0x00000001, 0x00000000, 0x00000000, 0x00000000] == [0x08008145, 0x00000080, 0x00010200, 0x20500000]) \/\\\n  (quarterround [0x00000000, 0x00000001, 0x00000000, 0x00000000] == [0x88000100, 0x00000001, 0x00000200, 0x00402000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000001, 0x00000000] == [0x80040000, 0x00000000, 0x00000001, 0x00002000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000001] == [0x00048044, 0x00000080, 0x00010000, 0x20100001]) \/\\\n  (quarterround [0xe7e8c006, 0xc4f9417d, 0x6479b4b2, 0x68c67137] == [0xe876d72b, 0x9361dfd5, 0xf1460244, 0x948541a3]) \/\\\n  (quarterround [0xd3917c5b, 0x55f1c407, 0x52a58a7a, 0x8f887a3b] == [0x3e2f308c, 0xd90a8f36, 0x6ab2a923, 0x2883524c])\n\nrowround : [16][32] -> [16][32]\nrowround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =\n    [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]\n  where\n    [ z0,  z1,  z2,  z3] = quarterround [ y0,  y1,  y2,  y3]\n    [ z5,  z6,  z7,  z4] = quarterround [ y5,  y6,  y7,  y4]\n    [z10, z11,  z8,  z9] = quarterround [y10, y11,  y8,  y9]\n    [z15, z12, z13, z14] = quarterround [y15, y12, y13, y14]\n\nproperty rowround_passes_tests =\n  (rowround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n            [0x08008145, 0x00000080, 0x00010200, 0x20500000,\n             0x20100001, 0x00048044, 0x00000080, 0x00010000,\n             0x00000001, 0x00002000, 0x80040000, 0x00000000,\n             0x00000001, 0x00000200, 0x00402000, 0x88000100]) \/\\\n  (rowround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n             0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n             0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n             0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n            [0xa890d39d, 0x65d71596, 0xe9487daa, 0xc8ca6a86,\n             0x949d2192, 0x764b7754, 0xe408d9b9, 0x7a41b4d1,\n             0x3402e183, 0x3c3af432, 0x50669f96, 0xd89ef0a8,\n             0x0040ede5, 0xb545fbce, 0xd257ed4f, 0x1818882d])\n\n\nrowround_opt : [16][32] -> [16][32]\nrowround_opt ys = join [ (quarterround (yi<<<i))>>>i | yi <- split ys | i <- [0 .. 3] : [_][8] ]\n\nproperty rowround_opt_is_rowround ys = rowround ys == rowround_opt ys\n\ncolumnround : [16][32] -> [16][32]\ncolumnround [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15] =\n    [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15]\n  where\n    [ y0,  y4,  y8, y12] = quarterround [ x0,  x4,  x8, x12]\n    [ y5,  y9, y13,  y1] = quarterround [ x5,  x9, x13,  x1]\n    [y10, y14,  y2,  y6] = quarterround [x10, x14,  x2,  x6]\n    [y15,  y3,  y7, y11] = quarterround [x15,  x3,  x7, x11]\n\nproperty columnround_passes_tests =\n  (columnround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x10090288, 0x00000000, 0x00000000, 0x00000000,\n                0x00000101, 0x00000000, 0x00000000, 0x00000000,\n                0x00020401, 0x00000000, 0x00000000, 0x00000000,\n                0x40a04001, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (columnround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n                0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n                0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n                0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n               [0x8c9d190a, 0xce8e4c90, 0x1ef8e9d3, 0x1326a71a,\n                0x90a20123, 0xead3c4f3, 0x63a091a0, 0xf0708d69,\n                0x789b010c, 0xd195a681, 0xeb7d5504, 0xa774135c,\n                0x481c2027, 0x53a8e4b5, 0x4c1f89c5, 0x3f78c9c8])\n\n\ncolumnround_opt : [16][32] -> [16][32]\ncolumnround_opt xs = join (transpose [ (quarterround (xi<<<i))>>>i | xi <- transpose(split xs) | i <- [0 .. 3] : [_][8] ])\n\ncolumnround_opt_is_columnround xs = columnround xs == columnround_opt xs\n\nproperty columnround_is_transpose_of_rowround ys =\n  rowround ys == join(transpose(split`{4}(columnround xs)))\n  where xs = join(transpose(split`{4} ys))\n\ndoubleround : [16][32] -> [16][32]\ndoubleround(xs) = rowround(columnround(xs))\n\nproperty doubleround_passes_tests =\n  (doubleround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x8186a22d, 0x0040a284, 0x82479210, 0x06929051,\n                0x08000090, 0x02402200, 0x00004000, 0x00800000,\n                0x00010200, 0x20400000, 0x08008104, 0x00000000,\n                0x20500000, 0xa0000040, 0x0008180a, 0x612a8020]) \/\\\n  (doubleround [0xde501066, 0x6f9eb8f7, 0xe4fbbd9b, 0x454e3f57,\n                0xb75540d3, 0x43e93a4c, 0x3a6f2aa0, 0x726d6b36,\n                0x9243f484, 0x9145d1e8, 0x4fa9d247, 0xdc8dee11,\n                0x054bf545, 0x254dd653, 0xd9421b6d, 0x67b276c1] ==\n               [0xccaaf672, 0x23d960f7, 0x9153e63a, 0xcd9a60d0,\n                0x50440492, 0xf07cad19, 0xae344aa0, 0xdf4cfdfc,\n                0xca531c29, 0x8e7943db, 0xac1680cd, 0xd503ca00,\n                0xa74b2ad6, 0xbc331c5c, 0x1dda24c7, 0xee928277])\n\nSalsa20 : {r} (8 >= width r) => [64][8] -> [64][8]\nSalsa20 xs = join ar\n  where\n    ar = [ littleendian_inverse words | words <- xw + zs@(`r\/2 : [8]) ]\n    xw = [ littleendian xi | xi <- split xs ]\n    zs = [xw] # [ doubleround zi | zi <- zs ]\n\nproperty Salsa20_bijective a b = (a == b) || (Salsa20 `{r=20} a != Salsa20 `{r=20} b)\nproperty Salsa20_passes_tests =\n  (Salsa20 `{r=20}\n           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0] ==\n           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]) \/\\\n  (Salsa20 `{r=20}\n            [211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37, 191, 187, 234, 136,\n             49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,  86,  16, 179, 207,\n             31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113, 238,  55, 204,  36,\n             79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,  88, 118, 104,  54] ==\n           [109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,  26, 110, 170, 154,\n             29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,  69, 144,  51,  57,\n            118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35,  27, 111, 114, 114,\n            219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158, 179,  19,  48, 202]) \/\\\n  (Salsa20 `{r=20}\n           [ 88, 118, 104,  54,  79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,\n            191, 187, 234, 136, 211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37,\n             86,  16, 179, 207,  49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,\n            238,  55, 204,  36,  31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113] ==\n           [179,  19,  48, 202, 219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158,\n             26, 110, 170, 154, 109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,\n             69, 144,  51,  57,  29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,\n             27, 111, 114, 114, 118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35])\n\nproperty Salsa20_has_no_collisions x1 x2 =\n    x1 == x2 \\\/ doubleround x1 != doubleround x2\n\/\/   if(x1 != x2) then (doubleround x1) != (doubleround x2) else True\n\nproperty Salsa20_passes_scrypt_tests =\n  Salsa20 `{r=8}\n          [ 0x7e, 0x87, 0x9a, 0x21, 0x4f, 0x3e, 0xc9, 0x86, 0x7c, 0xa9, 0x40, 0xe6, 0x41, 0x71, 0x8f, 0x26\n          , 0xba, 0xee, 0x55, 0x5b, 0x8c, 0x61, 0xc1, 0xb5, 0x0d, 0xf8, 0x46, 0x11, 0x6d, 0xcd, 0x3b, 0x1d\n          , 0xee, 0x24, 0xf3, 0x19, 0xdf, 0x9b, 0x3d, 0x85, 0x14, 0x12, 0x1e, 0x4b, 0x5a, 0xc5, 0xaa, 0x32\n          , 0x76, 0x02, 0x1d, 0x29, 0x09, 0xc7, 0x48, 0x29, 0xed, 0xeb, 0xc6, 0x8d, 0xb8, 0xb8, 0xc2, 0x5e\n          ]\n   == [ 0xa4, 0x1f, 0x85, 0x9c, 0x66, 0x08, 0xcc, 0x99, 0x3b, 0x81, 0xca, 0xcb, 0x02, 0x0c, 0xef, 0x05\n      , 0x04, 0x4b, 0x21, 0x81, 0xa2, 0xfd, 0x33, 0x7d, 0xfd, 0x7b, 0x1c, 0x63, 0x96, 0x68, 0x2f, 0x29\n      , 0xb4, 0x39, 0x31, 0x68, 0xe3, 0xc9, 0xe6, 0xbc, 0xfe, 0x6b, 0xc5, 0xb7, 0xa0, 0x6d, 0x96, 0xba\n      , 0xe4, 0x24, 0xcc, 0x10, 0x2c, 0x91, 0x74, 0x5c, 0x24, 0xad, 0x67, 0x3d, 0xc7, 0x61, 0x8f, 0x81\n      ]\n\n\/\/ Salsa 20 supports two key sizes, [16][8] and [32][8]\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(k, n) = z\n  where\n    [s0, s1, s2, s3] = split \"expand 32-byte k\" : [4][4][8]\n    [t0, t1, t2, t3] = split \"expand 16-byte k\" : [4][4][8]\n    x = if(`a == (2 : [8])) then s0 # k0 # s1 # n # s2 # k1 # s3\n                            else t0 # k0 # t1 # n # t2 # k0 # t3\n    z = Salsa20 `{r=20} x\n    [k0, k1] = (split(k#zero)):[2][16][8]\n\nSalsa20_encrypt : {a, l} (a >= 1, 2 >= a, l <= 2^^70) => ([16*a][8], [8][8], [l][8]) -> [l][8]\nSalsa20_encrypt(k, v, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(k, v#(split i)) | i <- [0, 1 ... ] ])\n    c     = m ^ salsa\n\nHSalsa20 : {r} (8 >= width r) => Key -> Nonce -> [8][32]\nHSalsa20 key0 nonce0 = zs @@ ([0,5,10,15,6,7,8,9] : [_][8])\n  where\n  zs    = infZs @ (`r\/2 :[8])\n  infZs = [xs] # [ doubleround x | x <- infZs ]\n\n  nonce                         = [ littleendian (split n) | n <- split (join nonce0)]\n  [x0,x5,x10,x15]               = Salsa20_Constant\n  [x1,x2,x3,x4,x11,x12,x13,x14] = [ littleendian (split k) | k <- split (join key0)]\n  [x6,x7,x8,x9]                 = nonce @@ ([0..3] : [_][8])\n\n  xs : [16][32]\n  xs     = [x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15]\n\nHSalsa20_bytes : {r} (8 >= width r) => Key -> Nonce -> [32][8]\nHSalsa20_bytes key0 nonce0 = join [littleendian_inverse x | x <- HSalsa20 `{r=r} key0 nonce0]\n\ntype Key      = [256\/8][8]\ntype Nonce    = [192\/8][8]\ntype Counter  = [64]\n\nSalsa20_Constant : [4][32]\nSalsa20_Constant = [littleendian (split x) | x <- split (join \"expand 32-byte k\") : [4][32]]\n\nXSalsa20 : {r} (8 >= width r) => Key -> Nonce -> Counter -> [64][8]\nXSalsa20 key0 nonce0 ctr =\n    split (join [littleendian (split (x' + z')) | x' <- xs' | z' <- zs'])\n  where\n  nonce                         = [ littleendian (split n) | n <- split (join nonce0)]\n\n  subKey = HSalsa20 `{r=r} key0 nonce0 \/\/ 'zs' in the literature\n\n  [x'0,x'5,x'10,x'15]                   = Salsa20_Constant\n  [x'1,x'2,x'3,x'4,x'11,x'12,x'13,x'14] = subKey\n  [x'6,x'7]                             = nonce @@ ([4,5] : [_][8])\n  [x'8,x'9]                             = reverse (split ctr)\n\n  xs', zs' : [16][32]\n  xs'       = [ x'0 ,x'1 ,x'2 ,x'3 ,x'4 ,x'5 ,x'6 ,x'7 ,x'8\n              , x'9 ,x'10 ,x'11 ,x'12 ,x'13 ,x'14 ,x'15\n              ]\n  infZs'    = [xs'] # [ doubleround x | x <- infZs' ]\n  zs'       = infZs' @ (`r\/2 : [8])\n\nXSalsa20_expansion : {n,r} (8 >= width r, 64 >= width n) => Key -> Nonce -> [n][8]\nXSalsa20_expansion k n = take (join ks)\n   where\n   ks = [XSalsa20 `{r=r} k n i | i <- [0...]]\n\nXSalsa20_encrypt : {n,r} (8 >= width r, 64 >= width n) => Key -> Nonce -> [n][8] -> [n][8]\nXSalsa20_encrypt k n msg = ks ^ msg\n where ks = XSalsa20_expansion `{r=r} k n\n\nproperty test =\n    ct == [0x00, 0x2d, 0x45, 0x13, 0x84, 0x3f, 0xc2, 0x40, 0xc4, 0x01, 0xe5, 0x41]\n  where\n   ct    = XSalsa20_encrypt `{r=20} key nonce \"Hello world!\"\n   key   = \"this is 32-byte key for xsalsa20\"\n   nonce = \"24-byte nonce for xsalsa\"\n\nproperty theorem1 a = quarterround [a, -a, a, -a] == [a,-a,a,-a]\nproperty theorem2 a b c d = rowround val == val\n    where val    = [a,-a,a,-a\n                   ,b,-b,b,-b\n                   ,c,-c,c,-c\n                   ,d,-d,d,-d]\nproperty theorem3 a b c d = columnround val == val\n    where val    = [a,-b,c,-d\n                   ,-a,b,-c,d\n                   ,a,-b,c,-d\n                   ,-a,b,-c,d]\nproperty theorem4 a = doubleround val == val\n    where val    = [a,-a,a,-a\n                   ,-a,a,-a,a\n                   ,a,-a,a,-a\n                   ,-a,a,-a,a]\nproperty theorem7 a b =\n    a ^ b != diff \\\/ Salsa20Words a == Salsa20Words b\n where\n  diff = [ 0x80000000 | _ <- [0..15]:[_][4] ]\n\nSalsa20Words : [16][32] -> [16][32]\nSalsa20Words x = [join (reverse r) | r <- split `{each=4} (Salsa20 `{r=20} (join [reverse (split `{4} v) | v <- x]))]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/MiniLock\/prim\/PBKDF2.cry","filetype":"cry","content":"module PBKDF2 where\n\nimport SHA256\nimport HMAC\n\n\/\/ PBKDF2 specialized to HMAC_SHA256 to avoid monomorphic type issues.\npbkdf2 : {pwBytes, saltBytes, dkLenBits, C}\n         ( 64 >= width (8 * pwBytes)\n         , dkLenBits >= 1\n         , fin dkLenBits\n         , C >= 1\n         , 16 >= width C\n         , 32 >= width (4 + saltBytes)\n         , 32 >= width ((dkLenBits + 255)\/256)\n         )\n      => [pwBytes][8] -> [saltBytes][8] -> [dkLenBits]\npbkdf2 P S = take `{dkLenBits} (join Ts)\n where\n Ts : [_][256]\n Ts = [ inner `{C=C} P (split (hmacSHA256 P (S # split i))) | i <- [1..len] : [_][32] ]\n type len = (dkLenBits + 255)\/256\n\ninner : {pwBytes, C}\n         ( 64 >= width (8 * pwBytes)\n         , C >= 1, 16 >= width C\n         )\n     =>  [pwBytes][8] -> [32][8] -> [256]\ninner P U0 = (Ts @ 0).0  where\n  \/\/ Ts : [_][([256],[32][8])]\n  Ts = [(join U0, U0)] # [ F P t u  | _ <- [1..C] : [_][16] | (t,u) <- Ts ]\n\nF : {pwBytes} ( 64 >= width (8 * pwBytes)\n              ) => [pwBytes][8] -> [256] -> [32][8] -> ([256],[32][8])\nF P Tprev Uprev = (Tnext,Unext)\n  where\n  Unext = split (hmacSHA256 P Uprev)\n  Tnext = Tprev ^ join Unext\n\n\ntest1 : Bit\nproperty test1 = pbkdf2 `{C=1,dkLenBits=64*8} \"passwd\" \"salt\" == 0x55ac046e56e3089fec1691c22544b605f94185216dde0465e68b9d57c20dacbc49ca9cccf179b645991664b39d77ef317c71b845b1e30bd509112041d3a19783\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Base64.cry","filetype":"cry","content":"module Base64 where\n\ntype Enc64 n = 4*(((3-(n%3))%3) + n)\/3\n\nbase64enc : {n,m,padZ} (4*(padZ + n)\/3 == m, fin n, fin m, padZ == (3-(n%3))%3, 2>=padZ)\n          => [n][8] -> [Enc64 n][8]\nbase64enc ns = take `{m} (chunks # padEq)\n where\n  chunks      = take `{(4*n+2)\/3} (base64chunks `{(n+2)\/3} (ns # padZero))\n  padZero     = take `{padZ} [zero | _ <- [1..2] : [_][2]]\n  padEq       = \"==\"\n\nalphabet = ['A'..'Z'] # ['a'..'z'] # ['0'..'9'] # \"+\/\"\n\n\nbase64chunks : {n} (fin n) => [n*3][8] -> [n*4][8]\nbase64chunks m = [basify x |  x <- ns]\n where\n  ns = split (join m) : [_][6]\n  basify : [6] -> [8]\n  basify x = alphabet @ x\n\n\/\/ Base64 strings are always in 4n byte chunks, the final chunk might be\n\/\/ padded. We can not give a proper cryptol implementation that strips the\n\/\/ padding because that would require the type, n, to depend on the value\n\/\/ (dependant types). Instead we return possibly excess bytes and, separetely,\n\/\/ the number of pad bytes (0,1 or 2) as a value.\nbase64dec : {n,m} (fin m, 4*n == 3*m, fin n) => [m][8] -> ([n][8],[2])\nbase64dec ms = (split (join [debase x | x <- ms]), nrEq)\n where\n nrEq : [2]\n nrEq = sum [ zero # [x == '='] | x <- take `{2} (reverse ms # [zero,zero]) ]\n\n debase : [8] -> [6]\n debase x = drop `{2} (debase' x)\n\n debase' : [8] -> [8]\n debase' x =\n    if x >= 'A' \/\\ x <= 'Z'\n        then x - 'A'\n        else if x >= 'a' \/\\ x <= 'z'\n              then x - 'a' + 26\n              else if x >= '0' \/\\ x <= '9'\n                    then x - '0' + 52\n                    else if x == '+'\n                        then 62\n                        else if x == '\/'\n                                then 63\n                                else zero \/\/ Pad bytes are decoded as NUL\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Base58.cry","filetype":"cry","content":"module Base58 where\n\n\/\/ Base 58 is a dependent format - the length of the encoded value depends on\n\/\/ the value being encoded This does not play well with Cryptol, which expects\n\/\/ a static type.   Thus we must consume the worst-case number of bytes and\n\/\/ produce a length value which we return to the callee.\n\n\/\/ Convert an N bit number (33 bytes for minilock) into a big endian base 58 representation (46 byte max for minilock).\nbase58enc : {n,m} (fin n, fin m, n >= 6 ) => [n] -> [m][8]\nbase58enc ns = [ x.1 | x <- reverse (take `{m} (drop `{1} enc))]\n where\n  enc      = [(ns,zero)] # [ (n\/58,charOf (n%58)) | (n,_) <- enc ]\n  charOf x = charMap @ x\n\ncharMap : [58][8]\ncharMap = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\nbase58dec : {n,m} (fin n, fin m, n >= 1, n >= width m, n >= 8) => [m][8] -> [n]\nbase58dec ms = sum [ (dec m) * 58 ^^ i | m <- reverse ms | i <- [0..m] ]\n where\n  dec : [8] -> [n]\n  dec x = zero # dec' x\n\n  dec' : [8] -> [8]\n  dec' x =\n    if x >= 'm'\n     then x - 'm' + 44\n     else if x >= 'a'\n            then x - 'a' + 33\n            else if x >= 'P'\n                  then x - 'P' + 22\n                  else if x > 'I'\n                        then x - 'J' + 17\n                        else if x >= 'A'\n                              then x - 'A' + 9\n                              else x - '1'\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/MiniLock\/prim\/bv.cry","filetype":"cry","content":"module bv where\n\n\/* Unsigned word extension. *\/\nuext : {a, b} (fin b,fin a) => [a] -> [a+b]\nuext(x) = zero # x\n\niext : {a, b} (fin b,fin a) => [a] -> [a+b]\niext(x) = (if x@0 then ~zero else zero) # x\n\n\/* Returns the (n+1)-bit sum of two n-bit numbers. *\/\nsafe_add : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_add(x,y) = uext(x) + uext(y)\n\n\/* returns the (n+1)-bit subtraction of two n-bit numbers. *\/\nsafe_sub : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_sub(x,y) = uext(x) - uext(y)\n\n\/* Is x in normalized form (relative to prime p)? *\/\nis_normal : {a} (fin a) => [a] -> [a] -> Bit\nis_normal p x = (x < p)\n\n\/* Returns the product of two inputs. *\/\nsafe_product : {a} (fin a) => ([a],[a]) -> [2*a]\nsafe_product(x,y) = uext(x) * uext(y)\n\n\/* Returns module reduction on input. *\/\nsafe_mod : {a, b} (fin a, fin b) => ([b],[a+b]) -> [b]\nsafe_mod(p,x) = drop `{a} (x % uext(p))\n\n\/* Add two n-bit numbers and input carry to obtain a n bit number and output carry. *\/\nadc : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nadc(x,y) = (drop(sm), sm@0)\n  where sm = safe_add(x,y)\n\n\/* sbb(x,y) subtracts y from x, and returns result along with output borrow bit. *\/\nsbb : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nsbb(x,y) = (drop(r), r@0)\n  where r = ([False] # x) - ([False] # y)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/MiniLock\/prim\/LittleEndian.cry","filetype":"cry","content":"module LittleEndian where\n\n\n\/\/ Takes a finite sequence of bytes, and turns them into a word via\n\/\/ a little-endian interpretation\nlittleendian : {a}(fin a) => [a][8] -> [a*8]\nlittleendian b = join(reverse b)\n\nproperty littleendian_passes_tests =\n  (littleendian [  0,   0,   0,   0] == 0x00000000) &&\n  (littleendian [ 86,  75,  30,   9] == 0x091e4b56) &&\n  (littleendian [255, 255, 255, 250] == 0xfaffffff)\n\nlittleendian_inverse : [32] -> [4][8]\nlittleendian_inverse b = reverse(split b)\n\nproperty littleendian_is_invertable b = littleendian_inverse(littleendian b) == b\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/param_modules\/AES\/SBox.cry","filetype":"cry","content":"module AES::SBox where\n\nimport AES::GF28\nimport AES::SubBytePlain\n\ntype SBox = [256] GF28\n\nsbox : SBox\nsbox = [ SubByte x | x <- [0 .. 255] ]\n\nsboxInv : SBox\nsboxInv = [ InvSubByte x | x <- [0 .. 255] ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/param_modules\/AES\/SubByteSBox.cry","filetype":"cry","content":"module AES::SubByteSBox where\n\nimport AES::GF28\nimport AES::SBox\n\nSubByte : GF28 -> GF28\nSubByte b = sbox @ b\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = sboxInv @ b\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/lib\/Cryptol\/Reference.cry","filetype":"cry","content":"module Cryptol::Reference where\n\n\/**\n * Performs multiplication of polynomials over GF(2).\n * Reference implementation.\n *\/\npmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\npmult x y = last zs\n  where\n    zs = [0] # [ (z << 1) ^ (if yi then 0 # x else 0) | yi <- y | z <- zs ]\n\n\/**\n * Performs division of polynomials over GF(2).\n * Reference implementation.\n *\/\npdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\npdiv x y = [ z ! degree | z <- zs ]\n  where\n    degree : [width v]\n    degree = last (ds : [1 + v]_)\n      where ds = [0\/0] # [if yi then i else d | yi <- reverse y | i <- [0..v] | d <- ds ]\n\n    reduce : [v] -> [v]\n    reduce u = if u ! degree then u ^ y else u\n\n    zs : [u][v]\n    zs = [ tail (reduce z # [xi]) | z <- [0] # zs | xi <- x ]\n\n\/**\n * Performs modulus of polynomials over GF(2).\n * Reference implementation.\n *\/\npmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\npmod x y = if y == 0 then 0\/0 else last zs\n  where\n    degree : [width v]\n    degree = last (ds : [2 + v]_)\n      where ds = [0\/0] # [if yi then i else d | yi <- reverse y | i <- [0..v] | d <- ds ]\n\n    reduce : [1 + v] -> [1 + v]\n    reduce u = if u ! degree then u ^ y else u\n\n    powers : [inf][1 + v]\n    powers = [reduce 1] # [ reduce (p << 1) | p <- powers ]\n\n    zs = [0] # [ z ^ (if xi then tail p else 0) | xi <- reverse x | p <- powers | z <- zs ]\n\n\/**\n * Functional left fold.\n *\n * foldl (+) 0 [1,2,3] = ((0 + 1) + 2) + 3\n *\n * Reference implementation.\n *\/\nfoldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\nfoldl f z bs = last (scanl f z bs)\n\n\/**\n * Scan left is like a foldl that also emits the intermediate values.\n *\n * Reference implementation.\n *\/\nscanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\nscanl f z bs = as\n  where\n    as = [z] # [ f a b | a <- as | b <- bs ]\n\n\/**\n * Map a function iteratively over a seed value, producing an infinite\n * list of successive function applications.\n *\n * Reference implementation.\n *\/\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = xs\n  where xs = [z] # [ f x | x <- xs ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol_eval\/test-files\/M.cry","filetype":"cry","content":"module M where\nf : [8] -> [2][8]\nf x = repeat x\n\ng : [8] -> [2][8]\ng x = [x, x]\n\nh : [2][8] -> [2][8]\nh x = x\n\nm : {a} (fin a, a > 42) => Z a\nm = 42\n\n\ntwo : [15]\ntwo = 2\n\nthree : [16]\nthree = 3\n\nfour : [17]\nfour = 4\n\nid : {a} a -> a\nid x = x\n\ntype Word8 = [8]\ntype Twenty a = [20]a\n\nisSqrtOf9 : [8] -> Bit\nisSqrtOf9 x = x*x == 9\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Names.cry","filetype":"cry","content":"module Names where\n\n\/\/ Examples of names included in `names()` (term names)\n\nparameter\n  key : [64]\n\nenc : [64] -> [64]\nenc x = x ^ key\n\nenc_correct : [64] -> Bit\nproperty enc_correct x =\n  x == enc (enc x)\n\nprimitive prim : [64] -> [64]\n\n(-!) : [64] -> [64] -> [64]\nx -! y = if y > x then 0 else x - y\n\n\/\/ Examples of names not included in `names()` (type and module names)\n\nparameter\n  type a : #\n\ntype b = a\n\ntype constraint fin_b = fin b\n\nprimitive type c : *\n\nnewtype d = { un_d : c }\n\nsubmodule M where\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Id.cry","filetype":"cry","content":"module Id where\n\nid : {n} (fin n) => [n] -> [n]\nid a = a\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/CplxQNewtype.cry","filetype":"cry","content":"\/\/ This is a development of rational complex numbers\n\ntype Q = Rational\n\nfortyTwo : Q\nfortyTwo = 42\n\n\/\/ Complex rational numbers in rectangular coordinates\nnewtype CplxQ =\n  { real : Q, imag : Q }\n\nembedQ : Q -> CplxQ\nembedQ x = CplxQ{ real = x, imag = 0 }\n\ncplxTwo : CplxQ\ncplxTwo = embedQ 2\n\ncplxForty : CplxQ\ncplxForty = embedQ 40\n\ncplxFortyTwo : CplxQ\ncplxFortyTwo = embedQ 42\n\n\ncplxAdd : CplxQ -> CplxQ -> CplxQ\ncplxAdd x y = CplxQ { real = r, imag = i }\n  where\n  r = x.real + y.real\n  i = x.imag + y.imag\n\ncplxMul : CplxQ -> CplxQ -> CplxQ\ncplxMul x y = CplxQ { real = r, imag = i }\n  where\n  r = x.real * y.real - x.imag * y.imag\n  i = x.real * y.imag + x.imag * y.real\n\ncplxEq : CplxQ -> CplxQ -> Bit\ncplxEq x y = (x.real == y.real) && (x.imag == y.imag)\n\nproperty cplxAddAssoc x y z =\n  cplxEq (cplxAdd (cplxAdd x y) z)\n         (cplxAdd x (cplxAdd y z))\n\nproperty cplxMulAssoc x y z =\n  cplxEq (cplxMul (cplxMul x y) z)\n         (cplxMul x (cplxMul y z))\n\nproperty cplxMulDistrib x y z =\n  cplxEq (cplxMul x (cplxAdd y z))\n         (cplxAdd (cplxMul x y) (cplxMul x z))\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Foo.cry","filetype":"cry","content":"module Foo where\n\nimport Id as Id\n\nid : {a} a -> a\nid x = x\n\nx : [8]\nx = 255\n\nadd : {a} (fin a) => [a] -> [a] -> [a]\nadd = (+)\n\nfoo : {foo : [32], bar : [32]} \nfoo = {foo = 23, bar = 99}\n\ngetFoo : {foo : [32], bar : [32]}  -> [32]\ngetFoo x = x.foo\n\nop1 : {n} (fin n) => [n] -> [n + 1]\nop1 a = 0\n\nop2 : {n} (fin n) => [n] -> [n - n]\nop2 a = 0\n\nop3 : {n} (fin n) => [n] -> [n * 1]\nop3 a = 0\n\nop4 : {n} (fin n) => [n] -> [n \/ 1]\nop4 a = 0\n\nop5 : {n} (fin n) => [n] -> [n % 1]\nop5 a = 0\n\nop6 : {n} (fin n) => [n] -> [n ^^ 1]\nop6 a = 0\n\nop7 : {n} (fin n) => [n] -> [n \/^ 1]\nop7 a = 0\n\nop8 : {n} (fin n) => [n] -> [width n]\nop8 a = 0\n\nop9 : {n} (fin n) => [n] -> [max n 1]\nop9 a = 0\n\nop10 : {n} (fin n) => [n] -> [min 1 n]\nop10 a = 0\n\nop11 : {n} (fin n) => [n] -> [lg2 n]\nop11 a = 0\n\nisSqrtOf9 : [8] -> Bit\nisSqrtOf9 x = x*x == 9","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Types.cry","filetype":"cry","content":"module Types where\n\nb : Bit\nb = True\n\nw : [16]\nw = 42\n\nz : Integer\nz = 420000\n\nm : Z 12\nm = 6\n\nq : Rational\nq = ratio 5 4\n\nt : (Bit, Integer)\nt = (False, 7)\n\ns : [3][3][8]\ns = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nr : {xCoord : [32], yCoord : [32]}\nr = {xCoord = 12 : [32], yCoord = 21 : [32]}\n\nid : {n} (fin n) => [n] -> [n]\nid a = a\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/ntt.cry","filetype":"cry","content":"\/* It type checks, and it succeeds in meeting the ntt_correct property\n   below which says that the inverse ntt applied to the ntt is the\n   identity function.  It also shows a way to use fast algorithms to\n   compute the naive ntt. *\/\n\nmodule Common::ntt where\n\n\/*\n * Dilithium parameters:\n * q = 8380417\n * n = 256\n * r = 1753\n *\/\n\ntype q = 8380417\n\ntype Fld = Z q\n\ntype nn = 256\n\n\/**\n * Primitive 512-th root of unity r mod q\n *\/\nr : Fld\nr = 1753\n\n\/* Naive NTT *\/\n\nall_powers : {n} (fin n) => Fld -> [n]Fld\nall_powers w = take`{n} (iterate ((*) w) 1)\n\nodd_powers : {n} (fin n) => Fld -> [n]Fld\nodd_powers w = take`{n} (iterate ((*) (w * w)) w)\n\nnaive_ntt : {n} (fin n) => [n]Fld -> [n]Fld\nnaive_ntt xs = map (polyeval xs) (odd_powers r)\n\n\/\/ Little endian\npolyeval : {n} (fin n) => [n]Fld -> Fld -> Fld\npolyeval p x = foldl (\\y pi -> (x * y) + pi) 0 (reverse p)\n\n\/**\n * n = 256 and ivn is the inverse of n in the field.\n *\/\nivn : Fld\nivn = recip (`nn : Fld)\n\n\/**\n * Inverse of the root of unity\n *\/\nivr : Fld\nivr = recip r\n\nnaive_ivntt : {n} (fin n) => [n]Fld -> [n]Fld\nnaive_ivntt xs = map ((*) ivn) ys\n  where\n    ys = [ foldl (+) 0 (zipWith (*) (reverse xs) (odd_powers wi))\n         | wi <- all_powers r ]\n\n\/**\n * ```repl\n * :check naive_ntt_correct\n * ```\n *\/\nnaive_ntt_correct : [nn]Fld -> Bool\nproperty naive_ntt_correct a = naive_ivntt (naive_ntt a) == a\n\n\/**\n * Unit vectors\n *\/\nunit : {n} (n < nn) => [nn]Fld\nunit =\n  [ if `n == i then 1 else 0 | i <- [0 .. <nn]]\n\n\/* Recursive NTT *\/\n\n\/**\n * Powers of the squares of the primitive root of unity\n *\/\nroots : [inf]Fld\nroots = iterate ((*) (r * r)) 1\n\n\/**\n * An O(n log n) number theortic transform for Dilithium.\n *\/\nntt : [nn]Fld -> [nn]Fld\nntt a = ntt_r`{lg2 nn} 0 a\n\nntt_r : {n} (fin n) => Integer -> [2 ^^ n]Fld -> [2 ^^ n]Fld\nntt_r depth a\n  | n == 0 =>  a\n  | n > 0 => butterfly depth even odd\n    where\n      (lft, rht) = shuffle a\n      even = ntt_r`{n - 1} (depth + 1) lft\n      odd = ntt_r`{n - 1} (depth + 1) rht\n\n\/**\n * Group even indices in first half and odd indices in second half.\n * This implementation uses list comprehension to make the code\n * obviously correct.\n *\/\nshuffle : {n, a} (fin n, n > 0) => [2 * n]a -> ([n]a, [n]a)\nshuffle a =\n  ([ a @ (i * 2) | i <- [0 .. <n]], [ a @ (i * 2 + 1) | i <- [0 .. <n]])\n\n\/**\n * Perform the butterfly operation.\n *\/\nbutterfly : {n} (fin n, n > 0) => Integer -> [n]Fld -> [n]Fld -> [2*n]Fld\nbutterfly depth even odd =\n  lft # rht\n  where\n    j = 2 ^^ depth\n    lft = [ even @ i + roots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n    rht = [ even @ i - roots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n\n\/* INVERSE NTT *\/\n\n\/**\n * Powers of the inverse squares of the root of unity\n *\/\nivroots : [inf]Fld\nivroots = iterate ((*) (ivr * ivr)) 1\n\n\/**\n * An O(n log n) inverse number theortic transform for Dilithium.\n *\/\nivntt : [nn]Fld -> [nn]Fld\nivntt a =\n  map ((*) ivn) (ivntt_r`{lg2 nn} 0 a)\n\nivntt_r : {n} (fin n) => Integer -> [2 ^^ n]Fld -> [2 ^^ n]Fld\nivntt_r depth a\n  | n == 0 => a\n  | n > 0 => ivbutterfly depth even odd\n    where\n      (lft, rht) = shuffle a\n      even = ivntt_r`{n - 1} (depth + 1) lft\n      odd = ivntt_r`{n - 1} (depth + 1) rht\n\n\/**\n * Perform the butterfly operation with inverse roots.\n *\/\nivbutterfly : {n} (fin n, n > 0) => Integer -> [n]Fld -> [n]Fld -> [2 * n]Fld\nivbutterfly depth even odd =\n  lft # rht\n  where\n    j = 2 ^^ depth\n    lft = [ even @ i + ivroots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n    rht = [ even @ i - ivroots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n\n\/**\n * Takes ~20s to prove.\n * ```repl\n * :prove ntt_correct\n * ```\n *\/\nntt_correct : [nn]Fld -> Bool\nproperty ntt_correct a = ivntt (ntt a) == a\n\n\/* Connection with naive ntt and recursive ntt *\/\n\nfntt : [nn]Fld -> [nn]Fld\nfntt xs = ntt (zipWith (*) xs (all_powers r))\n\n\/**\n * Takes ~40s to prove.\n * ```repl\n * :prove fntt_correct\n * ```\n *\/\nfntt_correct : [nn]Fld -> Bool\nproperty fntt_correct a = naive_ntt a == fntt a\n\nfivntt : [nn]Fld -> [nn]Fld\nfivntt xs = zipWith (*) (all_powers ivr) (ivntt xs)\n\n\/**\n * Takes ~10s to prove.\n * ```repl\n * :prove fivntt_correct\n * ```\n *\/\nfivntt_correct : [nn]Fld -> Bool\nproperty fivntt_correct a = fivntt a == naive_ivntt a\n\n\/**\n * Takes ~30s to prove.\n * ```repl\n * :prove ffivntt_correct\n * ```\n *\/\nffivntt_correct : [nn]Fld -> Bool\nproperty ffivntt_correct a = fivntt (fntt a) == a\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/LUP.cry","filetype":"cry","content":"\/* Solve linear equations over a field using LU decomposition\n *\n * John D. Ramsdell -- The MITRE Corporation -- December 2020\n *\/\n\nmodule Common::LUP where\n\nparameter\n\n  \/**\n   * Fld is the type of a field element.\n   * It must implement equality.\n   *\/\n  type Fld : *\n\n  type constraint (Eq Fld)\n\n  \/**\n   * The additive identity of the field\n   *\/\n  fzero : Fld\n\n  \/**\n   * Addition in the field\n   *\/\n  fadd : Fld -> Fld -> Fld\n\n  \/**\n   * The additive inverse of the field\n   *\/\n  fminus : Fld -> Fld\n\n  \/**\n   * The multiplicative identity of the field\n   *\/\n  fone : Fld\n\n  \/**\n   * Multiplication in the field\n   *\/\n  fmul : Fld -> Fld -> Fld\n\n  \/**\n   * The multiplicative inverse of the field\n   *\/\n  finv : Fld -> Fld\n\n\/**\n * Return x divided by y.\n *\/\nfdiv : Fld -> Fld -> Fld\nfdiv x y =\n  fmul x (finv y)\n\n\/**\n * Return the sequence of the natural numbers less that n.\n *\/\nnats : {n} (fin n) => [n][width n]\nnats = take`{n} [0 .. n]\n\n\/**\n * Map a function over a finite sequence and provide the function\n * with the position at which each element occurs.\n *\/\nmap_at : {n, a} (fin n) => ([width n] -> a -> a) -> [n]a  -> [n]a\nmap_at f m = [ f i (m @ i) | i <- nats ]\n\n\/**\n * Vectors of field elements\n *\/\ntype FldVec n = [n]Fld\n\n\/**\n * The dot product\n *\/\ndot : {n} (fin n) => FldVec n -> FldVec n -> Fld\ndot x y =\n  str ! 0\n  where\n    str = [ fzero ] # [ fadd acc (fmul xi yi)\n                      | xi <- x\n                      | yi <- y\n                      | acc <- str ]\n\n\/**\n * Vector addition\n *\/\nvecAdd : {n} (fin n) => FldVec n -> FldVec n -> FldVec n\nvecAdd x y = [ fadd xi yi | xi <- x | yi <- y ]\n\n\/**\n * Scalar multiplication of a vector\n *\/\nscalMul : {n} (fin n) => Fld -> FldVec n -> FldVec n\nscalMul c x = [ fmul c xi | xi <- x ]\n\n\/**\n * Square matrices\n *\/\ntype FldMat n = [n](FldVec n)\n\n\/**\n * The identity matrix\n *\/\nidMat : {n} (fin n) => FldMat n\nidMat = [ unitVec i | i <- nats ]\n\n\/**\n * The unit vector\n *\/\nunitVec : {n} (fin n) => [width n] -> FldVec n\nunitVec i =\n  [ if i == j then fone else fzero | j <- nats ]\n\n\/**\n * Matrix mulitplication\n *\/\nmatMul : {n} (fin n) => FldMat n -> FldMat n -> FldMat n\nmatMul x y =\n  [ [ dot (x @ i) (transpose y @ j) | j <- nats ] | i <- nats]\n\n\/**\n * Matrix vector multiplication\n *\/\nmatVec : {n} (fin n) => FldMat n -> FldVec n -> FldVec n\nmatVec x y =\n  [ dot (x @ i) y  | i <- nats]\n\n\/**\n * Swap two rows in a matrix.\n *\/\nswap : {n, a} (fin n) => [width n] -> [width n] -> [n]a -> [n]a\nswap i j x =\n  [ x @ perm k | k <- nats ]\n  where\n    perm k =\n      if (i >= `n) || (j >= `n)\n      then k\n      else if k == i\n           then j\n           else if k == j\n                then i\n                else k\n\n\/**\n * LU Decomposition with Partial Pivoting\n *\n * Decompose square matrix A as P*A = L*U where\n * P is a permutation matrix\n * L is unit lower triangular, and\n * U is upper triangular.\n * This is a Doolittle decomposition.\n *\n * L and U are stored in one matrix.\n *\/\n\n\/\/ The algorithm is from the Wikipedia page on LU Decomposition.\n\/\/ The algorithm follows.\n\n\/\/     \/\/ Pivot here\n\nLUPDecompose : {n} (fin n) => FldMat n -> (Bit, FldMat n, [n][width n])\nLUPDecompose a = str ! 0\n  where\n  perm = [ i | i <- nats ]\n  str = [(True, a, perm)] #\n        [ row i non_sing lu p\n        | (non_sing, lu, p) <- str\n        | i <- nats`{n=n}\n        ]\n\nprivate\n  \/**\n   * Perform partial pivoting and then elimination of matrix a and\n   * pivot p at i.  When ns = False, matrix a is known to be singular.\n   *\/\n  row : {n} (fin n) => [width n] -> Bit -> FldMat n -> [n][width n] ->\n                       (Bit, FldMat n, [n][width n])\n  row i ns a p =\n    if ns\n    then if ns'\n         then (ns', elim i a', p') \/\/ Perform elimination at row i\n         else (ns', a', p')        \/\/ a is singular, pivoting failed\n         where\n           (ns', a', p') = pivot i a p\n    else (ns, a, p)             \/\/ a is known to be singular\n\n  \/**\n   * Pivot rows when a[i][i] == 0.  The first element of the\n   * output is True when the matrix is non-singular.\n   *\/\n  pivot : {n} (fin n) => [width n] -> FldMat n -> [n][width n] ->\n                         (Bit, FldMat n, [n][width n])\n  pivot i a perm = str ! 0\n    where\n    str = [(False, a, perm)] #\n          [ f done lu p j | (done, lu, p) <- str | j <- nats`{n=n} ]\n    f done lu p j =\n      if j < i then (done, lu, p)\n       | j == i then (lu @ i @ i != fzero, lu, p)\n       | done then (done, lu, p)\n       | lu @ j @ i == fzero then (done, lu, p)\n      else (True, swap i j lu, swap i j p) \/\/ Pivot\n\n\/\/ for (j = i + 1; j < N; j++) {\n\/\/     A[j][i] \/= A[i][i];\n\/\/\n\/\/     for (k = i + 1; k < N; k++)\n\/\/         A[j][k] -= A[j][i] * A[i][k];\n\/\/ }\n\n  \/**\n   * Perform elimination in row i.\n   *\/\n  elim : {n} (fin n) => [width n] -> FldMat n -> FldMat n\n  elim i a = map_at f a\n    where\n      invA_i_i = finv (a @ i @ i)\n      f j v =\n        if i < j then\n          map_at g v\n          where\n            a_j_i = fmul (v @ i) invA_i_i\n            g k x =\n              if k < i then x\n               | k == i then a_j_i\n              else\n                fadd x (fminus (fmul a_j_i (a @ i @ k)))\n        else\n          v\n\n\/\/ Solving linear equations\n\n\/*\nvoid LUPSolve(double **A, int *P, double *b, int N, double *x) {\n\n    for (int i = 0; i < N; i++) {\n        x[i] = b[P[i]];\n\n        for (int k = 0; k < i; k++)\n            x[i] -= A[i][k] * x[k];\n    }\n\n    for (int i = N - 1; i >= 0; i--) {\n        for (int k = i + 1; k < N; k++)\n            x[i] -= A[i][k] * x[k];\n\n        x[i] \/= A[i][i];\n    }\n}\n*\/\n\n\/**\n * Solve a set of linear equations given an LUP decomposition of a\n * matrix.  That is, find x such that a * x = b, where lu and p are the\n * decomposition of matrix a.  This function assumes a is non-singular.\n *\/\nLUPSolve : {n} (fin n) => FldMat n -> [n][width n] ->\n                          FldVec n -> FldVec n\nLUPSolve lu p b =\n  bb\n  where\n    \/\/ Apply the pivot to b\n    pb = map_at pf b\n    pf i x = b @ (p @ i)\n    \/\/ Perform a forward subsitution on pb\n    fb = [ ff i x | x <- pb | i <- nats`{n=n} ]\n    ff i x = str ! 0\n      where\n        str = [ x ] # [ h j y | y <- str | j <- nats`{n=n} ]\n        h j y =\n          if j < i\n          then fadd y (fminus (fmul (lu @ i @ j) (fb @ j)))\n          else y\n    \/\/ Perform a backward subsitution on fb\n    bb = [ bf i x | x <- fb | i <- nats`{n=n} ]\n    bf i x = fdiv (str ! 0) (lu @ i @ i)\n      where\n        str = [ x ] # [ h j y | y <- str | j <- nats`{n=n} ]\n        h j y =\n          if i < j\n          then fadd y (fminus (fmul (lu @ i @ j) (bb @ j)))\n          else y\n\n\/**\n * Invert a matrix.\n * Return false if the matrix is singular.\n *\/\nLUPInvert : {n} (fin n) => FldMat n -> (Bit, FldMat n)\nLUPInvert a =\n  if ns then\n    (True, transpose [ LUPSolve lu p (unitVec i) | i <- nats ])\n  else\n    (False, a)\n  where\n    (ns, lu, p) = LUPDecompose a\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/GF28.cry","filetype":"cry","content":"\/**\n * Implementation of the finite field GF(2^8).\n *\n * @copyright Galois, Inc\n * @author Nichole Schimanski <nls@galois.com>\n * @author Alannah Carr\n * @author Marcella Hastings <marcella@galois.com>\n *\n * This implementation is drawn from the description of the Galois Field\n * GF(2^8) in [FIPS-197u1], Section 4.\n *\n * References\n * [FIPS-197u1]: Morris J. Dworkin, Elaine B. Barker, James R. Nechvatal,\n * James Foti, Lawrence E. Bassham, E. Roback, and James F. Dray Jr.\n * Advanced Encryption Standard (AES). Federal Inf. Process. Stds. (NIST FIPS)\n * 197, update 1. May 2023.\n *\/\nmodule Common::GF28 where\n\n\/**\n * The GF28 type represents a byte, where each bit is the coefficient of a\n * polynomial. [FIPS-197u1] Section 4, Algorithm 4.1.\n *\n * Both the spec and this implementation represent GF28 elements in big-endian\n * format.\n *\/\ntype GF28 = [8]\n\n\/**\n * Add a set of `n` elements in GF28. [FIPS-197u1] Section 4.1.\n *\n * Addition is computed by pairwise adding the coefficients modulo 2.\n *\/\nadd : {n} (fin n) => [n]GF28 -> GF28\nadd ps = foldl (^) zero ps\n\n\/**\n * The irreducable polynomial used in multiplication.\n * [FIPS-197u1] Section 4.2, Algorithm 4.3\n *\/\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\n\/**\n * Multiply two elements in GF28. [FIPS-197u1] Section 4.2.\n *\/\nmult : GF28 -> GF28 -> GF28\nmult x y = pmod (pmult x y) irreducible\n\n\/** A GF28 value to a scalar power *\/\npow : GF28 -> [8] -> GF28\npow n k = vals ! 0 where\n    sq x = mult x x\n    vals = [1] # [ if i then mult n (sq acc) else sq acc\n        | acc <- vals\n        | i   <- k]\n\n\/** Dot product of two vectors *\/\ndotProduct : {n} (fin n) => [n]GF28 -> [n]GF28 -> GF28\ndotProduct xs ys = add [ mult x y | x <- xs | y <- ys ]\n\n\/** Multiply a matrix by a vector *\/\nvectorMult : {n, m} (fin n) => [n]GF28 -> [m][n]GF28 -> [m]GF28\nvectorMult v ms = [ dotProduct v m | m <- ms ]\n\n\/**\n * Multiply two matrices. [FIPS-197u1] Section 4.3\n *\/\nmatrixMult : {n, m, k} (fin m) => [n][m]GF28 -> [m][k]GF28 -> [n][k]GF28\nmatrixMult xss yss = [ vectorMult xs yss' | xs <- xss ]\n    where yss' = transpose yss\n\n\/**\n * [FIPS-197u1] Section 4.4, Algorithm 4.10\n * ```repl\n * :prove inverseDefined\n * ```\n *\/\nproperty inverseDefined x =\n    if x == 0 then inverse x == 0\n    else mult x (inverse x) == 1\n\n\/**\n * Compute the inverse of a value. [FIPS-197u1 Section 4.4, Algorithm 4.11\n *\n * Mathematically speaking, the inverse isnt' defined for `x = 0`, but\n * we take the same liberties as the reference and use a method that\n * returns 0 for the inverse of 0. This is useful for computing Algorithm\n * 5.2 later.\n *\/\ninverse : GF28 -> GF28\ninverse x = pow x 254\n\n\/**\n * Correctness property for inverses.\n * ```repl\n * :prove inverseCorrect\n * ```\n *\/\nproperty inverseCorrect x = inverse (inverse x) == x\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol-specs\/Common\/ByteArray.cry","filetype":"cry","content":"module Common::ByteArray where\n\nimport Array\n\ntype ByteArray = Array[64][8]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/pick.cry","filetype":"cry","content":"\/* Generate random vectors and matrices\n *\n * This module provides functions that create random vectors,\n * matrices, and upper triangular matrices.\n *\n * John D. Ramsdell -- The MITRE Corporation -- March 2021\n *\/\n\nmodule Common::pick where\n\n\/**\n * Return the sequence of the natural numbers less that n.\n *\/\nnats : {n} (fin n) => [n][width n]\nnats = take`{n} [0 .. n]\n\n\/\/ The following routines are meant to be used with the output of the\n\/\/ random function.  The infinite stream is always the first item\n\/\/ returned.\n\n\/**\n * Pick one item from an infinite stream.\n * Return the remainder of the stream with the item.\n *\/\npickItem : {a} [inf]a -> ([inf]a, a)\npickItem g = (tail g, head g)\n\n\/**\n * Pick a sequence of values from an infinite stream.\n * Return the remainder of the stream with the sequence.\n *\/\npickSeq : {n, a, b} (fin n, n > 0) =>\n          ([inf]a -> ([inf]a, b)) -> [inf]a -> ([inf]a, [n]b)\npickSeq f vals =\n  (str, map snd vec)\n  where\n    vec = [f vals] # [f g | (g, _) <- vec | i <- nats`{n=n-1}]\n    snd (_, x) = x\n    (str, _) = vec ! 0            \/**\n * Pick a vector of values from an infinite stream.\n * Return the remainder of the stream with the vector.\n *\/\npickVec : {n, a} (fin n, n > 0) => [inf]a -> ([inf]a, [n]a)\npickVec = pickSeq pickItem\n\n\/**\n * Pick a matrix of values from an infinite stream.\n * Return the remainder of the stream with the matrix.\n *\/\npickMat : {n, m, a} (fin n, n > 0, fin m, m > 0) =>\n          [inf]a -> ([inf]a, [n][m]a)\npickMat = pickSeq pickVec\n\n\/**\n * Pick an upper trianglar matrix of values from an infinite stream.\n * Variable pick contains the item picker.  Variable nil is the zero\n * for type a.  Return the remainder of the stream with the matrix.\n *\/\npickTri : {n, a} (fin n, n > 0) =>\n          ([inf]a -> ([inf]a, a)) -> a -> [inf]a -> ([inf]a, [n][n]a)\npickTri pick nil s =\n  (str, map snd vec)\n  where\n    vec = [pickSeq pick s] # [pickTriRow pick nil g i\n                             | (g, _) <- vec\n                             | i <- nats`{n=n-1}\n                             ]\n    snd (_, x) = x\n    (str, _) = vec ! 0          private\n\n  \/**\n   * Pick one row of an upper triangular matrix.\n   *\/\n  pickTriRow : {n, a} (fin n, n > 0) => ([inf]a -> ([inf]a, a)) ->\n               a -> [inf]a -> [width (n - 1)] -> ([inf]a, [n]a)\n  pickTriRow pick nil s j =\n    (str, map snd vec)\n    where\n      vec = [pick s] # [f g i\n                       | (g, _) <- vec\n                       | i <- nats`{n=n-1}\n                       ]\n      f g i =\n        if i < j\n        then (g, nil)\n        else pick g\n      snd (_, x) = x\n      (str, _) = vec ! 0        ","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/Field.cry","filetype":"cry","content":"module Common::Field where\n\nimport Common::Morphism\nimport Common::Set\n\n\/\/ Field representations\ntype FieldRep fv =\n  { is_val : Set fv         \/\/ carrier set\n  , normalize : fv -> fv\n  , add : (fv,fv) -> fv\n  , sub : (fv,fv) -> fv\n  , neg : fv -> fv\n  , mul : (fv,fv) -> fv\n  , sq : fv -> fv\n  , half : fv -> fv\n  , div : (fv,fv) -> fv\n  \/* Zero value for field. *\/\n  , field_zero : fv\n    \/* Unit value for field. *\/\n  , field_unit : fv\n  \/* Return true if two field elements are equal. *\/\n  , is_equal : (fv, fv) -> Bit\n  }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/mod_arith.cry","filetype":"cry","content":"module Common::mod_arith where\n\nimport Common::bv\n\n\/* Add two numbers in normalized form. *\/\nmod_add : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_add(p,x,y) = if c1 || ~c2 then r2 else r1\n  where\n    (r1,c1) = adc( x, y)\n    (r2,c2) = sbb(r1, p)\n\n\/* Subtract two numbers in normalized form. *\/\nmod_sub : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_sub(p,x,y) = if b then r2 else r1\n  where\n    (r1,b) = sbb( x, y)\n    (r2,_) = adc(r1, p)\n\nmod_neg : {n} (fin n) => ([n],[n]) -> [n]\nmod_neg(p,x) = if x == 0 then 0 else (p - x)\n\nmod_half : {n} (fin n, n >= 1) => ([n],[n]) -> [n]\nmod_half(p, x) = if even(x) then x >> 1\n                 else take(safe_add(x, p))\n  where even y = (y && 1) == 0\n\n\/* Definition of modular multiplication. *\/\nmod_mul : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_mul(p,x,y) = safe_mod(p, safe_product(x, y))\n\n\/* Returns x\/y in F_p using Euler's binary gcd algorithm. *\/\n\/* Taken from [HMV] *\/\nmod_div : {a} (fin a, a >= 1) => ([a],[a],[a]) -> [a]\nmod_div(p,x,y) = egcd(p,0,y,x)\n  where\n    \/* In code below, a is always odd. *\/\n    egcd(a,ra,b,rb) =\n      if b == 0 then\n        ra\n      else if (b && 1) == 0 then \/* b is even. *\/\n        egcd(a, ra, b >> 1, mod_half(p, rb))\n      else if a < b then\n        egcd(a, ra, (b - a) >> 1, mod_half(p, mod_sub(p, rb, ra)))\n      else\n        egcd(b, rb, (a - b) >> 1, mod_half(p, mod_sub(p, ra, rb)))\n\nmod_pow : {a} (fin a, a >= 1) => ([a] , [a] , [a]) -> [a]\nmod_pow (p,x0,e0) = (results ! 0).2\n where\n results = [(x0,e0,1)] # [ (mod_mul (p,x,x), e>>1, if(e!0) then mod_mul(p,result,x) else result)\n                                | (x,e,result) <- results | _ <- [0..a] :[_][width a] ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Common\/OptionUtils.cry","filetype":"cry","content":"\/**\n * Convenience functions for working with `Option`s.\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n * @author Ryan Scott <rscott@galois.com>\n *\/\nmodule Common::OptionUtils where\n\nisSome : {a} Option a -> Bit\nisSome opt = case opt of\n    Some _ -> True\n    None -> False\n\nisNone : {a} Option a -> Bit\nisNone opt = ~ isSome opt\n\n\/**\n * Map an `Option a` to an `Option b` by applying a function to a contained\n * value (if `Some`) or returns `None` (if `None`).\n *\/\noptApply : {a, b} (a -> b) -> Option a -> Option b\noptApply f opt = case opt of\n    Some x -> Some (f x)\n    None -> None\n\n\/**\n * The `optFold` function takes a default value, a function, and an `Option`\n * value. If the `Option` value is `None`, then return the default value.\n * Otherwise, apply the function to the value inside the `Some` and return the\n * result.\n *\/\noptFold : {a, b} b -> (a -> b) -> Option a -> b\noptFold def f opt =\n  case opt of\n    Some x -> f x\n    None   -> def\n\n\/**\n * Takes a function outputting a `Bit` and an `Option` value. If the `Option`\n * value is `None`, return `False`. Otherwise, output the function applied\n * to the value inside the `Some` and return the result.\n *\/\noptTest : {a} (a -> Bit) -> Option a -> Bit\noptTest f opt = optFold False f opt\n\n\/**\n * Flatten a nested `Option` into a single `Option` that is `Some` only if\n * both original `Option`s are `Some`.\n *\/\noptFlatten : {a} Option (Option a) -> Option a\noptFlatten opt = case opt of\n    Some opt' -> opt'\n    None -> None\n\n\/**\n * Map an `Option a` to an `Option b` by calling `optApply` on a function that\n * produces an `Option b`, then `optFlatten`ing the result.\n *\/\noptFlatApply: {a, b} (a -> Option b) -> Option a -> Option b\noptFlatApply f opt = optFlatten (optApply f opt)\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Common\/Set.cry","filetype":"cry","content":"module Common::Set where\n\nimplies : Bit -> Bit -> Bit\nimplies P = \\Q -> if P then Q else True\n\ntype Set a = (a -> Bit)\n\n\/* NOTE: A set is *valid* if it always evaluates to true,\n**       i.e. it contains all elements of its underlying type.\n*\/\n\nintersect : {a} Set a -> Set a -> Set a\nintersect P = \\Q -> \\x -> P x && Q x\n\nunion : {a} Set a -> Set a -> Set a\nunion P = \\Q -> \\x -> P x || Q x\n\nsubset : {a} Set a -> Set a -> Set a\nsubset P = \\Q -> \\x -> implies (P x) (Q x)\n\nProdSet : {a, b} Set a -> Set b -> Set ((a,b))\nProdSet A = \\B -> \\(a,b) -> A a && B b\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol-specs\/Common\/GF24.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc\n * @author Nichole Schimanski <nls@galois.com>\n * @author Alannah Carr\n * @editor Marcella Hastings <marcella@galois.com>\n *\/\nmodule Common::GF24 where\n\ntype GF24 = [4]\n\nirreducible = <| x^^4 + x + 1 |>\n\n\/\/ Addition in GF24\ngf24Add : {n} (fin n) => [n]GF24 -> GF24\ngf24Add ps = foldl (^) zero ps\n\n\/\/ Polynomial multiplication in GF24\ngf24Mult : GF24 -> GF24 -> GF24\ngf24Mult x y = pmod (pmult x y) irreducible\n\n\/\/ Define a power of an element in GF24\ngf24Pow : GF24 -> GF24 -> GF24\ngf24Pow n k = vals ! 0 where\n    sq x = gf24Mult x x\n    vals = [1] # [ if i then gf24Mult n (sq acc) else sq acc\n        | acc <- vals\n        | i   <- k]\n\n\/\/ Self adding gives zero\npolySelfAdd' : GF24 -> Bit\nproperty polySelfAdd' x = x ^ x == zero\n\n\/\/ Inverse of an element in GF24\ngf24Inverse : GF24 -> GF24\ngf24Inverse x = gf24Pow x 14\n\nproperty gf24InverseCorrect x = gf24Inverse (gf24Inverse x) == x\n\n\/\/ Dot product in GF24\ngf24DotProduct : {n} (fin n) => [n]GF24 -> [n]GF24 -> GF24\ngf24DotProduct xs ys = gf24Add [ gf24Mult x y | x <- xs | y <- ys ]\n\n\/\/ Vector multiplication in GF24\ngf24VectorMult : {n, m} (fin n) => [n]GF24 -> [m][n]GF24 -> [m]GF24\ngf24VectorMult v ms = [ gf24DotProduct v m | m <- ms ]\n\n\/\/ Matrix multiplication in GF24\ngf24MatrixMult : {n, m, k} (fin m) => [n][m]GF24 -> [m][k]GF24 -> [n][k]GF24\ngf24MatrixMult xss yss = [ gf24VectorMult xs yss' | xs <- xss ]\n    where\n        yss' = transpose yss\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/Morphism.cry","filetype":"cry","content":"module Common::Morphism where\n\nimport Common::Set\n\n\/* This file contains types and functions for\n** coercing values between different Cryptol types.\n*\/\n\n\/\/ Morphism from type a to type b.\ntype Mor a b = a -> b\n\n\/\/ Contravariant morphism (Opposite morphism)\ntype Mor_OP a b = Mor b a\n\nid_mor : {a} Mor a a\nid_mor x = x\n\ncomp_mor : {a, b, c} Mor b c -> Mor a b -> Mor a c\ncomp_mor f g x = f (g x)\n\n\/\/ Homset morphism (contravariant in 1st arg, covariant in second arg)\nHom_mor : {a, b, c, d} Mor_OP a b -> Mor c d -> Mor (a -> c) (b -> d)\nHom_mor f g h = comp_mor g (comp_mor h f)\n\n\/\/ Product morphism\nPair_mor : {a, b, c, d} Mor a c -> Mor b d -> Mor (a,b) (c,d)\nPair_mor f g (a,b) = (f a, g b)\n\n\/\/ Diagonal morphism\nDiag_mor : {a, b} Mor a b -> Mor (a,a) (b,b)\nDiag_mor f = Pair_mor f f\n\n\/\/ Set morphism (contravariant)\nSet_mor : {a, b} Mor_OP a b -> Mor (Set a) (Set b)\nSet_mor m = Hom_mor m id_mor\n\n\/\/ Binary-Set morphism (contravariant)\nSet2_mor : {a, b} Mor_OP a b -> Mor (Set (a,a)) (Set (b,b))\nSet2_mor = comp_mor Set_mor Diag_mor\n\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol-specs\/Common\/bv.cry","filetype":"cry","content":"module Common::bv where\n\n\/* Returns the (n+1)-bit sum of two n-bit numbers. *\/\nsafe_add : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_add(x,y) = zext(x) + zext(y)\n\n\/* returns the (n+1)-bit subtraction of two n-bit numbers. *\/\nsafe_sub : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_sub(x,y) = zext(x) - zext(y)\n\n\/* Is x in normalized form (relative to prime p)? *\/\nis_normal : {a} (fin a) => [a] -> [a] -> Bit\nis_normal p x = (x < p)\n\n\/* Returns the product of two inputs. *\/\nsafe_product : {a} (fin a) => ([a],[a]) -> [2*a]\nsafe_product(x,y) = zext(x) * zext(y)\n\n\/* Returns module reduction on input. *\/\nsafe_mod : {a, b} (fin a, fin b) => ([b],[a+b]) -> [b]\nsafe_mod(p,x) = drop `{a} (x % zext(p))\n\n\/* Add two n-bit numbers and input carry to obtain a n bit number and output carry. *\/\nadc : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nadc(x,y) = (drop(sm), sm@0)\n  where sm = safe_add(x,y)\n\n\/* sbb(x,y) subtracts y from x, and returns result along with output borrow bit. *\/\nsbb : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nsbb(x,y) = (drop(r), r@0)\n  where r = ([False] # x) - ([False] # y)\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Common\/utils.cry","filetype":"cry","content":"module Common::utils where\n\n\/**\n * A functional view of the while loop.\n * `condition` and `body` are functions applied to `initial_state`.\n * `body` is applied to the state if `condition initial_state` is `True`.\n *\/\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\n\/**\n * A functional view of the do-while loop.\n * Like the `while` function, except `body` is guaranteed to be applied\n * on the first iteration.\n *\/\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\n\/**\n * Convert a `Z` type to a bitvector.\n *\/\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\n\/**\n * Convert a bitvector to a `Z` type.\n *\/\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\n\/**\n * Convert between `Z` types defined over different moduli.\n *\/\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\n\/**\n * Convert an integer to a bitvector.\n *\/\nintegerToBV : {m} (fin m) => Integer -> [m]\nintegerToBV x = fromInteger x\n\n\/**\n * Convert a bitvector to an integer.\n *\/\nintegerFromBV : {m} (fin m) => [m] -> Integer\nintegerFromBV x = toInteger x\n\n\/**\n * Convert an integer to a bitvector.\n * If the result of the conversion is less than 3,\n * return 3 instead of the conversion result.\n *\/\nintegerModulusFromBV : {m} (fin m) => [m] -> Integer\nintegerModulusFromBV x = if (integerFromBV x) < 3 then 3 else (integerFromBV x)\n\n\/**\n * Check if an integer is even.\n *\/\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\n\/**\n * Calculate the absolute value of an integer.\n *\/\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\n\/**\n * Unzip a sequence of tuples into a tuple of sequences.\n *\/\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\n\/**\n * \"Multiply\" `x` by `2` in an additive group.\n *\/\nmul2 x = x + x\n\n\/**\n * \"Multiply\" `x` by `3` in an additive group.\n *\/\nmul3 x = x + mul2 x\n\n\/**\n * \"Multiply\" `x` by `4` in an additive group.\n *\/\nmul4 x = mul2(mul2 x)\n\n\/**\n * \"Multiply\" `x` by `8` in an additive group.\n *\/\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\n\/**\n * Calculate \"half\" of a quantity in a mod `p` context.\n * I.e., `half x + half x == x`.\n *\/\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = fromInteger (if isEven xint then xint\/2 else ((xint + `p) \/ 2))\n  where\n    xint = fromZ x\n\n\/**\n * Verify that `half` is correct.\n * ```repl\n * :prove half_correct `{7}\n * ```\n *\/\nhalf_correct : {p} (fin p, p >= 3, isOdd p) => Z p -> Bit\nproperty half_correct x = half x + half x == x\n\n\/**\n * Function composition, specialized to functions from `(a -> a)`.\n * In particular, `(compose f g) x == g (f x)`.\n *\/\ncompose : {a} () => (a -> a) -> (a -> a) -> a -> a\ncompose f g = \\x -> g (f x)\n\n\/**\n * Composition of many functions from `(a -> a)`.\n * In particular, `(composeMany [a, b, c]) x == c (b (a x))`.\n *\/\ncomposeMany : {nf, a} () => [nf](a -> a) -> a -> a\ncomposeMany fcns\n    | nf == 0 => \\x -> x\n    | nf == 1 => fcns@0\n    | nf == 2 => compose (fcns@0) (fcns@1)\n    | nf > 2  => compose (fcns@0) (composeMany (drop `{1} fcns))\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/KDF\/HKDF256.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc\n * @author Aaron Tomb\n *\/\nmodule Primitive::Symmetric::KDF::HKDF256 = Primitive::Symmetric::KDF::HKDF where\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256 as HMAC_SHA256\n\ntype HashLen = 32\nHMAC = hmacBytes\n\nhmacBytes : {n, m} (64 >= width (8 * (64 + m)),\n                    64 >= width (8 * n), 32 >= width m, fin m, fin n) =>\n            [n][8] -> [m][8] -> [32][8]\nhmacBytes key msg = HMAC_SHA256::hmac key msg\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_GCM_SIV.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Authenticated::AES_GCM_SIV where\n\nparameter\n  \/\/ This constraint enforces the standard key sizes of 128 and\n  \/\/ 256-bits recommended in the draft RFC.\n  type KeySize : #\n  type constraint (fin KeySize, KeySize % 128 == 0, KeySize \/ 128 >= 1, KeySize \/ 128 <= 2)\n\n  type AAD : #\n  type constraint ( (36 + 8) >= width AAD )\n\n\n\/** This bit of algebra is here to satisfy the constraint solver.\n * `K` should be the same as `KeySize`, but the type inference doesn't work\n * if you set it directly equal.\n * `Mode` is 0 for AES-128 and 1 for AES-256.\n *\/\ntype Mode = KeySize \/ 128 - 1\ntype K  = 128 + 128 * Mode\nimport Primitive::Symmetric::Cipher::Block::AES::Specification as AES where\n  type KeySize' = KeySize\ntype KS = AES::KeySchedule\n\n\n\/** Note the weird byte-swapping business (also in `blockify` and `unblockify`)\n * It is not quite clear in what format we want the inputs\/outputs, but we\n * do the swapping so that inputs\/ouputs match the test vectors at\n * https:\/\/tools.ietf.org\/html\/draft-irtf-cfrg-gcmsiv-06\n *\/\naes_gcm_siv :\n  {n} ((36 + 8) >= width n) =>\n      { key   : [K]\n      , nonce : [96]\n      , aad   : [AAD]\n      , msg   : [n]\n      } -> [n + 128]\naes_gcm_siv input = c # byteSwap t\n  where\n  (c,t) = gcm_siv_plus (derive_key k' n') n' input.aad input.msg\n  k'    = byteSwap input.key\n  n'    = byteSwap input.nonce\n\naes : KS -> [128] -> [128]\naes ks v = byteSwap (AES::cipher ks (byteSwap v))\n\nexpandKey : [K] -> KS\nexpandKey k = AES::keyExpansion (byteSwap k)\n\n\/** See Figure 2 in Section 4 *\/\nderive_key : [K] -> [96] -> ([128], KS)\nderive_key K N = (mkKey parts1, expandKey (mkKey parts2))\n  where\n  parts1 # parts2 = [ drop (aes (expandKey K) (N # i)) | i <- take [ 0 ... ]  ]\n\n  mkKey : {n} (fin n) => [n][64] -> [64 * n]\n  mkKey xs = join (reverse xs)\n\n\n\/** See Figure 1 in Section 3 *\/\ngcm_siv_plus :\n  {n} (64 >= width n) => ([128], KS) -> [96] -> [AAD] -> [n] -> ([n],[128])\ngcm_siv_plus (K1,K2) N AAD MSG = (unblockify Cs,TAG)\n  where\n\n  TAG     = aes K2 (0b0 # drop (T ^ (0 # N)))\n  T       = polyvalFrom K1 (A # M # [msg_len # aad_len]) 0\n  A       = blockify AAD\n  M       = blockify MSG\n  aad_len = `AAD: [64]\n  msg_len = `n   : [64]\n\n  _ # tUpper # tLower = TAG\n\n  Cs = counter_mode K2 (0b1 # tUpper, tLower) M\n\ncounter_mode : {n} KS -> ([96],[32]) -> [n][128] -> [n][128]\ncounter_mode K2 (tUpper,tLower) M =\n            [ aes K2 (tUpper # lower32 i) ^ m | m <- M | i <- [ 0 ... ] ]\n  where\n  lower32 i = tLower + i\n\n\n\/** See Section 2.2 *\/\npolyvalFrom : {n} (fin n) => [128] -> [n][128] -> [128] -> [128]\npolyvalFrom H Xs start = psums ! 0\n  where psums = [start] # [ dot (s ^ x) H | s <- psums | x <- Xs ]\n\ndot : [128] -> [128] -> [128]\ndot x y = mult x (mult y x_neg_128)\n  where x_neg_128 = <| 1 + x^^114 + x^^121 + x^^124 + x^^127 |>\n        \/\/ This is x^(-128)\n\n\nmult : [128] -> [128] -> [128]\nmult x y = pmod (pmult x y) irred\n  where\n  irred = <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify x = [ byteSwap b | b <- split (x # zero) ]\n\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify xs = take (join [ byteSwap b | b <- xs ])\n\n\/\/ The spec uses byte-oriented little-endian representations.\n\/\/ This function changes back and forth.\nbyteSwap : {n} (fin n) => [8 * n] -> [8 * n]\nbyteSwap xs = join (reverse (split`{each=8} xs))\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/MEE_CBC.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Authenticated::MEE_CBC where\n\n\n\/\/ Fixing block size for simplicity.\ntype blkBytes = 16\n\/\/ Using blocks of bytes for greatest compatibility with both EasyCrypt\n\/\/ and other external descriptions of these algorithms\ntype Blk = [blkBytes][8]\n\/\/ Fixing encryption key size for simplicity.\ntype EKey = [blkBytes][8]\n\n\/\/ Fixing tag size for simplicity.\ntype tagBytes = 32\ntype Tag = [tagBytes][8]\n\n\/\/ Fixing signing key size for simplicity.\ntype skeyBytes = 64\ntype SKey = [skeyBytes][8]\n\ncbc_enc : {n} (fin n) => (EKey -> Blk -> Blk) -> EKey -> Blk -> [n]Blk -> [n]Blk\ncbc_enc enc k iv ps = cs\n where cs = [ enc k (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbc_dec : {n} (fin n) => (EKey -> Blk -> Blk) -> EKey -> Blk -> [n]Blk -> [n]Blk\ncbc_dec dec k iv cs = [ (dec k c) ^ c' | c <- cs | c' <- [iv] # cs ]\n\npad : {n, p, b}\n      (fin n, 8 >= width p, p == blkBytes*b - n, blkBytes*b >= n) =>\n      [n][8] -> Tag -> [b+2]Blk\npad msg tag = split `{each=blkBytes} (msg # tag # padding)\n  where\n    padding = (repeat `p) : [p][8]\n\nunpad : {n, p, b}\n        (fin n, 8 >= width p, p == blkBytes*b - n, blkBytes*b >= n) =>\n        [b+2]Blk -> ([n][8], Tag, Bit)\nunpad ct = (m, t, good)\n  where\n    padded = join ct\n    m = take `{n} padded\n    t = take `{tagBytes} (drop `{n} padded)\n    p = drop `{n + tagBytes} padded\n    good = p == ((repeat `p) : [p][8]) \/* \/\\ 1 <= p \/\\ p <= 16 *\/\n\nproperty unpad_pad_good_1000_256 msg tag =\n  unpad (pad `{n=1000,p=104} msg tag) == (msg, tag, True)\n\nmee_enc : {n, p, b}\n          (fin n, p == blkBytes*b - n, 8 >= width p, b >= 1, 16*b >= n) =>\n          (Blk -> Blk -> Blk)\n       -> (SKey -> [n][8] -> Tag)\n       -> EKey -> SKey -> Blk -> [n][8] -> [b+2]Blk\nmee_enc enc sign ekey skey iv msg =\n  cbc_enc enc ekey iv (pad msg (sign skey msg))\n\nmee_dec : {n, p, b}\n          (fin n, p == blkBytes*b - n, 8 >= width (32 + p), b >= 1, 16*b >= n)\n       => (EKey -> Blk -> Blk)\n       -> (SKey -> [n][8] -> Tag)\n       -> EKey -> SKey -> Blk -> [b+2]Blk -> ([n][8], Bit)\nmee_dec dec sign ekey skey iv ct = (m, good \/\\ sign skey m == t)\n  where\n    (m, t, good) = unpad (cbc_dec dec ekey iv ct)\n\nproperty mee_enc_dec_good_1000 enc dec sign ekey skey iv msg =\n  mee_dec `{n=1000,p=104} dec sign ekey skey iv ct == (msg, True)\n    where ct = mee_enc `{n=1000,p=104} enc sign ekey skey iv msg\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/trivium.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Stream::trivium where\n\nTrivium_stream : [93] -> [84] -> [111] -> [inf]\nTrivium_stream R1 R2 R3 = stream\n\twhere\n\t(stream, ra, rb, rc) = shift_regs R1 R2 R3\n\ntype N = 300\nTrivium : ([93], [84], [111]) -> [N]Bit\nTrivium (reg1, reg2, reg3) = keystream\n  where\n    keystream =  take`{N} (Trivium_stream reg1 reg2 reg3)\n\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n\t\tfills = [bit]#(drop`{1} (fill >> 1))\n\n\nshift_regs : {d,e,f} (fin d, fin e, fin f, d >=1, e >=1, f>=1) => [d] -> [e] -> [f] -> ([inf],[inf][d],[inf][e],[inf][f])\nshift_regs r1 r2 r3 = (stream, regA, regB, regC)\n\twhere\n\n\t\ts1 = [(f1 @ 65) ^ (f1 @ 92)  | f1 <- regA]\n\t\ts2 = [(f2 @ 68) ^ (f2 @ 83)  | f2 <- regB]\n\t\ts3 = [(f3 @ 65) ^ (f3 @ 110) | f3 <- regC]\n\n\t\tstream = s1 ^ s2 ^ s3\n\t\tt1 = [(f1 @ 65) ^ ((f1 @ 90) && (f1 @ 91)) ^ (f1 @ 92) ^ (f2 @ 77) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf1 <- regA ]\n\t\tt2 = [(f2 @ 68) ^ ((f2 @ 81) && (f2 @ 82)) ^ (f2 @ 83) ^ (f3 @ 86) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf3 <- regC ]\n\t\tt3 = [(f3 @ 65) ^ ((f3 @ 108) && (f3 @ 109)) ^ (f3 @ 110) ^ (f1 @ 68)|\n\t\t\t\tf1 <- regA |\n\t\t\t\tf3 <- regC ]\n\n\t\tregA = [r1] # [shift f b| f <- regA | b <- t3]\n\t\tregB = [r2] # [shift f b| f <- regB | b <- t1]\n\t\tregC = [r3] # [shift f b| f <- regC | b <- t2]\n\nTrivium_alt : ([93], [84], [111]) -> [N]Bit\nTrivium_alt (r1, r2, r3) = take`{N} (s1 ^ s2 ^ s3)\n  where\n    a_65 = drop`{27} a_92\n    a_68 = drop`{24} a_92\n    a_90 = drop`{2} a_92\n    a_91 = drop`{1} a_92\n    a_92 = reverse r1 # t3\n\n    b_68 = drop`{15} b_83\n    b_77 = drop`{6} b_83\n    b_81 = drop`{2} b_83\n    b_82 = drop`{1} b_83\n    b_83 = reverse r2 # t1\n\n    c_65 = drop`{45} c_110\n    c_86 = drop`{24} c_110\n    c_108 = drop`{2} c_110\n    c_109 = drop`{1} c_110\n    c_110 = reverse r3 # t2\n\n    s1 = a_65 ^ a_92\n    s2 = b_68 ^ b_83\n    s3 = c_65 ^ c_110\n\n    t1 = s1 ^ (a_90 && a_91) ^ b_77\n    t2 = s2 ^ (b_81 && b_82) ^ c_86\n    t3 = s3 ^ (c_108 && c_109) ^ a_68\n\n\/*********************************************************\/\n\niv1 = 0b111111111111111111101111111111111111111011111111111111111110111111111111111111101111111111111\niv2 = 0b000000000000000000001000000000000000000001000000000000000000001000000000000000000001\niv3 = 0b111111111111111110111111111111111111101111111111111111111011111111111111111110111111111111100000000000000000000\n\ntest_keystream = 0b011111110111101111110100001110000000000000100010000000000000000100011000101100001110001011011010101010000100101110001111100011000110000101001011001111011101110110111010011011010110001000111101101111101100101001000111010001010011111110011100100011101010011110101001001000011100001111111100000001110001\n\nproperty Trivium_correct = (Trivium(iv1, iv2, iv3)) == test_keystream\nproperty Trivium_search (x, y, z) = (Trivium(x, y, z)) == test_keystream\nproperty Trivium_alt_correct = (Trivium_alt(iv1, iv2, iv3)) == test_keystream\nproperty Trivium_alt_equivalent x = take`{200}(Trivium_alt x) == take (Trivium x)\n\ncycle : {n} (fin n) => [n] -> ([93], [84], [111]) -> Bit\ncycle n (rA, rB, rC) =\n  (rA == regAs @ n) \/\\ (rB == regBs @ n) \/\\ (rC == regCs @ n) \/\\ rA != 0 \/\\ rB != 0 \/\\ rC != 0\n    where\n      (_, regAs, regBs, regCs) = shift_regs rA rB rC\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/bivium.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Stream::bivium where\n\nBivium_stream : [93] -> [84] -> [inf]\nBivium_stream R1 R2 = stream\n\twhere\n\t(stream, ra, rb) = shift_regs R1 R2\n\ntype N = 200\nBivium : ([93], [84]) -> [N]Bit\nBivium (reg1, reg2) = keystream\n  where\n    keystream =  take`{N} (Bivium_stream reg1 reg2)\n\n\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n\t\tfills = [bit]#(drop`{1} (fill >> 1))\n\n\nshift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])\nshift_regs r1 r2 = (stream, regA, regB)\n\twhere\n\t\ts1 = [(f1 @ 65) ^ (f1 @ 92) | f1 <- regA]\n\t\ts2 = [(f2 @ 68) ^ (f2 @ 83) | f2 <- regB]\n\n\t\tstream = s1 ^ s2\n\t\tt1 = [(f1 @ 65) ^ ((f1 @ 90) && (f1 @ 91)) ^ (f1 @ 92) ^ (f2 @ 77) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf1 <- regA ]\n\t\tt2 = [(f2 @ 68) ^ ((f2 @ 81) && (f2 @ 82)) ^ (f2 @ 83) ^ (f1 @ 68) |\n\t\t\t\tf1 <- regA |\n\t\t\t\tf2 <- regB ]\n\n\t\tregA = [r1] # [shift f b| f <- regA | b <- t2]\n\t\tregB = [r2] # [shift f b| f <- regB | b <- t1]\n\nBivium_alt : ([93], [84]) -> [N]Bit\nBivium_alt (r1, r2) = take`{N} (s1 ^ s2)\n  where\n    a_65 = drop`{27} a_92\n    a_68 = drop`{24} a_92\n    a_90 = drop`{2} a_92\n    a_91 = drop`{1} a_92\n    a_92 = reverse r1 # t2\n\n    b_68 = drop`{15} b_83\n    b_77 = drop`{6} b_83\n    b_81 = drop`{2} b_83\n    b_82 = drop`{1} b_83\n    b_83 = reverse r2 # t1\n\n    s1 = a_65 ^ a_92\n    s2 = b_68 ^ b_83\n\n    t1 = s1 ^ (a_90 && a_91) ^ b_77\n    t2 = s2 ^ (b_81 && b_82) ^ a_68\n\n\/*************************************************************\/\n\niv1 = 0b111110000000101010100100010001000000101010100001011111111111111100100100111111111011111111111\niv2 = 0b000000000000000000001000000000000000000001000000000000000000001000000000000000000001\n\ntest_keystream = 0b01000010000100000101110001100011111101110101110111111110100001111111100110101001000010101100100010000100001100011100000010001001100101101001011101110100000001011010001101000011001000110011111010100110\n\n\nsuffix = 0b000000001000000000000000000001\nproperty Bivium_correct = (Bivium(iv1, iv2)) == test_keystream\nproperty Bivium_search (x, y) = (Bivium(x, y)) == test_keystream\nproperty Bivium_search_with_suffix (x, y) = (Bivium(x, y#suffix)) == test_keystream\nproperty Bivium_alt_equivalent r = Bivium_alt r == Bivium r\n\ncycle : {n} (fin n) => [n] -> [93] -> [84] -> Bit\ncycle n rA rB =\n  (rA == regAs @ n) \/\\ (rB == regBs @ n) \/\\ rA != 0 \/\\ rB != 0\n    where\n      (_, regAs, regBs) = shift_regs rA rB\n\ncycle0 rA rB = cycle (0 : [8]) rA rB\ncycle1 rA rB = cycle (1 : [8]) rA rB\ncycle2 rA rB = cycle (2 : [8]) rA rB\ncycle3 rA rB = cycle (3 : [8]) rA rB\ncycle4 rA rB = cycle (4 : [8]) rA rB\ncycle5 rA rB = cycle (5 : [8]) rA rB\ncycle10 rA rB = cycle (10 : [8]) rA rB\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/chacha20.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Stream::chacha20 where\n\ntype Round   = [16][32] \/\/ An input to the ChaCha20 core function\ntype Block   = [64][8]  \/\/ An output block from the ChaCha20 core function.\ntype Key     = [32][8]  \/\/ A 32-byte input key\ntype Nonce   = [12][8]  \/\/ A 12-byte nonce\ntype Counter = [32]     \/\/ Starting block counter. Usually 1 or 0.\n\n\/* -- Quarter Round ----------------- *\/\n\n\/\/ The quarter round. This takes 4 32-bit integers and diffuses them\n\/\/ appropriately, and is the core of the column and diagonal round.\nqround : [4][32] -> [4][32]\nqround [ a0, b0, c0, d0 ] = [ a2, b4, c2, d4 ]\n  where\n    a1 = a0 + b0   \/* a += b; d ^= a; d <<<= 16 *\/\n    d1 = d0 ^ a1\n    d2 = d1 <<< 16\n\n    c1 = c0 + d2   \/* c += d; b ^= c; b <<<= 12 *\/\n    b1 = b0 ^ c1\n    b2 = b1 <<< 12\n\n    a2 = a1 + b2   \/* a += b; d ^= a; d <<<= 8 *\/\n    d3 = d2 ^ a2\n    d4 = d3 <<< 8\n\n    c2 = c1 + d4   \/* c += d; b ^= c; b <<<= 7 *\/\n    b3 = b2 ^ c2\n    b4 = b3 <<< 7\n\n\n\/* -- Column and diagonal rounds ---- *\/\n\n\/\/ Perform the column round, followed by the diagonal round on the\n\/\/ input state, which are both defined in terms of the quarter\n\/\/ round. ChaCha20 requires 20 total rounds of interleaving\n\/\/ column\/diagonal passes on the state, and therefore `cdround` actually\n\/\/ does two passes at once (mostly for simplicity).\ncdround : Round -> Round\ncdround [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 ]\n      = [ z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15 ]\n  where\n    \/\/ Column round\n    [ y0, y4, y8,  y12 ] = qround [ x0, x4, x8,  x12 ]\n    [ y1, y5, y9,  y13 ] = qround [ x1, x5, x9,  x13 ]\n    [ y2, y6, y10, y14 ] = qround [ x2, x6, x10, x14 ]\n    [ y3, y7, y11, y15 ] = qround [ x3, x7, x11, x15 ]\n\n    \/\/ Diagonal round\n    [ z0, z5, z10, z15 ] = qround [ y0, y5, y10, y15 ]\n    [ z1, z6, z11, z12 ] = qround [ y1, y6, y11, y12 ]\n    [ z2, z7, z8,  z13 ] = qround [ y2, y7, y8,  y13 ]\n    [ z3, z4, z9,  z14 ] = qround [ y3, y4, y9,  y14 ]\n\n\n\/* -- Block encryption -------------- *\/\n\n\/\/ Given an input round, calculate the core ChaCha20 algorithm over\n\/\/ the round and return an output block. These output blocks form the\n\/\/ stream which you XOR your plaintext with, and successive iterations of\n\/\/ the core algorithm result in an infinite stream you can use as a\n\/\/ cipher.\ncore : Round -> Block\ncore x = block\n  where\n    rounds = iterate cdround x    \/\/ Do a bunch of column\/diagonal passes...\n    result = rounds @ 10          \/\/ And grab the 10th result (20 total passes)\n    block  = blocked (x + result) \/\/ Add to input, convert to output block\n\n\n\/* -- Key Expansion ----------------- *\/\n\n\/\/ Key expansion. Given a nonce and a key, compute a round (which is\n\/\/ fed to the core algorithm above) by taking the initial round state and\n\/\/ mixing in the key and nonce appropriately.\nkexp : Key -> Counter -> Nonce -> Round\nkexp k c n = [ c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15 ]\n  where\n    \/\/ The following describes the layout of the output round, which\n    \/\/ is fed into the core algorithm successively.\n\n    \/\/ Bytes 0-3: Constants\n    [ c0, c1, c2, c3 ] = [ 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574 ]\n\n    \/\/ Bytes 4-11: Key\n    [ c4, c5, c6,  c7 ]  = map rjoin (groupBy`{4} kslice1 : [4][4][8]) : [4][32]\n    [ c8, c9, c10, c11 ] = map rjoin (groupBy`{4} kslice2 : [4][4][8]) : [4][32]\n    kslice1 = k @@ ([ 0  .. 15 ] : [16][32]) \/\/ Top half\n    kslice2 = k @@ ([ 16 .. 31 ] : [16][32]) \/\/ Bottom half\n\n    \/\/ Bytes 12: Counter, starts off with whatever the user specified\n    \/\/ (usually 0 or 1)\n    [ c12 ] = [ c ]\n\n    \/\/ Bytes 14-15: Nonce\n    [ c13, c14, c15 ] = map rjoin (groupBy`{4} n)\n\n\n\/* -- Round increments -------------- *\/\n\n\/\/ Take a given number of iterations and the input round (after key\n\/\/ expansion!), and calculate the input round for the core algorithm\n\/\/ function. This allows you to index into a particular Round which\n\/\/ can be passed to the 'core' function.\niround : [64] -> Round -> Round\niround n r = (iterate once r) @ n where\n  \/\/ Given a round, increment the counter inside (index no 12)\n  once [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12,    x13, x14, x15 ]\n     = [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12+1,  x13, x14, x15 ]\n\n\/\/ Produce a psuedo-random stream given a nonce and a key, which can\n\/\/ be XOR'd with your data to encrypt it.\nstream : {n} (fin n) => Key -> Counter -> Nonce -> [n][8]\nstream k c n = take`{n} (join rounds) \/\/ Take n bytes from the final result\n  where\n    \/\/ Expand key\n    key    = kexp k c n\n\n    \/\/ Produce the stream by successively incrementing the input round\n    \/\/ by `i`, and running the core algorithm to get the resulting\n    \/\/ stream for the `i`th input. Once these are concatenated, you have\n    \/\/ an infinite list representing the ChaCha20 stream.\n    rounds = [ core (iround i key) | i <- [ 0, 1 ... ] ]\n\n\n\/\/ Given an message, a nonce, and a key, produce an encrypted\n\/\/ message. This is simply defined as the XOR of the message and the\n\/\/ corresponding encryption stream.\nencrypt : {n} (fin n) => Key -> Counter -> Nonce -> [n][8] -> [n][8]\nencrypt k c n m = m ^ (stream k c n)\n\n\/* -- Theorems, tests ------------------------------------------------------- *\/\n\n\/\/ Tests are private\nprivate\n  qround01 = qround in == out\n    where\n      in  = [ 0x11111111, 0x01020304, 0x9b8d6f43, 0x01234567 ]\n      out = [ 0xea2a92f4, 0xcb1cf8ce, 0x4581472e, 0x5881c4bb ]\n\n  core01 = kexp k 1 n == out\n    where\n      n = [ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x4a,\n            0x00, 0x00, 0x00, 0x00 ]\n      k = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f ]\n      out = [ 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,\n              0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,\n              0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c,\n              0x00000001, 0x09000000, 0x4a000000, 0x00000000 ]\n\n  core02 = core (kexp k 1 n) == out\n    where\n      n = [ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x4a,\n            0x00, 0x00, 0x00, 0x00 ]\n      k = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f ]\n      out = [ 0x10, 0xf1, 0xe7, 0xe4, 0xd1, 0x3b, 0x59, 0x15,\n              0x50, 0x0f, 0xdd, 0x1f, 0xa3, 0x20, 0x71, 0xc4,\n              0xc7, 0xd1, 0xf4, 0xc7, 0x33, 0xc0, 0x68, 0x03,\n              0x04, 0x22, 0xaa, 0x9a, 0xc3, 0xd4, 0x6c, 0x4e,\n              0xd2, 0x82, 0x64, 0x46, 0x07, 0x9f, 0xaa, 0x09,\n              0x14, 0xc2, 0xd7, 0x05, 0xd9, 0x8b, 0x02, 0xa2,\n              0xb5, 0x12, 0x9c, 0xd1, 0xde, 0x16, 0x4e, 0xb9,\n              0xcb, 0xd0, 0x83, 0xe8, 0xa2, 0x50, 0x3c, 0x4e ]\n\n  rfctest01 = encrypt zero zero zero zero\n       == [ 0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90, 0x40, 0x5d,\n            0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28, 0xbd, 0xd2, 0x19, 0xb8,\n            0xa0, 0x8d, 0xed, 0x1a, 0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77,\n            0x0d, 0xc7, 0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d,\n            0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37, 0x6a, 0x43,\n            0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c, 0xc3, 0x87, 0xb6, 0x69,\n            0xb2, 0xee, 0x65, 0x86 ]\n\n  rfctest02 = encrypt (zero # [1]) 1 (zero # [2]) msg == out\n    where\n      out = [ 0xa3, 0xfb, 0xf0, 0x7d, 0xf3, 0xfa, 0x2f, 0xde, 0x4f, 0x37,\n              0x6c, 0xa2, 0x3e, 0x82, 0x73, 0x70, 0x41, 0x60, 0x5d, 0x9f,\n              0x4f, 0x4f, 0x57, 0xbd, 0x8c, 0xff, 0x2c, 0x1d, 0x4b, 0x79,\n              0x55, 0xec, 0x2a, 0x97, 0x94, 0x8b, 0xd3, 0x72, 0x29, 0x15,\n              0xc8, 0xf3, 0xd3, 0x37, 0xf7, 0xd3, 0x70, 0x05, 0x0e, 0x9e,\n              0x96, 0xd6, 0x47, 0xb7, 0xc3, 0x9f, 0x56, 0xe0, 0x31, 0xca,\n              0x5e, 0xb6, 0x25, 0x0d, 0x40, 0x42, 0xe0, 0x27, 0x85, 0xec,\n              0xec, 0xfa, 0x4b, 0x4b, 0xb5, 0xe8, 0xea, 0xd0, 0x44, 0x0e,\n              0x20, 0xb6, 0xe8, 0xdb, 0x09, 0xd8, 0x81, 0xa7, 0xc6, 0x13,\n              0x2f, 0x42, 0x0e, 0x52, 0x79, 0x50, 0x42, 0xbd, 0xfa, 0x77,\n              0x73, 0xd8, 0xa9, 0x05, 0x14, 0x47, 0xb3, 0x29, 0x1c, 0xe1,\n              0x41, 0x1c, 0x68, 0x04, 0x65, 0x55, 0x2a, 0xa6, 0xc4, 0x05,\n              0xb7, 0x76, 0x4d, 0x5e, 0x87, 0xbe, 0xa8, 0x5a, 0xd0, 0x0f,\n              0x84, 0x49, 0xed, 0x8f, 0x72, 0xd0, 0xd6, 0x62, 0xab, 0x05,\n              0x26, 0x91, 0xca, 0x66, 0x42, 0x4b, 0xc8, 0x6d, 0x2d, 0xf8,\n              0x0e, 0xa4, 0x1f, 0x43, 0xab, 0xf9, 0x37, 0xd3, 0x25, 0x9d,\n              0xc4, 0xb2, 0xd0, 0xdf, 0xb4, 0x8a, 0x6c, 0x91, 0x39, 0xdd,\n              0xd7, 0xf7, 0x69, 0x66, 0xe9, 0x28, 0xe6, 0x35, 0x55, 0x3b,\n              0xa7, 0x6c, 0x5c, 0x87, 0x9d, 0x7b, 0x35, 0xd4, 0x9e, 0xb2,\n              0xe6, 0x2b, 0x08, 0x71, 0xcd, 0xac, 0x63, 0x89, 0x39, 0xe2,\n              0x5e, 0x8a, 0x1e, 0x0e, 0xf9, 0xd5, 0x28, 0x0f, 0xa8, 0xca,\n              0x32, 0x8b, 0x35, 0x1c, 0x3c, 0x76, 0x59, 0x89, 0xcb, 0xcf,\n              0x3d, 0xaa, 0x8b, 0x6c, 0xcc, 0x3a, 0xaf, 0x9f, 0x39, 0x79,\n              0xc9, 0x2b, 0x37, 0x20, 0xfc, 0x88, 0xdc, 0x95, 0xed, 0x84,\n              0xa1, 0xbe, 0x05, 0x9c, 0x64, 0x99, 0xb9, 0xfd, 0xa2, 0x36,\n              0xe7, 0xe8, 0x18, 0xb0, 0x4b, 0x0b, 0xc3, 0x9c, 0x1e, 0x87,\n              0x6b, 0x19, 0x3b, 0xfe, 0x55, 0x69, 0x75, 0x3f, 0x88, 0x12,\n              0x8c, 0xc0, 0x8a, 0xaa, 0x9b, 0x63, 0xd1, 0xa1, 0x6f, 0x80,\n              0xef, 0x25, 0x54, 0xd7, 0x18, 0x9c, 0x41, 0x1f, 0x58, 0x69,\n              0xca, 0x52, 0xc5, 0xb8, 0x3f, 0xa3, 0x6f, 0xf2, 0x16, 0xb9,\n              0xc1, 0xd3, 0x00, 0x62, 0xbe, 0xbc, 0xfd, 0x2d, 0xc5, 0xbc,\n              0xe0, 0x91, 0x19, 0x34, 0xfd, 0xa7, 0x9a, 0x86, 0xf6, 0xe6,\n              0x98, 0xce, 0xd7, 0x59, 0xc3, 0xff, 0x9b, 0x64, 0x77, 0x33,\n              0x8f, 0x3d, 0xa4, 0xf9, 0xcd, 0x85, 0x14, 0xea, 0x99, 0x82,\n              0xcc, 0xaf, 0xb3, 0x41, 0xb2, 0x38, 0x4d, 0xd9, 0x02, 0xf3,\n              0xd1, 0xab, 0x7a, 0xc6, 0x1d, 0xd2, 0x9c, 0x6f, 0x21, 0xba,\n              0x5b, 0x86, 0x2f, 0x37, 0x30, 0xe3, 0x7c, 0xfd, 0xc4, 0xfd,\n              0x80, 0x6c, 0x22, 0xf2, 0x21 ]\n\n      msg = [ 0x41, 0x6e, 0x79, 0x20, 0x73, 0x75, 0x62, 0x6d, 0x69, 0x73,\n              0x73, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68,\n              0x65, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x69, 0x6e, 0x74,\n              0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62,\n              0x75, 0x74, 0x6f, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x70,\n              0x75, 0x62, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n              0x20, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6f, 0x72,\n              0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61,\n              0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x49, 0x6e, 0x74,\n              0x65, 0x72, 0x6e, 0x65, 0x74, 0x2d, 0x44, 0x72, 0x61, 0x66,\n              0x74, 0x20, 0x6f, 0x72, 0x20, 0x52, 0x46, 0x43, 0x20, 0x61,\n              0x6e, 0x64, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x73, 0x74, 0x61,\n              0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x64,\n              0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,\n              0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x45, 0x54,\n              0x46, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79,\n              0x20, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64,\n              0x65, 0x72, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x20, 0x22, 0x49,\n              0x45, 0x54, 0x46, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69,\n              0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x2e, 0x20, 0x53,\n              0x75, 0x63, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6d,\n              0x65, 0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75,\n              0x64, 0x65, 0x20, 0x6f, 0x72, 0x61, 0x6c, 0x20, 0x73, 0x74,\n              0x61, 0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69,\n              0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x73, 0x65, 0x73,\n              0x73, 0x69, 0x6f, 0x6e, 0x73, 0x2c, 0x20, 0x61, 0x73, 0x20,\n              0x77, 0x65, 0x6c, 0x6c, 0x20, 0x61, 0x73, 0x20, 0x77, 0x72,\n              0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20,\n              0x65, 0x6c, 0x65, 0x63, 0x74, 0x72, 0x6f, 0x6e, 0x69, 0x63,\n              0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61,\n              0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x6d, 0x61, 0x64, 0x65,\n              0x20, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x69,\n              0x6d, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x6c, 0x61, 0x63,\n              0x65, 0x2c, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61,\n              0x72, 0x65, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,\n              0x65, 0x64, 0x20, 0x74, 0x6f ]\n\n  rfctest03 = encrypt key 42 (zero # [2]) msg == out\n    where\n      key = [ 0x1c, 0x92, 0x40, 0xa5, 0xeb, 0x55, 0xd3, 0x8a, 0xf3, 0x33,\n              0x88, 0x86, 0x04, 0xf6, 0xb5, 0xf0, 0x47, 0x39, 0x17, 0xc1,\n              0x40, 0x2b, 0x80, 0x09, 0x9d, 0xca, 0x5c, 0xbc, 0x20, 0x70,\n              0x75, 0xc0 ]\n      out = [ 0x27, 0x54, 0x77, 0x61, 0x73, 0x20, 0x62, 0x72, 0x69, 0x6c,\n              0x6c, 0x69, 0x67, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x73, 0x6c, 0x69, 0x74, 0x68, 0x79, 0x20,\n              0x74, 0x6f, 0x76, 0x65, 0x73, 0x0a, 0x44, 0x69, 0x64, 0x20,\n              0x67, 0x79, 0x72, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x67,\n              0x69, 0x6d, 0x62, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x77, 0x61, 0x62, 0x65, 0x3a, 0x0a, 0x41,\n              0x6c, 0x6c, 0x20, 0x6d, 0x69, 0x6d, 0x73, 0x79, 0x20, 0x77,\n              0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6f,\n              0x72, 0x6f, 0x67, 0x6f, 0x76, 0x65, 0x73, 0x2c, 0x0a, 0x41,\n              0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x6f, 0x6d,\n              0x65, 0x20, 0x72, 0x61, 0x74, 0x68, 0x73, 0x20, 0x6f, 0x75,\n              0x74, 0x67, 0x72, 0x61, 0x62, 0x65, 0x2e ]\n\n      msg = [ 0x62, 0xe6, 0x34, 0x7f, 0x95, 0xed, 0x87, 0xa4, 0x5f, 0xfa,\n              0xe7, 0x42, 0x6f, 0x27, 0xa1, 0xdf, 0x5f, 0xb6, 0x91, 0x10,\n              0x04, 0x4c, 0x0d, 0x73, 0x11, 0x8e, 0xff, 0xa9, 0x5b, 0x01,\n              0xe5, 0xcf, 0x16, 0x6d, 0x3d, 0xf2, 0xd7, 0x21, 0xca, 0xf9,\n              0xb2, 0x1e, 0x5f, 0xb1, 0x4c, 0x61, 0x68, 0x71, 0xfd, 0x84,\n              0xc5, 0x4f, 0x9d, 0x65, 0xb2, 0x83, 0x19, 0x6c, 0x7f, 0xe4,\n              0xf6, 0x05, 0x53, 0xeb, 0xf3, 0x9c, 0x64, 0x02, 0xc4, 0x22,\n              0x34, 0xe3, 0x2a, 0x35, 0x6b, 0x3e, 0x76, 0x43, 0x12, 0xa6,\n              0x1a, 0x55, 0x32, 0x05, 0x57, 0x16, 0xea, 0xd6, 0x96, 0x25,\n              0x68, 0xf8, 0x7d, 0x3f, 0x3f, 0x77, 0x04, 0xc6, 0xa8, 0xd1,\n              0xbc, 0xd1, 0xbf, 0x4d, 0x50, 0xd6, 0x15, 0x4b, 0x6d, 0xa7,\n              0x31, 0xb1, 0x87, 0xb5, 0x8d, 0xfd, 0x72, 0x8a, 0xfa, 0x36,\n              0x75, 0x7a, 0x79, 0x7a, 0xc1, 0x88, 0xd1 ]\n\nproperty allTestsPass =\n  and\n  [ \/\/ Basic tests\n    qround01, core01, core02\n    \/\/ Full RFC test vectors\n  , rfctest01, rfctest02, rfctest03\n  ]\n\n\/* -- Private utilities ----------------------------------------------------- *\/\n\nprivate\n  \/\/ Convert a round into a block, by splitting every 32-bit round entry\n  \/\/ into 4 bytes, and then serialize those values into a full block.\n  blocked : Round -> Block\n  blocked x = join (map toBytes x)\n    where\n      \/\/ This essentially splits a 32-bit number into 4-byte\n      \/\/ little-endian form, where 'rjoin' is the inverse and would merge\n      \/\/ 4 bytes as a 32-bit little endian number.\n      toBytes : [32] -> [4][8]\n      toBytes v = reverse (groupBy`{8} v)\n\n  \/\/ Map a function over a finite list.\n  map : { a, b, c }\n        (a -> b) -> [c]a -> [c]b\n  map f xs = [ f x | x <- xs ]\n\n  \/\/ Map a function iteratively over a seed value, producing an infinite\n  \/\/ list of successive function applications:\n  \/\/\n  \/\/ iterate f 0 == [ 0, f 0, f (f 0), f (f (f 0)), ... ]\n  iterate : { a } (a -> a) -> a -> [inf]a\n  iterate f x = [x] # [ f v | v <- iterate f x ]\n    where\n      \/\/ NB: Needs a binded name in order to tie the recursive knot.\n      xs = [x] # [ f v | v <- xs ]\n\n  \/\/ rjoin = join . reverse\n  \/\/ This encodes a sequence of values as a little endian number\n  \/\/ e.g. [ 0xaa, 0xbb, 0xcc, 0xdd ] is serialized as \\xdd\\xcc\\xbb\\xaa\n  rjoin : {a, b, c}\n        ( fin a, fin c\n        ) => [c][a]b -> [a * c]b\n  rjoin x = join (reverse x)\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/ZUC.cry","filetype":"cry","content":"\/\/ Version info: If the following variable is set to True, then we implement\n\/\/ Version 1.5 of ZUC. Otherwise, version 1.4 is implemented. There are\n\/\/ precisely two points in the implementation where the difference matters,\n\/\/ search for occurrences of version1_5 to spot them.\n\n\/\/ Note that the ZUC test vectors below will not work for version 1.4, as the\n\/\/ old test vectors are no longer published.\n\nmodule Primitive::Symmetric::Cipher::Stream::ZUC where\n\nversion1_5 : Bit\nversion1_5 = True\n\n\/\/ addition in GF(2^31-1) over a list of terms\nadd : {a} (fin a) => [a][31] -> [31]\nadd xs =\n    sums ! 0\n    where\n      sums =\n          [0] #\n          [plus (s, x) | s <- sums\n                       | x <- xs]\n      \/\/ the binary addition specified in the note at the end of section 3.2\n      plus : ([31], [31]) -> [31]\n      plus (a, b) =\n          if sab @ 0 then sab' + 1 else sab'\n          where\n            sab : [32]\n            sab = ((zero : [1]) # a) + ((zero : [1]) # b)\n            sab' : [31]\n            sab' = drop sab\n\n\/\/ The ZUC LFSR is 16 31-bit words\ntype LFSR = [16][31]\n\n\/\/ Section 3.2\nLFSRWithInitializationMode : ([31], LFSR) -> LFSR\nLFSRWithInitializationMode (u, ss) =\n    ss @@ [1 .. 15] # [s16]\n    where\n      v = add [s <<< c | s <- ss @@ [15, 13, 10, 4, 0, 0]\n                       | c <- [15, 17, 21, 20, 8, 0]]\n      vu = if version1_5 then add [v, u] else v ^ u\n      s16 = if vu == 0 then `0x7FFFFFFF else vu\n\n\/\/ Section 3.2\nLFSRWithWorkMode : LFSR -> LFSR\nLFSRWithWorkMode ss =\n    ss @@ [1 .. 15] # [s16]\n    where\n      v = add [s <<< c | s <- ss @@ [15, 13, 10, 4, 0, 0]\n                       | c <- [15, 17, 21, 20, 8, 0]]\n      s16 = if v == 0 then `0x7FFFFFFF else v\n\n\/\/ Section 3.3\nBitReorganization : LFSR -> [4][32]\nBitReorganization ss =\n    [ hi s15 # lo s14\n    , lo s11 # hi s9\n    , lo s7  # hi s5\n    , lo s2  # hi s0]\n    where\n      lo : [31] -> [16]\n      hi : [31] -> [16]\n      lo x = x @@ [15 .. 30]\n      hi x = x @@ [0  .. 15]\n      [s0, s2, s5, s7, s9, s11, s14, s15] = ss @@ [0, 2, 5, 7, 9, 11, 14, 15]\n\n\/\/ Section 3.4\nF : ([3][32], [2][32]) -> ([32], [2][32])\nF ([X0, X1, X2], [R1, R2]) =\n    (W, [R1', R2'])\n    where\n      W = (X0 ^ R1) + R2\n      W1 = R1 + X1\n      W2 = R2 ^ X2\n      [W1H, W1L] = split W1\n      [W2H, W2L] = split W2\n      R1' = S (L1 (W1L # W2H))\n      R2' = S (L2 (W2L # W1H))\n\n\/\/ Section 3.4.1\nS : [32] -> [32]\nS X =\n    Y0 # Y1 # Y2 # Y3\n    where\n      [X0, X1, X2, X3] = split X\n      [Y0, Y1, Y2, Y3] = [S0 X0, S1 X1, S2 X2, S3 X3]\n\n\/\/ Example 8\nproperty example8 = S(0x12345678) == 0xF9C05A4E\n\nS0 : [8] -> [8]\nS1 : [8] -> [8]\nS2 : [8] -> [8]\nS3 : [8] -> [8]\nS0 x = S0Table @ x\nS1 x = S1Table @ x\nS2 = S0\nS3 = S1\n\n\/\/ Table 3.1\nS0Table : [256][8]\nS0Table =\n    [0x3E, 0x72, 0x5B, 0x47, 0xCA, 0xE0, 0x00, 0x33, 0x04, 0xD1, 0x54,\n     0x98, 0x09, 0xB9, 0x6D, 0xCB, 0x7B, 0x1B, 0xF9, 0x32, 0xAF, 0x9D,\n     0x6A, 0xA5, 0xB8, 0x2D, 0xFC, 0x1D, 0x08, 0x53, 0x03, 0x90, 0x4D,\n     0x4E, 0x84, 0x99, 0xE4, 0xCE, 0xD9, 0x91, 0xDD, 0xB6, 0x85, 0x48,\n     0x8B, 0x29, 0x6E, 0xAC, 0xCD, 0xC1, 0xF8, 0x1E, 0x73, 0x43, 0x69,\n     0xC6, 0xB5, 0xBD, 0xFD, 0x39, 0x63, 0x20, 0xD4, 0x38, 0x76, 0x7D,\n     0xB2, 0xA7, 0xCF, 0xED, 0x57, 0xC5, 0xF3, 0x2C, 0xBB, 0x14, 0x21,\n     0x06, 0x55, 0x9B, 0xE3, 0xEF, 0x5E, 0x31, 0x4F, 0x7F, 0x5A, 0xA4,\n     0x0D, 0x82, 0x51, 0x49, 0x5F, 0xBA, 0x58, 0x1C, 0x4A, 0x16, 0xD5,\n     0x17, 0xA8, 0x92, 0x24, 0x1F, 0x8C, 0xFF, 0xD8, 0xAE, 0x2E, 0x01,\n     0xD3, 0xAD, 0x3B, 0x4B, 0xDA, 0x46, 0xEB, 0xC9, 0xDE, 0x9A, 0x8F,\n     0x87, 0xD7, 0x3A, 0x80, 0x6F, 0x2F, 0xC8, 0xB1, 0xB4, 0x37, 0xF7,\n     0x0A, 0x22, 0x13, 0x28, 0x7C, 0xCC, 0x3C, 0x89, 0xC7, 0xC3, 0x96,\n     0x56, 0x07, 0xBF, 0x7E, 0xF0, 0x0B, 0x2B, 0x97, 0x52, 0x35, 0x41,\n     0x79, 0x61, 0xA6, 0x4C, 0x10, 0xFE, 0xBC, 0x26, 0x95, 0x88, 0x8A,\n     0xB0, 0xA3, 0xFB, 0xC0, 0x18, 0x94, 0xF2, 0xE1, 0xE5, 0xE9, 0x5D,\n     0xD0, 0xDC, 0x11, 0x66, 0x64, 0x5C, 0xEC, 0x59, 0x42, 0x75, 0x12,\n     0xF5, 0x74, 0x9C, 0xAA, 0x23, 0x0E, 0x86, 0xAB, 0xBE, 0x2A, 0x02,\n     0xE7, 0x67, 0xE6, 0x44, 0xA2, 0x6C, 0xC2, 0x93, 0x9F, 0xF1, 0xF6,\n     0xFA, 0x36, 0xD2, 0x50, 0x68, 0x9E, 0x62, 0x71, 0x15, 0x3D, 0xD6,\n     0x40, 0xC4, 0xE2, 0x0F, 0x8E, 0x83, 0x77, 0x6B, 0x25, 0x05, 0x3F,\n     0x0C, 0x30, 0xEA, 0x70, 0xB7, 0xA1, 0xE8, 0xA9, 0x65, 0x8D, 0x27,\n     0x1A, 0xDB, 0x81, 0xB3, 0xA0, 0xF4, 0x45, 0x7A, 0x19, 0xDF, 0xEE,\n     0x78, 0x34, 0x60]\n\n\/\/ Table 3.2\nS1Table : [256][8]\nS1Table =\n    [0x55, 0xC2, 0x63, 0x71, 0x3B, 0xC8, 0x47, 0x86, 0x9F, 0x3C, 0xDA,\n     0x5B, 0x29, 0xAA, 0xFD, 0x77, 0x8C, 0xC5, 0x94, 0x0C, 0xA6, 0x1A,\n     0x13, 0x00, 0xE3, 0xA8, 0x16, 0x72, 0x40, 0xF9, 0xF8, 0x42, 0x44,\n     0x26, 0x68, 0x96, 0x81, 0xD9, 0x45, 0x3E, 0x10, 0x76, 0xC6, 0xA7,\n     0x8B, 0x39, 0x43, 0xE1, 0x3A, 0xB5, 0x56, 0x2A, 0xC0, 0x6D, 0xB3,\n     0x05, 0x22, 0x66, 0xBF, 0xDC, 0x0B, 0xFA, 0x62, 0x48, 0xDD, 0x20,\n     0x11, 0x06, 0x36, 0xC9, 0xC1, 0xCF, 0xF6, 0x27, 0x52, 0xBB, 0x69,\n     0xF5, 0xD4, 0x87, 0x7F, 0x84, 0x4C, 0xD2, 0x9C, 0x57, 0xA4, 0xBC,\n     0x4F, 0x9A, 0xDF, 0xFE, 0xD6, 0x8D, 0x7A, 0xEB, 0x2B, 0x53, 0xD8,\n     0x5C, 0xA1, 0x14, 0x17, 0xFB, 0x23, 0xD5, 0x7D, 0x30, 0x67, 0x73,\n     0x08, 0x09, 0xEE, 0xB7, 0x70, 0x3F, 0x61, 0xB2, 0x19, 0x8E, 0x4E,\n     0xE5, 0x4B, 0x93, 0x8F, 0x5D, 0xDB, 0xA9, 0xAD, 0xF1, 0xAE, 0x2E,\n     0xCB, 0x0D, 0xFC, 0xF4, 0x2D, 0x46, 0x6E, 0x1D, 0x97, 0xE8, 0xD1,\n     0xE9, 0x4D, 0x37, 0xA5, 0x75, 0x5E, 0x83, 0x9E, 0xAB, 0x82, 0x9D,\n     0xB9, 0x1C, 0xE0, 0xCD, 0x49, 0x89, 0x01, 0xB6, 0xBD, 0x58, 0x24,\n     0xA2, 0x5F, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xB8, 0x95, 0xE4,\n     0xD0, 0x91, 0xC7, 0xCE, 0xED, 0x0F, 0xB4, 0x6F, 0xA0, 0xCC, 0xF0,\n     0x02, 0x4A, 0x79, 0xC3, 0xDE, 0xA3, 0xEF, 0xEA, 0x51, 0xE6, 0x6B,\n     0x18, 0xEC, 0x1B, 0x2C, 0x80, 0xF7, 0x74, 0xE7, 0xFF, 0x21, 0x5A,\n     0x6A, 0x54, 0x1E, 0x41, 0x31, 0x92, 0x35, 0xC4, 0x33, 0x07, 0x0A,\n     0xBA, 0x7E, 0x0E, 0x34, 0x88, 0xB1, 0x98, 0x7C, 0xF3, 0x3D, 0x60,\n     0x6C, 0x7B, 0xCA, 0xD3, 0x1F, 0x32, 0x65, 0x04, 0x28, 0x64, 0xBE,\n     0x85, 0x9B, 0x2F, 0x59, 0x8A, 0xD7, 0xB0, 0x25, 0xAC, 0xAF, 0x12,\n     0x03, 0xE2, 0xF2]\n\n\/\/ Section 3.4.2\nL1 : [32] -> [32]\nL1 X = X ^ X <<< 2 ^ X <<< 10 ^ X <<< 18 ^ X <<< 24\n\n\/\/ Section 3.4.2\nL2 : [32] -> [32]\nL2 X = X ^ X <<< 8 ^ X <<< 14 ^ X <<< 22 ^ X <<< 30\n\n\/\/ Section 3.5\nLoadKey : ([128], [128]) -> LFSR\nLoadKey (key, iv) =\n    [k # d # i | k <- ks\n               | i <- is\n               | d <- ds]\n    where\n      ks : [16][8]\n      ks = split key\n      is : [16][8]\n      is = split iv\n      ds : [16][15]\n      ds =\n          [ 0b100010011010111, 0b010011010111100\n          , 0b110001001101011, 0b001001101011110\n          , 0b101011110001001, 0b011010111100010\n          , 0b111000100110101, 0b000100110101111\n          , 0b100110101111000, 0b010111100010011\n          , 0b110101111000100, 0b001101011110001\n          , 0b101111000100110, 0b011110001001101\n          , 0b111100010011010, 0b100011110101100\n          ]\n\ntype ZUC = (LFSR, [32], [32])\n\n\/\/ Return an infinite sequence of ZUC states by applying the initialization step\n\/\/ repeatedly. This is a generalization of section 3.6.1\nInitializeZUC : ([128], [128]) -> [inf]ZUC\nInitializeZUC (key, iv) =\n    outs\n    where\n      initLFSR = LoadKey (key, iv)\n      outs = [(initLFSR, 0, 0)] # [step out | out <- outs]\n      step (lfsr, R1, R2) =\n          (LFSRWithInitializationMode (drop (w >> 1), lfsr), R1', R2')\n          where\n            [X0, X1, X2, X3] = BitReorganization lfsr\n            (w', [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n            w = if version1_5 then w' else w' ^ X3\n\n\/\/ Section 3.6.2\nWorkingStage : ZUC -> ZUC\nWorkingStage (lfsr, R1, R2) =\n    (lfsr', R1', R2')\n    where\n      [X0, X1, X2, _] = BitReorganization lfsr\n      (_, [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n      lfsr' = LFSRWithWorkMode lfsr\n\n\/\/ Section 3.6.2\nProductionStage : ZUC -> ([32], ZUC)\nProductionStage (lfsr, R1, R2) =\n    (w ^ X3, (lfsr', R1', R2'))\n    where\n      [X0, X1, X2, X3] = BitReorganization lfsr\n      (w, [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n      lfsr' = LFSRWithWorkMode lfsr\n\n\/\/ ZUC API\nZUC : [128] -> [128] -> [inf][32]\nZUC key iv =\n    tail [w | (w, _) <- zucs]\n    where\n      initZuc = WorkingStage (InitializeZUC (key, iv) @ 32)\n      zucs = [(zero, initZuc)] # [ProductionStage zuc | (_, zuc) <- zucs]\n\n\/\/ Test vectors\nproperty ZUC_TestVectors =\n    t1 \/\\ t2 \/\\ t3 \/\\ t4\n    where\n      t1 = take (ZUC zero    zero   ) == [0x27BEDE74, 0x018082DA]\n      t2 = take (ZUC (~zero) (~zero)) == [0x0657CFA0, 0x7096398B]\n      t3 = take (ZUC (join [ 0x3D, 0x4C, 0x4B, 0xE9, 0x6A, 0x82, 0xFD, 0xAE\n                           , 0xB5, 0x8F, 0x64, 0x1D, 0xB1, 0x7B, 0x45, 0x5B\n                           ])\n                     (join [ 0x84, 0x31, 0x9A, 0xA8, 0xDE, 0x69, 0x15, 0xCA\n                           , 0x1F, 0x6B, 0xDA, 0x6B, 0xFB, 0xD8, 0xC7, 0x66\n                           ])) == [0x14F1C272, 0x3279C419]\n      t4 = take ks # [ks @ 1999] == [0xED4400E7, 0x0633E5C5, 0x7A574CDB]\n        where\n          ks = ZUC (join [ 0x4D, 0x32, 0x0B, 0xFA, 0xD4, 0xC2, 0x85, 0xBF\n                         , 0xD6, 0xB8, 0xBD, 0x00, 0xF3, 0x9D, 0x8B, 0x41\n                         ])\n                   (join [ 0x52, 0x95, 0x9D, 0xAB, 0xA0, 0xBF, 0x17, 0x6E\n                         , 0xCE, 0x2D, 0xC3, 0x15, 0x04, 0x9E, 0xB5, 0x74\n                         ])\n\n\/\/ 3.3-3.6 of the implementor's test data document lists \"LFSR-state at the\n\/\/ beginning\", which is immediately after running LoadKey.\nproperty LoadKey_TestVectors =\n    [ LoadKey(k, iv) == lfsr0\n    | k <- ks\n    | iv <- ivs\n    | lfsr0 <- lfsr0s\n    ] == ~0\n  where\n    ks = [ 0\n         , ~0\n         , 0x3d4c4be96a82fdaeb58f641db17b455b\n         , 0x4d320bfad4c285bfd6b8bd00f39d8b41\n         ]\n    ivs = [ 0\n          , ~0\n          , 0x84319aa8de6915ca1f6bda6bfbd8c766\n          , 0x52959daba0bf176ece2dc315049eb574\n          ]\n    lfsr0s = [ [ `0x0044d700, `0x0026bc00, `0x00626b00, `0x00135e00\n               , `0x00578900, `0x0035e200, `0x00713500, `0x0009af00\n               , `0x004d7800, `0x002f1300, `0x006bc400, `0x001af100\n               , `0x005e2600, `0x003c4d00, `0x00789a00, `0x0047ac00\n               ]\n             , [ `0x7fc4d7ff, `0x7fa6bcff, `0x7fe26bff, `0x7f935eff\n               , `0x7fd789ff, `0x7fb5e2ff, `0x7ff135ff, `0x7f89afff\n               , `0x7fcd78ff, `0x7faf13ff, `0x7febc4ff, `0x7f9af1ff\n               , `0x7fde26ff, `0x7fbc4dff, `0x7ff89aff, `0x7fc7acff\n               ]\n             , [ `0x1ec4d784, `0x2626bc31, `0x25e26b9a, `0x74935ea8\n               , `0x355789de, `0x4135e269, `0x7ef13515, `0x5709afca\n               , `0x5acd781f, `0x47af136b, `0x326bc4da, `0x0e9af16b\n               , `0x58de26fb, `0x3dbc4dd8, `0x22f89ac7, `0x2dc7ac66\n               ]\n             , [ `0x26c4d752, `0x1926bc95, `0x05e26b9d, `0x7d135eab\n               , `0x6a5789a0, `0x6135e2bf, `0x42f13517, `0x5f89af6e\n               , `0x6b4d78ce, `0x5c2f132d, `0x5eebc4c3, `0x001af115\n               , `0x79de2604, `0x4ebc4d9e, `0x45f89ab5, `0x20c7ac74\n               ]\n             ]\n\n\n\/\/ Collision attack on ZUC. Only version1.5 is resistant to it. Thus, the\n\/\/ following theorem holds only when version1_5 is set to True.\n\/\/\n\/\/ NB. We only compare the first output of the InitializeZUC sequence, as it\n\/\/ cuts down on the problem size and is sufficient to ensure the iv's will be\n\/\/ the same. That is, if this theorem fails, then so would the final iv's used\n\/\/ by ZUC.\n\/\/\n\/\/ Use a solver other than CVC4; Z3 and Boolector do it quickly.\nproperty ZUC_isResistantToCollisionAttack k iv1 iv2 =\n    if iv1 != iv2\n    then InitializeZUC (k, iv1) @ 1 != InitializeZUC (k, iv2) @ 1\n    else True\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/McMambo.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::McMambo where\n\ntype word = [32]\ntype state = [4][4]word\ntype key = [8]word\ntype tweak = [16]word\ntype block = [16]word\n\nnand : {a} [a] -> [a] -> [a]\nnand x y = ~(x && y)\n\nnor : {a} [a] -> [a] -> [a]\nnor x y = ~(x || y)\n\n(\u2191) = nand\n(\u2193) = nor\n(\u2295) = (^)\n(\u2227) = (&&)\n(\u2228) = (||)\n\nR : (word, word) -> word\nR (x, c) = x <<< c\n\nT : word -> tweak -> state -> state\nT n t s = s \u2295 (if n == 5 then split t else zero)\n\n\n\/**\n * ```repl\n * :prove T_bijective\n * ```\n *\/\nproperty T_bijective t n s s' =\n  (s != s') == (T n t s != T n t s')\n\n\/**\n * ```repl\n * :prove T_inverse\n * ```\n *\/\nproperty T_inverse n t s =\n  T n t (T n t s) == s\n\nQ : [4]word -> [4]word\nQ [x0, x1, x2, x3] = [y0, y1, y2, y3]\n  where\n    y1 = x1 \u2295 R (x0 \u2227 x2, 7)\n    y2 = x2 \u2295 R (x0 \u2228 x3, 9)\n    y3 = x3 \u2295 R (y1 \u2191 x0, 13)\n    y0 = x0 \u2295 R (y1 \u2193 y2, 18)\n\n\/**\n * ```repl\n * :prove Q_bijective\n * ```\n *\/\nproperty Q_bijective x x' =\n  (x != x') == (Q x != Q x')\n\nD : state -> state\nD X = Z\n  where\n    Y = transpose [ Q xs | xs <- X ]\n    Z = transpose [ Q ys | ys <- Y ]\n\nD' : state -> state\nD' X = Z\n  where\n    Y = [ Q xs | xs <- transpose X ]\n    Z = [ Q ys | ys <- transpose Y ]\n\nD_verbose : state -> state\nD_verbose [ [ x0,  x1,  x2,  x3]\n          , [ x4,  x5,  x6,  x7]\n          , [ x8,  x9, x10, x11]\n          , [x12, x13, x14, x15] ] = Z\n  where\n    [ y0,  y1,  y2,  y3] = Q [ x0,  x1,  x2,  x3]\n    [ y4,  y5,  y6,  y7] = Q [ x4,  x5,  x6,  x7]\n    [ y8,  y9, y10, y11] = Q [ x8,  x9, x10, x11]\n    [y12, y13, y14, y15] = Q [x12, x13, x14, x15]\n    [ z0,  z4,  z8, z12] = Q [ y0,  y4,  y8, y12]\n    [ z1,  z5,  z9, z13] = Q [ y1,  y5,  y9, y13]\n    [ z2,  z6, z10, z14] = Q [ y2,  y6, y10, y14]\n    [ z3,  z7, z11, z15] = Q [ y3,  y7, y11, y15]\n    Z = [ [ z0,  z1,  z2,  z3]\n        , [ z4,  z5,  z6,  z7]\n        , [ z8,  z9, z10, z11]\n        , [z12, z13, z14, z15] ]\n\nD'_verbose : state -> state\nD'_verbose [ [ x0,  x1,  x2,  x3]\n           , [ x4,  x5,  x6,  x7]\n           , [ x8,  x9, x10, x11]\n           , [x12, x13, x14, x15] ] = Z\n  where\n    [ y0,  y4,  y8, y12] = Q [ x0,  x4,  x8, x12]\n    [ y1,  y5,  y9, y13] = Q [ x1,  x5,  x9, x13]\n    [ y2,  y6, y10, y14] = Q [ x2,  x6, x10, x14]\n    [ y3,  y7, y11, y15] = Q [ x3,  x7, x11, x15]\n    [ z0,  z1,  z2,  z3] = Q [ y0,  y1,  y2,  y3]\n    [ z4,  z5,  z6,  z7] = Q [ y4,  y5,  y6,  y7]\n    [ z8,  z9, z10, z11] = Q [ y8,  y9, y10, y11]\n    [z12, z13, z14, z15] = Q [y12, y13, y14, y15]\n    Z = [ [ z0,  z1,  z2,  z3]\n        , [ z4,  z5,  z6,  z7]\n        , [ z8,  z9, z10, z11]\n        , [z12, z13, z14, z15] ]\n\n\/**\n * ```repl\n * :prove D_matches\n * ```\n *\/\nproperty D_matches =\n  D === D_verbose\n\n\/**\n * ```repl\n * :prove D'_matches\n * ```\n *\/\nproperty D'_matches =\n  D' === D'_verbose\n\nD_D'_correct s =\n  D' (D s) == s\n\nK : key -> word -> state -> state\nK [k0, k1, k2, k3, k4, k5, k6, k7] j x =\n  x \u2295 [ [  j, k0,  0, k1 ]\n      , [ k2,  j, k3,  0 ]\n      , [  0, k4,  j, k5 ]\n      , [ k6,  0, k7,  j ]\n      ]\n\n\/**\n * ```repl\n * :prove K_inverse\n * ```\n *\/\nproperty K_inverse k j s =\n  K k j (K k j s) == s\n\nC1 : key -> tweak -> state -> state\nC1 k t s0 = K k 0 (T 1 t (D (K k 1 (T 0 t (D (K k 0 s0))))))\n\nC : key -> tweak -> state -> state\nC k t s0 = K k 0 (ss!0)\n  where\n    ss : [13]state\n    ss = [s0] # [ T n t (D (K k n s)) | s <- ss | n <- [0..11] ]\n\nC' : key -> tweak -> state -> state\nC' k t s0 = ss!0\n  where\n    ss : [13]state\n    ss = [K k 0 s0] # [ K k n (D' (T n t s)) | s <- ss | n <- reverse [0..11] ]\n\nfrom_bytes : {a} [a*4][8] -> [a][32]\nfrom_bytes bytes = [ join (reverse xs) | (xs : [4][8]) <- blocks ]\n  where blocks : [a][4][8]\n        blocks = split bytes\n\nto_bytes : {a} [a][32] -> [a*4][8]\nto_bytes words = join [ reverse (split word : [4][8]) | word <- words ]\n\n\/**\n * ```repl\n * :prove from_to_bytes\n * ```\n *\/\nproperty from_to_bytes (words : [16][32]) =\n  from_bytes (to_bytes words) == words\n\n\/**\n * ```repl\n * :prove to_from_bytes\n * ```\n *\/\nproperty to_from_bytes (bytes : [64][8]) =\n  to_bytes (from_bytes bytes) == bytes\n\nC_C'_correct k t s0 =\n  C' k t (C k t s0) == s0\n\npad : {n, b} (fin n, b == (n+8) \/^ 512) => [n] -> [b][512]\npad m = split (m # 0x01 # zero)\n\npad_bytes : {n, b} (fin n, b == (n+1) \/^ 64) => [n][8] -> [b*64][8]\npad_bytes m = m # [0x01] # zero\n\nMambo : key -> tweak -> block -> block\nMambo k t m = join (C k t (split m))\n\nMambo' : key -> tweak -> block -> block\nMambo' k t m = join (C' k t (split m))\n\nMambo_bytes : [_][8] -> [_][8] -> [_][8] -> _\nMambo_bytes k t m = to_bytes (Mambo (from_bytes k) (from_bytes t) (from_bytes m))\n\nMambo_bytes' : [_][8] -> [_][8] -> [_][8] -> _\nMambo_bytes' k t m = to_bytes (Mambo' (from_bytes k) (from_bytes t) (from_bytes m))\n\n\/**\n * ```repl\n * :prove Mambo_test\n * ```\n *\/\nproperty Mambo_test =\n  join (Mambo_bytes (\"Me\" # zero) (\"Try\" # zero) (\"Test\" # zero)) ==\n  0xeb514a1ff2609f3a81ccfdd5e5342dba332d7b159a1571cee66d14bb6fd48ceb1ae956a91d3f54c8a545262c26611245a917d0a1582ecbc1d397b612baf7a62d\n\nMcMambo k ad npub M = undefined\n  where\n    Us = [zero] # [ u ^ Mambo_bytes k u a | u <- Us | a <- split (pad_bytes ad) ]\n    \u03c4 = Mambo_bytes k (Us!0) npub\n    u' = (Us!0) ^ \u03c4\n    Cs = [ Mambo_bytes k u m | u <- undefined | m <- split (pad_bytes M # \u03c4)]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/PRESENT.cry","filetype":"cry","content":"\/**\n * Cryptol PRESENT Implementation\n * @copyright Galois Inc. 2018\n * www.cryptol.net\n *\n * Source: \"PRESENT: An Ultra-Lightweight Block Cipher\" by Bogdanov et. al\n * @author Ajay Kumar Eeralla\n * Block size: 64 bits, key size:80, 128 bits\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::PRESENT where\n\ntype PrBlockSize = 64\ntype State = [4][4][4]\ntype StdBlockSize = 32\ntype PrKeySize = 80\ntype PrRkeySize = 64\ntype PrKeySize128 = 128\n\n\n\/\/S-box\n\nsbox = [0xc, 0x5, 0x6, 0xb, 0x9, 0x0, 0xa, 0xd, 0x3, 0xe, 0xf, 0x8, 0x4, 0x7, 0x1, 0x2]\n\nSbox_inv = [0x5, 0xe, 0xf, 0x8, 0xc, 0x1, 0x2, 0xd, 0xb, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xa]\n\n\/\/pLayer\n\npbox = [0x00, 0x10, 0x20, 0x30, 0x01, 0x11, 0x21, 0x31, 0x02, 0x12, 0x22,\n        0x32, 0x03, 0x13, 0x23, 0x33, 0x04, 0x14, 0x24, 0x34, 0x05, 0x15,\n        0x25, 0x35, 0x06, 0x16, 0x26, 0x36, 0x07, 0x17, 0x27, 0x37, 0x08,\n        0x18, 0x28, 0x38, 0x09, 0x19, 0x29, 0x39, 0x0a, 0x1a, 0x2a, 0x3a,\n        0x0b, 0x1b, 0x2b, 0x3b, 0x0c, 0x1c, 0x2c, 0x3c, 0x0d, 0x1d, 0x2d,\n        0x3d, 0x0e, 0x1e, 0x2e, 0x3e, 0x0f, 0x1f, 0x2f, 0x3f]\n\npbox_inv = [0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c, 0x20, 0x24, 0x28,\n          0x2c, 0x30, 0x34, 0x38, 0x3c, 0x01, 0x05, 0x09, 0x0d, 0x11, 0x15,\n          0x19, 0x1d, 0x21, 0x25, 0x29, 0x2d, 0x31, 0x35, 0x39, 0x3d, 0x02,\n          0x06, 0x0a, 0x0e, 0x12, 0x16, 0x1a, 0x1e, 0x22, 0x26, 0x2a, 0x2e,\n          0x32, 0x36, 0x3a, 0x3e, 0x03, 0x07, 0x0b, 0x0f, 0x13, 0x17, 0x1b,\n          0x1f, 0x23, 0x27, 0x2b, 0x2f, 0x33, 0x37, 0x3b, 0x3f]\n\n\/\/ Key schedule - 80bits\n\nupdateKey : [PrKeySize] -> [5] -> _\nupdateKey key i =  (rkey, shift, res,  key'')\n            where rkey = key !![79,78..16]\n                  shift =  (key !! [18,17..0]) # (key !! [79,78..19])\n                  res = sbox@((shift) !! [79,78,77, 76]) # (shift !! [75,74..0])\n                  key'' =  (res !! [79,78..20]) # ((res!![19,18..15])^(i+1)) # (res!![14,13..0])\n\n\/\/Round key List\n\nRoundKeyList : [PrKeySize] -> _\n\nRoundKeyList key = hs\n             where hs = [ (updateKey key 0) ] # [(updateKey (key'.3) i)\n                                                | i<- [1,2..31]\n                                                | key' <- hs\n                                                 ]\n\n\/\/ Add round key\n\naddRoundKey : State -> State -> State\naddRoundKey pt key = pt ^ key\n\n\/\/Substitute Sbox\n\nSubCell : [4] -> [4]\nSubCell st = sbox@st\n\nSubCells : State -> State\nSubCells st = [ [ SubCell b | b<- row ] | row <- st ]\n\n\/\/Sbox Layer for decryption\n\nSubCell_dec : [4] -> [4]\nSubCell_dec st = Sbox_inv@st\n\nSubCells_dec : State -> State\nSubCells_dec st = [ [ SubCell_dec b | b<- row ] | row <- st ]\n\n\/\/ Message to state\n\nmsgToState : [PrBlockSize] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg : State -> [PrBlockSize]\nstateToMsg st = join (join st)\n\n\/\/pemutation Layer\n\nSubpLayer: [PrBlockSize] -> [PrBlockSize]\nSubpLayer pt =  hs\n          where hs = [ pt!(pbox_inv ! i) | i <- [0,1..63] ]\n\n\/\/pLayer for decryption\n\nSubpLayer_dec: [PrBlockSize] -> [PrBlockSize]\nSubpLayer_dec pt =  hs\n          where hs = [ pt!(pbox ! i) | i <- [0,1..63] ]\n\n\/\/round encryption\n\nroundEncrypt:  (State, State) -> State\nroundEncrypt (pt, key) = msgToState(SubpLayer(stateToMsg(SubCells (addRoundKey pt key))))\n\n\/\/round Decryption\n\nroundDecrypt:  (State, State) -> State\nroundDecrypt (pt, key) = SubCells_dec (msgToState(SubpLayer_dec (stateToMsg (addRoundKey pt key))))\n\n\/\/ Encryption-80bits\n\nPrEncrypt : ([PrKeySize], [PrBlockSize]) -> [PrBlockSize]\nPrEncrypt (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                where hs = [ roundEncrypt (msgToState(pt), msgToState((key'@0).0)) ] # [ roundEncrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [1,2..30]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList key)\n\n\/\/ Decryption\n\nPrDecrypt : ([PrKeySize], [PrBlockSize]) -> _\nPrDecrypt (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@0).0))\n                where hs = [ roundDecrypt (msgToState(pt), msgToState((key'@31).0)) ] # [ roundDecrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [30,29..1]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList key)\n\n\n\n\n\n\n\/\/Correctness\n\nproperty PresentCorrectnes key m = PrDecrypt( key, PrEncrypt(key, m)) == m\n\n\n\/*********128-bit key ********\/\n\n\/\/keyschedule -128bit\n\n\nupdateKey_128 : [PrKeySize128] -> [5] -> _\nupdateKey_128 key i =  (rkey, key'')\n            where rkey = key !![127,126..64]\n                  shift =  (key !! [66,65..0]) # (key !! [127,126..67])\n                  res = sbox@((shift) !! [127,126,125, 124]) # sbox@((shift) !! [123,122,121, 120]) # (shift !! [119,118..0])\n                  key'' =  (res !! [127,126..67]) # ((res!![66,65,64,63,62])^(i+1)) # (res!![61,60..0])\n\n\nRoundKeyList_128: [PrKeySize128] -> _\n\nRoundKeyList_128 key = hs\n             where hs = [ (updateKey_128 key 0)] # [ (updateKey_128 (key'.1) i)\n                                                   | i <- [1,2..31]\n                                                   | key' <- hs ]\n\/\/Encryption-128bit\n\nPrEncrypt_128 : ([PrKeySize128], [PrBlockSize]) -> _\nPrEncrypt_128 (key , pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                         \/\/stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                where hs = [ roundEncrypt (msgToState(pt), msgToState((key'@0).0)) ] # [ roundEncrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [1,2..30]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList_128 key)\n\n\/\/Decryption-128bit\n\nPrDecrypt_128 : ([PrKeySize128], [PrBlockSize]) -> _\nPrDecrypt_128 (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@0).0))\n                where hs = [ roundDecrypt (msgToState(pt), msgToState((key'@31).0)) ] # [ roundDecrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [30,29..1]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList_128 key)\n\n\/\/Correctness\n\nproperty PresentCorrectnes128 key m = PrDecrypt_128(key, PrEncrypt_128(key, m)) == m\n\n\/\/ Heleper function to perform analaysis\n\nprEncrypt64 : ([PrBlockSize], [PrBlockSize]) -> [PrBlockSize]\nprEncrypt64 (key, pt)  = PrEncrypt_128 (key#zero, pt)\n\nprDecrypt64 : ([PrBlockSize], [PrBlockSize]) -> [PrBlockSize]\nprDecrypt64 (key, ct)  = PrDecrypt_128(key#zero , ct)\n\nproperty PrCorrect64 key m = prDecrypt64 (key, (prEncrypt64(key, m))) == m\n\n\nprEncrypt128 : ([PrKeySize128], [PrKeySize128]) -> [PrKeySize128]\nprEncrypt128 (key, pt)  = PrEncrypt_128(key, (take`{64} pt)) # zero\n\n\/\/ Testing\ntests = [test80_1, test80_2, test80_3, test80_4, test80_5, test128_1]\nproperty testsPass = and tests\n\/\/keysize: 80bits\n\ntest80_1 =  PrEncrypt (zero, zero) == 0x5579c1387b228445\ntest80_2 =  PrEncrypt (zero, zero) == 0x5579c1387b228445\ntest80_3 =  PrEncrypt (0xffffffffffffffffffff, zero) == 0xe72c46c0f5945049\ntest80_4 =  PrEncrypt (0xffffffffffffffffffff, 0xffffffffffffffff) == 0x3333dcd3213210d2\ntest80_5 =  PrEncrypt (zero, 0xffffffffffffffff) == 0xa112ffc72f68417b\n\n\n\/\/keysize: 128bits\n\n\ntest128_1 = PrEncrypt_128 ( 0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0x0e9d28685e671dd6\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Cipher.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Cipher where\n\ntype Cipher KeySize BlockSize =\n  { encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  , decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/GOST.cry","filetype":"cry","content":"\/**\n * Cryptol GOST Implementation\n * @copyright Galois Inc. 2018\n * @author Ajay Kumar Eeralla\n * www.cryptol.net\n * Block size: 64 bits, key size: 256 bits\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::GOST where\n\ntype BlockSize = 64\ntype StdBlockSize = 32\ntype KeySize = 256\n\n\/\/S-box used by Central Bank of Russian Federation\n\nsbox = [\n    [0x4, 0xa, 0x9, 0x2, 0xd, 0x8, 0x0, 0xe, 0x6, 0xb, 0x1, 0xc, 0x7, 0xf, 0x5, 0x3],\n    [0xe, 0xb, 0x4, 0xc, 0x6, 0xd, 0xf, 0xa, 0x2, 0x3, 0x8, 0x1, 0x0, 0x7, 0x5, 0x9],\n    [0x5, 0x8, 0x1, 0xd, 0xa, 0x3, 0x4, 0x2, 0xe, 0xf, 0xc, 0x7, 0x6, 0x0, 0x9, 0xb],\n    [0x7, 0xd, 0xa, 0x1, 0x0, 0x8, 0x9, 0xf, 0xe, 0x4, 0x6, 0xc, 0xb, 0x2, 0x5, 0x3],\n    [0x6, 0xc, 0x7, 0x1, 0x5, 0xf, 0xd, 0x8, 0x4, 0xa, 0x9, 0xe, 0x0, 0x3, 0xb, 0x2],\n    [0x4, 0xb, 0xa, 0x0, 0x7, 0x2, 0x1, 0xd, 0x3, 0x6, 0x8, 0x5, 0x9, 0xc, 0xf, 0xe],\n    [0xd, 0xb, 0x4, 0x1, 0x3, 0xf, 0x5, 0x9, 0x0, 0xa, 0xe, 0x7, 0x6, 0x8, 0x2, 0xc],\n    [0x1, 0xf, 0xd, 0x0, 0x5, 0x7, 0xa, 0x4, 0x9, 0x2, 0x3, 0xe, 0x6, 0xb, 0x8, 0xc]\n    ]\n\/\/Most recent S-box: GOST R 34.12-2015\n\nsbox_rec = [\n         [0xc, 0x4, 0x6, 0x2, 0xa, 0x5, 0xb, 0x9, 0xe, 0x8, 0xd, 0x7, 0x0, 0x3, 0xf, 0x1],\n         [0x6, 0x8, 0x2, 0x3, 0x9, 0xa, 0x5, 0xc, 0x1, 0xe, 0x4, 0x7, 0xb, 0xd, 0x0, 0xf],\n         [0xb, 0x3, 0x5, 0x8, 0x2, 0xf, 0xa, 0xd, 0xe, 0x1, 0x7, 0x4, 0xc, 0x9, 0x6, 0x0],\n         [0xc, 0x8, 0x2, 0x1, 0xd, 0x4, 0xf, 0x6, 0x7, 0x0, 0xa, 0x5, 0x3, 0xe, 0x9, 0xb],\n         [0x7, 0xf, 0x5, 0xa, 0x8, 0x1, 0x6, 0xd, 0x0, 0x9, 0x3, 0xe, 0xb, 0x4, 0x2, 0xc],\n         [0x5, 0xd, 0xf, 0x6, 0x9, 0x2, 0xc, 0xa, 0xb, 0x7, 0x8, 0x1, 0x4, 0x3, 0xe, 0x0],\n         [0x8, 0xe, 0x2, 0x5, 0x6, 0x9, 0x1, 0xc, 0xf, 0x4, 0xb, 0x0, 0xd, 0xa, 0x3, 0x7],\n         [0x1, 0x7, 0xe, 0xd, 0x0, 0x5, 0x8, 0x3, 0x4, 0xf, 0xa, 0x6, 0x9, 0xc, 0xb, 0x2]\n         ]\n\n\/\/ Split the plain text two blocks of 32bits each\n\nsplitPt: [BlockSize] -> [2][StdBlockSize]\nsplitPt pt = split pt:[2][StdBlockSize]\n\n\/\/ Key schedule: split the key into 8 blocks each with 32bit subkey\n\nkeySchedule : [KeySize] -> [8][StdBlockSize]\nkeySchedule key = split key : [8][StdBlockSize]\n\nroundKey:[KeySize] ->  _\nroundKey key = [ rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0\n                 ]\n         where rk = (keySchedule key)\nroundKey':[KeySize] ->  _\nroundKey' key = [ rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0\n                 ]\n         where rk = (keySchedule key)\nroundFun : [StdBlockSize]-> [StdBlockSize] -> [StdBlockSize]\nroundFun subpt subkey = roundRes\n            where res = subpt + subkey\n                  splitRes = split res: [8][4]\n                  subSboxRes = [ (sbox@i)@(splitRes@i) | i<- [0..7] ]\n                  roundRes = (join subSboxRes) <<< 11\n\nroundEncryption: [StdBlockSize] -> [StdBlockSize] -> [StdBlockSize] -> [BlockSize]\nroundEncryption lpt rpt rkey =  rpt # (lpt ^ (roundFun rpt rkey))\n\n\n\/\/Encryption\n\ngostEncrypt: ([KeySize], [BlockSize]) ->  [BlockSize]\ngostEncrypt (key, pt) = hs'\n            where hs = [(roundEncryption left right (round_key@0))]  # [ (roundEncryption ((splitPt pT)@0) ((splitPt pT)@1) (round_key@i))\n                                                  | i <- [1,2..31]\n                                                  | pT <- hs\n                                                  ]\n                  splt_pt = (splitPt pt)\n                  left = splt_pt@0\n                  right = splt_pt@1\n                  round_key = (roundKey key)\n                  hs' = hs!0\n\n\/\/One round decryption\n\nroundDecryption: [StdBlockSize] -> [StdBlockSize] -> [StdBlockSize] -> [BlockSize]\nroundDecryption lpt rpt rkey =  (rpt ^ (roundFun lpt rkey)) # lpt\n\n\n\/\/ Decryption\n\ngostDecrypt: ([KeySize], [BlockSize]) ->  [BlockSize]\ngostDecrypt (key, ct) = hs'\n            where hs = [(roundDecryption left right (round_key@0))]  # [ (roundDecryption ((splitPt pT)@0) ((splitPt pT)@1) (round_key@i))\n                                                  | i <- [1,2..31]\n                                                  | pT <- hs\n                                                  ]\n                  splt_pt = (splitPt ct)\n                  left = splt_pt@0\n                  right = splt_pt@1\n                  round_key = (roundKey' key)\n                  hs' = hs!0\n\n\/\/ Correctness\n\nproperty gostCorrect key m = gostDecrypt(key, gostEncrypt(key, m)) == m\n\n\n\/\/ Helper functions to perform analysis\n\ngostEncrypt64: ([BlockSize],[BlockSize]) -> [BlockSize]\ngostEncrypt64 (pt, key)  = gostEncrypt(key', pt)\n             where key' = key # zero\n\ngostDecrypt64 : ([BlockSize], [BlockSize]) -> [BlockSize]\ngostDecrypt64 (ct, key)  = gostDecrypt(key', ct)\n             where key' = key #zero\n\n\nproperty gostCorrect64 key m = gostDecrypt64( key, gostEncrypt64(key, m)) == m\n\n\n\/\/ To analyze the schemes from 5 through 20, we take |mi| = k  where k > n (block size)\n\ngostEncrypt256 : ([KeySize], [KeySize]) -> [KeySize]\ngostEncrypt256 (pt, key) = gostEncrypt(key, (take`{64} pt))# zero\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Threefish.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Threefish where\n\n\/\/ This implementation is based on Skein version 1.3:\n\/\/ http:\/\/www.skein-hash.info\/sites\/default\/files\/skein1.3.pdf\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.2: Bit and Byte Order\n\n\/\/ \"To convert from a sequence of bytes to an integer, we use the\n\/\/ least-significant-byte-first convention.\"\n\nToInt : {n} (fin n) => [n][8] -> [8 * n]\nToInt bytes = join (reverse bytes)\n\nToBytes : {n} (fin n) => [8 * n] -> [n][8]\nToBytes bits = reverse (split`{each = 8} bits)\n\nBytesToWords : {n} (fin n) => [8 * n][8] -> [n][64]\nBytesToWords bytes = [ ToInt bs | bs <- split`{each = 8} bytes ]\n\nWordsToBytes : {n} (fin n) => [n][64] -> [8 * n][8]\nWordsToBytes words = join [ ToBytes w | w <- words ]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3: A Full Specification of Threefish\n\nenc256 : [32][8] -> [16][8] -> [32][8] -> [32][8]\nenc256 = encrypt`{Nr=72} R4 pi4\n\nenc512 : [64][8] -> [16][8] -> [64][8] -> [64][8]\nenc512 = encrypt`{Nr=72} R8 pi8\n\nenc1024 : [128][8] -> [16][8] -> [128][8] -> [128][8]\nenc1024 = encrypt`{Nr=80} R16 pi16\n\nencrypt :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 4 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot ->\n  ([Nw][64] -> [Nw][64]) ->\n  [8 * Nw][8] -> [16][8] -> [8 * Nw][8] -> [8 * Nw][8]\nencrypt R pi key tweak plaintext = WordsToBytes (encrypt'`{Nr=Nr} R pi K T P)\n  where\n    K = BytesToWords key\n    T = BytesToWords tweak\n    P = BytesToWords plaintext\n\n\/\/ Encryption in terms of 64-bit words.\nencrypt' :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 4 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot -> ([Nw][64] -> [Nw][64]) ->\n  [Nw][64] -> [2][64] -> [Nw][64] -> [Nw][64]\nencrypt' R pi key tweak plaintext = last v + last ks\n  where\n    ks : [Nr\/4 + 1][Nw][64]\n    ks = KeySchedule key tweak\n\n    \/\/ Add a subkey from the key schedule once every four rounds.\n    e : [Nr][Nw][64]\n    e = [ vd + kd\n        | vd <- v\n        | subkey <- take`{Nr\/4} ks, kd <- [subkey, zero, zero, zero] ]\n\n    \/\/ Cycle over the eight lists of rotation amounts for the mixing function.\n    f : [Nr][Nw][64]\n    f = [ mixing Rd ed | Rd <- join (repeat`{inf} R) | ed <- e ]\n\n    \/\/ Permute the words every round.\n    v : [Nr+1][Nw][64]\n    v = [plaintext] # [ pi fd | fd <- f ]\n\n\/\/ One round of mixing.\nmixing : {w} (fin w) => [w]Rot -> [2 * w][64] -> [2 * w][64]\nmixing Rd e = join [ MIX R x | R <- Rd | x <- split`{each=2} e ]\n\n\/\/ Table 3: Values for the word permutation \u03c0(i).\n\npi4 : [4][64] -> [4][64]\npi4 xs = xs @@ [0, 3, 2, 1:[2]]\n\npi8 : [8][64] -> [8][64]\npi8 xs = xs @@ [2, 1, 4, 7, 6, 5, 0, 3:[3]]\n\npi16 : [16][64] -> [16][64]\npi16 xs = xs @@ [0, 9, 2, 13, 6, 11, 4, 15, 10, 7, 12, 3, 14, 5, 8, 1:[4]]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.1: MIX Functions\n\n\/\/ Rotation amount for a 64-bit word\ntype Rot = [6]\n\nMIX : Rot -> [2][64] -> [2][64]\nMIX R [x0, x1] = [y0, y1]\n  where\n    y0 = x0 + x1\n    y1 = (x1 <<< R) ^ y0\n\n\/\/ Table 4: Rotation constants\n\nR4 : [8][2]Rot\nR4 =\n  [[14, 16],\n   [52, 57],\n   [23, 40],\n   [ 5, 37],\n   [25, 33],\n   [46, 12],\n   [58, 22],\n   [32, 32]]\n\nR8 : [8][4]Rot\nR8 =\n  [[46, 36, 19, 37],\n   [33, 27, 14, 42],\n   [17, 49, 36, 39],\n   [44,  9, 54, 56],\n   [39, 30, 34, 24],\n   [13, 50, 10, 17],\n   [25, 29, 39, 43],\n   [ 8, 35, 56, 22]]\n\nR16 : [8][8]Rot\nR16 =\n  [[24, 13,  8, 47,  8, 17, 22, 37],\n   [38, 19, 10, 55, 49, 18, 23, 52],\n   [33,  4, 51, 13, 34, 41, 59, 17],\n   [ 5, 20, 48, 41, 47, 28, 16, 25],\n   [41,  9, 37, 31, 12, 47, 44, 30],\n   [16, 34, 56, 51,  4, 53, 42, 41],\n   [31, 44, 47, 46, 19, 42, 44, 25],\n   [ 9, 48, 35, 52, 23, 31, 37, 20]]\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.2: The Key Schedule\n\n\/\/ \"The key schedule turns the key and tweak into a sequence of Nr\/4+1\n\/\/ subkeys, each of which consists of Nw words.\"\n\nKeySchedule :\n  {Nw, r} (fin Nw, fin r, Nw >= 3) =>\n  [Nw][64] -> [2][64] -> [r][Nw][64]\nKeySchedule k [t0,t1] = take`{r} [ subkey s | s <- [0...] ]\n  where\n    k' = k # [foldl (^) C240 k]\n    t' = [t0, t1, t0 ^ t1]\n\n    subkey : [64] -> [Nw][64]\n    subkey s = take`{Nw} (k' <<< s) + tweak s\n\n    tweak : [64] -> [Nw][64]\n    tweak s = zero # take`{2} (t' <<< s) # [s]\n\nC240 : [64]\nC240 = 0x1BD11BDAA9FC1A22\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.3: Decryption\n\n\/\/ \"The Threefish decryption operation is the obvious inverse of the\n\/\/ encryption operation. Subkeys are used in reverse order and each\n\/\/ round consists of applying the inverse word permutation followed by\n\/\/ the inverse MIX functions.\"\n\ndec256 : [32][8] -> [16][8] -> [32][8] -> [32][8]\ndec256 = decrypt`{Nr=72} R4 pi4'\n\ndec512 : [64][8] -> [16][8] -> [64][8] -> [64][8]\ndec512 = decrypt`{Nr=72} R8 pi8'\n\ndec1024 : [128][8] -> [16][8] -> [128][8] -> [128][8]\ndec1024 = decrypt`{Nr=80} R16 pi16'\n\ndecrypt :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 8 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot ->\n  ([Nw][64] -> [Nw][64]) ->\n  [8 * Nw][8] -> [16][8] -> [8 * Nw][8] -> [8 * Nw][8]\ndecrypt R pi key tweak ciphertext = WordsToBytes (decrypt'`{Nr=Nr} R pi K T P)\n  where\n    K = BytesToWords key\n    T = BytesToWords tweak\n    P = BytesToWords ciphertext\n\n\/\/ Decryption in terms of 64-bit words.\ndecrypt' :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 8 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot -> ([Nw][64] -> [Nw][64]) ->\n  [Nw][64] -> [2][64] -> [Nw][64] -> [Nw][64]\ndecrypt' R pi key tweak ciphertext = last e - last ks\n  where\n    ks : [Nr\/4 + 1][Nw][64]\n    ks = reverse (KeySchedule key tweak)\n\n    \/\/ Add a subkey from the key schedule once every four rounds.\n    v : [Nr][Nw][64]\n    v = [ ed - kd\n        | ed <- e\n        | subkey <- take`{Nr\/4} ks, kd <- [subkey, zero, zero, zero] ]\n\n    \/\/ Cycle over the eight lists of rotation amounts for the mixing function.\n    e : [Nr+1][Nw][64]\n    e = [ciphertext] # [ mixing' Rd fd | Rd <- reverse (join (repeat`{Nr\/8} R)) | fd <- f ]\n\n    \/\/ Permute the words every round.\n    f : [Nr][Nw][64]\n    f = [ pi vd | vd <- v ]\n\n\n\/\/ Inverse MIX function\nMIX' : Rot -> [2][64] -> [2][64]\nMIX' R [y0, y1] = [x0, x1]\n  where\n    x0 = y0 - x1\n    x1 = (y0 ^ y1) >>> R\n\n\/\/ One round of inverse mixing.\nmixing' : {w} (fin w) => [w]Rot -> [2 * w][64] -> [2 * w][64]\nmixing' Rd e = join [ MIX' R x | R <- Rd | x <- split`{each=2} e ]\n\n\/\/ Inverse permutations.\n\npi4' : [4][64] -> [4][64]\npi4' xs = xs @@ [0, 3, 2, 1:[2]]\n\npi8' : [8][64] -> [8][64]\npi8' xs = xs @@ [6, 1, 0, 7, 2, 5, 4, 3:[3]]\n\npi16' : [16][64] -> [16][64]\npi16' xs = xs @@ [0, 15, 2, 11, 6, 13, 4, 9, 14, 1, 8, 5, 10, 3, 12, 7:[4]]\n\nproperty MIX_inv R x = MIX' R (MIX R x) == x\nproperty pi4_inv xs = pi4' (pi4 xs) == xs\nproperty pi8_inv xs = pi8' (pi8 xs) == xs\nproperty pi16_inv xs = pi16' (pi16 xs) == xs\n\n\n\/\/ https:\/\/sites.google.com\/site\/bartoszmalkowski\/threefish\n\nproperty test256a =\n  enc256 zero zero zero ==\n  split 0x84da2a1f8beaee947066ae3e3103f1ad536db1f4a1192495116b9f3ce6133fd8\n\nproperty test256b =\n  enc256\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xFFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0)\n  ==\n  split 0xe0d091ff0eea8fdfc98192e62ed80ad59d865d08588df476657056b5955e97df\n\nproperty test512a =\n  enc512 zero zero zero ==\n  split 0xb1a2bbc6ef6025bc40eb3822161f36e375d1bb0aee3186fbd19e47c5d479947b #\n  split 0x7bc2f8586e35f0cff7e7f03084b0b7b1f1ab3961a580a3e97eb41ea14a6d7bbe\n\nproperty test512b =\n  enc512\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f #\n     split 0x303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xfffefdfcfbfaf9f8f7f6f5f4f3f2f1f0efeeedecebeae9e8e7e6e5e4e3e2e1e0 #\n     split 0xdfdedddcdbdad9d8d7d6d5d4d3d2d1d0cfcecdcccbcac9c8c7c6c5c4c3c2c1c0)\n  ==\n  split 0xe304439626d45a2cb401cad8d636249a6338330eb06d45dd8b36b90e97254779 #\n  split 0x272a0a8d99463504784420ea18c9a725af11dffea10162348927673d5c1caf3d\n\nproperty test1024a =\n  enc1024 zero zero zero ==\n  split 0xf05c3d0a3d05b304f785ddc7d1e036015c8aa76e2f217b06c6e1544c0bc1a90d #\n  split 0xf0accb9473c24e0fd54fea68057f43329cb454761d6df5cf7b2e9b3614fbd5a2 #\n  split 0x0b2e4760b40603540d82eabc5482c171c832afbe68406bc39500367a592943fa #\n  split 0x9a5b4a43286ca3c4cf46104b443143d560a4b230488311df4feef7e1dfe8391e\n\nproperty test1024b =\n  enc1024\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f #\n     split 0x303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f #\n     split 0x505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f #\n     split 0x707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xfffefdfcfbfaf9f8f7f6f5f4f3f2f1f0efeeedecebeae9e8e7e6e5e4e3e2e1e0 #\n     split 0xdfdedddcdbdad9d8d7d6d5d4d3d2d1d0cfcecdcccbcac9c8c7c6c5c4c3c2c1c0 #\n     split 0xbfbebdbcbbbab9b8b7b6b5b4b3b2b1b0afaeadacabaaa9a8a7a6a5a4a3a2a1a0 #\n     split 0x9f9e9d9c9b9a999897969594939291908f8e8d8c8b8a89888786858483828180)\n  ==\n  split 0xa6654ddbd73cc3b05dd777105aa849bce49372eaaffc5568d254771bab85531c #\n  split 0x94f780e7ffaae430d5d8af8c70eebbe1760f3b42b737a89cb363490d670314bd #\n  split 0x8aa41ee63c2e1f45fbd477922f8360b388d6125ea6c7af0ad7056d01796e90c8 #\n  split 0x3313f4150a5716b30ed5f569288ae974ce2b4347926fce57de44512177dd7cde\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/SHACAL.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::SHACAL where\n\nimport Primitive::Keyless::Hash::SHA2Internal::SHA256\n\n\/**SHACAL1**\/\n\n\ntype shacal1Block = 160\ntype shacal1Key = 512\n\n\n\nshacal1Encrypt : ([shacal1Key], [shacal1Block]) -> [shacal1Block]\nshacal1Encrypt (key, pt) = join (block (pt', key'))\n              where pt' = split pt : [5][32]\n                    key' = split key : [16][32]\n\n\/\/ Helper function to analyse the PGV hash function constructions\n\nshacal1Encrypt160 : ([shacal1Block], [shacal1Block]) -> [shacal1Block]\nshacal1Encrypt160 (key, pt) = shacal1Encrypt(key#zero, pt)\n\nshacal1Encrypt512 : ([shacal1Key], [shacal1Key]) -> [shacal1Key]\nshacal1Encrypt512 (key, pt) = shacal1Encrypt(key, (take`{160} pt))#zero\n\n\n\/\/ \/\/Added 10 test vectors for more vectors, please visit:  https:\/\/www.cosic.esat.kuleuven.be\/nessie\/tweaks.html\n\nproperty shacal1TestsPass = and [shacal1Encrypt(key, plain) == cipher | (key, plain, cipher) <- tVector1]\n\ntVector1 = [ (0x8#zero, zero, 0x0FFD8D43B4E33C7C53461BD10F27A5461050D90D)\n           , (0x4#zero, zero, 0xB9C60AA972B49CA04D5A0D9B9E08B2A2BA138C93)\n           , (0x2#zero, zero, 0x3FA618501A3D10E3CAEB3CA06B8B47A16F8E3D9E)\n           , (0x1#zero, zero, 0x2B4AFB3268C32F86B89BB745EC85F24702B38498)\n           , (0x08#zero, zero, 0x58E782A1D205E53DD2901F0F302F8894D0A3B05B)\n           , (0x04#zero, zero, 0xB345AD4DC877D0BFCF760EE25056D21C7DB2F868)\n           , (0x02#zero, zero, 0x334C5A595919EA33E5EB467657AAE3ED825207D3)\n           , (0x01#zero, zero, 0x5F686F27819DF939F877099A222D01EE955F6E66)\n           , (0x008#zero, zero, 0x62BE68D266A28F7E6B44A83E62A476FFD627AF0E)\n           , (0x004#zero, zero, 0x2D5265CD2E72B52B6477F341816F2BB554428BC5)]\n\n\n\/**SHACAL2**\/\n\n\n\ntype shacal2Block = 256\ntype shacal2Key = 512\n\nshacal2Encrypt : ([shacal2Key], [shacal2Block]) -> [shacal2Block]\nshacal2Encrypt (key, pt) = join (processBlock_Common pt' key')\n              where pt' = split pt : [8][32]\n                    key' = split key : [16][32]\n\n\/\/ Helper function to analyse the PGV hash function constructions\n\nshacal2Encrypt256 : ([shacal2Block], [shacal2Block]) -> [shacal2Block]\nshacal2Encrypt256 (key, pt) = shacal2Encrypt(key#zero, pt)\n\nshacal2Encrypt512 : ([shacal2Key], [shacal2Key]) -> [shacal2Key]\nshacal2Encrypt512 (key, pt) = shacal2Encrypt(key, (take`{256} pt))#zero\n\n\/\/Testing\n\/\/Added 10 test vectors for more vectors, please visit:  https:\/\/www.cosic.esat.kuleuven.be\/nessie\/tweaks.html\n\nproperty shacal2TestsPass = and [shacal2Encrypt(key, plain) == cipher | (key, plain, cipher) <- tVector2]\n\ntVector2 = [ (0x8#zero, zero, 0x361AB6322FA9E7A7BB23818D839E01BDDAFDF47305426EDD297AEDB9F6202BAE)\n           , (0x4#zero, zero, 0xF3BAF53E5301E08813F8BE6F651BB19E9722151FF15063BA42A6FEF7CF3BF3D7)\n           , (0x1#zero, zero, 0xAE70E355CB7E26FF12421F46CDAD5CB98367FE0E86CC234EDF97481765CD1AD9)\n           , (0x08#zero, zero, 0x00CECD0B01311F881018E7A20BCE169766C089D91FF161346C4E1BD122EA199F)\n           , (0x08#zero, zero, 0x00CECD0B01311F881018E7A20BCE169766C089D91FF161346C4E1BD122EA199F)\n           , (0x04#zero, zero, 0x47A879CB6785AD37119C450CD50E9A36FE318FA8E7B6C6E0FA963430122F33CD)\n           , (0x02#zero, zero, 0xCF3D53B9F9F7CA2C66738A4C09CEA9212C056F525BDC26F263FBA1B482EDF503)\n           , (0x01#zero, zero, 0xA274D404E83E82817389A2CB7B528C792A0E80DE879A5A67DE633B0B7DD57B7B)\n           , (0x008#zero, zero, 0x09B3AB9332301D4E3C239D192A4221AFD43F6829A705D396FA96BDE1E716BC38)\n           , (0x004#zero, zero, 0xD3B9AB867A6868C4400D200979055C8F9E3A6BFB40D1F9E376B9EC89223D7050)]\n\nf : ([8], [32], [32], [32]) -> [32]\nf (t, x, y, z) =\n       if (0 <= t)  \/\\ (t <= 19) then (x && y) ^ (~x && z)\n        | (20 <= t) \/\\ (t <= 39) then x ^ y ^ z\n        | (40 <= t) \/\\ (t <= 59) then (x && y) ^ (x && z) ^ (y && z)\n        | (60 <= t) \/\\ (t <= 79) then x ^ y ^ z\n        else error \"f: t out of range\"\n\nKs : [80][32]\nKs = [ 0x5a827999 | t <- [0..19]  ]\n   # [ 0x6ed9eba1 | t <- [20..39] ]\n   # [ 0x8f1bbcdc | t <- [40..59] ]\n   # [ 0xca62c1d6 | t <- [60..79] ]\n\nblock : ([5][32], [16][32]) -> [5][32]\nblock ([H0, H1, H2, H3, H4], M) =\n [(H0+As@80), (H1+Bs@80), (H2+Cs@80), (H3+Ds@80), (H4+Es@80)]\n  where\n    Ws : [80][32]\n    Ws = M # [ (W3 ^ W8 ^ W14 ^ W16) <<< 1\n             | W16 <- drop`{16 - 16} Ws\n             | W14 <- drop`{16 - 14} Ws\n             | W8  <- drop`{16 - 8}  Ws\n             | W3  <- drop`{16 - 3}  Ws\n             | t <- [16..79]\n             ]\n    As = [H0] # TEMP\n    Bs = [H1] # As\n    Cs = [H2] # [ B <<< 30 | B <- Bs ]\n    Ds = [H3] # Cs\n    Es = [H4] # Ds\n    TEMP : [80][32]\n    TEMP = [ (A <<< 5) + f(t, B, C, D) + E + W + K\n           | A <- As | B <- Bs | C <- Cs | D <- Ds | E <- Es\n           | W <- Ws | K <- Ks\n           | t <- [0..79]\n           ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/CipherInterface.cry","filetype":"cry","content":"interface module Primitive::Symmetric::Cipher::Block::CipherInterface where\n  type KeySize : #\n  type BlockSize : #\n  type constraint (fin BlockSize, fin KeySize)\n  encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/KATAN.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::KATAN where\n\ntype Katan32 = 32\ntype Katan48 = 48\ntype Katan64 = 64\ntype KatanBlock = Katan64\ntype KatanKeySize = 80\ntype Round = 8\ntype xSize = 5\ntype ySize = 6\n\n\/\/Number of rounds\n\ntype Nr = 254\n\n\/\/Sizes of the registers\n\n\/\/32-bit\n\n\/\/48-bit\n\n\/\/64-bit\n\ntype L1Size = 25\ntype L2Size = 39\n\n\/\/ x, y values\n\n\/\/32-bit\n\n\/\/x = [12, 7, 8, 5, 3]\n\/\/y = [18, 7, 12, 10, 8, 3]\n\n\/\/48-bit\n\n\/\/x = [18, 12, 15, 7, 6]\n\/\/y = [28, 19, 21, 13, 15, 6]\n\n\/\/64-bit\n\nx = [24, 15, 20, 11, 9]\ny = [38, 25, 33, 21, 14, 9]\n\n\/\/ Split and load the plaintext into two registers L1||L2\n\nsplitBlock: [KatanBlock] -> ([L1Size], [L2Size])\n\nsplitBlock pt = (l1, l2)\n            where l1 = take`{L1Size} pt\n                  l2 = drop`{L1Size} pt\n\n\n\/\/Irregular round update\n\niR: [1][Nr]\n\niR = [0b11111110001101010101111011001100101001000100011000111100001000010100000111110011111101010001010100110000110011101111101110100101011010011100110110001011101101111001011011010111001001001101000111000100111101000011101011000001011001000000110111000000010010]\n\n\/\/Key Schedule-recursively extend the key\n\nkS: {a} (fin a) => ([a], [12]) -> [a+1]\nkS (key, i ) = key # [((key@(i-80))^ (key@(i-61)) ^ (key@(i-50)) ^ (key@(i-13)))]\n\nkS10 : {a} (fin a) => ([a], [12]) -> [a + 10]\nkS10 (key, i) = key9\n           where key0 = kS (key, i)\n                 key1 = kS (key0, i+1)\n                 key2 = kS (key1, i+2)\n                 key3 = kS (key2, i+3)\n                 key4 = kS (key3, i+4)\n                 key5 = kS (key4, i+5)\n                 key6 = kS (key5, i+6)\n                 key7 = kS (key6, i+7)\n                 key8 = kS (key7, i+8)\n                 key9 = kS (key8, i+9)\n\nkS100 : {a} (fin a) => ([a], [12]) -> [a + 100]\nkS100 (key, i) = key9\n            where key0 = kS10 (key, i)\n                  key1 = kS10 (key0, i+10)\n                  key2 = kS10 (key1, i+20)\n                  key3 = kS10 (key2, i+30)\n                  key4 = kS10 (key3, i+40)\n                  key5 = kS10 (key4, i+50)\n                  key6 = kS10 (key5, i+60)\n                  key7 = kS10 (key6, i+70)\n                  key8 = kS10 (key7, i+80)\n                  key9 = kS10 (key8, i+90)\n\nkeySchedule' :[80] -> [508]\nkeySchedule' key = key13\n            where key0 = kS100 (key, 80)\n                  key1= kS100 (key0, 180)\n                  key2 = kS100 (key1, 280)\n                  key3 = kS100 (key2, 380)\n                  key4 = kS10(key3, 480)\n                  key5 = kS10 (key4, 490)\n                  key6 = kS (key5, 500)\n                  key7 = kS (key6, 501)\n                  key8 = kS (key7, 502)\n                  key9 = kS (key8, 503)\n                  key10 = kS (key9, 504)\n                  key11 = kS (key10, 505)\n                  key12 = kS (key11, 506)\n                  key13 = kS (key12, 507)\n\/\/ functions fa and fb\n\nfunFa : [L1Size]-> [xSize][xSize] -> [508] -> [Round] -> Bit\n\nfunFa L1 x k i = (L1!(x@0)) ^ (L1!(x@1)) ^ ((L1!(x@2)) && (L1!(x@3))) ^ ((L1!(x@4)) && ((iR@0)@i)) ^ (k@(pmult (2:[2]) i))\n\nfunFb : [L2Size]-> [ySize][ySize] -> [508] -> [Round] -> Bit\n\nfunFb L2 y k i = (L2!(y@0)) ^ (L2!(y@1)) ^ (L2!(y@2) && L2!(y@3)) ^ (L2!(y@4) && L2!(y@5)) ^ (k@((pmult (2:[2]) i)+1))\n\n\/\/left shift L1 and L2 and replace LSBs of them with fb and fa respectively\n\n\naply_fb : [L1Size] -> [L2Size]->  [ySize][ySize] ->[KatanKeySize] -> [Round] -> [L1Size]\naply_fb l1 l2 y key i = (l1 !! [(L1Size-2),(L1Size-3)..0]) # [(funFb l2 y (keySchedule' key) i)]\n\naply_fa : [L1Size] -> [L2Size]-> [xSize][xSize]->[KatanKeySize] -> [Round] -> [L2Size]\naply_fa l1 l2 x key i = (l2 !! [(L2Size-2),(L2Size-3)..0]) # [(funFa l1 x (keySchedule' key) i)]\n\n\/\/Update LFSR for encryption\n\nupdateLfsr : [L1Size] -> [L2Size]-> [xSize][xSize] -> [ySize][ySize]->[KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\nupdateLfsr l1 l2 x y key i = if `(L1Size) == 13\n                             then (l1', l2')\n                             else if `(L1Size) == 19\n                                  then (l1'', l2'')\n                                  else (l1''', l2''')\n\n                 where pt = (aply_fb l1 l2 y key i) # (aply_fa l1 l2 x key i)\n                       l1' = (splitBlock pt).0\n                       l2' = (splitBlock pt).1\n                       pt' = (aply_fb l1' l2' y key i) # (aply_fa l1' l2' x key i)\n                       l1'' = (splitBlock pt').0\n                       l2'' =  (splitBlock pt').1\n                       pt'' = (aply_fb l1'' l2'' y key i) # (aply_fa l1'' l2'' x key i)\n                       l1''' = (splitBlock pt'').0\n                       l2''' =  (splitBlock pt'').1\n\n\/\/Encryption\n\nkatanEncrypt : ( [KatanKeySize], [KatanBlock]) -> _ katanEncrypt (key, pt) =  (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] # [ ( (updateLfsr pT.0 pT.1 x y key i).0, (updateLfsr pT.0 pT.1 x y key i).1)  | i<- [0,1..253] | pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\n\/\/ wrapper to do experiments\n\nkatanEncrypt64 : ([KatanBlock], [KatanBlock]) -> [KatanBlock]\nkatanEncrypt64 (key, pt) = katanEncrypt(key#zero, pt)\n\n\nkatanEncrypt80 : ([KatanKeySize], [KatanKeySize]) -> [KatanKeySize]\nkatanEncrypt80 (key, pt) = katanEncrypt(key, (take`{64} pt)) # zero\n\n\/\/Auxiliary functions for decryption\n\n\/\/ fa and fb\n\ndecFunFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ndecFunFa L1 L2 x k i = fa ^ (L1!((x@1)+1)) ^ (L1!((x@2)+1) && L1!((x@3)+1)) ^ (L1!((x@4)+1) && ((iR@0)@i)) ^ k@(2*i)\n         where fa = L2!0\n\ndecFunFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [508] -> [Round] -> Bit\ndecFunFb L2 L1 y k i =  fb ^ (L2!((y@1)+1)) ^ ((L2!((y@2)+1)) && L2!((y@3)+1)) ^ ((L2!((y@4)+1)) && L2!((y@5)+1)) ^ k@(2*i+1)\n         where fb = L1!0\n\n\/\/Left shifting L1, L2 and appending fa, fb values\n\naply_decFa_once : [L1Size] -> [L2Size] -> [xSize][xSize] -> [KatanKeySize] -> [Round] -> [L1Size]\n\naply_decFa_once  l1 l2 x k i = [(decFunFa l1 l2 x (keySchedule' k) i)] # (l1!![(L1Size-1),(L1Size-2)..1])\n\n\naply_decFb_once : [L2Size] -> [L1Size] -> [ySize][ySize] -> [KatanKeySize] -> [Round] -> [L2Size]\naply_decFb_once  l2 l1 y k i =  [(decFunFb l2 l1 y (keySchedule' k) i)] # (l2!![(L2Size-1),(L2Size-2)..1])\n\n\/\/ Updating LFSR for decryption\n\ndecUpdateLfsr: [L1Size] -> [L2Size] -> [xSize][xSize]-> [ySize][ySize] -> [KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\ndecUpdateLfsr  l1 l2 x y key i = if `(L1Size) == 13\n                                 then (l1', l2')\n                                 else if `(L1Size) == 19\n                                      then (l1'', l2'')\n                                      else (l1''', l2''')\n                               where ct = (aply_decFa_once l1 l2 x key i) # (aply_decFb_once l2 l1 y key i)\n                                     l1' = (splitBlock ct).0\n                                     l2' = (splitBlock ct).1\n                                     ct' = (aply_decFa_once l1' l2' x key i) # (aply_decFb_once l2' l1' y key i)\n                                     l1'' = (splitBlock ct').0\n                                     l2'' = (splitBlock ct').1\n                                     ct'' = (aply_decFa_once l1'' l2'' x key i) # (aply_decFb_once l2'' l1'' y key i)\n                                     l1''' = (splitBlock ct'').0\n                                     l2''' = (splitBlock ct'').1\n\/\/Decryption\n\nkatanDecrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\nkatanDecrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] #[ ((decUpdateLfsr pT.0 pT.1 x y key i).0 , (decUpdateLfsr pT.0 pT.1 x y key i).1)  | i <-[253,252..0] |pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\n\n\/\/ Correctness\n\nproperty katanCorrect key m = katanEncrypt( key, katanDecrypt(key, m)) == m\n\n\n\n\/*******KTANTAN*******************************************\/\n\/**********************************************************\/\n\nk_a_index = [0x3f, 0x1f, 0x1f, 0x0f, 0x0e, 0x3c, 0x28, 0x31, 0x23, 0x36, 0x2d,\n             0x3a, 0x25, 0x4a, 0x45, 0x4a, 0x35, 0x2b, 0x47, 0x3f, 0x1e, 0x2d,\n             0x0b, 0x36, 0x1c, 0x29, 0x03, 0x26, 0x3c, 0x19, 0x22, 0x05, 0x1a,\n             0x14, 0x09, 0x02, 0x14, 0x18, 0x01, 0x02, 0x34, 0x18, 0x11, 0x03,\n             0x06, 0x4c, 0x48, 0x31, 0x13, 0x17, 0x0f, 0x0e, 0x0c, 0x18, 0x10,\n             0x01, 0x02, 0x04, 0x28, 0x30, 0x11, 0x12, 0x05, 0x0a, 0x04, 0x08,\n             0x40, 0x40, 0x41, 0x33, 0x17, 0x2f, 0x0f, 0x4e, 0x4c, 0x49, 0x43,\n             0x37, 0x2f, 0x3f, 0x2f, 0x3e, 0x1d, 0x1a, 0x05, 0x0a, 0x24, 0x38,\n             0x21, 0x32, 0x15, 0x2a, 0x05, 0x3a, 0x14, 0x19, 0x03, 0x06, 0x0c,\n             0x38, 0x10, 0x21, 0x03, 0x46, 0x3c, 0x29, 0x43, 0x47, 0x4e, 0x4d,\n             0x3b, 0x27, 0x4f, 0x4f, 0x3e, 0x2d, 0x3b, 0x17, 0x2e, 0x0d, 0x2a,\n             0x34, 0x29, 0x42, 0x35, 0x2a, 0x35, 0x1b, 0x26, 0x0d, 0x4a, 0x34,\n             0x19, 0x23, 0x07, 0x3e, 0x2c, 0x49, 0x33, 0x16, 0x1d, 0x0b, 0x06,\n             0x2c, 0x48, 0x41, 0x32, 0x25, 0x4b, 0x37, 0x2e, 0x4d, 0x4b, 0x46,\n             0x3d, 0x1b, 0x27, 0x0f, 0x2e, 0x4c, 0x39, 0x22, 0x45, 0x3b, 0x26,\n             0x3d, 0x2b, 0x46, 0x4d, 0x3a, 0x15, 0x2b, 0x07, 0x1e, 0x2c, 0x09,\n             0x12, 0x24, 0x09, 0x32, 0x24, 0x39, 0x13, 0x16, 0x0d, 0x0a, 0x44,\n             0x38, 0x11, 0x13, 0x07, 0x0e, 0x1c, 0x28, 0x01, 0x42, 0x44, 0x39,\n             0x23, 0x37, 0x1f, 0x1e, 0x0d, 0x0a, 0x04, 0x48, 0x30, 0x21, 0x33,\n             0x27, 0x4e, 0x3d, 0x1a, 0x15, 0x0b, 0x06, 0x0c, 0x08, 0x20, 0x40,\n             0x31, 0x12, 0x25, 0x0b, 0x16, 0x1c, 0x09, 0x02, 0x04, 0x08, 0x00,\n             0x30, 0x20, 0x41, 0x43, 0x36, 0x1d, 0x1b, 0x07, 0x0e, 0x0c, 0x08,\n             0x00, 0x00, 0x10, 0x20, 0x01, 0x22, 0x44, 0x49, 0x42, 0x45, 0x4b,\n             0x47]\n\n\nk_b_index = [0x1f, 0x3f, 0x3f, 0x2f, 0x0e, 0x4c, 0x28, 0x11, 0x43, 0x16, 0x4d,\n             0x1a, 0x45, 0x0a, 0x45, 0x0a, 0x15, 0x2b, 0x07, 0x4f, 0x3e, 0x2d,\n             0x0b, 0x46, 0x3c, 0x29, 0x13, 0x46, 0x1c, 0x49, 0x22, 0x15, 0x4a,\n             0x34, 0x29, 0x12, 0x44, 0x38, 0x21, 0x02, 0x44, 0x38, 0x31, 0x23,\n             0x06, 0x4c, 0x08, 0x11, 0x33, 0x37, 0x3f, 0x2e, 0x1c, 0x48, 0x30,\n             0x31, 0x22, 0x14, 0x48, 0x10, 0x41, 0x32, 0x35, 0x3a, 0x24, 0x08,\n             0x40, 0x00, 0x01, 0x13, 0x37, 0x2f, 0x0f, 0x4e, 0x0c, 0x09, 0x03,\n             0x17, 0x2f, 0x1f, 0x4f, 0x1e, 0x4d, 0x3a, 0x25, 0x1a, 0x44, 0x18,\n             0x41, 0x12, 0x45, 0x2a, 0x05, 0x4a, 0x34, 0x39, 0x33, 0x26, 0x0c,\n             0x48, 0x30, 0x21, 0x03, 0x46, 0x1c, 0x29, 0x03, 0x47, 0x0e, 0x0d,\n             0x1b, 0x27, 0x0f, 0x4f, 0x1e, 0x2d, 0x1b, 0x47, 0x2e, 0x1d, 0x4a,\n             0x14, 0x49, 0x02, 0x45, 0x2a, 0x15, 0x4b, 0x26, 0x0d, 0x4a, 0x14,\n             0x39, 0x23, 0x07, 0x4e, 0x2c, 0x09, 0x43, 0x36, 0x3d, 0x2b, 0x16,\n             0x4c, 0x08, 0x41, 0x12, 0x25, 0x0b, 0x47, 0x2e, 0x0d, 0x4b, 0x06,\n             0x1d, 0x3b, 0x27, 0x1f, 0x4e, 0x0c, 0x49, 0x22, 0x05, 0x4b, 0x26,\n             0x1d, 0x4b, 0x06, 0x4d, 0x1a, 0x35, 0x2b, 0x17, 0x4e, 0x2c, 0x19,\n             0x42, 0x24, 0x09, 0x42, 0x24, 0x19, 0x43, 0x36, 0x2d, 0x0a, 0x44,\n             0x18, 0x31, 0x33, 0x27, 0x1e, 0x4c, 0x28, 0x01, 0x42, 0x04, 0x19,\n             0x23, 0x17, 0x4f, 0x3e, 0x3d, 0x2a, 0x04, 0x48, 0x10, 0x21, 0x13,\n             0x47, 0x0e, 0x4d, 0x3a, 0x35, 0x3b, 0x36, 0x2c, 0x18, 0x40, 0x00,\n             0x41, 0x32, 0x25, 0x1b, 0x46, 0x3c, 0x39, 0x32, 0x34, 0x28, 0x00,\n             0x40, 0x20, 0x01, 0x43, 0x16, 0x3d, 0x3b, 0x37, 0x3e, 0x3c, 0x38,\n             0x20, 0x10, 0x40, 0x20, 0x11, 0x42, 0x04, 0x49, 0x02, 0x05, 0x0b,\n             0x07]\n\n\/\/ functions fa and fb\n\ntanFa : [L1Size]-> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ntanFa L1 x k i = (L1!(x@0)) ^ (L1!(x@1)) ^ ((L1!(x@2)) && (L1!(x@3))) ^ ((L1!(x@4)) && ((iR@0)@i)) ^ (k@(k_a_index @i))\n\ntanFb : [L2Size]-> [ySize][ySize] -> [508] -> [Round] -> Bit\n\ntanFb L2 y k i = (L2!(y@0)) ^ (L2!(y@1)) ^ (L2!(y@2) && L2!(y@3)) ^ (L2!(y@4) && L2!(y@5)) ^ (k@(k_b_index @i))\n\n\/\/left shift L1 and L2 and replace LSBs of them with fb and fa respectively\n\n\ntanAplyFb : [L1Size] -> [L2Size]->  [ySize][ySize] ->[KatanKeySize] -> [Round] -> [L1Size]\ntanAplyFb l1 l2 y key i = (l1 !! [(L1Size-2),(L1Size-3)..0]) # [(tanFb l2 y (keySchedule' key) i)]\n\ntanAplyFa : [L1Size] -> [L2Size]-> [xSize][xSize]->[KatanKeySize] -> [Round] -> [L2Size]\ntanAplyFa l1 l2 x key i = (l2 !! [(L2Size-2),(L2Size-3)..0]) # [(tanFa l1 x (keySchedule' key) i)]\n\n\n\/\/Update LFSR KTANTAN\n\n\nupdateLfsrTan : [L1Size] -> [L2Size]-> [xSize][xSize] -> [ySize][ySize]->[KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\nupdateLfsrTan l1 l2 x y key i = if `(L1Size) == 13\n                             then (l1', l2')\n                             else if `(L1Size) == 19\n                                  then (l1'', l2'')\n                                  else (l1''', l2''')\n\n                 where pt = (tanAplyFb l1 l2 y key i) # (tanAplyFa l1 l2 x key i)\n                       l1' = (splitBlock pt).0\n                       l2' = (splitBlock pt).1\n                       pt' = (tanAplyFb l1' l2' y key i) # (tanAplyFa l1' l2' x key i)\n                       l1'' = (splitBlock pt').0\n                       l2'' =  (splitBlock pt').1\n                       pt'' = (tanAplyFb l1'' l2'' y key i) # (tanAplyFa l1'' l2'' x key i)\n                       l1''' = (splitBlock pt'').0\n                       l2''' =  (splitBlock pt'').1\n\n\/\/Encryption\n\nkatantanEncrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\n\nkatantanEncrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] # [((updateLfsrTan pT.0 pT.1 x y key i).0, (updateLfsrTan pT.0 pT.1 x y key i).1) | i<- [0,1..253] | pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\/\/ Wrapper to do experiments\n\nkatantanEncrypt64 : ([KatanBlock], [KatanBlock]) -> [KatanBlock]\nkatantanEncrypt64  (key, pt) = katantanEncrypt( key#zero, pt)\n\n\nkatantanEncrypt80 : ([KatanKeySize], [KatanKeySize]) -> [KatanKeySize]\nkatantanEncrypt80  (key, pt) = katantanEncrypt( key, (take`{64} pt)) # zero\n\n\n\/\/KTANTAN-Decryption\n\n\ndecTanFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ndecTanFa L1 L2 x k i = fa ^ (L1!((x@1)+1)) ^ (L1!((x@2)+1) && L1!((x@3)+1)) ^ (L1!((x@4)+1) && ((iR@0)@i)) ^ k@(k_a_index@i)\n         where fa = L2!0\n\ndecTanFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [508] -> [Round] -> Bit\ndecTanFb L2 L1 y k i =  fb ^ (L2!((y@1)+1)) ^ ((L2!((y@2)+1)) && L2!((y@3)+1)) ^ ((L2!((y@4)+1)) && L2!((y@5)+1)) ^ k@(k_b_index@i)\n         where fb = L1!0\n\n\/\/Left shifting L1, L2 and appending fa, fb values\n\ntanAplydecFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [KatanKeySize] -> [Round] -> [L1Size]\n\ntanAplydecFa  l1 l2 x k i = [(decTanFa l1 l2 x (keySchedule' k) i)] # (l1!![(L1Size-1),(L1Size-2)..1])\n\n\ntanAplydecFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [KatanKeySize] -> [Round] -> [L2Size]\ntanAplydecFb  l2 l1 y k i =  [(decTanFb l2 l1 y (keySchedule' k) i)] # (l2!![(L2Size-1),(L2Size-2)..1])\n\n\/\/ Updating LFSR for decryption\n\ndecUpdateLfsrTan: [L1Size] -> [L2Size] -> [xSize][xSize]-> [ySize][ySize] -> [KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\ndecUpdateLfsrTan  l1 l2 x y key i = if `(L1Size) == 13\n                                 then (l1', l2')\n                                 else if `(L1Size) == 19\n                                      then (l1'', l2'')\n                                      else (l1''', l2''')\n                               where ct = (tanAplydecFa l1 l2 x key i) # (tanAplydecFb l2 l1 y key i)\n                                     l1' = (splitBlock ct).0\n                                     l2' = (splitBlock ct).1\n                                     ct' = (tanAplydecFa l1' l2' x key i) # (tanAplydecFb l2' l1' y key i)\n                                     l1'' = (splitBlock ct').0\n                                     l2'' = (splitBlock ct').1\n                                     ct'' = (tanAplydecFa l1'' l2'' x key i) # (tanAplydecFb l2'' l1'' y key i)\n                                     l1''' = (splitBlock ct'').0\n                                     l2''' = (splitBlock ct'').1\n\/\/Decryption\n\nkatantanDecrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\nkatantanDecrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] #[ ((decUpdateLfsrTan pT.0 pT.1 x y key i).0 , (decUpdateLfsrTan pT.0 pT.1 x y key i).1)  | i <-[253,252..0] |pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\/\/ Correcteness\n\nproperty katantanCorrect key m = katantanDecrypt(key, katantanEncrypt(key, m)) == m\n\n\/\/ Testing\n\n\/\/32bit block size\n\n\/\/tests32 = [ katan32_2, katantan32_1, katantan32_2]\n\/\/property testsPass = and tests32\n\n\/\/katan32_1 = katanEncrypt(0x00000000, 0xffffffffffffffffffff) == 0x7e1ff945\n\/\/katan32_2 = katanEncrypt(0xffffffff, 0x00000000000000000000) == 0x432e61da\n\n\/\/katantan32_1 = katantanEncrypt(0x00000000, 0xffffffffffffffffffff) == 0x22ea3988\n\/\/katantan32_2 = katantanEncrypt(0xffffffff, 0x00000000000000000000) == 0x432e61da\n\n\n\/\/48bit block size\n\/*\ntests48 = [katan48_1, katan48_2, katantan48_1, katantan48_2]\nproperty testsPass = and tests48\n\nkatan48_1 = katanEncrypt(0x000000000000, 0xffffffffffffffffffff) == 0x4b7efcfb8659\nkatan48_2 = katanEncrypt(0xffffffffffff, 0x00000000000000000000) == 0xa4bd196d0b85\n\nkatantan48_1 = katantanEncrypt(0x000000000000, 0xffffffffffffffffffff) == 0x936d0fa33a05\nkatantan48_2 = katantanEncrypt(0xffffffffffff, 0x00000000000000000000) == 0xa4bd196d0b85\n*\/\n\n\/\/64bit block size\n\ntests64 = [katan64_1, katan64_2, katantan64_1, katantan64_2]\nproperty testsPass = and tests64\n\nkatan64_1 = katanEncrypt( 0xffffffffffffffffffff, zero) == 0x21f2e99c0fab828a\nkatan64_2 = katanEncrypt(zero, 0xffffffffffffffff) == 0xc956100dbeb64ba8\n\nkatantan64_1 = katantanEncrypt(0xffffffffffffffffffff, zero) == 0xc02de05bfa194b16\nkatantan64_2 = katantanEncrypt(zero, 0xffffffffffffffff) == 0xc956100dbeb64ba8\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/TEA.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::TEA where\n\ntype Nb = 2\ntype Nkb = 4\ntype Nr = 2\ntype TeaBlockSize = 64\ntype TeaKeySize = 128\ntype stdBlock = 32\ntype keyInd = 2\n\n\/\/ Splitting plain text\n\nsplitPT: [TeaBlockSize] -> [Nb][stdBlock]\nsplitPT pt = split(pt):[Nb][stdBlock]\n\n\/\/Splitting key\n\nsplitKey: [TeaKeySize] -> [Nkb][stdBlock]\nsplitKey key = split(key):[Nkb][stdBlock]\n\n\/\/A constant derived from golden number\n\ndlta : [stdBlock]\ndlta = 0x9e3779b9\n\nsum = 0xc6ef3720\n\n\/\/ Round function for TEA\n\nteaRoundFun : [stdBlock] -> [stdBlock] -> [stdBlock] -> [stdBlock] -> [stdBlock]\nteaRoundFun pt k1 k2 delta = (pt << 4 + k1) ^ (pt + delta) ^ ((pt>>5)+k2)\n\n\/\/ TEA encryption cycle contains two Feistel rounds\n\nteaEncCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nteaEncCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          k0 = (splitKey key)@0\n          k1 = (splitKey key)@1\n          k2 = (splitKey key)@2\n          k3 = (splitKey key)@3\n          fiestr1 = rpt# roundf1\n          roundf1 = lpt + (teaRoundFun rpt k0 k1 sum)\n          fiestr2 = roundf1 # roundf2\n          roundf2 = rpt + (teaRoundFun roundf1 k2 k3 sum)\n\n\/\/ TEA decryption cycle with two Feistel rounds\n\nteaDecCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nteaDecCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          k0 = (splitKey key)@0\n          k1 = (splitKey key)@1\n          k2 = (splitKey key)@2\n          k3 = (splitKey key)@3\n          roundf2 = rpt - (teaRoundFun lpt k2 k3 sum)\n          roundf1 = lpt - (teaRoundFun roundf2 k0 k1 sum)\n          fiestr2 = roundf1 # roundf2\n\n\n\/\/Encryption: 32 TEA cycles are recommended\n\/\/We change the blocksize as the key size\n\/\/teaEncrypt encrypts actually half of the given plaintext\n\nteaEncrypt : ([TeaKeySize], [TeaBlockSize]) -> [TeaBlockSize]\nteaEncrypt (key, pt) = (hs!0)\n    where hs = [pt] # [ teaEncCycle(m, key, i*dlta) | i <- [1,2..32] | m <- hs ]\n\n\n\n\/\/Decryption\n\nteaDecrypt : ([TeaKeySize], [TeaBlockSize]) -> [TeaBlockSize]\nteaDecrypt (key, ct) = (hs!0)\n    where hs = [ct] # [ teaDecCycle(cT, key, sum-i*dlta) | i <- [0,1..31] | cT <- hs ]\n\n\n\n\nproperty teaCorrect key m = teaDecrypt(key, teaEncrypt (key, m)) == m\n\n\/\/ Helper to run the experiments\n\nteaEncrypt' : ([TeaBlockSize], [TeaBlockSize]) -> [TeaBlockSize]\nteaEncrypt' (key, pt) = (hs!0)\n    where hs = [pt] # [ teaEncCycle(m, key', i*dlta) | i <- [1,2..32] | m <- hs ]\n          key' = key # zero\n\nteaDecrypt' : ([TeaBlockSize], [TeaBlockSize]) -> [TeaBlockSize]\nteaDecrypt' (key, ct) = (hs!0)\n    where hs = [ct] # [ teaDecCycle(cT, key', sum-i*dlta) | i<- [0,1..31] | cT <- hs ]\n          key' = key #zero\n\n\nproperty teaCorrect' key m = teaDecrypt'(key, teaEncrypt'(key, m)) == m\n\n\/************************************************************************\/\n\/************************************************************************\/\n\/* eXtended TEA *\/\n\n\/\/Round function for XTEA\n\nxTeaRoundFun : [stdBlock] -> [TeaKeySize] -> [stdBlock] -> [stdBlock] -> [stdBlock]\nxTeaRoundFun pt key sum1 sum2 = (((pt << 4) ^ (pt >> 5)) + pt) ^ (sum1 + k)\n    where k = (splitKey key)@(sum2 !![1,0])\n\n\/\/ XTEA cycle contains two Feistel rounds\n\nxTeaEncCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nxTeaEncCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          roundf1 = lpt +(xTeaRoundFun rpt key sum sum)\n          fiestr2 = roundf1 # roundf2\n          roundf2 = rpt+(xTeaRoundFun roundf1 key (sum+dlta) ((sum+dlta)>>11))\n\n\/\/XTEA decryption cycle contains two Feistel rounds\n\nxTeaDecCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nxTeaDecCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          roundf2 = rpt - (xTeaRoundFun lpt key sum (sum>>11))\n          roundf1 = lpt - (xTeaRoundFun roundf2 key (sum-dlta) (sum-dlta))\n          fiestr2 = roundf1 # roundf2\n\n\n\/\/Encryption: 32 XTEA cycles are recommended\n\/\/I change the signatures to run the experiments\n\ntype PTSize = TeaBlockSize\ntype CTSize = TeaBlockSize\n\nxTeaEncrypt : ([TeaKeySize], [PTSize]) -> [CTSize]\nxTeaEncrypt (key, pt) = (hs!0)\n    where hs = [pt] # [ xTeaEncCycle (m, key, i*dlta) | i <- [0,1..31] | m <- hs ]\n\n\/\/Decryption\n\nxTeaDecrypt : ([TeaKeySize], [CTSize]) -> [PTSize]\nxTeaDecrypt (key, ct) = (hs!0)\n    where hs = [ct] # [ xTeaDecCycle (pT, key, i*dlta) | i <- [32,31..1] | pT <- hs ]\n\nproperty xTeaCorrect key m = xTeaDecrypt(key, xTeaEncrypt(key, m)) == m\n\n\/\/ Helper function to run experiments\n\nxTeaEncrypt64 : ([PTSize], [PTSize]) -> [CTSize]\nxTeaEncrypt64 (key, pt) = (hs!0)\n    where hs = [pt] # [ xTeaEncCycle (m, key', i*dlta) | i <- [0,1..31] | m <- hs ]\n          key' = key # zero\n\nxTeaDecrypt64 : ([CTSize], [PTSize]) -> [PTSize]\nxTeaDecrypt64 (key, ct) = (hs!0)\n    where hs = [ct] # [ xTeaDecCycle (pT, key', i*dlta) | i <- [32,31..1] | pT <- hs ]\n          key' = key # zero\n\nproperty xTeaCorrect64 key m = xTeaDecrypt64 (key, xTeaEncrypt64(key,m)) == m\n\n\nxTeaEncrypt128 : ([TeaKeySize], [TeaKeySize]) -> [TeaKeySize]\nxTeaEncrypt128 (key, pt) = xTeaEncrypt (key, (take`{64} pt)) # zero\n\n\/************************************************************************\/\n\/************************************************************************\/\n\/* Corrected Block TEA or XXTEA*\/\n\/* XTEA modified to cater larger block sizes*\/\n\ntype NB = 2\nNr = 6 + 52\/`NB\ntype bTeaPtSize= NB*stdBlock\n\n\/\/Splitting text into number of words\n\nsplitPtN: [bTeaPtSize] -> [NB][stdBlock]\nsplitPtN pt = split(pt) : [NB][stdBlock]\n\n\/\/Round Function\n\nbTeaRoundFun: [stdBlock]-> [stdBlock]-> [TeaKeySize]-> [6]-> [stdBlock]->[stdBlock]\nbTeaRoundFun y z key p sum = ((z>>5) ^ (y<<2)) + ((y>>3) ^ (z<<4)) ^ (sum ^ y) + ((ki @ ((p!![1,0]) ^ e)) ^ z)\n    where ki = (splitKey key)\n          e = (sum >> 2) !![1,0]\n\n\/\/Mixing in encryption\n\nbTeaEncMixing : ([bTeaPtSize], [TeaKeySize], [stdBlock]) -> [bTeaPtSize]\n\nbTeaEncMixing (pt, key, sum) = join hs'\n    where pt' = splitPtN pt\n          hs = [ (pt'@0)+(bTeaRoundFun (pt'@1) (pt'@(`NB-1)) key 0 sum) ] # [ (pt'@p)+(bTeaRoundFun (pt'@(p+1)) h key p sum) | p <- [1,2..NB-2] | h <- hs ]\n          hs' = hs # [ (pt'@(`NB-1)) + (bTeaRoundFun (hs@0) (hs!0) key (`NB-1) sum) ]\n\n\n\n\/\/Encryption\n\nbTeaEncrypt : ([TeaKeySize], [bTeaPtSize]) -> [bTeaPtSize]\nbTeaEncrypt (key, pt) = hs!0\n    where hs = [bTeaEncMixing (pt, key, dlta)] # [ bTeaEncMixing (pT, key, i*dlta) | i <- [2,3..Nr] | pT <- hs ]\n\n\n\/\/Mixing in decryption\n\n\nbTeaDecMixing : ([bTeaPtSize], [TeaKeySize], [stdBlock]) -> [bTeaPtSize]\n\nbTeaDecMixing (pt, key, sum) = join hs''\n    where pt' = splitPtN pt\n          hs= [(pt'@(`NB-1)) - (bTeaRoundFun (pt'@0) (pt'@(`NB-2)) key  1 sum)] # [ pt'@(`NB-1-p)-(bTeaRoundFun h (pt'@ (`NB-2-p)) key p sum) | p <- [1,2..(NB-2)] | h <- hs ]\n          hs' =  hs # [ pt'@0 - (bTeaRoundFun (hs!0) (hs@0) key  0 sum)]\n          hs'' = [hs'!0] # [hs'!i | i<- [1,2..NB-1] ]\n          \/\/e = (sum >> 2) !![1,0]\n          \/\/hs'' = [(hs'!0).2]# [((hs'!i).2) | i<-[1,2..`NB-1]]\n\n\/\/ Decryption\n\nbTeaDecrypt : ([TeaKeySize], [bTeaPtSize]) -> [bTeaPtSize]\nbTeaDecrypt (key, pt) =  hs!0\n    where hs = [bTeaDecMixing (pt, key, `Nr*dlta)] # [ bTeaDecMixing (pT, key, (`Nr-i)*dlta) | i <- [1,2..(Nr-1)] | pT <- hs ]\n\n\/\/ correctness\n\nproperty bTeaCorrect key m = bTeaDecrypt(key, bTeaEncrypt (key, m)) == m\n\n\ntests = [teaTest, xteaTest, xxteaTest]\nproperty testsPass = and tests\n\n\/\/ TEA\nteaTest = teaEncrypt(0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0xce674a7575034065\n\/\/XTEA\nxteaTest = xTeaEncrypt(0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0x27e795e076b2b537\n\/\/XXTEA or bTEA\nxxteaTest = bTeaEncrypt(0x0123456789abcdef0123456789abcdef,0x0123456789abcdef) == 0x2b98de778c9b788c\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Specification.cry","filetype":"cry","content":"\/*\nGalois Counter Mode in Cryptol\n\n@copyright Galois, Inc.\n@author Sean Weaver\n@author Marcella Hastings <marcella@galois.com>\n\nThis implementation follows NIST special publication 800-38D:\n[NIST-SP-800-38D] Morris Dworkin. Recommendation for Block Cipher Modes\nof Operation: Galois\/Counter Mode (GCM) and GMAC. NIST Special\nPublication 800-38D. November 2007.\n\nThis implementation deviates from the original spec in the following ways:\n- The original spec allows tag lengths 96, 104, 112, 120, and 128 in all\n  settings, and allows length 64 or 32 in certain applications. This\n  implementation does not allow short tags (32 or 64) at all.\n\n\u26a0\ufe0f Warning \u26a0\ufe0f: There are several properties of GCM mode that Cryptol cannot\nenforce! These include:\n- GCM mode will fail catastrophically if a (key, IV) pair is ever reused\n  to encrypt different pieces of data.\n  Implementors must manually verify that keys and IVs are chosen in such\n  a way that they will not be reused. See [NIST-SP-800-38D] Section 8.\n- The total number of invocations of `GCM_AE` with a given key must not\n  exceed 2^{32}. This is to prevent the catastrophic failure in the previous\n  point. Cryptol cannot evaluate the \"global\" use of the encryption function.\n- The intermediate values used in the execution of GCM functions must be\n  secret, and not reused or recomputed for any other purpose.\n- The original spec requires an implementation with `GCM_AE` and `GCM_AD`\n  must support the same ciphertext, associated data, and IV lengths for\n  both algorithms.\n*\/\n\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Specification where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\/**\n * GCM mode is only defined for ciphers that operate over 128-bit blocks.\n * [NIST-SP-800-38D] Section 5.1\n *\/\ninterface constraint (C::BlockSize == 128)\n\/**\n * GCM mode is only defined for ciphers with a key size of at least 128 bits.\n * [NIST-SP-800-38D] Section 5.1\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: GCM mode has other requirements on the key that cannot be\n * enforced by Cryptol (for example, that it is generated uniformly at random).\n * See Section 8.1 of [NIST-SP-800-38D].\n *\/\n interface constraint (128 <= C::KeySize)\n\n\/**\n * The IV has bit length `1 \u2264 IV \u2264 2^64 - 1` and is a multiple of 8.\n * [NIST-SP-800-38D] Section 5.2.1.1\n *\/\ntype constraint ValidIV IV = (width IV <= 64, IV >= 1, IV % 8 == 0)\n\/**\n * The associated data has bit length `AAD \u2264 2^64 - 1` and is a multiple of 8.\n * [NIST-SP-800-38D] Section 5.2.1.1\n *\/\ntype constraint ValidAAD AAD = (width AAD <= 64, AAD % 8 == 0)\n\/**\n * The tag T can be of length 96, 104, 112, 120, or 128.\n * [NIST-SP-800-38D] Section 5.2.1.2\n *\/\ntype constraint ValidTag T = (fin T, T % 8 == 0, T \/ 8 >= 12, T \/ 8 <= 16)\n\/**\n * The plaintext (for encryption) and ciphertext (for decryption) must not\n * be too large and is a multiple of 8.\n * [NIST-SP-800-38D] Section 5.2.1.1 (for plaintexts) and Section 5.2.2\n * (for ciphertexts).\n *\/\ntype constraint ValidText P = (fin P, P <= 2^^39 - 256, P % 8 == 0)\n\n\/**\n * GCM-AE Function, [NIST-SP-800-38D] Section 7.1, Algorithm 4. This provides\n * authenticated encryption.\n *\/\nGCM_AE : { len_C, len_IV, len_A, T } (ValidText len_C, ValidIV len_IV, ValidAAD len_A, ValidTag T)\n => [C::KeySize] -> [len_IV] -> [len_C] -> [len_A] -> ([len_C], [T])\nGCM_AE k iv p a = (C, T)\n  where\n    CIPHk = C::encrypt k\n\n    H = CIPHk 0\n    J0 = define_J0 k iv H\n    C = GCTR CIPHk (inc`{32} J0) p\n    type u = len_C %^ 128 \/\/ Equivalently: 128 * len_C \/^ 128 - len_C\n    type v = len_A %^ 128 \/\/ Equivalently: 128 * len_A \/^ 128 - len_A\n    S = GHASH`{len_A\/^ 128 + len_C \/^ 128 + 1}\n            H (a # (0 : [v]) # C # (0 : [u]) # (`len_A : [64]) # (`len_C : [64]))\n    T = MSB`{T} (GCTR CIPHk J0 S)\n\n\/**\n * GCM-AD Function, [NIST-SP-800-38D] Section 7.2, Algorithm 5. This provides\n * authenticated decryption.\n *\/\nGCM_AD : { len_C, len_IV, len_A, T } (ValidText len_C, ValidIV len_IV, ValidAAD len_A, ValidTag T)\n => [C::KeySize] -> [len_IV] -> [len_C] -> [len_A] -> [T] -> Option [len_C]\nGCM_AD key iv ct aad tag =\n  if tag == T'\n  then Some P\n  else None\n  where\n    CIPHk = C::encrypt key\n\n    H = CIPHk 0\n    J0 = define_J0 key iv H\n    P = GCTR CIPHk (inc`{32} J0) ct\n    type u = len_C %^ 128 \/\/ Equivalently: 128 * len_C \/^ 128 - len_C\n    type v = len_A %^ 128 \/\/ Equivalently: 128 * len_A \/^ 128 - len_A\n    S = GHASH`{len_A \/^ 128 + len_C \/^ 128 + 1}\n            H (aad # (0 : [v]) # ct # (0 : [u]) # (`len_A : [64]) # (`len_C : [64]))\n    T' = MSB`{T} (GCTR CIPHk J0 S)\n\n\/**\n * Property demonstrating equivalence between `mult` and `\u2022`.\n * This takes more than 25 minutes to `:prove`.\n * ```repl\n * :check dotAndMultAreEquivalent\n * ```\n *\/\nproperty dotAndMultAreEquivalent X Y = mult X Y == X \u2022 Y\n\n\/**\n * Property demonstrating that decryption is the inverse of encryption.\n *\n * This property takes more than 20 minutes to `:prove`.\n * It's spot-checked in the test vectors.\n * Here we pick a fixed set of parameters, but it should be true\n * for all valid tag, aad, and plaintext lengths.\n * - P = 256 because we want to test the block chaining, so we need at least 2\n * - IV = 96 because it's the shortest allowable value\n * - AAD = 8 because we want to make sure it's incorporated\n *\n * ```repl\n * :check gcmIsSymmetric `{AAD=8, P=256, IV=96}\n * ```\n *\/\ngcmIsSymmetric : { P, IV, AAD } ( ValidText P, ValidIV IV, ValidAAD AAD )\n  => [C::KeySize] -> [IV] -> [P] -> [AAD] -> Bool\nproperty gcmIsSymmetric key iv pt aad = is_symmetric\n    where\n        (ct, tag : [96]) = GCM_AE key iv pt aad\n        dec = GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nprivate\n  \/**\n  * A helper function used in GCM_AE and GCM_AD. We must define this at the top\n  * level due to its use of Cryptol's numeric constraint guards feature, which\n  * currently only works in top-level definitions.\n  *\n  * See [NIST-SP-800-38D] Algorithm 4, Step 2 and Algorithm 5, Step 3.\n  *\/\n  define_J0 : { len_IV } ( ValidIV len_IV ) => [C::KeySize] -> [len_IV] -> [128] -> [128]\n  define_J0 k iv H\n    | len_IV == 96 => iv # (0 : [31]) # (1 : [1])\n    | len_IV != 96 => GHASH`{len_IV \/^ 128 + 1} H (iv # (0 : [s + 64]) # (`len_IV: [64]))\n    where\n      type s = len_IV %^ 128  \/\/ Equivalently: 128 * len_IV \/^ 128 - len_IV\n\n  \/**\n  * Multiplication Operation on Blocks, [NIST-SP-800-38D] Section\n  * 6.3, Algorithm 1. This is optimized to use Cryptol's built-in `pmult` and\n  * `pmod` functions. This operation is described using little-endian\n  * notation, hence the `reverse`s.\n  *\/\n\n  (\u2022) : [128] -> [128] -> [128]\n  (\u2022) X Y = reverse (pmod (pmult (reverse X) (reverse Y))\n                          <| 1 + x + x^^2 + x^^7 + x^^128|>)\n\n  \/**\n  * Multiplication Operation on Blocks, [NIST-SP-800-38D] Section\n  * 6.3. This matches the spec very closely.\n  *\/\n\n  mult : [128] -> [128] -> [128]\n  mult X Y = last Z\n    where\n      R = 0b11100001 # (0 : [120])\n      Z = [0] # [ if [xi] == 0 then Zi else Zi ^ Vi\n                | Zi <- Z\n                | xi <- X\n                | Vi <- V ]\n      V = [Y] # [ if LSB`{1} Vi == 0 then Vi >> 1 else (Vi >> 1) ^ R\n                | Vi <- V ]\n\n  \/**\n  * GHASH Function, [NIST-SP-800-38D] Section 6.4, Algorithm 2.\n  *\/\n\n  GHASH : {m} (fin m) => [128] -> [m * 128] -> [128]\n  GHASH H X = last Y\n    where Y = [0] # [ (Yi ^ Xi) \u2022 H | Yi <- Y | Xi <- groupBy`{128} X ]\n\n  \/**\n  * The output of incrementing the right-most s bits of the bit\n  * string X, regarded as the binary representation of an integer, by\n  * 1 modulo 2s, [NIST-SP-800-38D] Sections 4.2.2 and 6.2. Care was\n  * taken here to ensure `s` could be zero.\n  *\/\n\n  inc : {s, a} (fin s, fin a, a >= s) => [a] -> [a]\n  inc X = MSB`{a-s} X # (LSB`{s} X + take (1 : [max s 1]))\n\n\n  \/**\n  * The bit string consisting of the s right-most bits\n  * of the bit string X, [NIST-SP-800-38D] Section 4.2.2.\n  *\/\n\n  LSB : {s, a} (fin s, fin a, a >= s) => [a] -> [s]\n  LSB X = drop X\n\n  \/**\n  * The bit string consisting of the s left-most bits of\n  * the bit string X, [NIST-SP-800-38D] Section 4.2.2.\n  *\/\n\n  MSB : {s, a} (fin s, a >= s) => [a] -> [s]\n  MSB X = take X\n\n  \/**\n  * GCTR Function, [NIST-SP-800-38D] Section 6.5, Algorithm 3.\n  *\/\n\n  GCTR : {a} (fin a) => ([128] -> [128]) -> [128] -> [a] -> [a]\n  GCTR CIPHk ICB X = Y\n    where\n      Y = X ^ take`{a} (join (map CIPHk CB))\n      CB = iterate inc`{32} ICB\n\n  \/**\n   * GCTR should return an empty output when given an empty input.\n   * This property is described in [NIST-SP-800-38D], Algorithm 3.\n   *\n   * ```repl\n   * :prove emptyInputProducesEmptyOutputGCTR\n   * ```\n   *\/\n  emptyInputProducesEmptyOutputGCTR : [C::KeySize] -> [128] -> Bool\n  property emptyInputProducesEmptyOutputGCTR key icb =\n   zero == (GCTR CIPHk icb (zero : [0]))\n    where\n      CIPHk = C::encrypt key\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Tests\/AES128_GCM.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES128_GCM where\nimport Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM as AES_GCM\n\n\/**\n * Source: [GCM Submission]\n * ```repl\n * :prove aes128_vector_0\n * ```\n *\/\nproperty aes128_vector_0 = ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        pt = []\n        key = zero : [128]\n        iv = zero : [96]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt []\n        dec = AES_GCM::GCM_AD key iv ct [] tag\n        expected_ct = [] : [0]\n        expected_tag = 0x58e2fccefa7e3061367f1d57a4e7455a : [128]\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\n\/**\n * Source: [GCM Submission]\n * ```repl\n * :prove aes128_vector_1\n * ```\n *\/\nproperty aes128_vector_1 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = zero\n        iv = zero : [96]\n        pt = zero\n        aad = []\n        expected_ct = 0x0388dace60b6a392f328c2b971b2fe78 : [128]\n        expected_tag = 0xab6e47d42cec13bdf53a67b21257bddf : [128]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\n\n\/**\n * Source: [GCM Submission]\n * ```repl\n * :prove aes128_vector_2\n * ```\n *\/\nproperty aes128_vector_2 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = 0xfeffe9928665731c6d6a8f9467308308\n        iv = 0xcafebabefacedbaddecaf888 : [96]\n        pt = 0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b391aafd255\n        aad = []\n        expected_ct = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091473f5985\n        expected_tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4 : [128]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\n\n\/**\n * Source: [GCM Submission]\n * ```repl\n * :prove aes128_vector_3\n * ```\n *\/\nproperty aes128_vector_3 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = 0xfeffe9928665731c6d6a8f9467308308\n        pt  = 0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39\n        iv  = 0xcafebabefacedbaddecaf888\n        aad = 0xfeedfacedeadbeeffeedfacedeadbeefabaddad2\n        expected_ct  = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091\n        expected_tag = 0x5bc94fbc3221a5db94fae95ae7121a47\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Tests\/AES256_GCM.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES256_GCM where\nimport Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES256_GCM as AES_GCM\n\n\/**\n * Source: [OPENSSL]\n * ```repl\n * :prove aes256_vector_0\n * ```\n *\/\nproperty aes256_vector_0 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key   = 0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f : [256]\n        iv    = 0x99aa3e68ed8173a0eed06684 : [96]\n        pt    = 0xf56e87055bc32d0eeb31b2eacc2bf2a5 : [128]\n        aad   = 0x4d23c3cec334b49bdb370c437fec78de : [128]\n        expected_ct   = 0xf7264413a84c0e7cd536867eb9f21736\n        expected_tag  = 0x67ba0510262ae487d737ee6298f77e0c\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\n\/**\n * Source: Modified from [OPENSSL]. I just borked the tag to make sure decryption fails if\n * the tag is wrong.\n * ```repl\n * :prove aes256_invalid_vector_1\n * ```\n *\/\nproperty aes256_invalid_vector_1 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ requires_symmetry\n    where\n        key   = 0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f : [256]\n        iv    = 0x99aa3e68ed8173a0eed06684 : [96]\n        pt    = 0xf56e87055bc32d0eeb31b2eacc2bf2a5 : [128]\n        aad   = 0x4d23c3cec334b49bdb370c437fec78de : [128]\n        expected_ct   = 0xf7264413a84c0e7cd536867eb9f21736\n        expected_tag  = 0x67ba0510262ae487d737ee6298f77e0c\n        invalid_tag  = 0x67ba0510262ae487d737ee6298f77888\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        requires_symmetry = case (AES_GCM::GCM_AD key iv ct aad invalid_tag) of\n            Some _ -> False\n            None -> True\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Instantiations\/AES128_GCM.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM =\n    Primitive::Symmetric::Cipher::Authenticated::GCM::Specification {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Instantiations\/AES256_GCM.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES256_GCM =\n    Primitive::Symmetric::Cipher::Authenticated::GCM::Specification {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CBC.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC where\n\nimport Primitive::Symmetric::Cipher::Block::TripleDES (encrypt, decrypt)\n\n\/\/ Test vectors from https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/TDES_CBC.pdf\ntype iv = [64]\ntype block = [64]\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncbcTDesEnc : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncbcTDesEnc k1 k2 k3 iv ps = cs\n    where\n        ks = [ k1, k2, k3 ]\n        cs = [ encrypt ks (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbcTDesDec : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncbcTDesDec k1 k2 k3 iv cts = pts\n    where\n        ks  = [ k1, k2, k3 ]\n        pts = [ (decrypt ks ct) ^ fb |  ct <- cts | fb <- [iv] # cts  ]\n\ncbcTDESEncryptDecryptInverts : k1 -> k2 -> k3 -> iv -> [3]block -> Bit\nproperty cbcTDESEncryptDecryptInverts k1 k2 k3 iv pt = pt == pt'\n    where\n        ct  = cbcTDesEnc k1 k2 k3 iv pt\n        pt' = cbcTDesDec k1 k2 k3 iv ct\n\n\/\/ Number of blocks := 2\n\ntestKey = { k1=0x0123456789ABCDEF\n          , k2=0x23456789ABCDEF01\n          , k3=0x456789ABCDEF0123\n          , iv=0xF69F2445DF4F9B17\n          }\ntestPt  = [0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]\ntestCt  = [0x2079C3D53AA763E1, 0x93B79E2569AB5262, 0x516570481F25B50F, 0x73C0BDA85C8E0DA7]\n\nproperty testsPass = pt == testPt\n                  \/\\ ct == testCt\n    where\n        ct = cbcTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv testPt\n        pt = cbcTDesDec testKey.k1 testKey.k2 testKey.k3 testKey.iv testCt\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CBC.cry","filetype":"cry","content":"\/*\n * Cipher Block Chaining mode of operation, as defined in [NIST-SP-800-38A], Section 6.2.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure confidentiality, CBC mode requires that the initialization vector (IV) is generated \"unpredictably\".\n * This specification does not verify IV generation;\n * implementors must manually verify that their IVs were chosen appropriately.\n *\n * For guidelines on generating IVs, see Appendix C of [NIST-SP-800-38A].\n * For information on the importance of protecting IV integrity, see Appendix D of [NIST-SP-800-38A].\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n * @author Stanislav Lyakhov <stan@galois.com>\n * www.cryptol.net\n *\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n *     Modes of Operation: Methods and Techniques. NIST Special Publication\n *     800-38A. December 2001.\n *     @see https:\/\/doi.org\/10.6028\/NIST.SP.800-38A\n *\n *\/\n\n\nmodule Primitive::Symmetric::Cipher::Block::Modes::CBC where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\n\/**\n * CBC encryption: [NIST-SP-800-38A] Section 6.2.\n *\n * Parameters: key, initialization vector, plaintext\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure confidentiality, CBC mode requires that the initialization vector (IV) is generated \"unpredictably\".\n * This specification does not verify IV generation;\n * implementors must manually verify that their IVs were chosen appropriately.\n *\/\nencrypt : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\nencrypt K IV Ps = Cs\n    where\n        CIPH_K = C::encrypt K\n        Cs = [ CIPH_K (P_j ^ C_j_1) | P_j <- Ps | C_j_1 <- [IV] # Cs]\n\n\/**\n * CBC decryption: [NIST-SP-800-38A] Section 6.2.\n *\n * Parameters: key, initialization vector, ciphertext\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure confidentiality, CBC mode requires that the initialization vector (IV) is generated \"unpredictably\".\n * This specification does not verify IV generation;\n * implementors must manually verify that their IVs were chosen appropriately.\n *\/\ndecrypt : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\ndecrypt K IV Cs = Ps\n    where\n        CIPH_K_inv = C::decrypt K\n        Ps = [ (CIPH_K_inv C_j) ^ C_j_1 | C_j <- Cs | C_j_1 <- [IV] # Cs]\n\n\/**\n * Decryption must be the inverse of encryption.\n * With high probability, this will be incredibly slow to prove.\n * ```repl\n * :check encryptCorrect`{n=5}\n * ```\n *\/\nencryptCorrect : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> Bool\nproperty encryptCorrect K IV Ps = (decrypt K IV (encrypt K IV Ps)) == Ps\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CTR.cry","filetype":"cry","content":"\/*\n * Counter mode of operation, as defined in [NIST-SP-800-38A], Section 6.5.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: CTR mode will fail catastrophically if a (key, counter) pair is ever reused.\n * Cryptol cannot detect such failures! Please audit your implementations separately for\n * this issue.\n *\n *\n * This deviates from the original NIST spec in several ways:\n * - The spec allows arbitrary length plaintexts. This implementation fixes\n *   the plaintext to be an exact multiple of the block length.\n * - The spec allows any incrementing function that generates `n` unique strings\n *   of `m` bits in succession, where `n` is the plaintext length and `m` is the\n *   number of bits to be updated in the counter block (n <= C::BlockSize).\n *   This implementation fixes the incrementing function to be the standard\n *   incrementing function: `[x]_m -> [x + 1 mod 2^m]_m` for `m = C::BlockSize`.\n *   See Appendix B of [NIST-SP-800-38A] for discussion.\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n * www.cryptol.net\n *\n * References:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n * Modes of Operation: Methods and Techniques. NIST Special Publication\n * 800-38A. December 2001.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Modes::CTR where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\n\/**\n * CTR encryption: [NIST-SP-800-38A] Section 6.5.\n *\n * Parameters: key, initial counter, plaintext\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: CTR mode will fail catastrophically if a (key, counter) pair is ever reused.\n * Cryptol cannot detect such failures!\n * The type constraint on `n` prevents counter reuse within a single encryption, but\n * implementors must manually verify that counter reuse will not happen across multiple\n * calls to `encrypt`.\n *\/\nencrypt : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\nencrypt k t_1 ps = cs\n    where\n        ciph_k = C::encrypt k\n        \/\/ `ciph_k t_j` is called `O_j` in the original spec\n        cs = [p_j ^ (ciph_k t_j) | p_j <- ps | t_j <- ctrs]\n        \/\/ Counters are called `T_1, ..., T_n` in the original spec\n        ctrs = [t_1 + i | i<- [0...]]\n\n\/**\n * CTR decryption: [NIST-SP-800-38A] Section 6.5.\n *\n * Parameters: key, initial counter, ciphertext\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: CTR mode will fail catastrophically if a (key, counter) pair is ever reused.\n * Cryptol cannot detect such failures!\n *\/\ndecrypt : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\ndecrypt k t_1 cs = ps\n    where\n        ciph_k = C::encrypt k\n        \/\/ (ciph_k t_j) is called O_j in the original spec\n        ps = [c_j ^ (ciph_k t_j) | c_j <- cs | t_j <- ctrs]\n        \/\/ Counters are called T_1, ..., T_n in the original spec\n        ctrs = [t_1 + i | i<- [0...]]\n\n\/**\n * Decryption must be the inverse of encryption.\n * With high probability, this will be incredibly slow to prove.\n * ```repl\n * :check encryptCorrect`{n=5}\n * ```\n *\/\nencryptCorrect : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> Bool\nproperty encryptCorrect k c ps = (decrypt k c (encrypt k c ps)) == ps\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/XTS.cry","filetype":"cry","content":"\/**\n * Implementation of the XTS Tweakable Block Cipher mode.\n *\n * This version implements the specification as defined in [IEEE2007].\n * The primary difference in [IEEE2018] constraints the overall\n * size of a data stream in a way that isn't constrained by this\n * implementation and would need to be enforced by the application.\n *\n * This implementation does not define key scopes or key export as described\n * in sections 6 and 7.\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n * @author John Christensen <jchristensen@galois.com>\n *\n * References:\n * [NIST]: NIST SP 800-38E: Recommendation for Block Cipher Modes of Operation:\n *   The XTS-AES Mode for Confidentiality on Storage Devices.\n * [IEEE2007]: IEEE Std 1619-2007, The XTS-AES Tweakable Block Cipher, Institute of\n *   Electrical and Electronics Engineers, Inc., Apr. 18, 2008.\n * [IEEE2018]: IEEE Std 1619-2018, The XTS-AES Tweakable Block Cipher, Institute of\n *   Electrical and Electronics Engineers, Inc., Oct. 23 2018.\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::XTS where\n\n\/\/ [IEEE2007] only defines XTS-AES-128 and XTS-AES-256. Other instantiations\n\/\/ of this functor are not permitted by [NIST].\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\n\/*\n * XTS encrypts a `data stream` that is divided into consecutive equal size\n * `data units`.\n *\n * References:\n *   [IEEE2007] Section 5.1\n *   [IEEE2018] Section 5.1\n *\/\n\n\/**\n * In particular, the result of AES encryption and decryption (a 16-byte value) is\n * multiplied by a primitive element of GF(2^128) during the encryption and decryption\n * procedures.\n *\n * References:\n *   [IEEE2007] Section 5.2\n *   [IEEE2018] Section 5.2\n *\/\ninterface constraint (C::BlockSize == 128)\n\n\/**\n * Cryptol treats all bitvectors in big-endian numbers.\n * The specification treats byte arrays as little-endian numbers\n * for the purposes of encrypting the tweak.\n *\n * References:\n *   [IEEE2007] Section 5.2\n *   [IEEE2018] Section 5.2\n *\/\nflipEndian : [128] -> [128]\nflipEndian x = join (reverse (groupBy`{8} x))\n\n\/**\n * The `flipEndian` procedure is its own inverse.\n *\n * ```repl\n * :prove flipEndianInvolutive\n * ```\n *\/\nproperty flipEndianInvolutive x = flipEndian (flipEndian x) == x\n\n\/**\n * NIST SP 800-38E states: The length of the data unit for any instance of\n * an implementation of XTS-AES shall not exceed 2^20 AES blocks.\n *\n * This restriction of _within a data unit_ is consistent with both\n * [IEEE2007] and [IEEE2018].\n *\n * [IEEE2007] and [IEEE2018] Section 5.3.2 imply the data unit must be\n * at least the length of the block size. The final block, presuming there\n * is at least one full block, can be extended with ciphertext stealing,\n * but there is no such scheme if the plaintext length is too short.\n *\n * [IEEE2007] and [IEEE2018] Section 5.1:\n * - The data unit size shall be at least 128 bits.\n * - The number of 128-bit blocks should not exceed 2^20.\n *\/\ntype constraint ValidLength n = (n \/^ C::BlockSize <= 2^^20, n >= C::BlockSize, fin n)\n\n\/**\n * 5.1 Computing initial tweak from a data unit number.\n *\n * The initialization vector is defined to be a little-endian, zero-padded\n * representation of the data unit sequence number.\n *\n * Technically, per 5.1 the tweak is a non-negative integer.\n * When it is encrypted, it is converted to a little-endian byte array.\n * It must be the correct block size for AES encryption\/decryption, hence,\n * the padding.\n *\n * Per section 5.3.1, the tweak is a 128 bit value.\n *\n * References:\n *   [IEEE2007] Section 5.1, 5.3.1\n *   [IEEE2018] Section 5.1, 5.3.1\n *\/\ndataUnitSeqNoToIV : {n} (n <= 128) => [n] -> [128]\ndataUnitSeqNoToIV S = flipEndian (zext S)\n\n\/**\n * Example found in 5.1\n *\n * ```repl\n * :prove dataUnitSeqNoExample\n * ```\n *\/\nproperty dataUnitSeqNoExample = dataUnitSeqNoToIV 0x123456789a == 0x9a785634120000000000000000000000\n\n\/**\n * 5.2 Multiplication by a primitive element \u0251\n *\n *  The next tweak value is computed by performing a GF128 multiplication of\n *  \u03b1 modulo an irreducible polynomial. This arithmetic is defined to be\n *  performed using a little-endian byte order.\n *\n * This is a single iteration of the formula in Section 5.2.\n *\/\nmultAlphaLE : [128] -> [128]\nmultAlphaLE x = flipEndian (multAlpha (flipEndian x))\n  where\n    multAlpha p = pmod (pmult p alpha) irreducible\n\n\/**\n * The IEEE standard `\u03b1` to be the polynomial `x` in GF(2^128).\n * This is a primitive polynomial in this field, which means taking\n * powers of `\u03b1` generate all non-zero elements of the field.\n *\n * References:\n *  [IEEE2007] Section 4.2\n *  [IEEE2018] Section 4.2\n *\/\nalpha : [2]\nalpha = <| x |>\n\n\/**\n * Irreducible polynomial defining GF(2^128).\n *\n * References:\n *  [IEEE2007] Section 4.2\n *  [IEEE2018] Section 4.2\n *\/\nirreducible : [129]\nirreducible = <| x^^128 + x^^7 + x^^2 + x + 1 |>\n\n\/**\n * Generates an infinite stream of tweak blocks to be used in encryption and\n * decryption given an initialization vector. This can be thought of as\n * multiplication by successive powers of \u03b1, starting with the zeroth power,\n * with an initial value of the encryption of the first tweak.\n *\n * Each element of the resulting stream at index `j` has the value\n * `AES-enc(Key\u2082, i) \u2297 \u03b1^j`\n * (using the notation from [IEEE2007]).\n *\n * Here, the tweak has already been converted to a 128 bit value,\n * per Section 5.3.1 of the IEEE standards.\n *\n * The iteration is defined in [IEEE2007] Section 5.2.\n * The initial value is defined in [IEEE2007] Section 5.3.1, Step 1.\n *\/\ngenerateTweaks : [C::KeySize] -> [128] -> [inf][128]\ngenerateTweaks K2 i = iterate multAlphaLE (C::encrypt K2 i)\n\n\/**\n * 5.3.1 encryption of a single 128-bit block\n *\/\nencryptBlock : [C::KeySize] -> [128] -> [128] -> [128]\nencryptBlock K T P = C\n  where\n    \/\/ `T` is computed externally using the\n    \/\/ `generateTweaks` function in this implementation.\n    PP = T ^ P     CC = C::encrypt K PP     C  = CC ^ T \/**\n *  5.3.2 encryption of a data unit.\n *\n * Here, the sequence number `j` is implicit, and\n * is handled by `generateTweaks`.\n *\n * This implementation separates out the case where the plaintext is a\n * multiple of the blocksize.\n *\n *\/\nencrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]\nencrypt (K1 # K2) i P\n  | 0 == n % 128 =>\n    join\n      [ encryptBlock K1 T blk\n      | T <- generateTweaks K2 i\n      | blk <- split`{n \/ 128} P ]\n  | otherwise => C\n    where\n      \/\/ Number of full blocks of plaintext\n      \/\/ Section 5.3.2 calls `M` `m`.\n      type M = n \/ 128\n\n      \/\/ Generate `M + 1` tweaks.\n      \/\/ If `Pm`, the final block, is empty,\n      \/\/ we will not need this tweak.\n      T_0_m1 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)\n\n      \/\/ Partition `P` into `M + 1` blocks.\n      \/\/ The first `m` blocks are all 128 bits long.\n      \/\/ The final block, `Pm`, is between `1` and `127` bits long.\n      P_0_m2 # Pm1 # Pm = P\n\n      \/\/ Step 1.\n      C_0_m2 = join [encryptBlock K1 T blk | T <- T_0_m1 | blk <- split`{M - 1} P_0_m2]\n\n      \/\/ Step 4a.\n      CC = encryptBlock K1 Tm1 Pm1\n\n      \/\/ Step 4b - 4c.\n      Cm # CP = CC\n\n      \/\/ Step 4d.\n      PP = Pm # CP\n\n      \/\/ Step 4e.\n      Cm1 = encryptBlock K1 Tm PP\n\n      \/\/ Step 5.\n      C = C_0_m2 # Cm1 # Cm\n\n\/**\n * Convenience type-constraint that is always satisified.\n * The name is inspired by the Haskell `otherwise` guard.\n *\/\ntype constraint otherwise = ()\n\n\/**\n * 5.4.1 decryption of a single 128-bit block\n *\/\ndecryptBlock : [C::KeySize] -> [128] -> [128] -> [128]\ndecryptBlock K T C = P\n  where\n    \/\/ Like `encryptBlock`, `T` is computed externally to\n    \/\/ this procedure in this implementation.\n    CC = C ^ T     PP = C::decrypt K CC     P = PP ^ T \/**\n * 5.4.2 decryption of a data unit\n *\/\ndecrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]\ndecrypt (K1 # K2) i C\n  | 0 == n % 128 =>\n    join\n      [ decryptBlock K1 T blk\n      | T <- generateTweaks K2 i\n      | blk <- split`{n \/ 128} C ]\n  | otherwise => P\n    where\n      \/\/ Number of full blocks of ciphertext\n      type M = n \/ 128\n\n      \/\/ Generate tweaks.\n      T_0_m2 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)\n\n      \/\/ Partition the ciphertext into `M` full blocks and a partial final block.\n      C_0_m2 # Cm1 # Cm = C\n\n      \/\/ Step 1.\n      P_0_m2 = join [decryptBlock K1 T blk | T <- T_0_m2 | blk <- split`{M - 1} C_0_m2]\n\n      \/\/ Steps 4d - 4f.\n      Pm # CP = decryptBlock K1 Tm Cm1\n\n      \/\/ Step 4g.\n      CC = Cm # CP\n\n      \/\/ Step 4h.\n      Pm1 = decryptBlock K1 Tm1 (Cm # CP)\n\n      \/\/ Step 5.\n      P = P_0_m2 # Pm1 # Pm\n\n\n\/**\n * Decryption inverts encryption.\n * This is a fundamental correctness property.\n *\n * ```repl\n * :check decryptInvertsEncrypt `{192}\n * ```\n *\/\ndecryptInvertsEncrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> Bool\nproperty decryptInvertsEncrypt K i P = decrypt K i (encrypt K i P) == P\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CFB.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::TDES_CFB where\n\nimport Primitive::Symmetric::Cipher::Block::TripleDES (encrypt)\n\n\/\/ Test vectors from https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/TDES_CFB.pdf\n\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncfbTDesEnc : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncfbTDesEnc k1 k2 k3 iv ps = cs\n    where\n        ks = [ k1, k2, k3 ]\n        cs = [ (encrypt ks c') ^ p | p <- ps | c' <- [iv] # cs ]\n\ncfbTDesDec : {n} (fin n) => k1 -> k1 -> k3 -> iv -> [n]block -> [n]block\ncfbTDesDec k1 k2 k3 iv cts = pts\n    where\n        ks  = [ k1, k2, k3 ]\n        pts = [ (encrypt ks fb) ^ ct | ct <- cts | fb <- [iv] # cts ]\n\ncfbTDESEncryptDecryptInverts : k1 -> k2 -> k3 -> iv -> [3]block -> Bit\nproperty cfbTDESEncryptDecryptInverts k1 k2 k3 iv pt = pt == pt'\n    where\n        ct = cfbTDesEnc k1 k2 k3 iv pt\n        pt' = cfbTDesDec k1 k2 k3 iv ct\n\n\/\/ Number of blocks := 4\n\ntestKey = { k1=0x0123456789ABCDEF\n          , k2=0x23456789ABCDEF01\n          , k3=0x456789ABCDEF0123\n          , iv=0xF69F2445DF4F9B17\n          }\ntestPt = [0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]\ntestCt = [0x078BB74E59CE7ED6, 0x7666DE9CF95EAF3F, 0xE9ED6BB460F45152, 0x8A5F9FE4ED710918]\n\nproperty testsPass = ct == testCt\n                  \/\\ pt == testPt\n    where\n        ct = cfbTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv testPt\n        pt = cfbTDesDec testKey.k1 testKey.k2 testKey.k3 testKey.iv testCt\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AESKeyWrap.cry","filetype":"cry","content":"\/**\n * This specification describes algorithms that are approved for\n * \"key wrapping:\" protecting the confidentiality and integrity of\n * cryptographic keys.\n *\n * These modes of operation are approved to be used to protect both\n * cryptographic keys and general data.\n *\n * This specification is based on [SP-800-38F]. The schemes are\n * essentially equivalent to [RFC-3394] and [RFC-5649], but use\n * different naming and have some additional restrictions. See\n * [SP-800-38F], Appendix B.1.\n *\n * This executable specification has some minor differences relative to\n * the NIST specification [SP-800-38F].\n * - [SP-800-38F] allows implementations of the authenticated-encryption and\n *   authenticated-decryption functions to further restrict the lengths of\n *   the plaintext and ciphertext (Section 8). This executable specification\n *   requires exactly the maximum allowable lengths.\n * - [SP-800-38F] also defines a key wrap method based on a different\n *   block cipher, TDEA. This executable specification does not include\n *   those algorithms.\n * - This executable specification adds an additional input to the KWP-AD\n *   function. See the notes on that algorithm.\n * - In [SP-800-38F], all the functions (`W`, `W^{-1}`, `KW-AE`, `KW-AD`,\n *   `KWP-AE`, `KWP-AD`) take the keyed cipher functions (`CIPH_K` and\n *   `CIPH_K^{-1}`) as prerequisites, rather than explicitly passing the\n *   cipher function and key as parameters. This executable specification\n *   takes the key as an explicit parameter.\n *\n * References:\n * [SP-800-38F]: Morris Dworkin. Recommendations for Block Cipher Modes of\n *     Operation: Methods for Key Wrapping. (National Institute of Standards\n *     and Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST\n *     SP 800-38F. December 2012.\n *     @see https:\/\/doi.org\/10.6028\/NIST.SP.800-38F\n *\n * [RFC-3394]: J. Schaad, R. Housley. Advanced Encryption Standard (AES) Key\n *     Wrap Algorithm. Internet Request for Comments (RFC) 3394. September\n *     2002.\n *     @see https:\/\/datatracker.ietf.org\/doc\/rfc3394\n *\n * [RFC-5649]: R. Housley, M. Dworkin. Advanced Encryption Standard (AES) Key\n *     Wrap with Padding Algorithm. Internet Request for Comments (RFC) 5649.\n *     August 2009.\n *     @see https:\/\/datatracker.ietf.org\/doc\/rfc5649\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::AESKeyWrap where\n\n\/*\n * This algorithm is only approved for instantiation with AES.\n * [SP-800-38F] Section 3.1.\n *\/\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\ninterface constraint (C::KeySize >= 64)\ninterface constraint (C::BlockSize == 128)\n\n\/**\n * A byte.\n * [SP-800-38F] Section 4.1.\n *\/\ntype Octet = 8\n\n\/**\n * Given a block cipher `C`, a bit string whose length is half of the block\n * size.\n * [SP-800-38F] Section 4.1.\n *\n * Note: the term \"`n` semiblocks\" can mean a bit string that\n * can be represented as `n` semiblocks (`[n * Semiblock]`) or a semiblock\n * string of length `n` (`[n][Semiblock]`). [SP-800-38F] Section 5.2.\n *\/\ntype Semiblock = C::BlockSize \/ 2\n\n\/**\n * The 64-bit default ICV (integrity check value) for AES key wrap (KW).\n * [SP-800-38F] Section 4.3.\n *\/\nICV1 = 0xA6A6A6A6A6A6A6A6\n\n\/**\n * The 32-bit default ICV (integrity check value) for AES key wrap with\n * padding (KWP).\n * [SP-800-38F] Section 4.3.\n *\/\nICV2 = 0xA65959A6\n\n\/**\n * The output of the cipher function of the block cipher under the key `K`\n * applied to the block `X`.\n * [SP-800-38F] Section 4.4.\n *\/\nCIPHK K X = C::encrypt K X\n\n\/**\n * The output of the inverse of the cipher function of the block cipher under\n * the key `K` applied to the block `X`.\n * [SP-800-38F] Section 4.4.\n *\/\nCIPHInvK K X = C::decrypt K X\n\n\/**\n * The integer for which the bit string passed as a parameter is the binary\n * representation.\n * [SP-800-38F] Section 4.4.\n *\/\nint = toInteger\n\n\/**\n * The bit length of the bit string `_X`.\n * [SP-800-38F] Section 4.4.\n *\n * Note: This demotes the Cryptol type to a value. In practice, we use the\n * type representation of the value (e.g. using `n` directly, rather than\n * calling this function). See `KWP_AE`, below.\n *\/\nlen : {n} (fin n) => [n] -> Integer\nlen _X = `n\n\n\/**\n * Get the `s` right-most bits of the input.\n * [SP-800-38F] Section 4.4.\n *\/\nLSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]\nLSB = drop`{n - s}\n\n\/**\n * Get the `s` left-most bits of the input.\n * [SP-800-38F] Section 4.4.\n *\/\nMSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]\nMSB = take`{s}\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove hexRepresentation\n * ```\n *\/\nproperty hexRepresentation = 0xA659 == 0b1010011001011001\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove zeroRepresentation\n * ```\n *\/\nproperty zeroRepresentation = (zero : [8]) == 0b00000000\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove concatRepresentation\n * ```\n *\/\nproperty concatRepresentation = 0b001 # 0b10111 == 0b00110111\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove xorRepresentation\n * ```\n *\/\nproperty xorRepresentation = 0b10011 ^ 0b10101 == 0b00110\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove lenRepresentation\n * ```\n *\/\nproperty lenRepresentation = len 0b00010 == 5\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove signficanceWorks\n * ```\n *\/\nproperty signficanceWorks = lsb && msb where\n    X = 0b111011010\n    lsb = LSB`{3} X == 0b010\n    msb = MSB`{4} X == 0b1110\n\n\/**\n * The instances of the `[x]_s` notation in the spec are all used to convert\n * base-10 literal values into bit strings. We can handle these instances using\n * explicit typing in Cryptol. This property shows the expected notation and\n * demonstrates that the endianness of this conversion aligns with the\n * requirement in the specification.\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove integerToString\n * ```\n *\/\nproperty integerToString = (39 == 0b00100111) && ((39 : [8]) == 0b00100111)\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove stringToInteger\n * ```\n *\/\nproperty stringToInteger = int 0b00011010 == 26\n\n\/**\n * The plaintext for AES key wrap (KW) shall be a semiblock string with fewer\n * than 2^54 semiblocks.\n * Note: the Cryptol expression `width n < X` is equivalent to `n < 2^^X - 1`.\n * [SP-800-38F] Section 5.3.1 and Table 1.\n *\/\ntype constraint KW_Plaintext n = (2 <= n, width n <= 54)\n\n\/**\n * The ciphertext for AES key wrap (KW) is a semiblock string with length one\n * semiblock longer than the corresponding ciphertext.\n * [SP-800-38F] Section 5.3.1 and Table 1.\n *\/\ntype constraint KW_Ciphertext n = (3 <= n, n <= 2^^54)\n\n\/**\n * The plaintext for AES key wrap with padding (KWP) shall be an octet string\n * with fewer than 2^32 octets.\n * Note: the Cryptol expression `width n < X` is equivalent to `n < 2^^X - 1`.\n * [SP-800-38F] Section 5.3.1 and Table 1.\n *\/\ntype constraint KWP_Plaintext n = (1 <= n, width n <= 32)\n\n\/**\n * The ciphertext for AES key wrap with padding (KWP) is a semiblock string\n * with length one semiblock longer than the corresponding ciphertext.\n * [SP-800-38F] Section 5.3.1 and Table 1.\n *\/\ntype constraint KWP_Ciphertext n = (2 <= n, n <= 2^^29)\n\n\/**\n * Wrapping function for the encryption functions in AES key wrap and AES key\n * wrap with padding.\n * [SP-800-38F] Section 6.1, Algorithm 1.\n *\n * There is an additional explicit constraint here that the variable\n * `s = 6(n - 1)` must fit into a semiblock (64 bits). This is implied by the\n * conversion in step 2a: `[t]_64` gives the binary representation of `t` in\n * 64 bits; it requires that `t` is less than `2^64`. The maximum value of `t`\n * is `s`. This constraint will always be satisfied in an approved\n * instantiation due to the plaintext length restrictions. See:\n * - the definition of `[]` in Section 4.4;\n * - Plaintext length descriptions in Section 5.3.1; and\n * - Discussion on plaintext length descriptions in Appendix A.4.\n *\n * This function is not approved for use independently of the KW_AE and KWP_AE\n * functions. [SP-800-38F] Section 8.\n *\/\nW : {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n][Semiblock] -> [n * Semiblock]\nW K S = C where\n    \/\/ Step 1. Note that the input string is 1-indexed in the spec and\n    \/\/ 0-indexed here.\n    type s = 6 * (n - 1)\n    A0 = S@0\n    R0 = drop`{1} S\n\n    \/\/ Step 2.\n    \/\/ `At1` corresponds to `A^{t-1}` in the text. Likewise for `Rt1`.\n    \/\/ In the spec, `R^t` is indexed from 2 to `n`. Here, it is indexed\n    \/\/ from 0 to `n - 2`.\n    update_variables : ([Semiblock], [n-1][Semiblock]) -> [Semiblock]\n        -> ([Semiblock], [n-1][Semiblock])\n    update_variables (At1, Rt1) t = (At, Rt) where\n        At = MSB`{64} (CIPHK K (At1 # Rt1@0)) ^ t\n        Rnt = LSB`{64} (CIPHK K (At1 # Rt1@0))\n        Rt = drop`{1} Rt1 # [Rnt]\n\n    (As, Rs) = foldl update_variables (A0, R0) [1..s]\n\n    \/\/ Step 3.\n    C1 = As\n    Cis = Rs\n    C = C1 # (join Cis)\n\n\/**\n * Unwrapping function for the decryption functions in AES key wrap and AES key\n * wrap with padding. This is denoted `W^{-1}` in the spec.\n * [SP-800-38F] Section 6.1, Algorithm 2.\n *\n * There is an additional explicit constraint here that the variable `s` must\n * fit into a semiblock. See note on `W`.\n *\n * This function is not approved for use independently of the KW_AD and KWP_AD\n * functions. [SP-800-38F] Section 8.\n *\/\nWInv : {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n][Semiblock] -> [n * Semiblock]\nWInv K C = S where\n    \/\/ Step 1. Note that the input string is 1-indexed in the spec and\n    \/\/ 0-indexed here.\n    type s = 6 * (n - 1)\n    As = C@0\n    Rs = drop`{1} C\n\n    \/\/ Step 2.\n    \/\/ `At1` corresponds to `A^{t-1}` in the text. Likewise for `Rt1`.\n    \/\/ In the spec, `R^t` is indexed from 2 to `n`. Here, it is indexed\n    \/\/ from 0 to `n - 2`.\n    update_variables : ([Semiblock], [n-1][Semiblock]) -> [Semiblock]\n        -> ([Semiblock], [n-1][Semiblock])\n    update_variables (At, Rt) t = (At1, Rt1) where\n        At1 = MSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))\n        R2t1 = LSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))\n        Rt1 = [R2t1] # take`{n-2} Rt\n\n    (A0, R0) = foldl update_variables (As, Rs) [s, s-1..1]\n\n    \/\/ Step 3.\n    S1 = A0\n    Sis = R0\n    S = S1 # (join Sis)\n\n\/**\n * The unwrapping function `WInv` must be the inverse of the wrapping function\n * `W`.\n * [SP-800-38F] Section 5.2.\n * ```repl\n * :check wrappingInverts`{3}\n * :check wrappingInverts`{6}\n * ```\n *\/\nwrappingInverts :\n    {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n * Semiblock] -> Bit\nproperty wrappingInverts K S = S == S' where\n    C = W K (split S)\n    S' = WInv K (split C)\n\n\/**\n * Authenticated encryption function for AES key wrap.\n * [SP-800-38F] Section 6.2, Algorithm 3.\n *\/\nKW_AE : {n} (KW_Plaintext n)\n    => [C::KeySize] -> [n * Semiblock] -> [(n + 1) * Semiblock]\nKW_AE K P = C where\n    S = ICV1 # P\n    C = W K (split S)\n\n\/**\n * Authenticated decryption function for AES key wrap.\n * [SP-800-38F] Section 6.2, Algorithm 4.\n *\/\nKW_AD : {n} (KW_Ciphertext n)\n    => [C::KeySize] -> [n * Semiblock] -> Option [(n - 1) * Semiblock]\nKW_AD K C = if MSB`{64} S != ICV1 then None\n    else Some (LSB`{64 * (n - 1)} S)\n    where\n        S = WInv K (split C)\n\n\/**\n * Authenticated decryption must be the inverse of authenticated encryption for\n * AES key wrap.\n * ```repl\n * :check keyWrapInverts`{3}\n * ```\n *\/\nkeyWrapInverts : {n} (KW_Plaintext n) => [C::KeySize] -> [n * Semiblock] -> Bit\nproperty keyWrapInverts K P = inverts where\n    C = KW_AE K P\n    inverts = case (KW_AD K C) of\n        Some maybeP -> maybeP == P\n        None -> False\n\n\/**\n * The authenticated encryption function for AES key wrap with padding (KWP).\n * [SP-800-38F] Section 6.3, Algorithm 5.\n *\/\nKWP_AE : {n} (KWP_Plaintext n, KWP_Ciphertext (n \/^ 8 + 1))\n    => [C::KeySize] -> [n * Octet] -> [(n \/^ 8 + 1) * Semiblock]\nKWP_AE K P = C where\n    \/\/ The type signature checks the validity of the plaintext `P` against `n`:\n    \/\/ the number of octets. `len(P)` in the spec is the number of _bits_.\n    type lenP = 8 * n\n\n    \/\/ Step 2.\n    type padlen = 8 * (lenP \/^ 64) - (lenP \/ 8)\n\n    \/\/ Step 3.\n    PAD = zero : [8 * padlen]\n\n        S = ICV2 # (`(lenP \/ 8) : [32]) # P # PAD\n\n    \/\/ Step 5.\n    C = KWP_AE_Step5`{n} K S\n\n\/**\n * This is step 5 of the KWP_AE algorithm.\n * [SP-800-38F] Section 6.3, Algorithm 5, Step 5.\n *\n * It's separated into its own function to use the numeric constraint guard,\n * which is only permitted in a top-level function.\n *\/\nKWP_AE_Step5: {n} (KWP_Plaintext n)\n    => [C::KeySize] -> [(n \/^ 8 + 1) * Semiblock] -> [(n \/^ 8 + 1) * Semiblock]\nKWP_AE_Step5 K S\n    | 8 * n <= 64 => CIPHK K S\n    | 8 * n > 64 => W K (split S)\n\n\/**\n * The authenticated decryption function for AES key wrap with padding (KWP).\n * [SP-800-38F] Section 6.3, Algorithm 6.\n *\n * This algorithm differs from the specification in that it requires the output\n * length (`m`, the length of the unpadded plaintext in octets) to be specified\n * at the top level; the specification determines the length dynamically, based\n * on the ciphertext.\n * The additional type parameter is necessary in Cryptol to allow stripping the\n * padding off the plaintext, but it introduces two concrete changes:\n *\n * 1. There is an additional type constraint, which restricts the ciphertext and\n *    plaintext lengths to be within the range of allowable padding of each\n *    other.\n *\n * 2. There are two additional failure checks, to make sure that `m` is correct\n *    with respect to the values (`Plen`, `padlen`) derived from the ciphertext:\n *    - `Plen` must be the same as `m`.\n *    - `padlen == m %^ 8`. `padlen` is the number of octets of padding needed\n *      to fill out the plaintext to the nearest semiblock (8 bytes) and `m` is\n *      the number of octets in the plaintext. We use the ceiling modulus to\n *      compute the expected amount of padding for `m`.\n *\n * Thanks to Sean Weaver for assistance with formulating this definition.\n *\/\nKWP_AD : {m, n} (KWP_Ciphertext n, KWP_Plaintext m, n == 1 + m \/^ 8)\n    => [C::KeySize] -> [n * Semiblock] -> Option [m * Octet]\nKWP_AD K C =\n    if (ICV2 != MSB`{32} S)                         || (padlen < 0)                     \/\/ Step 7.\n        || (padlen > 7)                     \/\/ Step 7.\n        || (zero   != LSB`{8 * m %^ 64} S)  \/\/ Step 8.\n        || (Plen   != `m)                   \/\/ Cryptol-specific.\n        || (padlen != `(m %^ 8))            \/\/ Cryptol-specific.\n    then None\n    else Some P\n    where\n        S = KWP_AD_Step3 K C\n\n        \/\/ Step 5 - 6.\n        Plen = int (LSB`{32} (MSB`{64} S))\n        padlen = 8 * (`n - 1) - Plen\n\n        \/\/ Step 9. The conditional above restricts `m = Plen`.\n        P = MSB`{8 * m} (LSB`{64 * (n - 1)} S)\n\n\/**\n * This is step 3 of the KWP_AD algorithm.\n * [SP-800-38F] Section 6.3, Algorithm 6.\n *\n * It is separated into its own function to support the numeric constraint\n * guard, which is only permitted in a top-level function.\n *\/\nKWP_AD_Step3 : {n} (KWP_Ciphertext n)\n    => [C::KeySize] -> [n * Semiblock] -> [n * 64]\nKWP_AD_Step3 K C\n    | n == 2 => CIPHInvK K C\n    | n > 2 => WInv K (split C)\n\n\/**\n * Authenticated decryption must be the inverse of authenticated encryption for\n * AES key wrap with padding.\n *\n * The lengths below are chosen to check various amounts of padding.\n * ```repl\n * :check keyWrapInverts`{1}\n * :check keyWrapInverts`{3}\n * :check keyWrapInverts`{7}\n * :check keyWrapInverts`{8}\n * ```\n *\/\nkeyWrapPaddedInverts : {n} (KWP_Ciphertext (n \/^ 8 + 1), KWP_Plaintext n)\n    => [C::KeySize] -> [n * Octet] -> Bit\nproperty keyWrapPaddedInverts K P = inverts where\n    C = KWP_AE K P\n    inverts = case (KWP_AD K C) of\n        Some maybeP -> maybeP == P\n        None -> False\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CFB.cry","filetype":"cry","content":"\/*\n * Cipher Feedback (CFB) mode of operation, as defined in [NIST-SP-800-38A],\n * Section 6.3.\n *\n * CFB mode utilizes an integer parameter, denoted by `s`, such that\n * `1 \u2264 s \u2264 BlockSize`. The parameter `s` specifies the plaintext \/ ciphertext\n * block length; that is, each plaintext \/ ciphertext block is `s` bits long.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure confidentiality, CFB mode requires that the\n * initialization vector (IV) must be \"unpredictable\". This specification does\n * not verify IV generation; implementors must manually verify that their IVs\n * are chosen appropriately.\n *\n * For guidelines on generating IVs, see Appendix C of [NIST-SP-800-38A].\n * For information on the importance of protecting IV integrity, see Appendix D\n * of [NIST-SP-800-38A].\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Alex J. Malozemoff <amaloz@galois.com>\n * www.cryptol.net\n *\n * Sources:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n *     Modes of Operation: Methods and Techniques. NIST Special Publication\n *     800-38A. December 2001.\n *     @see https:\/\/doi.org\/10.6028\/NIST.SP.800-38A\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Modes::CFB where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\n\/**\n * CFB encryption: [NIST-SP-800-38A] Section 6.3.\n *\n * Parameters: key, initialization vector, plaintext\n *\n * NIST Specification (Section 6.3):\n *\n *   I_1 = IV;\n *   I_j = LSB_{b-s}(I_{j-1}) | C_{j-1}  for j = 2 ... n;\n *   O_j = CIPH_K(I_j)                   for j = 1 ... n;\n *   C_j = P_j \u2295 MSB_s(O_j)             for j = 1 ... n.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure confidentiality, CFB mode requires that the\n * initialization vector (IV) must be \"unpredictable\". This specification does\n * not verify IV generation; implementors must manually verify that their IVs\n * are chosen appropriately.\n *\/\nencrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]\nencrypt K IV Ps = Cs\n    where\n        CIPH_K = C::encrypt K\n        Is = [ (drop`{s} I_j_1) # C_j_1\n             | I_j_1 <- [IV] # Is\n             | C_j_1 <- Cs\n             ]\n        Cs = [ P_j ^ (take`{s} (CIPH_K I_j))\n             | P_j <- Ps\n             | I_j <- [IV] # Is\n             ]\n\n\/**\n * CFB decryption: [NIST-SP-800-38A] Section 6.3.\n *\n * Parameters: key, initialization vector, ciphertext\n *\n * NIST Specification (Section 6.3):\n *\n *  I_1 = IV;\n *  I_j = LSB_{b-s}(I_{j-1}) | C_{j-1}  for j = 2 ... n;\n *  O_j = CIPH_K(I_j)                   for j = 1 ... n;\n *  P_j = C_j \u2295 MSB_s(O_j)             for j = 1 ... n.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure confidentiality, CFB mode requires that the\n * initialization vector (IV) must be \"unpredictable\". This specification does\n * not verify IV generation; implementors must manually verify that their IVs\n * are chosen appropriately.\n *\/\ndecrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]\ndecrypt K IV Cs = Ps\n    where\n        CIPH_K = C::encrypt K\n        Is = [ (drop`{s} I_j_1) # C_j_1\n             | I_j_1 <- [IV] # Is\n             | C_j_1 <- Cs\n             ]\n        Ps = [ C_j ^ (take`{s} (CIPH_K I_j))\n             | C_j <- Cs\n             | I_j <- [IV] # Is\n             ]\n\n\/**\n * Decryption must be the inverse of encryption.\n * With high probability, this will be incredibly slow to prove.\n * ```repl\n * :check encryptCorrect`{s=1, n=5}\n * :check encryptCorrect`{s=8, n=5}\n * :check encryptCorrect`{s=128, n=5}\n * ```\n *\/\nencryptCorrect : {s, n} (fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> Bool\nproperty encryptCorrect K IV Ps = (decrypt K IV (encrypt K IV Ps)) == Ps\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Specification.cry","filetype":"cry","content":"\/**\n *\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n * @author David Lazar\n * www.cryptol.net\n *\n * This provides the basic Simon block cipher, abstracted over the key length,\n * plaintext size, number of rounds, and constant sequence.\n *\n * Simon is presented in two ways in the reference documentation.\n * Firstly, it is presented as a mathematical function derived from a root key.\n * Secondly, it is presented as an imperative algorithm.\n * This specification prefers the former presentation, but encodes both.\n *\n * Test vectors for particular instances of this parameterized specification\n * are located in a bespoke test file.\n *\n * References\n * [SIMON]: Beaulieu, Shors, Smith, Treatman-Clark, Weeks, Wingers\n *   The Simon and Speck Families of Lightweight Block Ciphers\n *   19 June 2013\n *   @see https:\/\/eprint.iacr.org\/2013\/404.pdf\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Specification where\n\nparameter\n\n  \/*\n   * The Simon block cipher is parameterized by two integers `n` and `m`,\n   * a sequence `z_j`, and a number of rounds, `T`.\n   *\/\n\n  \/**\n   * `n` is the word length in bits.\n   * A Simon block is two words.\n   *\/\n  type n : #\n\n  \/**\n   * `m` is the number of `n`-bit words in a Simon key.\n   * `m` takes the value4 2, 3, or 4.\n   *\/\n  type m : #\n\n  \/**\n   * This type contraint satifies Cryptol's type checker, and\n   * admits all valid parameterizations of Simon. It does not\n   * exclude all invalid parameterizations of Simon.\n   *\/\n  type constraint (fin n, fin m, n >= 4, m >= 2, m <= 4)\n\n  \/**\n   * There are five possible constant sequences `z_j`.\n   *\/\n  type j : #\n  type constraint (j >= 0, j < 5)\n\n  \/**\n   * `T` is the number of rounds.\n   * `T` may take on the values specified in Table 3.1 of [SIMON].\n   *\/\n  type T : #\n\n  \/**\n   * This type constraint satifies Cryptol's type checker, but\n   * does not exclude invalid numbers of rounds.\n   *\/\n  type constraint (fin T, T > 4)\n\n\/**\n * The Simon encryption function.\n * Described in Section 3.1 of [SIMON].\n * Simon encryption is the composition of T round functions\n * derived from the key schedule applied to the plaintext.\n * Simon keys are length `m * n` bits for appropriate choices of `m` and `n`.\n * Simon plaintexts are length `2 * n` bits for appropriate choice of `n`.\n *\/\nencrypt : [m * n] -> [2 * n] -> [2 * n]\nencrypt key plaintext = ciphertext\n  where\n    Simon_k = composeMany Rks\n    \/\/ The Simon specification parses the key LSB first.\n    \/\/ Cryptol takes a MSB first convention, so the key is reversed.\n    Rks = map R (keySchedule (reverse (split key)))\n    ciphertext = join (Simon_k (split plaintext))\n\n\/**\n * The Simon decryption function. Simon decryption is the same as Simon\n * encryption from a structural point of view, except that the inverse\n * round function is used rather than the round function.\n *\/\ndecrypt : [m * n] -> [2 * n] -> [2 * n]\ndecrypt key ciphertext = plaintext\n  where\n    Simon_k = composeMany (reverse Rks)\n    \/\/ The Simon specification parses the key LSB first.\n    \/\/ Cryptol takes a MSB first convention, so the key is reversed.\n    Rks = map R_Inv (keySchedule (reverse (split key)))\n    plaintext = join (Simon_k (split ciphertext))\n\nprivate\n\n  \/**\n   * This property encodes the fact that Simon decryption is the inverse of\n   * Simon encryption.\n   *\n   * ```repl\n   * :check decryptInvertsEncrypt\n   * ```\n   *\/\n  property decryptInvertsEncrypt k pt = pt == decrypt k (encrypt k pt)\n\n  \/**\n   * Simon is described in psuedocode.\n   *\n   * Reference: [SIMON] Figure 3.3.\n   *\/\n  encrypt' : [m * n] -> [2 * n] -> [2 * n]\n  encrypt' key plaintext = join (rounds ! 0)\n    where\n      [x, y] = split plaintext\n      ks     = keySchedule' (reverse (split key))\n      \/\/ there are T round keys\n      \/\/ So, the following list comprehension runs over i = 0..T-1\n      rounds = [[x, y]] # [R k p | k <- ks | p <- rounds]\n\n  \/**\n   * Likewise, the decryption can be calculated in a more imperative fashion.\n   *\/\n  decrypt' : [m * n] -> [2 * n] -> [2 * n]\n  decrypt' key ciphertext = join (rounds ! 0)\n    where\n      [x, y] = split ciphertext\n      ks = keySchedule' (reverse (split key))\n      rounds = [[x, y]] # [R_Inv k ct | k <- (reverse ks) | ct <- rounds]\n\n  \/**\n   * The two formulations of encryption are functionally equiavalent.\n   *\n   * ```repl\n   * :check encryptsEquivalent\n   * ```\n   *\/\n  property encryptsEquivalent k p = encrypt k p == encrypt' k p\n\n  \/**\n   * The two formulations of decryption are functionally equiavalent.\n   *\n   * ```repl\n   * :check decryptsEquivalent\n   * ```\n   *\/\n  property decryptsEquivalent k p = decrypt k p == decrypt' k p\n\n  \/**\n   * Left circular shift by `i` bits.\n   * `i` is chosen over `j`, which the specification uses, to avoid shadowing.\n   * Although this is built-in, we choose the name `S`\n   * since this notation is used in Section 3.1 of [SIMON].\n   *\/\n  S : {i} (fin i) => [n] -> [n]\n  S x = x <<< `i\n\n  \/**\n   * Right circular shift by `i` bits.\n   * `i` is chosen over `j`, which the specification uses, to avoid shadowing.\n   * Although this is built-in, we choose the name `S_Inv`.\n   * This is chosen to avoid arithmetic strangeness with signed bitvectors.\n   *\/\n  S_Inv : {i} (fin i) => [n] -> [n]\n  S_Inv x = x >>> `i\n\n  \/**\n   * The specification uses the notation `S^(-i)` to notate\n   * right circular shift by `i` bits, the inverse of left\n   * circular shift. This property verifies that\n   * `S` is the inverse of `S_Inv`.\n   *\n   * ```repl\n   * :prove SInvertible `{8}\n   * :prove SInvertible `{3}\n   * :prove SInvertible `{2}\n   * :prove SInvertible `{1}\n   * ```\n   *\/\n  SInvertible : {i} (fin i) => [n] -> Bit\n  property SInvertible x = S_Inv `{i} (S `{i} x) == x\n\n  \/**\n   * The function `f` is a constituent function of the encryption and decryption\n   * round functions.\n   *\n   * Reference: [SIMON] Section 3.1.\n   *\/\n  f : [n] -> [n]\n  f x = (S `{1} x && S `{8} x) ^ S `{2} x\n\n  \/**\n   * The Simon (encryption) round function is defined in Section 3.1 of [SIMON].\n   * It is defined on `n`-bit words, which can be thought of as \"halves\" of\n   * the plaintext block being processed.\n   * The round function is parameterized by the choice of round key, `k`.\n   *\/\n  R : [n] -> [2][n] -> [2][n]\n  R k [x, y] = [y ^ f x ^ k, x]\n\n  \/**\n   * The Simon (decryption) round function is defined in Section 3.1 of [SIMON].\n   * It is defined on `n`-bit words, which can be thought of as \"halves\" of\n   * the ciphertext block being processed.\n   * The round function is parameterized by the choice of round key, `k`.\n   *\/\n  R_Inv : [n] -> [2][n] -> [2][n]\n  R_Inv k [x, y] = [y, x ^ f y ^ k]\n\n  \/**\n   * This property encodes the fact that `R_Inv` is the inverse of `R`\n   * for corresponding choices of round key.\n   *\n   * ```repl\n   * :prove RInvertible\n   * ```\n   *\/\n  property RInvertible k x = x == R_Inv k (R k x)\n\n  \/**\n   * `u` is a periodic sequence with period 31.\n   * `u` is used in the definition of the Simon key schedule, and\n   * is decribed in Section 3.2 of [SIMON].\n   *\/\n  u : [inf]\n  u = 0b1111101000100101011000011100110 # u\n\n  \/**\n   * `v` is a periodic sequence with period 31\n   * `v` is used in the definition of the Simon key schedule, and\n   * is decribed in Section 3.2 of [SIMON].\n   *\/\n  v : [inf]\n  v = 0b1000111011111001001100001011010 # v\n\n  \/**\n   * `w` is a periodic sequence with period 31\n   * `w` is used in the definition of the Simon key schedule, and\n   * is decribed in Section 3.2 of [SIMON].\n   *\/\n  w : [inf]\n  w = 0b1000010010110011111000110111010 # w\n\n  \/**\n   * `t` is a periodic sequence with period 2.\n   *\n   * Reference: [SIMON] Section 3.2.\n   *\/\n  t : [inf]\n  t = 0b01 # t\n\n  \/**\n   * The sequence `z0` is an alternative name of the sequence `u`.\n   *\n   * Reference: [SIMON] Section 3.2.\n   *\/\n  z0 = u\n\n  \/**\n   * The sequence `z1` is an alternative name of the sequence `v`.\n   *\n   * Reference: [SIMON] Section 3.2.\n   *\/\n  z1 = v\n\n  \/**\n   * The sequence `z2` is the bitwise XOR of `u` and `t`.\n   *\n   * Reference: [SIMON] Section 3.2.\n   *\/\n  z2 = u ^ t\n\n  \/**\n   * The sequence `z3` is the bitwise XOR of `v` and `t`.\n   *\n   * Reference: [SIMON] Section 3.2.\n   *\/\n  z3 = v ^ t\n\n  \/**\n   * The sequence `z4` is the bitwise XOR of `w` and `t`.\n   *\n   * Reference: [SIMON] Section 3.2.\n   *\/\n  z4 = w ^ t\n\n  \/**\n   * Convert an infinite sequence of bits into an infinite sequence of `n`-bit\n   * vectors, where the `i`th vector has the same value as the `i`th bit.\n   *\n   * This does not appear explicitly in [SIMON]. Cryptol only supports bitwise\n   * XOR between bit vectors of the same length, but the round key formulae in\n   * [SIMON] computes the XOR of an individual bit from an infinite sequence\n   * with an n-bit word. We apply this function to the relevant infinite\n   * sequences to support the XOR.\n   *\/\n  extend : [inf] -> [inf][n]\n  extend s = map (zext `{n}) (split `{inf, 1} s)\n\n  \/**\n   * The list of sequences `zj` with the zero-extension applied.\n   *\/\n  zjs = map extend [z0, z1, z2, z3, z4]\n\n  \/**\n   * The particular sequence `zj` of the instance.\n   * These indices are the same as [SIMON].\n   *\/\n  zj = zjs@`j\n\n  \/**\n   * `c` is a bitvector of length `n`.\n   * It's length is implied by the shift register diagrams\n   * in Figure 3.2 of [SIMON] and usage in the key schedule\n   * recursive formulae.\n   *\/\n  c : [n]\n  c = fromInteger (2 ^^ `n - 4)\n\n  \/**\n   * `IS_Inv` is a function defined for convenience of this specification.\n   * The recursive formulae defining the key schedule include a\n   * quantity that is bitwise XORed with a right shift of itself.\n   * This is notated distributively in the original specification.\n   *\/\n  IS_Inv : [n] -> [n]\n  IS_Inv x = x ^ S_Inv `{1} x\n\n  \/**\n   * The Simon key schedule is defined by recursively expanding\n   * the initial key material according to the formulae in Section 3.2\n   * of [SIMON]. There is a different formula depending on how many\n   * words, `m`, make up the key.\n   *\/\n  keySchedule : [m][n] -> [T][n]\n  keySchedule k0\n    | m == 2 => k where\n      k = k0 # [\n      c ^ zji ^ (k @ i) ^ IS_Inv (S_Inv `{3} (k @ (i+1)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n    | m == 3 => k where\n      k = k0 # [\n      c ^ zji ^ (k@i) ^ IS_Inv (S_Inv `{3} (k@(i+2)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n    | m == 4 => k where\n      k  = k0 # [\n      c ^ zji ^ (k@i) ^ IS_Inv (S_Inv `{3} (k@(i+3)) ^ (k@(i+1)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n\n  \/**\n   * The Simon key schedule is described in pseudo-code in [SIMON].\n   * This formulation might be preferred by some implementers. It is\n   * included here for documentary purposes, as well as for property checking.\n   *\/\n  keySchedule' : [m][n] -> [T][n]\n  keySchedule' k0 = k\n    where\n      k = k0 # [ ki where\n                  tmp0 = k @ (i - 1) >>> 3\n                  tmp1 = if `m == 4 then tmp0 ^ k @ (i - 3) else tmp0\n                  tmp2 = tmp1 ^ tmp1 >>> 1\n                  ki = ~ k @ (i - `m) ^ tmp2 ^ z ^ 3\n                  z = zj @ ((i - `m) % 62)\n            | i <- [m .. T - 1]\n            ]\n\n  \/**\n   * This property encodes the fact that the key schedule is injective.\n   * That is, different round keys are produced for every choice of key.\n   *\n   * ```repl\n   * :prove keyScheduleInjective\n   * ```\n   *\/\n  property keyScheduleInjective k p = k != p ==> keySchedule k != keySchedule p\n\n  \/**\n   * This property encodes the fact that the psuedocode formulation of the\n   * key schedule is functionally equivalent to formulaic definition.\n   *\n   * ```repl\n   * :check keySchedulesEquivalent\n   * ```\n   *\/\n  property keySchedulesEquivalent k = keySchedule k == keySchedule' k\n\n  \/**\n   * Composition of functions `g` and `h`\n   * specialized to functions from `(a -> a)`.\n   *\/\n  compose : {a} () => (a -> a) -> (a -> a) -> a -> a\n  compose g h = \\x -> h (g x)\n\n  \/**\n   * Composition of many functions from `(a -> a)`\n   *\/\n  composeMany : {nf, a} (fin n) => [nf](a -> a) -> a -> a\n  composeMany fcns\n    | nf == 0 => \\x -> x\n    | nf == 1 => fcns@0\n    | nf == 2 => compose (fcns@0) (fcns@1)\n    | nf > 2  => compose (fcns@0) (composeMany (drop `{1} fcns))\n\n\n  \/**\n   * Multiplication of a row vector by a matrix\n   * This is not defined in the Simon specification.\n   * We take the straightforward approach of treating\n   * this as a linear combination of a subset of the\n   * matrix rows depending on which bits of the row vector are set.\n   *\/\n  linearMap : {rows, cols} (fin rows, fin cols) =>\n    [rows][cols] -> [rows] -> [cols]\n  linearMap matrix vector = foldl (^) zero matrix'\n    where\n      matrix' = map (\\(i, vi) -> if i then vi else zero) (zip vector matrix)\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `u`\n   * if the initial fill `0b00001` is used.\n   *\/\n  U = [ 0b01000\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10001\n      ]\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `v`\n   * if the initial fill `0b00001` is used.\n   *\/\n  V = [ 0b01100\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10000\n      ]\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `w`\n   * if the initial fill `0b00001` is used.\n   *\/\n  W = [ 0b01000\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10000\n      ]\n\n  \/**\n   * A function that treats row vector - matrix multiplication\n   * as a shift register, generating the sequence of shift\n   * register outputs for a given initial fill.\n   *\/\n  seqn : [5][5] -> [inf]\n  seqn matrix = map (\\x -> x@4) steps\n    where\n      steps     = iterate (\\x -> linearMap matrix x) 0b00001\n\n  \/**\n   * A formal definition of the sequence `u`,\n   * given in Section 3.2 of [SIMON].\n   *\/\n  u' = seqn U\n\n  \/**\n   * A formal definition of the sequence `v`,\n   * given in Section 3.2 of [SIMON].\n   *\/\n  v' = seqn V\n\n  \/**\n   * A formal definition of the sequence `w`,\n   * given in Section 3.2 of [SIMON].\n   *\/\n  w' = seqn W\n\n  \/**\n   * A property encoding that the formal and informal definitions of `u`\n   * are equivalent.\n   *\n   * ```repl\n   * :check uDefinitionEquivalence\n   * ```\n   *\/\n  property uDefinitionEquivalence = take `{100} u == take `{100} u'\n\n  \/**\n   * A property encoding that the formal and informal definitions of `v`\n   * are equivalent.\n   *\n   * ```repl\n   * :check vDefinitionEquivalence\n   * ```\n   *\/\n  property vDefinitionEquivalence = take `{100} v == take `{100} v'\n\n  \/**\n   * A property encoding that the formal and informal definitions of `w`\n   * are equivalent.\n   *\n   * ```repl\n   * :check wDefinitionEquivalence\n   * ```\n   *\/\n  property wDefinitionEquivalence = take `{100} w == take `{100} w'\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Specification.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n *\n * This module provides a Cryptol specification of the Speck block cipher.\n * Speck is abstracted over the key size, the block size, the number of\n * rounds, and two rotation constants.\n *\n * @author John Christensen <jchristensen@galois.com>\n * @author David Lazar\n *\n * References\n * [SPECK]: Beaulieu, Shors, Smith, Treatman-Clark, Weeks, Wingers\n *          The Simon and Speck Families of Lightweight Block Ciphers\n *          19 June 2013\n * @see https:\/\/eprint.iacr.org\/2013\/404.pdf\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\nimport Common::utils (composeMany, compose)\n\nparameter\n\n    \/**\n     * `n` is the Speck word size in bits.\n     * `2 * n` is the Speck block size.\n     *\/\n    type n : #\n\n    \/**\n     * `m` is the number of words in the Speck key.\n     * Thus, the length of the Speck key is `n * m` bits.\n     *\/\n    type m : #\n\n    \/**\n     * `T` is the number of rounds.\n     *\/\n    type T : #\n\n    \/**\n     * The following type constraints satisfy Cryptol's type checker.\n     * They admit all valid Speck instantiations.\n     * They do not exclude all invalid instantiations.\n     *\/\n    type constraint (fin n, fin T, fin m)\n    type constraint (m >= 2, m <= 4, T >= 2, n >= width T)\n    type constraint (n >= 16)\n\n\/**\n * The Speck encryption function is the composition of `T` round functions.\n * Each of the `T` round function is derived from the key by the key schedule.\n *\n * Reference: [SPECK], Section 4.1\n *\/\nencrypt : [m * n] -> [2 * n] -> [2 * n]\nencrypt key plaintext = join (Speck_k (split plaintext))\n    where\n        \/\/ The Speck specification document parses the key LSB first.\n        \/\/ Cryptol parses all bitvectors MSB first.\n        \/\/ Thus, we reverse the key to match the\n        \/\/ convention of the specification.\n        Rks = map R (keySchedule (reverse (split key)))\n        Speck_k = composeMany Rks\n\n\/**\n * The Speck decryption function is the inverse of the encryption function.\n * To derive the inverse, the round functions are composed in reverse order.\n *\n * Reference: [SPECK], Section 4.1.\n *\/\ndecrypt : [m * n] -> [2 * n] -> [2 * n]\ndecrypt key ciphertext = join (Speck_k (split ciphertext))\n    where\n        \/\/ As in `encrypt`, we reverse the key.\n        Rks = map R_Inv (keySchedule (reverse (split key)))\n        Speck_k = composeMany (reverse Rks)\n\nprivate\n\n    \/**\n     * The encryption and decryption functions are inverses of each other.\n     *\n     * ```repl\n     * :check decryptInvertsEncrypt\n     * ```\n     *\/\n    property decryptInvertsEncrypt k x = decrypt k (encrypt k x) == x\n\n    \/**\n     * Left circular shift.\n     * The notation `S` is used because it appears in the specification.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    S : {j} (fin j) => [n] -> [n]\n    S x = x <<< `j\n\n    \/**\n     * Right circular shift.\n     * The notation `S_Inv` is used rather than using 'negative exponents'\n     * to avoid arithmetic strangeness with negative bitvectors.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    S_Inv : {j} (fin j) => [n] -> [n]\n    S_Inv x = x >>> `j\n\n    \/**\n     * Left circular shift by the rotation constant \u03b1.\n     * The rotation constant can be derived from the word size.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    S\u03b1: [n] -> [n]\n    S\u03b1 x | n == 16 => S `{7} x\n         | n >= 16 => S `{8} x\n\n    \/**\n     * Left circular shift by the rotation constant \u03b2.\n     * The rotation constant can be derived from the word size.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    S\u03b2 : [n] -> [n]\n    S\u03b2 x | n == 16 => S `{2} x\n         | n >= 16 => S `{3} x\n\n    \/**\n     * Right circular shift by the rotation constant \u03b1.\n     * The rotation constant can be derived from the word size.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    S\u03b1_Inv : [n] -> [n]\n    S\u03b1_Inv x | n == 16 => S_Inv `{7} x\n             | n >= 16 => S_Inv `{8} x\n\n    \/**\n     * Right circular shift by the rotation constant \u03b2.\n     * The rotation constant can be derived from the word size.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    S\u03b2_Inv : [n] -> [n]\n    S\u03b2_Inv x | n == 16 => S_Inv `{2} x\n             | n >= 16 => S_Inv `{3} x\n\n    \/**\n     * The Speck round function. This function is parameterized by a key.\n     * This function is a composition of shifts and modular additions.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    R : [n] -> [2][n] -> [2][n]\n    R k [x, y] = [(S\u03b1_Inv x + y) ^ k, S\u03b2 y ^ (S\u03b1_Inv x + y) ^ k]\n\n    \/**\n     * The inverse Speck round function.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    R_Inv : [n] -> [2][n] -> [2][n]\n    R_Inv k [x, y] = [S\u03b1 ((x ^ k) - S\u03b2_Inv (x ^ y)), S\u03b2_Inv (x ^ y)]\n\n    \/**\n     * `R_Inv` is the inverse of `R`.\n     *\n     * ```repl\n     * :prove RInvertible\n     * ```\n     *\/\n    property RInvertible k x = R_Inv k (R k x) == x\n\n    \/**\n     * `R` can be decomposed as two Feistel-like maps\n     * with respect to modular addition. This is the\n     * map with addition modulo `2^n`. Part of this function's\n     * output is used in the key schedule.\n     *\n     * Reference: [SPECK], Section 4.1, 4.2.\n     *\/\n    Rf1 : [n] -> [2][n] -> [2][n]\n    Rf1 k [x, y] = [y, (S\u03b1_Inv x + y) ^ k]\n\n    \/**\n     * `R` can be decomposed as two Feistel-like maps\n     * with respect to modular addition. This is the\n     * map with addition modulo `2` (i.e., XOR). Part of\n     * this function's output is used in the key schedule.\n     *\n     * Note that this function has no key dependence.\n     *\n     * Reference: [SPECK], Section 4.1, 4.2.\n     *\/\n    Rf2 : [2][n] -> [2][n]\n    Rf2 [x, y] = [y, S\u03b2 x ^ y]\n\n    \/**\n     * Composition of the Feistel-like maps.\n     * An alternative formulation of `R`.\n     *\/\n    Rf : [n] -> [2][n] -> [2][n]\n    Rf k s = f s\n        where\n            f = compose (Rf1 k) Rf2\n\n    \/**\n     * `Rf` is functionally equiavalent to `R`.\n     *\n     * ```repl\n     * :prove REquivalent\n     * ```\n     *\/\n    property REquivalent k s = Rf k s == R k s\n\n    \/**\n     * The Speck key schedule.\n     * This procedure generates the round keys from which\n     * each round function is derived. This procedure relies\n     * on the constituent functions that make up the round\n     * function.\n     *\n     * Reference: [Speck], Section 4.2.\n     *\/\n    keySchedule : [m][n] -> [T][n]\n    keySchedule K = ks\n        where\n            \/\/ write key K as (k0, l0, ... l_m-2)\n            [k0] # li = K\n            \/\/ define mutual recursion of sequences ki and li\n            ks = [k0] # [S\u03b2 (ks @ i) ^ (ls @ (i + `m - 1)) | i <- [0..T - 2]]\n            ls = li # [(k + S\u03b1_Inv (ls @ i)) ^ i | k <- ks | i <- [0..T - 2] ]\n\n    \/**\n     * The key schedule is injective.\n     *\n     * ```repl\n     * :prove keyScheduleInjective\n     * ```\n     *\/\n    property keyScheduleInjective k v = k != v ==> result\n        where\n            result = keySchedule k != keySchedule v\n\n    \/**\n     * The Speck key schedule, formulated in terms of the Speck round function.\n     * The formula in the specification explicitly unfolds these definitions;\n     * this formula leaves the definitions folded to illuminate the usage of\n     * the constituent functions.\n     *\n     * Reference: [SPECK], Section 4.2.\n     *\/\n    keySchedule' : [m][n] -> [T][n]\n    keySchedule' K = ks\n        where\n            \/\/ write key K as (k0, l0, ... l_m-2)\n            [k0] # li = K\n            \/\/ define mutual recursion of sequences ki and li\n            ks = [k0] # [f2 [(ks @ i), (ls @ (i + `m - 1))] | i <- [0..T - 2]]\n            ls = li # [f1 i [ls @ i, k] | k <- ks | i <- [0..T - 2] ]\n            \/\/ the key schedule uses the half of the output of the Speck round\n            \/\/ functions, discarding the half that isn't transformed by the\n            \/\/ Feistel-like map. The \"key\" for f1, in this case, is a counter.\n            f1 k s = (Rf1 k s) @ 1\n            f2 s = (Rf2 s) @ 1\n\n    \/**\n     * The key schedule formulations are equiavalent.\n     *\n     * ```repl\n     * :prove keySchedulesEquivalent\n     * ```\n     *\/\n    property keySchedulesEquivalent K = keySchedule K == keySchedule' K\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Specification.cry","filetype":"cry","content":"\/**\n * Cryptol AES Implementation.\n *\n * Intended use for this is that users interact with the `encrypt` and `decrypt`\n * functions. In practice, most users should use a mode of operation like\n * AES-GCM or AES-CTR, instead of using this directly.\n *\n * @copyright Galois Inc.\n * @author Nichole Schimanski <nls@galois.com>\n * @editor Brian Huffman\n * @author Marcella Hastings <marcella@galois.com>\n * @editor Lee Newcomb <newcomb@galois.com>\n * www.cryptol.net\n *\n *\n * References\n * [FIPS-197u1]: Morris J. Dworkin, Elaine B. Barker, James R. Nechvatal,\n *     James Foti, Lawrence E. Bassham, E. Roback, and James F. Dray Jr.\n *     Advanced Encryption Standard (AES). Federal Inf. Process. Stds. (NIST FIPS)\n *     197, update 1. May 2023.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.197-upd1\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::AES::Specification where\n\nimport Common::GF28 as GF28\nprivate type GF28 = GF28::GF28\n\nparameter\n  \/\/ This constraint enforces the standard key sizes of 128, 192, and\n  \/\/ 256-bits. [FIPS-197u1] Sections 1, 5, and 6.1.\n  type KeySize' : #\n  type constraint (fin KeySize', KeySize' % 64 == 0, KeySize' \/ 64 >= 2,\n    KeySize' \/ 64 <= 4)\n\n\/**\n * The AES implementation uses the `Mode` type to compute other parameters.\n * The mode corresponds directly to the key size:\n * Mode 0 = 128 bits; Mode 1 = 192 bits; Mode 2 = 256 bits\n *\/\ntype Mode = (KeySize \/ 64) - 2\n\n\/**\n * Key length: number of 32 bit words in the key.\n * [FIPS-197u1] Section 5, Table 3\n *\/\ntype Nk = 4 + 2 * Mode\n\n\/**\n * Number of rounds\n * [FIPS-197u1] Section 5, Table 3\n *\/\ntype Nr = 6 + Nk\n\n\/**\n * The number of words in the state is generic for the underlying Rijndael\n * algorithm, but in the standard it is fixed to 4.\n * [FIPS-197u1] Section 5.\n *\/\ntype Nb = 4\n\n\/\/ Make `KeySize` and `BlockSize` accessible outside the module.\n\/\/ This also lets us use AES as an instantiation of `CipherInterface`\ntype KeySize = KeySize'\ntype BlockSize = 128\n\n\/**\n * AES encryption.\n * [FIPS-197u1], Section 5, Equation 5.1.\n * This differs slightly from the spec:\n * - The spec calls this `AES-<Keysize>` instead of `encrypt`.\n * - The spec passes parameters in the opposite order `(in, key)`\n *   where `in` is the data input block and `key` is the key. Here\n *   we pass the key `k` first and the input block second.\n *\/\nencrypt : [KeySize] -> [BlockSize] -> [BlockSize]\nencrypt k = cipher (keyExpansion k)\n\n\/**\n * AES decryption.\n * [FIPS-197u1], Section 5.\n * The spec does not give this an explicit name.\n *\/\ndecrypt : [KeySize] -> [BlockSize] -> [BlockSize]\ndecrypt k = invCipher (keyExpansion k)\n\n\/**\n * `decrypt` must be the inverse of `encrypt`.\n * With high probability, this will be extremely slow to prove.\n * [FIPS-197u1], Section 5.\n * ```repl\n * :check aesIsCorrect\n * ```\n *\/\nproperty aesIsCorrect k pt = decrypt k (encrypt k pt) == pt\n\n\/**\n * The algorithms for AES block ciphers are performed on a 4x4 array of bytes.\n * [FIPS-197u1] Section 3.4.\n *\/\ntype State = [4][Nb]GF28\n\n\/**\n * In the specifications for AES, the first step is to copy the input array\n * of 16 bytes into the state array.\n *\n * [FIPS-197u1] Section 3.4, Equation 3.6.\n *\/\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\n\/**\n * After the state array is transformed, its final value is copied to the\n * output array of bytes.\n *\n * [FIPS-197u1] Section 3.4, Equation 3.7.\n *\/\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\n\/**\n * This demonstrates the property in [FIPS-197u1] Section 3.4, Figure 1.\n * Note that we don't ever need this property in the execution of AES,\n * but it should hold true anyway.\n *\n * ```repl\n * :prove ioInverts\n * ```\n *\/\nproperty ioInverts msg = stateToMsg (msgToState msg) == msg\n\n\/**\n * The substitution table as given in Table 4. The table is pulled out here\n * for efficiency, letting us compute the table once per access in AES.\n *\n * `GF28::inverse b` corresponds to Equation 5.2.\n *\/\nsboxTable : [256]GF28\nprivate sboxTable = [ transform (GF28::inverse b) | b <- [0 .. 255] ] where\n    \/\/ Equation 5.3.\n    transform b = GF28::add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n    \/\/ The constant byte {01100011}.\n    c = 0x63\n\n\/**\n * SBox: A non-linear substitution table for AES.\n * [FIPS-197u1] Section 5.1.1.\n *\/\nSBox : GF28 -> GF28\nSBox b = sboxTable @ b\n\n\/**\n * SBox example from [FIPS-197u1] Section 5.1.1 (page 14).\n * ```repl\n *  :prove SBox53\n * ```\n *\/\nproperty SBox53 = SBox 0x53 == 0xed\n\n\/**\n * The substitution table as given in Table 6. The table is pulled out here\n * for efficiency, letting us compute the table once per access in AES.\n *\/\nsboxInvTable : [256]GF28\nprivate sboxInvTable = [ GF28::inverse (transformInv b) | b <- [0 .. 255] ] where\n    transformInv b = GF28::add [(b >>> 2), (b >>> 5), (b >>> 7), d]\n    d = 0x05\n\n\/**\n * Inverted substitution table for AES.\n * [FIPS-197u1] Section 5.3.2.\n *\/\nSBoxInv : GF28 -> GF28\nSBoxInv b = sboxInvTable @ b\n\n\/**\n * S-box inversion must be correctly defined.\n * ```repl\n * :prove SBoxInverts\n * ```\n *\/\nproperty SBoxInverts b = SBoxInv (SBox b) == b\n\n\/**\n * The round key is a block that is usually represented as a sequence of four words.\n * [FIPS-197u1] Section 5.\n *\n * A word is a sequence of four bytes. [FIPS-197u1] Section 3.5.\n *\/\ntype RoundKey = [4][4]GF28\n\n\/** The keys for all the rounds *\/\ntype KeySchedule = [Nr+1]RoundKey\n\/**\n * The general function for executing AES with 128-, 192-, or 256-bit keys.\n *\n * Corresponds to [FIPS-197u1] Section 5.1, Algorithm 1.\n *\n * In the spec, the three inputs to `Cipher` are the input data, the number of\n * rounds `Nr`, and the round keys `w`. In this implementation, we don't explicitly\n * pass `Nr` as a parameter; instead it's defined as a type above. We also\n * switch the order of the input and keys.\n *\/\ncipher: KeySchedule -> [128] -> [128]\ncipher w pt = stateToMsg final_state   where\n        state0 = AddRoundKey (w @ 0) (msgToState pt)\n        state4 = foldl transform state0 (w @@ [1 .. (Nr - 1)])\n        transform state word = AddRoundKey word (MixColumns (ShiftRows (SubBytes state)))\n        final_state = AddRoundKey (w @ `Nr) (ShiftRows (SubBytes (state4)))\n\n\/**\n * SubBytes applies an invertible, non-linear transformation to the state.\n * [FIPS-197u1] Section 5.1.1.\n *\n * It does so by applying the AES S-box independently to each byte in the state.\n *\/\nSubBytes : State -> State\nSubBytes state = [ [ SBox b | b <- row ] | row <- state ]\n\n\/**\n * ShiftRows transforms the state by cycling the last three rows.\n * [FIPS-197u1] Section 5.1.2.\n *\/\nShiftRows : State -> State\nShiftRows state = [ row <<< i | row <- state | i : [2] <- [0 .. 3] ]\n\n\/**\n * MixColumns multiplies the state columns by a fixed matrix.\n * [FIPS-197u1] Section 5.1.3.\n *\/\nMixColumns : State -> State\nMixColumns state = GF28::matrixMult m state\n    where m = [ [2,3,1,1] >>> i | i : [2] <- [0 .. 3] ]\n\n\/**\n * AddRoundKey combines the state with a round key via the\n * bitwise XOR operator\n * [FIPS-197u1] Section 5.1.4\n *\/\nAddRoundKey : RoundKey -> State -> State\nAddRoundKey w state = w ^ state\n\n\/**\n * Key expansion depends on 10 fixed words denoted by `Rcon`.\n * [FIPS-197u1] Section 5.2, Table 5.\n *\n * This function requires `1 <= j <= 10`.\n *\/\nRcon : [8] -> [4]GF28\nRcon j = constants @ (j - 1) where\n    constants = [\n        [0x01, 0x00, 0x00, 0x00],\n        [0x02, 0x00, 0x00, 0x00],\n        [0x04, 0x00, 0x00, 0x00],\n        [0x08, 0x00, 0x00, 0x00],\n        [0x10, 0x00, 0x00, 0x00],\n        [0x20, 0x00, 0x00, 0x00],\n        [0x40, 0x00, 0x00, 0x00],\n        [0x80, 0x00, 0x00, 0x00],\n        [0x1b, 0x00, 0x00, 0x00],\n        [0x36, 0x00, 0x00, 0x00]\n    ]\n\n\/**\n * The value of the left-most byte of `Rcon[j]` in polynomial form is `x^(j-1)`.\n * [FIPS-197u1] Section 5.2.\n * ```repl\n * :prove RconIsExponentiation\n * ```\n *\/\nRconIsExponentiation : [8] -> Bit\nproperty RconIsExponentiation j = (1 <= j) && (j <= 10) ==>\n    (Rcon j)@0 == GF28::pow <| x |> (j-1)\n\n\/**\n * Transformation on words for key expansion.\n * [FIPS-197u1] Equation 5.10.\n *\/\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\n\/**\n * Transformation on words for key expansion.\n * [FIPS-197u1] Equation 5.11.\n *\/\nSubWord : [4]GF28 -> [4]GF28\nSubWord [a0, a1, a2, a3] = [ SBox a0, SBox a1, SBox a2, SBox a3 ]\n\n\/**\n * KeyExpansion() routine.\n * [FIPS-197u1] Algorithm 2.\n *\n * The algorithm in the spec returns the key as a single object `w`. For\n * convenience at the point of use, we split it into three parts, separating\n * the first and last keys from the main set of round keys:\n * `w_0, [w_1, ..., w_{Nr-1}], w_{Nr}`.\n *\n * In generating the key stream, we use slightly different notation compared\n * to the original spec in an attempt at readability.\n * `w_{i-1}` is denoted `w_1`, and `w_{i-Nk}` is denoted `w_nk`.\n *\/\nkeyExpansion : [32 * Nk] -> [Nr+1]RoundKey\nkeyExpansion key = keys\n  where\n    \/\/ Lines 2-6: The first `Nk` words of the expanded key are the key itself\n    seed : [Nk][4]GF28\n    seed = split (split key)\n\n    \/\/ Lines 7-16: A loop to recursively generate the key stream\n    ws : [inf][4]GF28\n    ws = seed # [ nextWord i w_1 w_nk\n       | i    <- [ `Nk ... ]\n       | w_1  <- drop`{Nk-1} ws\n       | w_nk <- ws\n       ]\n\n    \/\/ Generate a single word `w_i` in the key stream.\n    \/\/ Each word `w_i` is a function of the previous word `w_{i-1}`\n    \/\/ and the word `Nk` positions earlier `w_{i-Nk}`.\n    nextWord : [8] ->[4]GF28 -> [4]GF28 -> [4]GF28\n    nextWord i w_1 w_nk = w_i where\n      \/\/ Lines 8 - 13: Derive the mask `temp`.\n      temp =\n        \/\/ If `i` is a multiple of `Nk`:\n        if i % `Nk == 0 then\n          SubWord (RotWord w_1) ^ Rcon (i \/ `Nk)\n        \/\/ For AES-256 (Nk == 8), if `i + 4` is a multiple of 8:\n        else if (`Nk > 6) && (i % `Nk == 4) then\n          SubWord w_1\n        \/\/ For all other cases:\n        else w_1\n\n      \/\/ Line 14: Apply the mask to the `i-Nk`th word to get the `i`th word.\n      w_i = w_nk ^ temp\n\n    \/\/ Line 17: Return the resulting key stream\n    \/\/ This breaks the stream into correctly-shaped words\n    keys = take `{Nr+1} [ transpose g | g <- split ws ]\n\n\/**\n * The general function for inverting AES with 128-, 192-, or 256-bit keys.\n *\n * This inverts and reverses the order of the transformations in `cipher`.\n * Corresponds to [FIPS-197u1] Section 5.3, Algorithm 3.\n *\n * In the spec, the three inputs to `InvCipher` are the input data, the number of\n * rounds `Nr`, and the round keys `w`. In this implementation, we don't explicitly\n * pass `Nr` as a parameter; instead it's defined as a type above. We also\n * switch the order of the input and keys.\n *\/\ninvCipher: KeySchedule -> [128] -> [128]\ninvCipher w ct = stateToMsg final_state   where\n        state0 = AddRoundKey (w @ `Nr) ( msgToState ct)\n        state4 = foldl transform state0 (reverse (w @@ [1 .. (Nr - 1)]))\n        transform state word = InvMixColumns (AddRoundKey word (InvSubBytes (InvShiftRows state)))\n        final_state = AddRoundKey (w @ 0) (InvSubBytes (InvShiftRows (state4)))\n\n\/**\n * Inverts the `ShiftRows` function.\n * [FIPS-197u1] Section 5.3.1.\n *\/\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> i | row <- state | i : [2] <- [0 .. 3] ]\n\n\/**\n * Inverts the `SubBytes` function.\n * [FIPS-197u1] Section 5.3.2\n *\/\nInvSubBytes : State -> State\nInvSubBytes state = [ [ SBoxInv b | b <- row ] | row <- state ]\n\n\/**\n * Inverts the `MixColumns` function.\n * [FIPS-197u1] Section 5.3.3.\n *\/\nInvMixColumns : State -> State\nInvMixColumns state = GF28::matrixMult m state\n    where m = [[0x0e, 0x0b, 0x0d, 0x09] >>> i | i : [2] <- [0 .. 3] ]\n\n\/**\n * SubBytes inversion must be correctly defined.\n * ```repl\n * :prove subBytesInverts\n * ```\n *\/\nsubBytesInverts : State -> Bool\nproperty subBytesInverts s = InvSubBytes (SubBytes s) == s\n\n\/**\n * ShiftRows inversion must be correctly defined.\n * ```repl\n * :prove shiftRowsInverts\n * ```\n *\/\nshiftRowsInverts : State -> Bool\nproperty shiftRowsInverts s = InvShiftRows (ShiftRows s) == s\n\n\/**\n * MixColumns inversion must be correctly defined.\n * ```repl\n * :check mixColumnsInverts\n * ```\n *\/\nmixColumnsInverts : State -> Bool\nproperty mixColumnsInverts s = InvMixColumns (MixColumns s) == s\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CTR.cry","filetype":"cry","content":"\/*\n * Test vectors for AES256 in CTR mode.\n * These are taken from [NIST-SP-800-38A] Appendix F.5\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n *  www.cryptol.net\n *\n * References:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n * Modes of Operation: Methods and Techniques. NIST Special Publication\n * 800-38A. December 2001.\n *\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR as AES256_CTR\n\n\/**\n * ```repl\n * :prove aes256_ctr_encrypt_vector\n * ```\n *\/\nproperty aes256_ctr_encrypt_vector = (AES256_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x601ec313775789a5b7a7f504bbf3d228,\n        0xf443e3ca4d62b59aca84e990cacaf5c5,\n        0x2b0930daa23de94ce87017ba2d84988d,\n        0xdfc9c58db67aada613c2dd08457941a6]\n\n\/**\n * ```repl\n * :prove aes256_ctr_decrypt_vector\n * ```\n *\/\nproperty aes256_ctr_decrypt_vector = (AES256_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x601ec313775789a5b7a7f504bbf3d228,\n        0xf443e3ca4d62b59aca84e990cacaf5c5,\n        0x2b0930daa23de94ce87017ba2d84988d,\n        0xdfc9c58db67aada613c2dd08457941a6]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CFB.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB as AES192_CFB\n\n\/**\n * Section F.3.3: CFB1-AES192.Encrypt\n *\n * ```repl\n * :prove aes192_cfb1_encrypt_vector\n * ```\n *\/\nproperty aes192_cfb1_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b1, 0b1,\n            0b0, 0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1\n        ]\n\n\/**\n * Section F.3.4: CFB1-AES192.Decrypt\n *\n * ```repl\n * :prove aes192_cfb1_decrypt_vector\n * ```\n *\/\nproperty aes192_cfb1_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b1, 0b1,\n            0b0, 0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\n\/**\n * Section F.3.9: CFB8-AES192.Encrypt\n *\n * ```repl\n * :prove aes192_cfb8_encrypt_vector\n * ```\n *\/\nproperty aes192_cfb8_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0xcd, 0xa2, 0x52, 0x1e, 0xf0, 0xa9, 0x05, 0xca, 0x44,\n            0xcd, 0x05, 0x7c, 0xbf, 0x0d, 0x47, 0xa0, 0x67, 0x8a\n        ]\n\n\/**\n * Section F.3.10: CFB8-AES192.Decrypt\n *\n * ```repl\n * :prove aes192_cfb8_decrypt_vector\n * ```\n *\/\nproperty aes192_cfb8_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xcd, 0xa2, 0x52, 0x1e, 0xf0, 0xa9, 0x05, 0xca, 0x44,\n            0xcd, 0x05, 0x7c, 0xbf, 0x0d, 0x47, 0xa0, 0x67, 0x8a\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\n\/**\n * Section F.3.15: CFB128-AES192.Encrypt\n *\n * ```repl\n * :prove aes192_cfb128_encrypt_vector\n * ```\n *\/\nproperty aes192_cfb128_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0xcdc80d6fddf18cab34c25909c99a4174,\n            0x67ce7f7f81173621961a2b70171d3d7a,\n            0x2e1e8a1dd59b88b1c8e60fed1efac4c9,\n            0xc05f9f9ca9834fa042ae8fba584b09ff\n        ]\n\n\/**\n * Section F.3.16: CFB128-AES192.Decrypt\n *\n * ```repl\n * :prove aes192_cfb128_decrypt_vector\n * ```\n *\/\nproperty aes192_cfb128_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv =  0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xcdc80d6fddf18cab34c25909c99a4174,\n            0x67ce7f7f81173621961a2b70171d3d7a,\n            0x2e1e8a1dd59b88b1c8e60fed1efac4c9,\n            0xc05f9f9ca9834fa042ae8fba584b09ff\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CTR.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR as AES128_CTR\n\n\/**\n * ```repl\n * :prove aes128_ctr_encrypt_vector\n * ```\n *\/\nproperty aes128_ctr_encrypt_vector = (AES128_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x874d6191b620e3261bef6864990db6ce,\n        0x9806f66b7970fdff8617187bb9fffdff,\n        0x5ae4df3edbd5d35e5b4f09020db03eab,\n        0x1e031dda2fbe03d1792170a0f3009cee]\n\n\/**\n * ```repl\n * :prove aes128_ctr_decrypt_vector\n * ```\n *\/\nproperty aes128_ctr_decrypt_vector = (AES128_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x874d6191b620e3261bef6864990db6ce,\n        0x9806f66b7970fdff8617187bb9fffdff,\n        0x5ae4df3edbd5d35e5b4f09020db03eab,\n        0x1e031dda2fbe03d1792170a0f3009cee]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CFB.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB as AES256_CFB\n\n\/**\n * Section F.3.5: CFB1-AES256.Encrypt\n *\n * ```repl\n * :prove aes256_cfb1_encrypt_vector\n * ```\n *\/\nproperty aes256_cfb1_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b0, 0b0,\n            0b0, 0b0, 0b1, 0b0, 0b1, 0b0, 0b0, 0b1\n        ]\n\n\/**\n * Section F.3.6: CFB1-AES256.Decrypt\n *\n * ```repl\n * :prove aes256_cfb1_decrypt_vector\n * ```\n *\/\nproperty aes256_cfb1_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b0, 0b0,\n            0b0, 0b0, 0b1, 0b0, 0b1, 0b0, 0b0, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\n\/**\n * Section F.3.11: CFB8-AES256.Encrypt\n *\n * ```repl\n * :prove aes256_cfb8_encrypt_vector\n * ```\n *\/\nproperty aes256_cfb8_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0xdc, 0x1f, 0x1a, 0x85, 0x20, 0xa6, 0x4d, 0xb5, 0x5f,\n            0xcc, 0x8a, 0xc5, 0x54, 0x84, 0x4e, 0x88, 0x97, 0x00\n        ]\n\n\/**\n * Section F.3.12: CFB8-AES256.Decrypt\n *\n * ```repl\n * :prove aes256_cfb8_decrypt_vector\n * ```\n *\/\nproperty aes256_cfb8_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xdc, 0x1f, 0x1a, 0x85, 0x20, 0xa6, 0x4d, 0xb5, 0x5f,\n            0xcc, 0x8a, 0xc5, 0x54, 0x84, 0x4e, 0x88, 0x97, 0x00\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\n\/**\n * Section F.3.17: CFB128-AES256.Encrypt\n *\n * ```repl\n * :prove aes256_cfb128_encrypt_vector\n * ```\n *\/\nproperty aes256_cfb128_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0xdc7e84bfda79164b7ecd8486985d3860,\n            0x39ffed143b28b1c832113c6331e5407b,\n            0xdf10132415e54b92a13ed0a8267ae2f9,\n            0x75a385741ab9cef82031623d55b1e471\n        ]\n\n\/**\n * Section F.3.18: CFB256-AES192.Decrypt\n *\n * ```repl\n * :prove aes256_cfb128_decrypt_vector\n * ```\n *\/\nproperty aes256_cfb128_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv =  0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xdc7e84bfda79164b7ecd8486985d3860,\n            0x39ffed143b28b1c832113c6331e5407b,\n            0xdf10132415e54b92a13ed0a8267ae2f9,\n            0x75a385741ab9cef82031623d55b1e471\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CTR.cry","filetype":"cry","content":"\/*\n * Test vectors for AES192 in CTR mode.\n * These are taken from [NIST-SP-800-38A] Appendix F.5\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n *  www.cryptol.net\n *\n * References:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n * Modes of Operation: Methods and Techniques. NIST Special Publication\n * 800-38A. December 2001.\n *\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CTR as AES192_CTR\n\n\/**\n * ```repl\n * :prove aes192_ctr_encrypt_vector\n * ```\n *\/\nproperty aes192_ctr_encrypt_vector = (AES192_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x1abc932417521ca24f2b0459fe7e6e0b,\n        0x090339ec0aa6faefd5ccc2c6f4ce8e94,\n        0x1e36b26bd1ebc670d1bd1d665620abf7,\n        0x4f78a7f6d29809585a97daec58c6b050]\n\n\/**\n * ```repl\n * :prove aes192_ctr_decrypt_vector\n * ```\n *\/\nproperty aes192_ctr_decrypt_vector = (AES192_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x1abc932417521ca24f2b0459fe7e6e0b,\n        0x090339ec0aa6faefd5ccc2c6f4ce8e94,\n        0x1e36b26bd1ebc670d1bd1d665620abf7,\n        0x4f78a7f6d29809585a97daec58c6b050]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CFB.cry","filetype":"cry","content":"\/*\n * Test vectors for AES128 in CFB mode.\n *\n * These are taken from [NIST-SP-800-38A], Appendix F.3.\n *\n * @copyright Galois, Inc.\n * @author Alex J Malozemoff <amaloz@galois.com>\n * www.cryptol.net\n *\n * Sources:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n *     Modes of Operation: Methods and Techniques. NIST Special Publication\n *     800-38A. December 2001.\n *     @see https:\/\/doi.org\/10.6028\/NIST.SP.800-38A\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB as AES128_CFB\n\n\/**\n * Section F.3.1: CFB1-AES128.Encrypt\n *\n * ```repl\n * :prove aes128_cfb1_encrypt_vector\n * ```\n *\/\nproperty aes128_cfb1_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b0, 0b0,\n            0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1, 0b1\n        ]\n\n\/**\n * Section F.3.2: CFB1-AES128.Decrypt\n *\n * ```repl\n * :prove aes128_cfb1_decrypt_vector\n * ```\n *\/\nproperty aes128_cfb1_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b0, 0b0,\n            0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\n\/**\n * Section F.3.7: CFB8-AES128.Encrypt\n *\n * ```repl\n * :prove aes128_cfb8_encrypt_vector\n * ```\n *\/\nproperty aes128_cfb8_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0x3b, 0x79, 0x42, 0x4c, 0x9c, 0x0d, 0xd4, 0x36, 0xba,\n            0xce, 0x9e, 0x0e, 0xd4, 0x58, 0x6a, 0x4f, 0x32, 0xb9\n        ]\n\n\/**\n * Section F.3.8: CFB8-AES128.Decrypt\n *\n * ```repl\n * :prove aes128_cfb8_decrypt_vector\n * ```\n *\/\nproperty aes128_cfb8_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0x3b, 0x79, 0x42, 0x4c, 0x9c, 0x0d, 0xd4, 0x36, 0xba,\n            0xce, 0x9e, 0x0e, 0xd4, 0x58, 0x6a, 0x4f, 0x32, 0xb9\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\n\/**\n * Section F.3.13: CFB128-AES128.Encrypt\n *\n * ```repl\n * :prove aes128_cfb128_encrypt_vector\n * ```\n *\/\nproperty aes128_cfb128_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0x3b3fd92eb72dad20333449f8e83cfb4a,\n            0xc8a64537a0b3a93fcde3cdad9f1ce58b,\n            0x26751f67a3cbb140b1808cf187a4f4df,\n            0xc04b05357c5d1c0eeac4c66f9ff7f2e6\n        ]\n\n\/**\n * Section F.3.14: CFB128-AES128.Decrypt\n *\n * ```repl\n * :prove aes128_cfb128_decrypt_vector\n * ```\n *\/\nproperty aes128_cfb128_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0x3b3fd92eb72dad20333449f8e83cfb4a,\n            0xc8a64537a0b3a93fcde3cdad9f1ce58b,\n            0x26751f67a3cbb140b1808cf187a4f4df,\n            0xc04b05357c5d1c0eeac4c66f9ff7f2e6\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CBC.cry","filetype":"cry","content":"\/*\n * Test vectors for AES192 in CBC mode.\n * These are taken from [NIST-SP-800-38A] Appendix F.2\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n * @author Stanislav Lyakhov <stan@galois.com>\n *  www.cryptol.net\n *\n * References:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n * Modes of Operation: Methods and Techniques. NIST Special Publication\n * 800-38A. December 2001.\n *\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CBC as AES192_CBC\n\n\/**\n * ```repl\n * :prove aes192_cbc_encrypt_vector\n * ```\n *\/\nproperty aes192_cbc_encrypt_vector = (AES192_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x4f021db243bc633d7178183a9fa071e8,\n        0xb4d9ada9ad7dedf4e5e738763f69145a,\n        0x571b242012fb7ae07fa9baac3df102e0,\n        0x08b0e27988598881d920a9e64f5615cd]\n\n\/**\n * ```repl\n * :prove aes192_cbc_decrypt_vector\n * ```\n *\/\nproperty aes192_cbc_decrypt_vector = (AES192_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0x4f021db243bc633d7178183a9fa071e8,\n        0xb4d9ada9ad7dedf4e5e738763f69145a,\n        0x571b242012fb7ae07fa9baac3df102e0,\n        0x08b0e27988598881d920a9e64f5615cd]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CBC.cry","filetype":"cry","content":"\/*\n * Test vectors for AES256 in CBC mode.\n * These are taken from [NIST-SP-800-38A] Appendix F.2\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n * @author Stanislav Lyakhov <stan@galois.com>\n *  www.cryptol.net\n *\n * References:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n * Modes of Operation: Methods and Techniques. NIST Special Publication\n * 800-38A. December 2001.\n *\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CBC as AES256_CBC\n\n\/**\n * ```repl\n * :prove aes256_cbc_encrypt_vector\n * ```\n *\/\nproperty aes256_cbc_encrypt_vector = (AES256_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0xf58c4c04d6e5f1ba779eabfb5f7bfbd6,\n        0x9cfc4e967edb808d679f777bc6702c7d,\n        0x39f23369a9d9bacfa530e26304231461,\n        0xb2eb05e2c39be9fcda6c19078c6a9d1b]\n\n\/**\n * ```repl\n * :prove aes256_cbc_decrypt_vector\n * ```\n *\/\nproperty aes256_cbc_decrypt_vector = (AES256_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0xf58c4c04d6e5f1ba779eabfb5f7bfbd6,\n        0x9cfc4e967edb808d679f777bc6702c7d,\n        0x39f23369a9d9bacfa530e26304231461,\n        0xb2eb05e2c39be9fcda6c19078c6a9d1b]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_KeyWrapPadded_AE.cry","filetype":"cry","content":"\/**\n * Test vectors for AES key wrap with padding's authenticated encryption\n * function from NIST's ACVP cryptographic validation program.\n *\n * These values are specifically drawn from the `internalProjection.json` file,\n * specifically the section with group ID `\"tgId\" : 11`.\n *\n * [ACVP]: NIST. usnistgov. GitHub repo \"ACVP-Server\".\n *     @see https:\/\/github.com\/usnistgov\/ACVP-Server\/tree\/master\/gen-val\/json-files\/ACVP-AES-KWP-1.0\n *\n * Rather than decorate every property, we use a single docstring up here:\n * ```repl\n * :exhaust\n * ```\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AE where\n\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap\n\ncheck_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct\n\nproperty tcId1001 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x39FA276B26B762599AA1070192987D0CF8184DDB1C98EEA23F06FF81B63481E0\n    pt = 0x8D\n    ct = 0x35A739A8A322805B94DEB3CB1A56A008\n\nproperty tcId1002 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF80E0BDD0D1B3407F241522045574E3C80CA99D3A6854706047942EB694CDBF3\n    pt = 0xC5\n    ct = 0x9581CB7E06C38D57C5262A7BD4BD8840\n\nproperty tcId1003 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC93821958B2A3AC969FFCA59EF5623E609F38585A6C9A9ADE41D546578DE141D\n    pt = 0x1E\n    ct = 0xDD6DC03E825F2E77480F998902FA6BE8\n\nproperty tcId1004 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF6C4018216BC7EAB22D57893BE5E9E3A2A7189813E37D26BFD8A866BADE775F8\n    pt = 0xE3\n    ct = 0x56F07FA0F5512B159F5E70A50C442B0B\n\nproperty tcId1005 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDC426450A27CCAD9B7890661B13480D2225918AAC7C03829512492865763ABDC\n    pt = 0x3F\n    ct = 0x686DE8ABFFBEDF79AAFD4432ECD4CF50\n\nproperty tcId1006 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x44F2DE705C848A3448FF6FFCBD221C0DC2119351D384CE21D5AC2606FE21B6F8\n    pt = 0xDA\n    ct = 0xE4B9BC2CE14293EAF05955A42627269D\n\nproperty tcId1007 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC933E2E4EE7D519FA406AA70EAC833CCD50FBB044427B1D25624254A555EDC43\n    pt = 0x1E\n    ct = 0x901B3CE56E12F8C188039535EBA61996\n\nproperty tcId1008 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x6E0627242E7C51B204DB46A58D6A411B96514555CF8C21DD8B2DC37CDA95F9CD\n    pt = 0x15\n    ct = 0x2AD76F428813B950D099C10105A29FB5\n\nproperty tcId1009 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1FD3508E9533EC697E4B8F59FFFE4B98857919A4DEF918426D068F70F3B2948E\n    pt = 0x02\n    ct = 0x530967E906FD940C887A6AD9F37AC42D\n\nproperty tcId1010 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x85BFD16F7B562AD251329106A3D7A184C5C96CCE489B2DD797A084A72404376D\n    pt = 0x94\n    ct = 0xEFC758A879A703D39B7B85F7BB7B2D44\n\nproperty tcId1011 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDDD6FAB4C49DD7FF2985AE928BD5EA87CC70A31163074F1FB1BC02F7F969D418\n    pt = 0x86\n    ct = 0xBD96D9C865A87BE05A306AB3D6BBA3A5\n\nproperty tcId1012 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDA37F25B6EBE88C9DB9E03A5E126D5AE55F632B1686115C956228326A0DBC789\n    pt = 0xA9\n    ct = 0xAC58CFA83697E911CD09BEA23CA4CD45\n\nproperty tcId1013 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1BB566FE462A27901D86EEF8558F53E505E47D81A66F2918AADE08EA347201B3\n    pt = 0x1D\n    ct = 0x8A51E6B709CB04F59981F7FFDB783D0B\n\nproperty tcId1014 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x73B2AB98DDC2A3557AC51C1976D43F2997D4305D6C1D8DE38B393161DE44A1BA\n    pt = 0x54\n    ct = 0x281900A08220B5F74CF06D739F7C5DC6\n\nproperty tcId1015 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCACF12AE11477B1254437CA92D329F1C7EE6B2C022E4F12C3EAC649621AB0137\n    pt = 0xE2\n    ct = 0x6DCC8657EC2A2443DD056EF73DBBFB7B\n\nproperty tcId1016 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3E7517AE08DA6B2B027AC829D0D96FB0D2B27C611D217174FFF385EEA51ABC9F\n    pt = 0x7E\n    ct = 0x542A995D5BEB0FEF0CA3B56DB914E0DF\n\nproperty tcId1017 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x636062EAF492C67B4E98DC4653031942CE29FB1B81462A31FCA2A40DF760ED1F\n    pt = 0x9C\n    ct = 0x9F24ED46467485D4ED54D232E50E8885\n\nproperty tcId1018 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x86CF07CC35A7624129A9390B14EE6FA8B8D7A9F613050E7CE3E3AF3CAD54ABB3\n    pt = 0x75\n    ct = 0x76A00B69214577BAD18CCDC983C8BAFD\n\nproperty tcId1019 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC4C825E849AE1C195748979D8821711590403E3AC47984C526DF896D120E7396\n    pt = 0x9E\n    ct = 0x5808672A0F4EEDD81328D99819993EB7\n\nproperty tcId1020 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFF84BC98909D273B28F0AC9D0C44386533BFE6A0586294D57DF370FFECCDDB3F\n    pt = 0xC9\n    ct = 0xDA9785C2ADC2CE92EFF5E3523D469235\n\nproperty tcId1021 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x8670FB10B54781839B56C7A14C660412FE2E48F3655ACC55553B794D9FFA32B7\n    pt = 0xF0\n    ct = 0x8850EF6CB7396E775D4F330C6E01EDCE\n\nproperty tcId1022 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x211A909A1C1B0F56BEBBF3362DC2CD75AB14BB2CB4EB191557B5ABAC7EF9E4E4\n    pt = 0x19\n    ct = 0xC76400B498AEB0023E266AFF9EE30FE8\n\nproperty tcId1023 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xB77EBA3E4E1FD9D5989A233E66BFC9CBB8CF245C9DCF7C59AF1D5FDD4811D76A\n    pt = 0xC0\n    ct = 0xC8869A194252053D69CB3700B519B400\n\nproperty tcId1024 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x96A325D96DF23193F21C409B20B83B157E4BC00E7B872A96D57EA7791575B797\n    pt = 0x60\n    ct = 0x9C5C1DCBFE8CEA38DED462DC2268D090\n\nproperty tcId1025 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x67BA246D02CBBBEDDE0B24C8DD8EE9ECF80DC34ECF0A211B1967BC141265F099\n    pt = 0x00\n    ct = 0x38AE876F1E45933C75D8B57531B59075\n\nproperty tcId1026 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x81C3403F359326663B025C16865E245808C4848A54011F6B88385A1A64FBECBC\n    pt = 0xC2\n    ct = 0x8C0DEC2FD4B6AB0231EC56BD50852D84\n\nproperty tcId1027 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x428666365FFAE2B604A71E3EA61D1AB85CFCDEDEF5D40CFE8E53FDB96AC27630\n    pt = 0x1D\n    ct = 0x48D46E384AE3AA2BDCEC10399A82BE37\n\nproperty tcId1028 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x859857F302D7B4BECF1220B55857A1DF064355AB306E9E9C3FEC3DC86FAFCC3A\n    pt = 0x91\n    ct = 0x7E0CF4C530ED36B947CA4C5D7DE0097A\n\nproperty tcId1029 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFC304BE2EBA8E1CD41680F2228E150718D829821F99994AC44D59C7494BDB6A8\n    pt = 0xC2\n    ct = 0xF125384DEE677C7923697F5A3BFC6184\n\nproperty tcId1030 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5D124C781D08A9A1EF74B9BFC5B92C093F47B6C20E566B12ECBC361813688F01\n    pt = 0x3D\n    ct = 0x8435A5CB88740BADEC2C57FE0BBA0DA8\n\nproperty tcId1031 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xAA5AB62D3DF457E141F244ECB7A1B02B7C849535F6114EE43FE5474FA7934D3E\n    pt = 0x19\n    ct = 0xF3E526B2D27DCAE85E3B603219079B17\n\nproperty tcId1032 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B2B4903C7F4FEBFE9600D357C043E891BC2659AA21694810AD9DF8DE2C5D87B\n    pt = 0x7F\n    ct = 0x9AE5B26B28514B2E02866F655689D8A2\n\nproperty tcId1033 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B7572593C032234A0047A9D2A92E9F7323226FD9879B8F8BF73631C16560922\n    pt = 0x5E\n    ct = 0x2E94CB8DFFCDA2399BC422B24928A91A\n\nproperty tcId1034 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x68380612EB8E22DC776E8D05BE01B619D0C1CB99EBC7947C8444CB26FEAC0E91\n    pt = 0xBB\n    ct = 0xAA6ABD32EA59851AFE3AD836727E5DC6\n\nproperty tcId1035 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xED0580C7DAB265D63DCCFEB165778BA3ADCC9C92D807B0DA7D08F05A2D1E0EF1\n    pt = 0xAB\n    ct = 0xC3DC9EA6773BA6B254156BCA2D6CCDC4\n\nproperty tcId1036 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x512E2D54D84820280EFEC1286247D6A17DC5A23F33FC1C32D5A023D38EE43B8E\n    pt = 0xF5\n    ct = 0x4E50FAEF7FEDF00A97744D1E50180D29\n\nproperty tcId1037 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCDDD9A61EE554E27E75D9D2A6905763363ABFDA1A2E0D1351CFAC3B870E72AB7\n    pt = 0x9C\n    ct = 0x13865E5DA697B608016326560370FC34\n\nproperty tcId1038 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xBCDA299791DF47EFEFA436000A4234F9F1DDB2959F7F5CECD7D114DA1555DF39\n    pt = 0x23\n    ct = 0x957A898CF5CA014FA0BC445FA0411B8E\n\nproperty tcId1039 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x14AC4E2D21736EDCC6D423E3AF1E2BC4E8115A9C190AFD7C5A764CB7FDEFE222\n    pt = 0x27\n    ct = 0x47F8738AE025CB323AA904BB8FC94D5A\n\nproperty tcId1040 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD780739A8A8F203E593DFA988C4BEDDAD17EC65E32FF9420E8B7B094AD3504CE\n    pt = 0xA4\n    ct = 0x0ACA7980AA5D91E7CF8A7FF32ACFB820\n\nproperty tcId1041 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFE9E71CE3F0372783D47D1219919A9176DBBA7E1E7BB0E6BD94599DA51F616EA\n    pt = 0x18\n    ct = 0x4BEF98A1A912C5CCFB44398501393A5B\n\nproperty tcId1042 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD067989158B5C486D6CB2317DC4A1F174EDA232A5D0572313666B602F80FAA82\n    pt = 0x87\n    ct = 0x1622F42C6EB932C9C3BA6EE528F5EE2E\n\nproperty tcId1043 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF08EAD0CDBBCC69EF06549FAED6989E5177678A31CDE24081E962C06F80DFFF1\n    pt = 0xB6\n    ct = 0xA164FE1AAC233A7B292190106242BC35\n\nproperty tcId1044 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x6FFA0B069567D8B8CF189E1E651126E16432F4B1DF14D28C7930F167D90E71DC\n    pt = 0xBC\n    ct = 0x81AF399406890408830494067B975DC3\n\nproperty tcId1045 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF0D9A00431BFC37776632DCE8392FB668738B8E7E87B32FE6970AEDE141DBB12\n    pt = 0x15\n    ct = 0x21A2E83460738D67E274DE0231F5DB08\n\nproperty tcId1046 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x8758E274D03DE0037EB638671BF7A5762262CD81FA4710612F0F8C00DD544FD2\n    pt = 0x10\n    ct = 0xB58EF1C43EF4FB8D25C53D673C074A9F\n\nproperty tcId1047 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x611CB910E6F3554891709BE3269311CAEEA4167646770C93B1EB24150B08E7FF\n    pt = 0xAE\n    ct = 0xC4D38071B0325A7DBAE7B8C97E140567\n\nproperty tcId1048 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x595D643FEE1B9DA657E5E0DD89BEA95FBA9D60A9F569E5BD2263ECDA865B6397\n    pt = 0x8A\n    ct = 0x291C122B76FF48EB7A9B1A25C20FF3E9\n\nproperty tcId1049 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF66827A982352FB10D7BD294A6DA6661B9593E850D9AEE8C7E2C2F0662B66609\n    pt = 0x1A\n    ct = 0x8320E7CDE94090DDB0AFA279F71CF86C\n\nproperty tcId1050 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x927B27D5B50BA9D198E9EECD1317FD659A80F9E061A2703E797B61D420C7164D\n    pt = 0x62\n    ct = 0xEF84DE1F6C508958F7ADC6D11C606DB8\n\nproperty tcId1051 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF416A4C6552B4E2E2D5F88C6AF5494C4EA1D04BB22A377C0806611418475F1F8\n    pt = 0x10\n    ct = 0x562ADB01EA14439CE1D8A6FBA46515F4\n\nproperty tcId1052 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x42EE175CB7A7F28620500AE8856C7CDE3C4052FBA5ABF91C9E91E20857AF5066\n    pt = 0x29\n    ct = 0xB5465699DD3DC2969DCF8B1DA3C0DFCC\n\nproperty tcId1053 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD9C652FA5E6A16E51DC513B53AFBC7E6624B8C3E4E3C58CD223320228EEE5DFD\n    pt = 0x55\n    ct = 0x0AD61A07DB5EC915C16F1A320BF0EAED\n\nproperty tcId1054 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x070FDEE3C8E60C382E9EFB3E61AD9B84620F2513F25DE9A535C344774F14BBC0\n    pt = 0xA4\n    ct = 0x906B0FA922E825B9375863FCA511B446\n\nproperty tcId1055 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x965B12BA6F405A1C99A702AC08084090FD80854BF5C09D00D1CBF8020E1FC853\n    pt = 0xEE\n    ct = 0x338C2D6EF2A4F0215F32117A6999E2FE\n\nproperty tcId1056 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x16E8974B487171A030AB25FE03E5789772A2A91E4FBBEFA62A2C3957AC69DAC3\n    pt = 0x51\n    ct = 0xFE89DB7AB88A6A50DBC7B4BBFD7C7D19\n\nproperty tcId1057 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9A729225A773F82968D4E4A61F67F7FEFA1C1EB951506220D2B44FB4EF06C54A\n    pt = 0xFD\n    ct = 0xBC7ED8E326F929CD1CF2939519972DB5\n\nproperty tcId1058 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x41472533F605B84462AD4C8FD062FC9B24B9EE7EBA935D0ECA424D2AB503DEF8\n    pt = 0xF9\n    ct = 0x32746F33EC7A049B4A3C48BD0ED21CE8\n\nproperty tcId1059 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x80F14DD8F5F9EF689A6840363AD88F58DE0EDCDB74700BA33A7DD923FDCB5DAD\n    pt = 0x29\n    ct = 0xF34CACF3816972C90A4AF0E67E7AED85\n\nproperty tcId1060 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xBD62F4F0449F892825008928D877A7543FADFAD05D3877033FFBD343EB83E622\n    pt = 0xD7\n    ct = 0x54F7EF87C184A81009EBF9BF6688CD7C\n\nproperty tcId1061 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x44D2B78F5FD38A5F681DA45F2FD177AFC122B7E780BB516AF29D928F3A17DAF5\n    pt = 0xD2\n    ct = 0x286F752B981CE6847661E0DCDD4D5F49\n\nproperty tcId1062 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x19556188E0349531F56D4144DAD2E5E0F6FFD349E017EFD31A05DB09291ED515\n    pt = 0xEF\n    ct = 0xE6DFA16F00FA7241F84E614649045B40\n\nproperty tcId1063 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC2DF0F8EC128AC630349FA9E452A2A8A10B500E00B9524E146518780EE62B117\n    pt = 0x81\n    ct = 0xDF68CB42ED2761D74BEBCE73E590A4DF\n\nproperty tcId1064 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x4E88503C08AD7EF21832B200F39489D3C5457CDB45912DAA380A6DF414B125C8\n    pt = 0x2D\n    ct = 0x52D5A548C2E4D287DCAAFE03E016AD79\n\nproperty tcId1065 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xA45AFB02BF762298F315E033B04325127E9DC8F237261DDB114D384B44571929\n    pt = 0x42\n    ct = 0xCD487595DFE7F933FEF5B10587AC8981\n\nproperty tcId1066 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x7FB2623EBF05DBAEBD5122920E97DFFF06F57C838DA933538C97FAD59E25EB8A\n    pt = 0x77\n    ct = 0x8A5F782FBED1132D0636F53A51CDBF79\n\nproperty tcId1067 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x150F4FB634BAC25DE6992583F54DD734173E93AB43F63594832D9287778AD0EE\n    pt = 0x7A\n    ct = 0x799C8243EF5EF87891E005B506BF2F64\n\nproperty tcId1068 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B6CF52B74C43964097B6E38D37E01D673FB71F23C3329581F6409D8ED32A16E\n    pt = 0x4D\n    ct = 0xF293CE2D1F9C6725E1F9F107421AC396\n\nproperty tcId1069 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2644CCF9D7C419A437C954C8141CBB2D60F57DE10A5393554A14CCC72229E286\n    pt = 0xE0\n    ct = 0xDA510B1D9A10255380655980A3A73536\n\nproperty tcId1070 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5A2BF1A5098964EEC4D82F7E7C2D5723A5777F202E5CF729B506A5DC9775F1DE\n    pt = 0x11\n    ct = 0x19B164EFC41F5FFF402A1097CD89259C\n\nproperty tcId1071 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9B35B7F2AB8EEBA30101BC8D0BF94B09C8EA02114ED9912F7659967DC3C7D841\n    pt = 0x71\n    ct = 0xC788AB3CE96444554BBA805A1E3A8F91\n\nproperty tcId1072 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B7783AD07911FC6D685E60FCB1213EDFF5DCD7EAC1D73DA2685585AE4C39177\n    pt = 0x3E\n    ct = 0x0EA7AB3B26CDA9612A508EF9B41DB7C8\n\nproperty tcId1073 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFB56787EC73A1EED0C9061D023A305AC301E2455E349B2E573F2AFE326709ADD\n    pt = 0xC1\n    ct = 0x2C713F375FDD12469E753C68BAEAC6D4\n\nproperty tcId1074 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1AC45D1DB5E960DECD86AEA2507F1CD51EAC9BD3EA8B6093D4A795EFCA7187B0\n    pt = 0x73\n    ct = 0x24B65C239B23D8C8F44EC2721ED03B15\n\nproperty tcId1075 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDE8A1521277486D6FCDA3A24031DEE8647344F88A051A4DA7F452A7036DAA8C0\n    pt = 0x5E\n    ct = 0x708D55D92DB692A62CBA3CA4D009C8CE\n\nproperty tcId1076 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xA66E6DA21D52FC24733C303A121AD10626A5194884054CF8B73E7A71AA49380B\n    pt = 0xD3\n    ct = 0x7AD507B5FA5CD4A98C797A8DD824923F\n\nproperty tcId1077 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCC3710FD1C78A8B019AE0E8608E5C60F614D1F043196A3D87A67074A267B5542\n    pt = 0x02\n    ct = 0xF02A71952C7F74D6F509D0DA905B5E44\n\nproperty tcId1078 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x371EEFF5ACEC4E980CA59E9D91BEBF9B1B8013B3340BC45D624F0AA0943118DA\n    pt = 0x74\n    ct = 0x7BD179C985A426CD4FF9BFBEF858436E\n\nproperty tcId1079 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x54D9324535DAC6090439406626141312CB4A61ADC61189947D5572FBD326CB57\n    pt = 0x7F\n    ct = 0xFF0061FC09D685215C4B22BE822405FD\n\nproperty tcId1080 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3EA9325069ED93A96C331BDD6DD766EC64BBBA83A72C69ED75DF55043FB0BFD1\n    pt = 0x06\n    ct = 0x40A9C42012BA38211B800E6E313B6876\n\nproperty tcId1081 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2C0CD8480E0768FB9E33A9929F3991A0DE0B0AC1F35D0CB7E58757A9D28D49D4\n    pt = 0x06\n    ct = 0xCADAD5CFD536F7BA6897EF398483F38F\n\nproperty tcId1082 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2BB319F216DBBA31EB4BB3265FF85D13ABD8B12083DC0CD48C40372C946F70D5\n    pt = 0xE5\n    ct = 0x85427703FBC3BE25BE88765DC8791554\n\nproperty tcId1083 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD393149C58FDB23C4ABDF43EE03D603DEB1FD06CD625F821FF93B27376458C9E\n    pt = 0x1B\n    ct = 0x3D737A3A014ABDDA0BE2696C8097EE95\n\nproperty tcId1084 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x03353DEAB5D9CD40338E8ECC8D810DE4E29B6D34CF158F68DB5AE356A4225266\n    pt = 0x8D\n    ct = 0x9313D7D59E08024181C2146F9123A78F\n\nproperty tcId1085 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x0CFD3A3B0540E5B3F044EB60050FEAFC80BAC758DB99016F79F0F5BF80307779\n    pt = 0xFC\n    ct = 0x02EC669FB26BDCDCC398545D7BDBDEC7\n\nproperty tcId1086 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x4CBC12CEE939C4F915DAE23A4B6F30B8B45734686067B27BF592BCF929C7E75E\n    pt = 0x34\n    ct = 0x5965D7F3EE0A4940BADDDFFA05A30BF4\n\nproperty tcId1087 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1BAD340ABB934070C9B7662815BB7BAA652A056CCF246A375B6D959ADD5D7DEC\n    pt = 0x2A\n    ct = 0xEED916D3195F9C39406802285CA665D3\n\nproperty tcId1088 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xB0D6764B9B604A44D6A201A07E1F3CFCD0DA1A322DAA1251EFA19C12A8488D0E\n    pt = 0x8A\n    ct = 0xFE2A001CB35F00EAF85614EC594E2D9F\n\nproperty tcId1089 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x59BB9A295C7263842521D5F1EDD2DB92D9F09A607F758E2E3EF8CA6137616C93\n    pt = 0xB0\n    ct = 0x4AE1CF2A3BBD5BC2573D8A13212E445A\n\nproperty tcId1090 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x07E0C27A362DFB87EDE1B5E0A1790FA3FB09A99E12A6A71EB0A41B6356C9CC92\n    pt = 0xAC\n    ct = 0x70D749E0C9C77A0EDD98F8BCE3753733\n\nproperty tcId1091 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x50E530EF3EB1A1BAE45B8263BA7E30F6F5A7D2418F3611E30830C87D741647CD\n    pt = 0xFB\n    ct = 0x4FAA8357F2F3EF340A5E8B7AA74DD290\n\nproperty tcId1092 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xE1DE28540953AAF2AFB9EEF0DDBD08B5A1AAB73EECDD2F0E85F8915C94699E4A\n    pt = 0x17\n    ct = 0xC686DC8FE198F9D36374F5C56B99E3DF\n\nproperty tcId1093 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFBDCABF978959C69724C63165A17DB5F1FA7FC2871F9BDFC799391C908F78F6C\n    pt = 0xC8\n    ct = 0xB6B5D8288DAFE8F8584514B5193EEEFE\n\nproperty tcId1094 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x417887E598A05E102E6C651F6900C22412DEB49140585A650DECA9B1BA211B1E\n    pt = 0x72\n    ct = 0x5B0B9FAB5479528F87EB3C91225BB64D\n\nproperty tcId1095 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3BDBA3053CC76471EA0D78531BBA04A9584995BE194A348185698FE4D1338BBE\n    pt = 0xFA\n    ct = 0xF56924CE90ED7C0A79B8CAA4101D1DBC\n\nproperty tcId1096 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9DDFEA3DA8FF9F5401D5BDBBE520E4D47263E5B268BB15DC6FD62939FFA49377\n    pt = 0x58\n    ct = 0x01F0962438250AAEEDF8069D7CFD1F95\n\nproperty tcId1097 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x59DE802DC7805F487E4537941C71A24317B585BD58CC1FF9B5AC18FFA78E74A3\n    pt = 0x0E\n    ct = 0x2B7E6ACDA4967F644662A58CE8077917\n\nproperty tcId1098 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x35F2322E2999AAA3BEBA5E33A237E9D84DF0DA5BB732370AAEF97316F78DD413\n    pt = 0x1E\n    ct = 0x8A4DBD736974C2E73DD27C5E47955D94\n\nproperty tcId1099 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x45D780CFD96B54CF1AB425FAA701645B0FC5F84AA385B1372771BD7AD6109F0F\n    pt = 0xFC\n    ct = 0xA2E47585D0D8F81BA155324417EC2571\n\nproperty tcId1100 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDF9F0529DBBABA0D2A925AD2E0B81E01A0386DFC2033D3D6D446845957C02A15\n    pt = 0x0A\n    ct = 0xF6B6398CA55ACE0222A9391FD81CD276\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CBC.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC as AES128_CBC\n\n\/**\n * ```repl\n * :prove aes128_cbc_encrypt_vector\n * ```\n *\/\nproperty aes128_cbc_encrypt_vector = (AES128_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x7649abac8119b246cee98e9b12e9197d,\n        0x5086cb9b507219ee95db113a917678b2,\n        0x73bed6b8e3c1743b7116e69e22229516,\n        0x3ff1caa1681fac09120eca307586e1a7]\n\n\/**\n * ```repl\n * :prove aes128_cbc_decrypt_vector\n * ```\n *\/\nproperty aes128_cbc_decrypt_vector = (AES128_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0x7649abac8119b246cee98e9b12e9197d,\n        0x5086cb9b507219ee95db113a917678b2,\n        0x73bed6b8e3c1743b7116e69e22229516,\n        0x3ff1caa1681fac09120eca307586e1a7]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_KeyWrapPadded_AD.cry","filetype":"cry","content":"\/**\n * Test vectors for AES key wrap with padding's authenticated decryption\n * function from NIST's ACVP cryptographic validation program.\n *\n * These values are specifically drawn from the `internalProjection.json` file,\n * specifically the section with group ID `\"tgId\" : 35`.\n *\n * [ACVP]: NIST. usnistgov. GitHub repo \"ACVP-Server\".\n *     @see https:\/\/github.com\/usnistgov\/ACVP-Server\/tree\/master\/gen-val\/json-files\/ACVP-AES-KWP-1.0\n *\n * Rather than decorate every property, we use a single docstring up here:\n * ```repl\n * :exhaust\n * ```\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AD where\n\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap\n\ncheck_KWP_AD key pt ct = case KWP_AD key ct of\n    Some pt' -> pt == pt'\n    None -> False\n\nproperty tcId3401 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1C8AB00037582D4E850D92E4244B6229D1FA54D6A0B1D1B71D43C0E45C544A18\n    pt = 0x3E\n    ct = 0x4358AA665202E40D725B01FEB065AABF\n\nproperty tcId3402 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA2423B2160857B73A2ED23C995F8374B7DFB2BA458B781131CF7DC4A5B370669\n    pt = 0x44\n    ct = 0x581BA83958B7528436CF9EA163E4873F\n\nproperty tcId3403 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x084D092899BC5F76288CFD7C45C336380BD2D768C98C5144B20D5612CA9CF598\n    pt = 0x59\n    ct = 0xC1B83872E7B0FC48156A06154219A608\n\nproperty tcId3404 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x518594C8D42412C9EDFB1E17E821B37DA0A020CAF4620FF2298AF4254EA0CFB3\n    pt = 0xB8\n    ct = 0x74C938C320B03451ED58DE73BFCAEE25\n\nproperty tcId3405 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x7F45132EE8CD57D9EADB90F15506D716311F2A226CB38D545F5BA4A76E065C90\n    pt = 0xAF\n    ct = 0x43AD1FAC8D9A4878414BC5D224856FC2\n\nproperty tcId3406 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x37839C73459186707F2C53440AA3E7A294A52481C6A8E72BF8FF44A61DC3C94A\n    pt = 0x3B\n    ct = 0x670DDA784A6F7B8629CC487125D83D82\n\nproperty tcId3407 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x699A20B3FED880092AC54A072D0F1944E5AC618E89BF6D82D85B8149409E0A69\n    pt = 0xC7\n    ct = 0xDA945A1E4ADD229EA2628BD2CBF648C5\n\nproperty tcId3408 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF39BBB0C6D6A48FFCD19A8E4FF8EC4D18DB342984D56204A72CC79EA4D331527\n    pt = 0x13\n    ct = 0x731375F0AAAE126D698A3A35C1B59BB4\n\nproperty tcId3409 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x2CC17C155EAED98EE7C5C988A4652BBC1E548D83E355EF2B9CAAB553E33248D1\n    pt = 0xE8\n    ct = 0x9ACE37E97BF83606F87F2C37F2DD0495\n\nproperty tcId3410 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x6EC1F03FE2E913911497B56C997AA18573FADAF5D3D40B5C3AE20C122D57CA26\n    pt = 0x0F\n    ct = 0x9EA3A713894A9A60EC886F994F6E6964\n\nproperty tcId3411 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x222373119D81095C1EA6BC266B7BAC7CC5338B183491E464517F6A1CEE323D72\n    pt = 0x24\n    ct = 0xC4684B34339464E99D38883F4E218D43\n\nproperty tcId3412 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x0E16E4ED5AE9010E977FC718B0A196D05C4EC8CC03881E9498798221CEEF4F60\n    pt = 0x59\n    ct = 0x45E26A81F2A3F3B36F6A1DFD5794339E\n\nproperty tcId3413 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF7C0B2E09007A87A2C6C02F547AE13D315D9F40E8432E2883EBAAD360AE58154\n    pt = 0x28\n    ct = 0xC6EADFAE6689D612BD7720A5FFDF6917\n\nproperty tcId3414 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1E094BFD3FD9FA39528B0A041943F26A146E1B6FFA9B89DBB3F3629E248786B3\n    pt = 0xD9\n    ct = 0x5900AC3014005CD4CB5B58D464D77851\n\nproperty tcId3415 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x2D72DDE845897E8DD914977D23B9C53A3C682F5322923F609786C0DEC4B9B391\n    pt = 0xF7\n    ct = 0x6F26295442B138B9B8559BDF24559292\n\nproperty tcId3416 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD4E74B1FB2D1B8A3A96D69484A3C14D6DAADCAAE26CF0D8C69FE1FF48FFCE55B\n    pt = 0x50\n    ct = 0x8E584B2DE61B3A7408E9CA039A5A2D3F\n\nproperty tcId3417 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8D2E8DC1019C058E0120F7BD454FEB9D2A0CF49C476215D9E1B36EBE31AA8E60\n    pt = 0xF6\n    ct = 0x89EE6AD335AB813F688EA34856C6CC62\n\nproperty tcId3418 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9EF5DA6F8AFEE4EC25A39C0BF3B4661CE1E60F4A08562803F9DAF43C1F5D901C\n    pt = 0x9D\n    ct = 0xF0B50CF34D7E9846BF0C63BC22C132C9\n\nproperty tcId3419 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x163668F7B7DEF32970EB681A9D9CBA20DD3612E48272C7F4ABB2BF32A6F07EC2\n    pt = 0x67\n    ct = 0x1CD75C122ECFBE1519FCC8266FD5BFBA\n\nproperty tcId3420 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8AAC75606AE5DD234EA1D037B220F89AE202BD465CC96CDC629D3AAF663D1811\n    pt = 0xFA\n    ct = 0x62845E954748CE3D22BC3DD347FCFF34\n\nproperty tcId3421 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xE46BBE8227B15C9F7EBC941D324D61A6D4539EE8557989F5D2B05F6EC9247238\n    pt = 0xBE\n    ct = 0xB26924971CA3A0593AD2D41330728677\n\nproperty tcId3422 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD541DD6C55C182DAE396180557E1527405E64C76072491162AEF584C3A723B8E\n    pt = 0x93\n    ct = 0x0ECF1EB9E9FC1A1B1F4061A2C6D8CB5E\n\nproperty tcId3423 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x448042C7E69DE6CD177324D07AA2B074F4914CCADF38E9BA241B847BFBE6A048\n    pt = 0xF8\n    ct = 0x5B16E3D2E4EB040700929EB1F3293826\n\nproperty tcId3424 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xE2FF9378361B637A9C7AB7991232E5C4E450F3F1884B99B32B35F3E483C63F02\n    pt = 0xC1\n    ct = 0x9694370FC567B3CCA1BF96BBC77F2924\n\nproperty tcId3425 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x71F1B8D033B2763D24C824BBC5C7B90F7465312EE68499AEB13936C6820D2DB8\n    pt = 0x41\n    ct = 0xEB1742979FF0D05DDA7A9AA4BC44A3DC\n\nproperty tcId3426 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x5B5D5403DC5F79CD612CE5BE434CDCB0CEF22A431BFFA8DFD03A40496867F36F\n    pt = 0x2A\n    ct = 0xEEF7F7FBA12F09C0E000D7DF78C3B7A7\n\nproperty tcId3427 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x4B6860891760551B1796F7EA2867B5F72CD55158751CECCDD07466B358E5DC2C\n    pt = 0x37\n    ct = 0xFC4728851CB09569B9C09F0DD974FC46\n\nproperty tcId3428 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8CC592A0827016D33FAC7046043CBA05F0F6D52360A131B68BB5CF3473D493E2\n    pt = 0xE9\n    ct = 0x6C4DA849D0312D2C1969F763FB0717EE\n\nproperty tcId3429 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA822410F60C3155AA4612A0A3D69FB6ABAE9CCCE764C45F0715167D4A29F92CC\n    pt = 0x60\n    ct = 0xFD4C6C336BF8189A6578C5D18755332D\n\nproperty tcId3430 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x4887BDA1567FA98C9E6C54A4C40ED9910888F0BB2F3092A990DD15A9FAF514E4\n    pt = 0xA1\n    ct = 0x6E8E313899901A660F45BE923325B3A0\n\nproperty tcId3431 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA34A8ACD5DE1D09B06C68A4BA6B26AD8849A96D097F7234CD87D0B22A77F64A1\n    pt = 0xF0\n    ct = 0x51A1D5CBBE044436F8E30F5EB9760A99\n\nproperty tcId3432 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA91FB46F7AE95553194F72BDE2DEC9C75CBE6F5D5CDA19CAE8DFEF10D2091878\n    pt = 0x49\n    ct = 0xAD8B08BC99A15AD1F61A534E6A6FD912\n\nproperty tcId3433 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBD31DE22B62709C3ADAE6A22C110AF041692A2EFF5AFD94D6F084A5AF7A10BA1\n    pt = 0x12\n    ct = 0xEA18D84DDEACDBFE6308356BD337389E\n\nproperty tcId3434 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xAAA495706CD217702F6589F3A7DCF77796EB9AD9301DACB70679353895821116\n    pt = 0x98\n    ct = 0x570F464452070AB993FDBA098413FA2E\n\nproperty tcId3435 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA6D1836D8FC15DC6655A6AF3C9908D1A458115DE813874DA2A31BAF535F4B898\n    pt = 0xC4\n    ct = 0x52BDFE3157F7E5320FA33902FFE86D9C\n\nproperty tcId3436 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9A372C3FE4AA3D244D7A31F26BE0DC94321AE6A9D399A3024DF1D2FAE01F5D5A\n    pt = 0xA3\n    ct = 0x74785BCEB51BB5BBBF237D204DF5DC3D\n\nproperty tcId3437 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x18EDF67DCED65DB1106F9E95F6E9CA0BCCDDB9C1B0704800E79288B4348D5ED8\n    pt = 0x97\n    ct = 0x53A16352DC6466B129B98EB20E871CB2\n\nproperty tcId3438 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xCA6909990051E5A00B321DB36E9EDC37C21517D05412C27308FA6230B194F3D6\n    pt = 0x8C\n    ct = 0xFA3388CC18FE4DB12B286D78A88F43CE\n\nproperty tcId3439 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x53D9C10A1F2A520C799E17CA84A9F37B7E41C8A8366A0999E6C640B9084F8D89\n    pt = 0xA7\n    ct = 0xCD7DA687F90A8E5B5A8D752383E2A921\n\nproperty tcId3440 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x40DA3BF159117B28AF81C41329BEA2446B47BBA5AA3CFED9C9B6D0FCAC447A26\n    pt = 0xBB\n    ct = 0xB3EB65346F8509E074B4340B225748AF\n\nproperty tcId3441 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xCFD6EACDFE41A0716399AAD812A5904F43E46E94C8F33551244107CBD4454630\n    pt = 0x86\n    ct = 0xEF426FD61C094CB99E553FA242B35BC5\n\nproperty tcId3442 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFEEACB41470DF0A95D4D17413575ECBE4473501166E2B253AC69B769D1DE6EE4\n    pt = 0xD5\n    ct = 0x3B6CE49140A31C29E2B57082556D4655\n\nproperty tcId3443 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC37E571FA0B30A4C320000E46DE47D739D71E958E6D9B5BF165891FD76A2EB69\n    pt = 0x7F\n    ct = 0xCA0BD69463B6FE257339A6F352C383B7\n\nproperty tcId3444 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0xBF4D98E63641C3B0C6C87F94FFADD24E9447DAE3C8179057B992F3E87ABB9371\n    pt = 0x77\n    ct = 0x8C309F22B1A69A82FC959024D9A41055\n\nproperty tcId3445 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xB340E2147C24AA9245D32B44D81932486162078E04E8D604C3BEC77E80D00587\n    pt = 0x9F\n    ct = 0x08E763DE0E9BDB77652BE9F239E76C3A\n\nproperty tcId3446 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x64CC83AE40375F36DF9EFA92623952D9B921C193A303BA44EAF249173E75346A\n    pt = 0x2B\n    ct = 0x96249FF04AE658C774BB76543946F1A7\n\nproperty tcId3447 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xDBB7B9A24F84518CDF7BE4204966A4A82C14F1DF9D3EED53B85BAF4110D2E5A7\n    pt = 0x00\n    ct = 0xBED6EBF099BF397B9CEEE98862B02A82\n\nproperty tcId3448 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x7A07B0AA1E991FC058CF99123C3797A5088331724452A8E6C866456B88700E4E\n    pt = 0xAA\n    ct = 0x0D8879321C745BC971154AE83455FEBF\n\nproperty tcId3449 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x7F9D0A3C5A5778247C91729D9067A522DCBC440B40EABF50E2501C55AD2924F8\n    pt = 0x72\n    ct = 0x22FD8008FA349050267F2C690218E766\n\nproperty tcId3450 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x5E804B2481BC5FBE520F8039375C018037E3BBAECB2249700CCA6A7BD7AA5717\n    pt = 0x2C\n    ct = 0xA75D5317E32EC6AE64F52BDEDF66DF44\n\nproperty tcId3451 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x5C7BA7305D3B4F81FEC1C53743F8C303CB060E9F8CCE92F33653485C1AEF6DB6\n    pt = 0xD2\n    ct = 0x0BEDF4F707D2D7B9703934FDAAD3FEFD\n\nproperty tcId3452 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFB590D85CC2E6666135A6317F8464F3BE2657532F9CD34823C8F9CDD22547223\n    pt = 0xAB\n    ct = 0xB0CBDD6BF81C0518EFAC69E74A5BAEF3\n\nproperty tcId3453 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9FEDC13CB212B80795956FDE94F420032F24C8EAEAD55A5293316FADFCC633C5\n    pt = 0x77\n    ct = 0x7DD4C22110BFE0530FC441F53518F9D1\n\nproperty tcId3454 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x95AC358D0BB126E90D6F604B30129A2B7D830F479C759F3D53CF4C6F998D2117\n    pt = 0x2E\n    ct = 0xCC42D7BD7EC583B5CA43C0BB3B449144\n\nproperty tcId3455 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF7D14A80AA1CB08AEA6CF77961555983FD09F50FE37E3E99F9B521AB0742840F\n    pt = 0x0A\n    ct = 0xF5A1CC956791996B6D0273D8E206E59D\n\nproperty tcId3456 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBDD2F02BD33BE2B9B035B0D7CC3A284979AF20C8DD4FE8EE60DCEFDEF4381813\n    pt = 0xEE\n    ct = 0xECF28482AA1214D6880CB5A909D2C9BF\n\nproperty tcId3457 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xAE2F98FD07E2AAB3E0F790AA523C8B36C4063C22A60AE5FC2D2B54C8D46DF7EF\n    pt = 0xF2\n    ct = 0x4677BCCC99567C44FC8C7326AD57F4F9\n\nproperty tcId3458 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x3530B064609EA0F443877A7070CFFF076741C8374FA72268349450173167509F\n    pt = 0x0E\n    ct = 0xCF30EA838A02E16758F641463221386B\n\nproperty tcId3459 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xDFF4C1198259942F942B1F3525E34D091AFE20A84948FFD6C5ABF1887C2E7324\n    pt = 0x84\n    ct = 0xB73B2D548186990CF25BBC4133344B6E\n\nproperty tcId3460 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x4D2A4B5B3C0F1D90D51B48E72926D1FC584FCDDDCE5971B522E96D9CB10F88EA\n    pt = 0xA6\n    ct = 0x64A8CB69731FDD89376C06309DF26460\n\nproperty tcId3461 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBB3670D9C9E461428A80595F716E091B9F5DBF92228ABB1CD0DFB8596B2F69DA\n    pt = 0x9A\n    ct = 0xC552F589E5D11EFCA42051369F008785\n\nproperty tcId3462 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC4633D8B4A999ED5A664EA02DBC047ABDE3041905A0D06726D7D5C2C2651B3AA\n    pt = 0x36\n    ct = 0x0425D5CD3FE9666B0CCE3C98E280C205\n\nproperty tcId3463 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xEDDD75B989E10681C4AA0D8C6418EB981B69C894FD804D06DDE643D7F53582EB\n    pt = 0xC3\n    ct = 0x3A205767FC5EF65D8CB70E8725B836EA\n\nproperty tcId3464 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x374D48822E30895944C18518E02156238707664276D5A599BF2C390E5C840D91\n    pt = 0xE2\n    ct = 0x26C2CD7AF348C457B5D816182803EA92\n\nproperty tcId3465 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x2795AF727A53461AC2B969CE61708DEEB395DCE6FF17923AEFD57E6E0D4BF308\n    pt = 0x47\n    ct = 0x25F38BC30E500B77ABF0D5B6CB038AEB\n\nproperty tcId3466 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9689C4C49E152D4A554A69BB926A945AC737C6D191D1FA3EF65331D501689383\n    pt = 0x5A\n    ct = 0xA47247E3631B1648EF30CDA790B98B96\n\nproperty tcId3467 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1D3C20DB2B0DE8AB0F9597E1FD3448B80F571EFF3F327F6095614AAA9CAC9811\n    pt = 0xFE\n    ct = 0xF27A4B12E93D2DEB7697C85DA15B92E2\n\nproperty tcId3468 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x9F3AB283C68BC9F03EB9743F816683595FC3C8D71E738422240F473399768437\n    pt = 0x3A\n    ct = 0xC5E6F5DC654A03FE5577FBA06A22DAB7\n\nproperty tcId3469 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x74A9D44D89694D93A1B61BDD02A81E7966118603BDED187D6E1BC4B06894744A\n    pt = 0x66\n    ct = 0xCEEDBDB7D9FD68D8A77DDD7F1C77F8C1\n\nproperty tcId3470 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC3C6ECBA08443278A12A21A390802A3081BFFC3BEC67600F52FF7CA367885A98\n    pt = 0x65\n    ct = 0x2F266F5CE092FFC3F36F8614FDC20C83\n\nproperty tcId3471 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFA610A36F2ADBBE68D460C13ECEABF708F56796EA820915B63D4F3BE2FD984EE\n    pt = 0x8A\n    ct = 0x85469A8A8A8957547CEFD17E5ECFC85D\n\nproperty tcId3472 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD6611F782D10A57647974D5C656B7F7506E37535416326B219AF81BC4A8743BD\n    pt = 0x58\n    ct = 0xE64D8579FE6BB20D0AFE72488E1F3CD7\n\nproperty tcId3473 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x34FCB48486EF3B0ED9EC197F55EC38F291CC68B1F0F68DABEBBB2787E8756303\n    pt = 0xC4\n    ct = 0x936AFF79592C2759AF94E5B48B6C130C\n\nproperty tcId3474 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8CFF7404B9BE4A6E3122654AB28EB3C1A773BC4887192D02C6BB5B50FC33435C\n    pt = 0x90\n    ct = 0x799292C2391C29826E6FE4A48289A37F\n\nproperty tcId3475 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xB6FF2FBAE349BC523847288225C94A3B4B1FCD53947524929BE5198045F81F03\n    pt = 0x4C\n    ct = 0x93C4EBC6F811C7E5025BFB48439C002D\n\nproperty tcId3476 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x730721960D62212552AC8CA2F135A07E884DD33209FD5397EC4CC162D8547BDE\n    pt = 0x98\n    ct = 0x46E634181EFE6254399D78F25549D1D9\n\nproperty tcId3477 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFF2F2B2DC1C3ABFB36C5C2A67EB8FF4E9B2746D43FBE675AD19D15FA782F419C\n    pt = 0x92\n    ct = 0xEB7FC5493BB24DEE35746090C5337BC3\n\nproperty tcId3478 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x575A096AC3B257827DEE39BE44DB62C0B8C8993A0B058AA268CB9401365EE6CA\n    pt = 0x19\n    ct = 0xA36764DF638074D2DB73BA3C73311152\n\nproperty tcId3479 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF61E5A48BFC7142E210405A0063FD24005549DFC3D0CC426C9707D0E3F62EAB4\n    pt = 0x9A\n    ct = 0xEB6575503055566BFC4694FE71A7821F\n\nproperty tcId3480 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBD3D9ECC1F178756F685C94D82E322860C0080471948B1B3B7FFC7A4B0D32D8A\n    pt = 0xCE\n    ct = 0x7D98C641A46D8701F468347EAE06B222\n\nproperty tcId3481 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x44934AB4E3104CFD6BBF02FE2FBEFA40301DA33CD1383728A93D5C772CAAB2D0\n    pt = 0x67\n    ct = 0xC1A236A91FCEB0D4B673934F650B8164\n\nproperty tcId3482 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0xE0695B4D76C38ADF1699088111D2C119B8B3EADAD9D4A62CE6FEAC789BD99048\n    pt = 0x47\n    ct = 0x6F5B8A798E1C44DA653C50AF8B8E96E5\n\nproperty tcId3483 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xE37B904A857C891114209A80CDBAA6B9C372EACB9065D95FC4CE2593E81D6F14\n    pt = 0x4A\n    ct = 0x62A104566D84A2A6F0BD3759EB95B079\n\nproperty tcId3484 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x72A2CA6161F22236DDB39B345F72656ACE5FD1745F6185C839C51509444AE9B3\n    pt = 0x82\n    ct = 0x8EA924155A8F514C73C62250BD742EF4\n\nproperty tcId3485 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1F2801EE032D01D052CDE826C494EA5A5C5CAB39DC871E9B57F8E040D3982E2F\n    pt = 0x16\n    ct = 0xA238DCE4AF87DBB8D4244AEDB9A42CA1\n\nproperty tcId3486 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x70638F85B9B31FAC449DF6AA19FB451960B5EE5CEC6FF3C473AEF8C71615DF65\n    pt = 0x8A\n    ct = 0x21E951E1DEC5BC71F2FA4B0AA90C0ED0\n\nproperty tcId3487 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF64D02392D650E0865F0C18B62772F1C890798E22A1871754ACAE6176583967E\n    pt = 0x05\n    ct = 0x903545EF6A52EC670DD793F78A50B23A\n\nproperty tcId3488 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x629F665A6786B5BC6A604B9306FC7F9B9390B28DA404C1082939DB657D16E280\n    pt = 0x40\n    ct = 0x10067350D2DC09942720CEF27CB6EB9D\n\nproperty tcId3489 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x43C453F9A65CBCF3BCA65BDFC94EFB6DF647391E821ACFBB62DE786890FB8649\n    pt = 0x56\n    ct = 0x9228F1AFED0E44378E1CA3B60005DCC4\n\nproperty tcId3490 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC77DEADC06B1F73C13AADC4EB8E5571EA6BFE3F89600C1FB0EB005A4F96ADB85\n    pt = 0x54\n    ct = 0xEE488F48CC2248482856D2056385A722\n\nproperty tcId3491 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x41FF08CAFC5580110B07360491752DC4654A6CFA0023FF9B423370E48BA881EE\n    pt = 0x3F\n    ct = 0x149D9466A536B0E1C4CB5616D3626845\n\nproperty tcId3492 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x6563A6A6707CCB4CA7CA9AD828F0F94860B932502EA9E3E86E561AB219BF3EBE\n    pt = 0x36\n    ct = 0x9F934514BDCC514DDCBC77510CE6F05E\n\nproperty tcId3493 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x56D362245CA9C93774451E5193D3E54E928ABAD5F1DD0C34C1B6B19C8346458A\n    pt = 0xC2\n    ct = 0x31ACBD193BE3BDF7E4D398BA4F5CCF81\n\nproperty tcId3494 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x01BEA442DFCAE33FE752FCD7F029C0E48A2FEC00CD124FB99A777BA9D43EFADF\n    pt = 0xCA\n    ct = 0xF1F01B25DB56D08FF63B95F9A8320873\n\nproperty tcId3495 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x91B234088667FAD2E005E9791DB57B7E2E65D09442C4396A284ADBD18D58294A\n    pt = 0x51\n    ct = 0xF6501E880ACC1AD562C1589BA3DAE3B2\n\nproperty tcId3496 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD0846D465C055E3CCD45343B6BD9DC549DA718FE62842AA7C0E3D915DE176B14\n    pt = 0x3D\n    ct = 0x5F836DC239426A8AE06D5A40FA8FFE5A\n\nproperty tcId3497 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA9803E483158D203A22C48F9BABCBA8B4E25328A11BA1D310E57F0D7226EC355\n    pt = 0xD9\n    ct = 0x6AACCBB9DBD4B319E50898EB21BA7470\n\nproperty tcId3498 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x063726D0EB03547D726E9D10ACCCB3CFF01006209D7FB39C05211EC88EE37C7F\n    pt = 0x16\n    ct = 0x341CEB90D234A324941D12B2024EBC1E\n\nproperty tcId3499 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x245F675642C52A62E1AD864EDA33FA65006C8BCD3D360D5A3E54D3F0982E2A01\n    pt = 0x42\n    ct = 0x5424035C2260598A200029E0F7533CA4\n\nproperty tcId3500 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x63FEA6C364B3A9C7813472E289513ADC0631493A7C9014FFB395560F7C767E11\n    pt = 0x57\n    ct = 0x92AA71DCDE68A0DA1CDFC86DABF331AA\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_XTS.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_XTS =\n    Primitive::Symmetric::Cipher::Block::Modes::XTS {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_CTR.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR =\n    Primitive::Symmetric::Cipher::Block::Modes::CTR {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES192_CFB.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB =\n    Primitive::Symmetric::Cipher::Block::Modes::CFB {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192\n    }\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_XTS.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_XTS =\n    Primitive::Symmetric::Cipher::Block::Modes::XTS {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_CTR.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR =\n    Primitive::Symmetric::Cipher::Block::Modes::CTR {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_CFB.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB =\n    Primitive::Symmetric::Cipher::Block::Modes::CFB {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_KeyWrap.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap =\n    Primitive::Symmetric::Cipher::Block::Modes::AESKeyWrap {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES192_CTR.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CTR =\n    Primitive::Symmetric::Cipher::Block::Modes::CTR {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_CFB.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB =\n    Primitive::Symmetric::Cipher::Block::Modes::CFB {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES192_CBC.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CBC =\n    Primitive::Symmetric::Cipher::Block::Modes::CBC {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_CBC.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CBC =\n    Primitive::Symmetric::Cipher::Block::Modes::CBC {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_CBC.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC =\n    Primitive::Symmetric::Cipher::Block::Modes::CBC {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Tests\/tests.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Simon::Tests::tests where\n\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon32_64 as Simon32_64\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_72 as Simon48_72\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_96 as Simon48_96\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_96 as Simon64_96\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_128 as Simon64_128\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96 as Simon96_96\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_144 as Simon96_144\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128 as Simon128_128\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_192 as Simon128_192\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256 as Simon128_256\n\n\n\/**\n * A test vector for Simon32_64\n *\n * ```repl\n * :check t0\n * ```\n *\/\nproperty t0 = Simon32_64::encrypt k pt == ct\n  where\n    k = 0x1918_1110_0908_0100\n    pt = 0x6565_6877\n    ct = 0xc69b_e9bb\n\n\/**\n * A test vector for Simon48_72\n *\n * ```repl\n * :check t1\n * ```\n *\/\nproperty t1 = Simon48_72::encrypt k pt == ct\n  where\n    k = 0x121110_0a0908_020100\n    pt = 0x612067_6e696c\n    ct = 0xdae5ac_292cac\n\n\/**\n * A test vector for Simon48_96\n *\n * ```repl\n * :check t2\n * ```\n *\/\nproperty t2 = Simon48_96::encrypt k pt == ct\n  where\n    k = 0x1a1918_121110_0a0908_020100\n    pt = 0x726963_20646e\n    ct = 0x6e06a5_acf156\n\n\/**\n * A test vector for Simon64_96\n *\n * ```repl\n * :check t3\n * ```\n *\/\nproperty t3 = Simon64_96::encrypt k pt == ct\n  where\n    k = 0x13121110_0b0a0908_03020100\n    pt = 0x6f722067_6e696c63\n    ct = 0x5ca2e27f_111a8fc8\n\n\/**\n * A test vector for Simon64_128\n *\n * ```repl\n * :check t4\n * ```\n *\/\nproperty t4 = Simon64_128::encrypt k pt == ct\n  where\n    k = 0x1b1a1918_13121110_0b0a0908_03020100\n    pt = 0x656b696c_20646e75\n    ct = 0x44c8fc20_b9dfa07a\n\n\/**\n * A test vector for Simon96_96\n *\n * ```repl\n * :check t5\n * ```\n *\/\nproperty t5 = Simon96_96::encrypt k pt == ct\n  where\n    k = 0x0d0c0b0a0908_050403020100\n    pt = 0x2072616c6c69_702065687420\n    ct = 0x602807a462b4_69063d8ff082\n\n\/**\n * A test vector for Simon96_144\n *\n * ```repl\n * :check t6\n * ```\n *\/\nproperty t6 = Simon96_144::encrypt k pt == ct\n  where\n    k = 0x151413121110_0d0c0b0a0908_050403020100\n    pt = 0x746168742074_73756420666f\n    ct = 0xecad1c6c451e_3f59c5db1ae9\n\n\/**\n * A test vector for Simon128_128\n *\n * ```repl\n * :check t7\n * ```\n *\/\nproperty t7 = Simon128_128::encrypt k pt == ct\n  where\n    k = 0x0f0e0d0c0b0a0908_0706050403020100\n    pt = 0x6373656420737265_6c6c657661727420\n    ct = 0x49681b1e1e54fe3f_65aa832af84e0bbc\n\n\/**\n * A test vector for Simon128_128\n *\n * ```repl\n * :check t8\n * ```\n *\/\nproperty t8 = Simon128_192::encrypt k pt == ct\n  where\n    k = 0x1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n    pt = 0x206572656874206e_6568772065626972\n    ct = 0xc4ac61effcdc0d4f_6c9c8d6e2597b85b\n\n\/**\n * A test vector for Simon128_256\n *\n * ```repl\n * :check t9\n * ```\n *\/\nproperty t9 = Simon128_256::encrypt k pt == ct\n  where\n    k = 0x1f1e1d1c1b1a1918_1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n    pt = 0x74206e69206d6f6f_6d69732061207369\n    ct = 0x8d2b5579afc8a3a0_3bf72a87efe7b868\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon96_96.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 48\n    type m = 2\n    type T = 52\n    type j = 2\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon96_144.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_144 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 48\n    type m = 3\n    type T = 54\n    type j = 3\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon64_128.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_128 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 32\n    type m = 4\n    type T = 44\n    type j = 3\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon48_72.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_72 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 24\n    type m = 3\n    type T = 36\n    type j = 0\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon128_128.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 64\n    type m = 2\n    type T = 68\n    type j = 2\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon64_96.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 32\n    type m = 3\n    type T = 42\n    type j = 2\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon128_256.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 64\n    type m = 4\n    type T = 72\n    type j = 4\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon128_192.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_192 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 64\n    type m = 3\n    type T = 69\n    type j = 3\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon32_64.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon32_64 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 16\n    type m = 4\n    type T = 32\n    type j = 0\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon48_96.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 24\n    type m = 4\n    type T = 36\n    type j = 1\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Tests\/tests.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Test vectors for Speck.\n * These test vectors were taken Appendix C of:\n *\n * [SPECK]: Beaulieu, Shors, Smith, Treatman-Clark, Weeks, Wingers\n *          The Simon and Speck Families of Lightweight Block Ciphers\n *          19 June 2013\n * @see https:\/\/eprint.iacr.org\/2013\/404.pdf\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Tests::tests where\n\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck32_64 as Speck32_64\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_72 as Speck48_72\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_96 as Speck48_96\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_96 as Speck64_96\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_128 as Speck64_128\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_96 as Speck96_96\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_144 as Speck96_144\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_128 as Speck128_128\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_192 as Speck128_192\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_256 as Speck128_256\n\n\/**\n * Test vector for Speck32_64\n *\n * ```repl\n * :prove t0\n * ```\n *\/\nproperty t0 = Speck32_64::encrypt k p == c\n    where\n        k = 0x1918_1110_0908_0100\n        p = 0x6574_694c\n        c = 0xa868_42f2\n\n\/**\n * Test vector for Speck48_72\n *\n * ```repl\n * :prove t1\n * ```\n *\/\nproperty t1 = Speck48_72::encrypt k p == c\n    where\n        k = 0x121110_0a0908_020100\n        p = 0x20796c_6c6172\n        c = 0xc049a5_385adc\n\n\/**\n * Test vector for Speck48_96\n *\n * ```repl\n * :prove t2\n * ```\n *\/\nproperty t2 = Speck48_96::encrypt k p == c\n    where\n        k = 0x1a1918_121110_0a0908_020100\n        p = 0x6d2073_696874\n        c = 0x735e10_b6445d\n\n\/**\n * Test vector for Speck64_96\n *\n * ```repl\n * :prove t3\n * ```\n *\/\nproperty t3 = Speck64_96::encrypt k p == c\n    where\n        k = 0x13121110_0b0a0908_03020100\n        p = 0x74614620_736e6165\n        c = 0x9f7952ec_4175946c\n\n\/**\n * Test vector for Speck64_128\n *\n * ```repl\n * :prove t4\n * ```\n *\/\nproperty t4 = Speck64_128::encrypt k p == c\n    where\n        k = 0x1b1a1918_13121110_0b0a0908_03020100\n        p = 0x3b726574_7475432d\n        c = 0x8c6fa548_454e028b\n\n\/**\n * Test vector for Speck96_96\n *\n * ```repl\n * :prove t5\n * ```\n *\/\nproperty t5 = Speck96_96::encrypt k p == c\n    where\n        k = 0x0d0c0b0a0908_050403020100\n        p = 0x65776f68202c_656761737520\n        c = 0x9e4d09ab7178_62bdde8f79aa\n\n\/**\n * Test vector for Speck96_144\n *\n * ```repl\n * :prove t6\n * ```\n *\/\nproperty t6 = Speck96_144::encrypt k p == c\n    where\n        k = 0x151413121110_0d0c0b0a0908_050403020100\n        p = 0x656d6974206e_69202c726576\n        c = 0x2bf31072228a_7ae440252ee6\n\n\/**\n * Test vector for Speck128_128\n *\n * ```repl\n * :prove t7\n * ```\n *\/\nproperty t7 = Speck128_128::encrypt k p == c\n    where\n        k = 0x0f0e0d0c0b0a0908_0706050403020100\n        p = 0x6c61766975716520_7469206564616d20\n        c = 0xa65d985179783265_7860fedf5c570d18\n\n\/**\n * Test vector for Speck128_192\n *\n * ```repl\n * :prove t8\n * ```\n *\/\nproperty t8 = Speck128_192::encrypt k p == c\n    where\n        k = 0x1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n        p = 0x7261482066656968_43206f7420746e65\n        c = 0x1be4cf3a13135566_f9bc185de03c1886\n\n\/**\n * Test vector for Speck128_256\n *\n * ```repl\n * :prove t9\n * ```\n *\/\nproperty t9 = Speck128_256::encrypt k p == c\n    where\n        k = 0x1f1e1d1c1b1a1918_1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n        p = 0x65736f6874206e49_202e72656e6f6f70\n        c = 0x4109010405c0f53e_4eeeb48d9c188f43\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck48_96.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_96 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 24\ntype m = 4\ntype T = 23\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck32_64.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck32_64 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 16\ntype m = 4\ntype T = 22\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck128_128.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_128 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 64\ntype m = 2\ntype T = 32\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck64_96.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_96 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 32\ntype m = 3\ntype T = 26\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck128_256.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_256 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 64\ntype m = 4\ntype T = 34\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck96_144.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_144 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 48\ntype m = 3\ntype T = 29\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck64_128.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_128 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 32\ntype m = 4\ntype T = 27\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck96_96.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_96 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 48\ntype m = 2\ntype T = 28\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck48_72.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_72 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 24\ntype m = 3\ntype T = 22\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck128_192.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_192 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 64\ntype m = 3\ntype T = 33\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Verifications\/AES256.saw","filetype":"saw","content":"\/**\n * Cryptol AES property verification.\n *\n * This module efficiently checks that decrypt is the inverse of encrypt.\n *\n * @copyright Galois Inc.\n * @author Eric Mertens <emertens@galois.com>\n *\/\n\nimport \"..\/Instantiations\/AES256.cry\";\nimport \"..\/..\/..\/..\/..\/..\/Common\/GF28.cry\" as GF28;\n\nlet ss0 = cryptol_ss ();\n\nprint \"Verifying that cipher unrolls\";\nunroll_cipher <- prove_print\n    (w4_unint_z3 [\"AddRoundKey\", \"MixColumns\", \"SubBytes\", \"ShiftRows\"])\n    {{ \\w pt -> cipher w pt ==\n    (stateToMsg (AddRoundKey (w@14) (ShiftRows (SubBytes (t 13 (t 12 (t 11 (t 10 (t 9 (t 8 (t 7 (t 6 (t 5 (t 4 (t 3 (t 2 (t 1 (AddRoundKey (w@0) (msgToState pt))))))))))))))))))\n        where\n        t i state = AddRoundKey (w@i) (MixColumns (ShiftRows (SubBytes state))))\n    }};\n\nprint \"Verifying that invCipher unrolls\";\nunroll_invCipher <- prove_print\n    (w4_unint_z3 [\"AddRoundKey\", \"InvMixColumns\", \"InvSubBytes\", \"InvShiftRows\"])\n    {{ \\w ct -> invCipher w ct ==\n    (stateToMsg (AddRoundKey (w@0) (InvSubBytes (InvShiftRows (t 1 (t 2 (t 3 (t 4 (t 5 (t 6 (t 7 (t 8 (t 9 (t 10 (t 11 (t 12 (t 13 (AddRoundKey (w@14) ( msgToState ct))))))))))))))))))\n        where\n        t i state = InvMixColumns (AddRoundKey (w@i) (InvSubBytes (InvShiftRows state))))\n    }};\n\ninclude \"Common.saw\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Tests\/AES128.cry","filetype":"cry","content":"\/**\n * Test vectors for AES128.\n * These are drawn from the NIST Cryptographic Standards and Guidelines\n * project.\n *\n * [AES128]: AES Core 128. Block Cipher Modes of Operation Electronic Codebook\n *    (ECB).\n *    @see https:\/\/csrc.nist.rip\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/AES_Core128.pdf\n *\n *  @copyright Galois Inc.\n *  @author Nichole Schimanski <nls@galois.com>\n *  @author Marcella Hastings <marcella@galois.com>\n *  www.cryptol.net\n *\/\nmodule Primitive::Symmetric::Cipher::Block::AES::Tests::AES128 where\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128 as AES128\n\n\/**\n * ```repl\n * :prove aes128TestVectorsPass\n * ```\n *\/\nproperty aes128TestVectorsPass = and encryptions \/\\ and decryptions\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        pts = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        expected_cts = [\n            0x3ad77bb40d7a3660a89ecaf32466ef97,\n            0xf5d3d58503b9699de785895a96fdbaaf,\n            0x43b1cd7f598ece23881b00e3ed030688,\n            0x7b0c785e27e8ad3f8223207104725dd4\n        ]\n        encryptions = [ AES128::encrypt key msg == ct | msg <- pts | ct <- expected_cts ]\n        decryptions = [ AES128::decrypt key ct == pt | pt <- pts | ct <- expected_cts ]\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Tests\/AES256.cry","filetype":"cry","content":"\/**\n * Test vectors for AES256\n * These are drawn from the NIST Cryptographic Standards and Guidelines\n * project.\n *\n * [AES256]: AES Core 256. Block Cipher Modes of Operation Electronic Codebook\n *    (ECB). https:\/\/csrc.nist.rip\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/AES_Core256.pdf\n *\n *  @copyright Galois Inc.\n *  @author Nichole Schimanski <nls@galois.com>\n *  @author Marcella Hastings <marcella@galois.com>\n *  www.cryptol.net\n *\/\nmodule Primitive::Symmetric::Cipher::Block::AES::Tests::AES256 where\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 as AES256\n\n\/**\n * ```repl\n * :prove aes256TestVectorsPass\n * ```\n *\/\nproperty aes256TestVectorsPass = and encryptions \/\\ and decryptions\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        pts = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        expected_cts = [\n            0xf3eed1bdb5d2a03c064b5a7e3db181f8,\n            0x591ccb10d410ed26dc5ba74a31362870,\n            0xb6ed21b99ca6f4f9f153e7b1beafed1d,\n            0x23304b7a39f9f3ff067d8d8f9e24ecc7\n        ]\n        encryptions = [ AES256::encrypt key msg == ct | msg <- pts | ct <- expected_cts ]\n        decryptions = [ AES256::decrypt key ct == pt | pt <- pts | ct <- expected_cts ]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Tests\/AES192.cry","filetype":"cry","content":"\/**\n * Test vectors for AES192\n * These are drawn from the NIST Cryptographic Standards and Guidelines\n * project.\n *\n * [AES192]: AES Core 192. Block Cipher Modes of Operation Electronic Codebook\n *    (ECB).\n *    @see https:\/\/csrc.nist.rip\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/AES_Core192.pdf\n *\n *  @copyright Galois Inc.\n *  @author Nichole Schimanski <nls@galois.com>\n *  @author Marcella Hastings <marcella@galois.com>\n *  www.cryptol.net\n *\/\nmodule Primitive::Symmetric::Cipher::Block::AES::Tests::AES192 where\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192 as AES192\n\n\/**\n * ```repl\n * :prove aes192TestVectorsPass\n * ```\n *\/\nproperty aes192TestVectorsPass = and encryptions \/\\ and decryptions\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        pts = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        expected_cts = [\n            0xbd334f1d6e45f25ff712a214571fa5cc,\n            0x974104846d0ad3ad7734ecb3ecee4eef,\n            0xef7afd2270e2e60adce0ba2face6444e,\n            0x9a4b41ba738d6c72fb16691603c18e0e\n        ]\n        encryptions = [ AES192::encrypt key msg == ct | msg <- pts | ct <- expected_cts ]\n        decryptions = [ AES192::decrypt key ct == pt | pt <- pts | ct <- expected_cts ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES128.cry","filetype":"cry","content":"\/**\n * AES128.\n * @copyright Galois Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128 =\n    Primitive::Symmetric::Cipher::Block::AES::Specification where\n    type KeySize' = 128\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES256.cry","filetype":"cry","content":"\/**\n * AES256.\n * @copyright Galois Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 =\n    Primitive::Symmetric::Cipher::Block::AES::Specification where\n    type KeySize' = 256\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES192.cry","filetype":"cry","content":"\/**\n * AES192.\n * @copyright Galois Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192 =\n    Primitive::Symmetric::Cipher::Block::AES::Specification where\n    type KeySize' = 192\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Specification.cry","filetype":"cry","content":"\/**\n * Implementation of Keyed-Hash Message Authentication Code (HMAC)\n * as specified in [FIPS-198-1], Section 4.\n *\n * @copyright Galois, Inc.\n * @author Eric Mertens <emertens@galois.com>\n * @author Alex J Malozemoff <amaloz@galois.com>\n * www.cryptol.net\n *\n * For discussion on security considerations while using HMAC, please see\n * [NIST-SP-800-107]. This has important security notes about choosing key\n * lengths, truncation, and the overall security strength of the algorithm.\n *\n * Sources:\n *\n * [FIPS-198-1]: National Institute of Standards and Technology.\n *     The Keyed-Hash Message Authentication Code (HMAC).\n *     (Department of Commerce, Washington, D.C.),\n *     Federal Information Processing Standards Publication (FIPS) NIST FIPS 198-1.\n *     July 2008.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.198-1\n *\n * [NIST-SP-800-107]: Quynh Dang. Recommendations for Applications Using\n *     Approved Hash Algorithms. NIST Special Publication 800-107 Revision 1.\n *     August 2012.\n *     @see https:\/\/doi.org\/10.6028\/NIST.SP.800-107r1\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Specification where\n\nparameter\n  \/** Block size (in bytes) of the input to the Approved hash function. *\/\n  type B : #\n\n  \/** Block size (in bytes) of the output of the Approved hash function. *\/\n  type L : #\n\n  type constraint (fin B, L <= B, width (8 * L) <= B, width (8 * (B + L)) <= B)\n\n  \/** An Approved hash function. *\/\n  H : {T} (width (8 * T) <= B) => [T][8] -> [L][8]\n\n\/**\n * Compute a pseudorandom block using the HMAC construction as\n * specified in [FIPS-198-1], Section 4.\n *\n * # Type parameters\n * - k: Length of secret key (in bytes)\n * - n: Length of input text (in bytes)\n *\n * # Parameters\n * - K: Secret key shared between the originator and the intended receiver(s).\n * - text: The data on which the HMAC is calculated. text does *not* include\n *         the padded key. The length of text is n bits, where 0 \u2264 n < 2^B - 8B.\n *\/\nhmac : {k, n} (width (8 * k) <= B, width (8 * (n + B)) <= B) => [k][8] -> [n][8] -> [L][8]\nhmac K text = H ((K\u2080 ^ opad) # H ((K\u2080 ^ ipad) # text)) where\n  \/* K\u2080: The key K after any necessary pre-processing to form a B byte key. *\/\n  K\u2080 = expand_key K\n\n\/**\n * Compute a truncated HMAC output.\n *\n * Truncation is implemented as defined in [FIPS-198-1], Section 5 and\n * [NIST-SP-800-107], Section 5.1.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: If collision resistance is required, \u03bb needs to be at least\n * twice the required collision resistence strength s (in bits) for the\n * truncated message digest (i.e., \u03bb \u2265 2s). See [NIST-SP-800-107], Section 5.1\n * for more details.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: If used within a digital signature, \u03bb needs to be at least\n * twice the desired security strength (in bits) required for the digital\n * signature. See [NIST-SP-800-107], Section 5.2.2 for more details.\n *\n * # Type parameters\n * - \u03bb: Length of truncated output (in bytes). \u03bb must be less than L\n *      ([NIST-SP-800-107], Section 5.1) and no less than 32 bits\n *      ([NIST-SP-800-107], Section 5.3.4).\n * - k: Length of secret key (in bytes)\n * - n: Length of input text (in bytes)\n *\n * # Parameters\n * - K: Secret key shared between the originator and the intended receiver(s).\n * - text: The data on which the HMAC is calculated. text does *not* include\n *         the padded key. The length of text is n bits, where 0 \u2264 n < 2^B - 8B.\n  *\/\nhmac_truncate : {\u03bb, k, n} (\u03bb < L, \u03bb >= 4, width (8 * k) <= B, width (8 * (n + B)) <= B)\n  => [k][8] -> [n][8] -> [\u03bb][8]\nhmac_truncate K text = take output where\n  output = hmac K text\n\nprivate\n  \/** Inner pad; the byte x\u201836\u2019 repeated B times. *\/\n  ipad : [B][8]\n  ipad = repeat 0x36\n\n  \/** Outer pad; the byte x\u20185c\u2019 repeated B times. *\/\n  opad : [B][8]\n  opad = repeat 0x5c\n\n  \/** Key expansion as defined in [FIPS-198-1], Section 3. *\/\n  expand_key : {k} (width (8 * k) <= B) => [k][8] -> [B][8]\n  expand_key K\n    | k <= B => K # zero\n    \/*\n     * When an application uses a K longer than B-bytes, then it shall first\n     * hash the K using H and then use the resultant L-byte string as the key\n     * K\u2080.\n     *\/\n    | k > B => H K # zero\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA2_512.cry","filetype":"cry","content":"\/**\n * Test vectors for HMAC-SHA-512 found in [RFC-4868], Section 2.7.\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\n * Sources:\n *\n * [RFC-4868] S. Kelly, S. Frankel. Using HMAC-SHA-256, HMAC-SHA-384, and\n *     HMAC-SHA-512 with IPsec. Request for Comments: 4868. May 2007.\n *     @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc4868\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA2_512 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA512 as H512\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_512 : [512]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params =\n  H512::hmac params.Key params.Data == split params.PRF_HMAC_SHA_512\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_1\n * ```\n *\/\nproperty rfc_4868_2_7_1_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_512 =\n      0x87aa7cdea5ef619d4ff0b4241a1d6cb0 #\n      0x2379f4e2ce4ec2787ad0b30545e17cde #\n      0xdaa833b7d6b8a702038b274eaea3f4e4 #\n      0xbe9d914eeb61f1702e696c203a126854\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_2\n * ```\n *\/\nproperty rfc_4868_2_7_1_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_512 =\n      0x164b7a7bfcf819e2e395fbe73b56e0a3 #\n      0x87bd64222e831fd610270cd7ea250554 #\n      0x9758bf75c05a994a6d034f65f8f0e6fd #\n      0xcaeab1a34d4a6b4b636e070a38bce737\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_3\n * ```\n *\/\nproperty rfc_4868_2_7_1_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_512 =\n      0xfa73b0089d56a284efb0f0756c890be9 #\n      0xb1b5dbdd8ee81a3655f83e33b2279d39 #\n      0xbf3e848279a722c806b485a47e67c807 #\n      0xb946a337bee8942674278859e13292fb\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_4\n * ```\n *\/\nproperty rfc_4868_2_7_1_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_512 =\n      0xb0ba465637458c6990e5a8c5f61d4af7 #\n      0xe576d97ff94b872de76f8050361ee3db #\n      0xa91ca5c11aa25eb4d679275cc5788063 #\n      0xa5f19741120c4f2de2adebeb10a298dd\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_5\n * ```\n *\/\nproperty rfc_4868_2_7_1_5 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_512 =\n      0x80b24263c7c1a3ebb71493c1dd7be8b4 #\n      0x9b46d1f41b4aeec1121b013783f8f352 #\n      0x6b56d037e05f2598bd0fd2215d6a1e52 #\n      0x95e64f73f63f0aec8b915a985d786598\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_6\n * ```\n *\/\nproperty rfc_4868_2_7_1_6 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.\"\n  , PRF_HMAC_SHA_512 =\n      0xe37b6a775dc87dbaa4dfa9f96e5e3ffd #\n      0xdebd71f8867289865df5a32d20cdc944 #\n      0xb6022cac3c4982b10d5eeb55c3e4de15 #\n      0x134676fb6de0446065c97440fa8c6a58\n  }\n\ntype AuthTest512 T =\n  { Key : [64][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_512 : [512]\n  , HMAC_SHA_512_256 : [256]\n  }\n\nsha2_512_auth_test : {T} (T < 256) => AuthTest512 T -> Bit\nsha2_512_auth_test params =\n  H512::hmac params.Key params.Data == split params.PRF_HMAC_SHA_512 \/\\\n  H512::hmac_truncate params.Key params.Data == split params.HMAC_SHA_512_256\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_3_1\n * ```\n *\/\nproperty rfc_4868_2_7_2_3_1 = sha2_512_auth_test\n  { Key = repeat`{64} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_512 =\n      0x637edc6e01dce7e6742a99451aae82df #\n      0x23da3e92439e590e43e761b33e910fb8 #\n      0xac2878ebd5803f6f0b61dbce5e251ff8 #\n      0x789a4722c1be65aea45fd464e89f8f5b\n  , HMAC_SHA_512_256 =\n      0x637edc6e01dce7e6742a99451aae82df #\n      0x23da3e92439e590e43e761b33e910fb8\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_3_2\n * ```\n *\/\nproperty rfc_4868_2_7_2_3_2 = sha2_512_auth_test\n  { Key = \"JefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_512 =\n      0xcb370917ae8a7ce28cfd1d8f4705d614 #\n      0x1c173b2a9362c15df235dfb251b15454 #\n      0x6aa334ae9fb9afc2184932d8695e397b #\n      0xfa0ffb93466cfcceaae38c833b7dba38\n  , HMAC_SHA_512_256 =\n      0xcb370917ae8a7ce28cfd1d8f4705d614 #\n      0x1c173b2a9362c15df235dfb251b15454\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_3_3\n * ```\n *\/\nproperty rfc_4868_2_7_2_3_3 = sha2_512_auth_test\n  { Key = repeat`{64} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_512 =\n      0x2ee7acd783624ca9398710f3ee05ae41 #\n      0xb9f9b0510c87e49e586cc9bf961733d8 #\n      0x623c7b55cebefccf02d5581acc1c9d5f #\n      0xb1ff68a1de45509fbe4da9a433922655\n  , HMAC_SHA_512_256 =\n      0x2ee7acd783624ca9398710f3ee05ae41 #\n      0xb9f9b0510c87e49e586cc9bf961733d8\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_3_4\n * ```\n *\/\nproperty rfc_4868_2_7_2_3_4 = sha2_512_auth_test\n  { Key =\n      \/\/ Corrected example from RFC\n      split 0x0102030405060708090a0b0c0d0e0f10 #\n      split 0x1112131415161718191a1b1c1d1e1f20 #\n      split 0x2122232425262728292a2b2c2d2e2f30 #\n      split 0x3132333435363738393a3b3c3d3e3f40\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_512 =\n      0x5e6688e5a3daec826ca32eaea224eff5 #\n      0xe700628947470e13ad01302561bab108 #\n      0xb8c48cbc6b807dcfbd850521a685babc #\n      0x7eae4a2a2e660dc0e86b931d65503fd2\n  , HMAC_SHA_512_256 =\n      0x5e6688e5a3daec826ca32eaea224eff5 #\n      0xe700628947470e13ad01302561bab108\n  }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA1.cry","filetype":"cry","content":"\/**\n * Test vectors for HMAC-SHA-1 found in [RFC-2202], Section 3.\n *\n * @copyright Galois, Inc.\n * @author Eric Mertens <emertens@galois.com>\n *\n * Sources:\n *\n * [RFC-2202] P. Cheng, R. Glenn. Test Cases for HMAC-MD5 and HMAC-SHA-1.\n *     Request for Comments: 2202. September 1997.\n *     @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc2202\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA1 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_1 : [160]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params = hmac params.Key params.Data == split params.PRF_HMAC_SHA_1\n\ntype AuthTest T =\n  { Key : [20][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_1 : [160]\n  , HMAC_SHA_1_96 : [96]\n  }\n\nsha1_auth_test : {T} (T < 256) => AuthTest T -> Bit\nsha1_auth_test params =\n  hmac params.Key params.Data == split params.PRF_HMAC_SHA_1 \/\\\n  hmac_truncate params.Key params.Data == split params.HMAC_SHA_1_96\n\n\/**\n * ```repl\n * :check rfc_2202_3_1\n * ```\n *\/\nproperty rfc_2202_3_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_1 = 0xb617318655057264e28bc0b6fb378c8ef146be00\n  }\n\n\/**\n * ```repl\n * :check rfc_2202_3_2\n * ```\n *\/\nproperty rfc_2202_3_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_1 = 0xeffcdf6ae5eb2fa2d27416d5f184df9c259a7c79\n  }\n\n\/**\n * ```repl\n * :check rfc_2202_3_3\n * ```\n *\/\nproperty rfc_2202_3_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_1 = 0x125d7342b9ac11cd91a39af48aa17b4f63f175d3\n  }\n\n\/**\n * ```repl\n * :check rfc_2202_3_4\n * ```\n *\/\nproperty rfc_2202_3_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_1 = 0x4c9007f4026250c6bc8414f9bf50c86c2d7235da\n  }\n\n\/**\n * ```repl\n * :check rfc_2202_3_5\n * ```\n *\/\nproperty rfc_2202_3_5 = sha1_auth_test\n  { Key = repeat`{20} 0x0c\n  , Data = \"Test With Truncation\"\n  , PRF_HMAC_SHA_1 = 0x4c1a03424b55e07fe7f27be1d58bb9324a9a5a04\n  , HMAC_SHA_1_96 = 0x4c1a03424b55e07fe7f27be1\n  }\n\n\/**\n * ```repl\n * :check rfc_2202_3_6\n * ```\n *\/\nproperty rfc_2202_3_6 = prf_test\n  { Key = repeat`{80} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_1 = 0xaa4ae5e15272d00e95705637ce8a3b55ed402112\n  }\n\n\/**\n * ```repl\n * :check rfc_2202_3_7\n * ```\n *\/\nproperty rfc_2202_3_7 = prf_test\n  { Key = repeat`{80} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data\"\n  , PRF_HMAC_SHA_1 = 0xe8e99d0f45237d786d6bbaa7965c7808bbff1a91\n  }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA2_256.cry","filetype":"cry","content":"\/**\n * Test vectors for HMAC-SHA-256 found in [RFC-4868], Section 2.7.\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\n * Sources:\n *\n * [RFC-4868] S. Kelly, S. Frankel. Using HMAC-SHA-256, HMAC-SHA-384, and\n *     HMAC-SHA-512 with IPsec. Request for Comments: 4868. May 2007.\n *     @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc4868\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA2_256 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256 as H256\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_256 : [256]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params =\n  H256::hmac params.Key params.Data == split params.PRF_HMAC_SHA_256\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_1\n * ```\n *\/\nproperty rfc_4868_2_7_1_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_256 =\n      0xb0344c61d8db38535ca8afceaf0bf12b #\n      0x881dc200c9833da726e9376c2e32cff7\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_2\n * ```\n *\/\nproperty rfc_4868_2_7_1_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_256 =\n      0x5bdcc146bf60754e6a042426089575c7 #\n      0x5a003f089d2739839dec58b964ec3843\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_3\n * ```\n *\/\nproperty rfc_4868_2_7_1_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_256 =\n      0x773ea91e36800e46854db8ebd09181a7 #\n      0x2959098b3ef8c122d9635514ced565fe\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_4\n * ```\n *\/\nproperty rfc_4868_2_7_1_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_256 =\n      0x82558a389a443c0ea4cc819899f2083a #\n      0x85f0faa3e578f8077a2e3ff46729665b\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_5\n * ```\n *\/\nproperty rfc_4868_2_7_1_5 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_256 =\n      0x60e431591ee0b67f0d8a26aacbf5b77f #\n      0x8e0bc6213728c5140546040f0ee37f54\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_6\n * ```\n *\/\nproperty rfc_4868_2_7_1_6 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.\"\n  , PRF_HMAC_SHA_256 =\n      0x9b09ffa71b942fcb27635fbcd5b0e944 #\n      0xbfdc63644f0713938a7f51535c3a35e2\n  }\n\ntype AuthTest256 T =\n  { Key : [32][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_256 : [256]\n  , HMAC_SHA_256_128 : [128]\n  }\n\nsha2_256_auth_test : {T} (T < 256) => AuthTest256 T -> Bit\nsha2_256_auth_test params =\n  H256::hmac params.Key params.Data == split params.PRF_HMAC_SHA_256 \/\\\n  H256::hmac_truncate params.Key params.Data == split params.HMAC_SHA_256_128\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_1_1\n * ```\n *\/\nproperty rfc_4868_2_7_2_1_1 = sha2_256_auth_test\n  { Key = repeat`{32} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_256 =\n      0x198a607eb44bfbc69903a0f1cf2bbdc5 #\n      0xba0aa3f3d9ae3c1c7a3b1696a0b68cf7\n  , HMAC_SHA_256_128 =\n      0x198a607eb44bfbc69903a0f1cf2bbdc5\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_1_2\n * ```\n *\/\nproperty rfc_4868_2_7_2_1_2 = sha2_256_auth_test\n  { Key = \"JefeJefeJefeJefeJefeJefeJefeJefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_256 =\n      0x167f928588c5cc2eef8e3093caa0e87c #\n      0x9ff566a14794aa61648d81621a2a40c6\n  , HMAC_SHA_256_128 =\n      0x167f928588c5cc2eef8e3093caa0e87c\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_1_3\n * ```\n *\/\nproperty rfc_4868_2_7_2_1_3 = sha2_256_auth_test\n   { Key = repeat`{32} 0xaa\n   , Data = repeat`{50} 0xdd\n   , PRF_HMAC_SHA_256 =\n      0xcdcb1220d1ecccea91e53aba3092f962 #\n      0xe549fe6ce9ed7fdc43191fbde45c30b0\n   , HMAC_SHA_256_128 =\n      0xcdcb1220d1ecccea91e53aba3092f962\n   }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_1_4\n * ```\n *\/\nproperty rfc_4868_2_7_2_1_4 = sha2_256_auth_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10 #\n          split 0x1112131415161718191a1b1c1d1e1f20\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_256 =\n      0x372efcf9b40b35c2115b1346903d2ef4 #\n      0x2fced46f0846e7257bb156d3d7b30d3f\n  , HMAC_SHA_256_128 =\n      0x372efcf9b40b35c2115b1346903d2ef4\n  }\n\ntype AuthTest384 T =\n  { Key : [48][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_384 : [384]\n  , HMAC_SHA_384_192 : [192]\n  }\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA2_384.cry","filetype":"cry","content":"\/**\n * Test vectors for HMAC-SHA-384 found in [RFC-4868], Section 2.7.\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\n * Sources:\n *\n * [RFC-4868] S. Kelly, S. Frankel. Using HMAC-SHA-256, HMAC-SHA-384, and\n *     HMAC-SHA-512 with IPsec. Request for Comments: 4868. May 2007.\n *     @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc4868\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA2_384 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384 as H384\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_384 : [384]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params =\n  H384::hmac params.Key params.Data == split params.PRF_HMAC_SHA_384\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_1\n * ```\n *\/\nproperty rfc_4868_2_7_1_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_384 =\n      0xafd03944d84895626b0825f4ab46907f #\n      0x15f9dadbe4101ec682aa034c7cebc59c #\n      0xfaea9ea9076ede7f4af152e8b2fa9cb6\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_2\n * ```\n *\/\nproperty rfc_4868_2_7_1_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_384 =\n      0xaf45d2e376484031617f78d2b58a6b1b #\n      0x9c7ef464f5a01b47e42ec3736322445e #\n      0x8e2240ca5e69e2c78b3239ecfab21649\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_3\n * ```\n *\/\nproperty rfc_4868_2_7_1_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_384 =\n      0x88062608d3e6ad8a0aa2ace014c8a86f #\n      0x0aa635d947ac9febe83ef4e55966144b #\n      0x2a5ab39dc13814b94e3ab6e101a34f27\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_4\n * ```\n *\/\nproperty rfc_4868_2_7_1_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_384 =\n      0x3e8a69b7783c25851933ab6290af6ca7 #\n      0x7a9981480850009cc5577c6e1f573b4e #\n      0x6801dd23c4a7d679ccf8a386c674cffb\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_5\n * ```\n *\/\nproperty rfc_4868_2_7_1_5 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_384 =\n      0x4ece084485813e9088d2c63a041bc5b4 #\n      0x4f9ef1012a2b588f3cd11f05033ac4c6 #\n      0x0c2ef6ab4030fe8296248df163f44952\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_6\n * ```\n *\/\nproperty rfc_4868_2_7_1_6 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.\"\n  , PRF_HMAC_SHA_384 =\n      0x6617178e941f020d351e2f254e8fd32c #\n      0x602420feb0b8fb9adccebb82461e99c5 #\n      0xa678cc31e799176d3860e6110c46523e\n  }\n\ntype AuthTest384 T =\n  { Key : [48][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_384 : [384]\n  , HMAC_SHA_384_192 : [192]\n  }\n\nsha2_384_auth_test : {T} (T < 256) => AuthTest384 T -> Bit\nsha2_384_auth_test params =\n  H384::hmac params.Key params.Data == split params.PRF_HMAC_SHA_384 \/\\\n  H384::hmac_truncate params.Key params.Data == split params.HMAC_SHA_384_192\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_2_1\n * ```\n *\/\nproperty rfc_4868_2_7_2_2_1 = sha2_384_auth_test\n  { Key = repeat`{48} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_384 =\n      0xb6a8d5636f5c6a7224f9977dcf7ee6c7 #\n      0xfb6d0c48cbdee9737a959796489bddbc #\n      0x4c5df61d5b3297b4fb68dab9f1b582c2\n  , HMAC_SHA_384_192 =\n      0xb6a8d5636f5c6a7224f9977dcf7ee6c7 #\n      0xfb6d0c48cbdee973\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_2_2\n * ```\n *\/\nproperty rfc_4868_2_7_2_2_2 = sha2_384_auth_test\n  { Key = \"JefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_384 =\n      0x2c7353974f1842fd66d53c452ca42122 #\n      0xb28c0b594cfb184da86a368e9b8e16f5 #\n      0x349524ca4e82400cbde0686d403371c9\n  , HMAC_SHA_384_192 =\n      0x2c7353974f1842fd66d53c452ca42122 #\n      0xb28c0b594cfb184d\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_2_3\n * ```\n *\/\nproperty rfc_4868_2_7_2_2_3 = sha2_384_auth_test\n  { Key = repeat`{48} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_384 =\n      0x809f439be00274321d4a538652164b53 #\n      0x554a508184a0c3160353e3428597003d #\n      0x35914a18770f9443987054944b7c4b4a\n  , HMAC_SHA_384_192 =\n      0x809f439be00274321d4a538652164b53 #\n      0x554a508184a0c316\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_2_4\n * ```\n *\/\nproperty rfc_4868_2_7_2_2_4 = sha2_384_auth_test\n  { Key =\n      split 0x0102030405060708090a0b0c0d0e0f10 #\n      split 0x1112131415161718191a1b1c1d1e1f20 #\n      split 0x0a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_384 =\n      0x5b540085c6e6358096532b2493609ed1 #\n      0xcb298f774f87bb5c2ebf182c83cc7428 #\n      0x707fb92eab2536a5812258228bc96687\n  , HMAC_SHA_384_192 =\n      0x5b540085c6e6358096532b2493609ed1 #\n      0xcb298f774f87bb5c\n  }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA512.cry","filetype":"cry","content":"\/**\n * HMAC instantiated with SHA2-512 as defined in [RFC-4868].\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\n * [RFC-4868] @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc4868\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA512 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA2::Instantiations::SHA512\n  type B = 128\n  type L = 64\n  H = hashBytes\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA1.cry","filetype":"cry","content":"\/**\n * HMAC instantiated with SHA1.\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA1::Specification as SHA1\n  type B = 64\n  type L = 20\n  H text = SHA1::hashBytes text\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA256.cry","filetype":"cry","content":"\/**\n * HMAC instantiated with SHA2-256 as defined in [RFC-4868].\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\n * [RFC-4868] @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc4868\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256\n  type B = 64\n  type L = 32\n  H = hashBytes\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA384.cry","filetype":"cry","content":"\/**\n * HMAC instantiated with SHA2-384 as defined in [RFC-4868].\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\n * [RFC-4868] @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc4868\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA2::Instantiations::SHA384\n  type B = 128\n  type L = 48\n  H = hashBytes\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/FNV.cry","filetype":"cry","content":"module Primitive::Keyless::Hash::FNV where\n\nfnv1a : {n} (fin n) => [n] -> [64]\nfnv1a ws = fnv1a' (pad ws)\n\npad : {msgLen} (fin msgLen) => [msgLen] -> [msgLen \/^ 8][8]\npad msg = split (msg # (zero:[msgLen %^ 8]))\n\nfnv1a' : {chunks} (fin chunks) => [chunks][8] -> [64]\nfnv1a' msg = Ss ! 0\n  where\n   Ss = [fnv1a_offset_basis] #\n           [ block s m\n           | s <- Ss\n           | m <- msg\n           ]\n\nblock : {padLen} ( padLen == 64 - 8) => [64] -> [8] -> [64]\nblock state val = (state ^ ((zero : [padLen]) # val)) * fnv1a_prime\n\nfnv1a_offset_basis : [64]\nfnv1a_offset_basis = 14695981039346656037\n\nfnv1a_prime : [64]\nfnv1a_prime = 1099511628211\n\nt1 = fnv1a [] == 0xcbf29ce484222325\nt2 = fnv1a (join \"a\") == 0xaf63dc4c8601ec8c\nt3 = fnv1a (join \"foobar\") == 0x85944171f73967e8\n\nproperty testsPass = and [t1, t2, t3]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/HashInterface.cry","filetype":"cry","content":"interface module Primitive::Keyless::Hash::HashInterface where\n    \/**\n     * Upper bound on the length of messages that can be hashed with this\n     * hash function.\n     *\n     * This can be set to `inf` for hash functions that do not have a\n     * restriction on message length.\n     *\/\n    type MessageUpperBound : #\n\n    \/**\n     * Length of the hash digest, in bits.\n     *\/\n    type DigestLength : #\n\n    \/**\n     * Security strength (in bits) of the hash function.\n     *\n     * This is assumed to be the minimum of the collision resistance strength,\n     * the preimage resistance strength, and the second preimage resistance\n     * strength. For most NIST-standardized hash functions, the security\n     * strength is half the digest length. The exception is SHA-1, which is\n     * largely deprecated.\n     * @see https:\/\/csrc.nist.gov\/projects\/hash-functions#security-strengths\n     *\/\n    type SecurityStrength : #\n\n    \/**\n     * Hash function, mapping an arbitrary-length message to a fixed-length\n     * message digest.\n     *\/\n    hash: {m} (fin m, width m < MessageUpperBound) => [m] -> [DigestLength]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/Blake2b.cry","filetype":"cry","content":"module Primitive::Keyless::Hash::Blake2b where\n\ntype Block   = [16][64]\ntype State   = [8][64]\ntype LocalState = [16][64]\ntype Counter = [128]\n\ntype Context = { state : State, counter : Counter }\n\nbbVal : [128]\nbbVal = 128\n\n\nIV : [8][64]\nIV = [ 0x6A09E667F3BCC908, 0xBB67AE8584CAA73B,\n       0x3C6EF372FE94F82B, 0xA54FF53A5F1D36F1,\n       0x510E527FADE682D1, 0x9B05688C2B3E6C1F,\n       0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179\n     ]\n\nSIGMA_TABLE : [12][16][4]\nSIGMA_TABLE =\n    [  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ,  [ 11, 8,  12, 0,   5, 2,  15, 13, 10, 14,  3, 6,   7, 1,   9, 4  ]\n    ,  [  7, 9,   3, 1,  13, 12, 11, 14,  2, 6,   5, 10,  4, 0,  15, 8  ]\n    ,  [  9, 0,   5, 7,   2, 4,  10, 15, 14, 1,  11, 12,  6, 8,   3, 13 ]\n    ,  [  2, 12,  6, 10,  0, 11,  8, 3,   4, 13,  7, 5,  15, 14,  1, 9  ]\n    ,  [ 12, 5,   1, 15, 14, 13,  4, 10,  0, 7,   6, 3,   9, 2,   8, 11 ]\n    ,  [ 13, 11,  7, 14, 12, 1,   3, 9,   5, 0,  15, 4,   8, 6,   2, 10 ]\n    ,  [  6, 15, 14, 9,  11, 3,   0, 8,  12, 2,  13, 7,   1, 4,  10, 5  ]\n    ,  [ 10, 2,   8, 4,   7, 6,   1, 5,  15, 11,  9, 14,  3, 12, 13, 0  ]\n    ,  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ]\n\n\/\/ Section 2.1 constants\nR1,R2,R3,R4 : [6]\nR1 = 32\nR2 = 24\nR3 = 16\nR4 = 63\n\n\/\/ Section 3.1: Mixing function 'G'\nG : [4] -> [4] -> LocalState -> [4][6] -> Block -> [16][64]\nG r i vec abcd ms = updates vec abcd new\n  where\n  new  = G' r i (vec @@ abcd) ms\n\nG' : [4] -> [4] -> [4][64] -> Block -> [4][64]\nG' r i vals ms = [a2, b2, c2, d2]\n  where\n  x = ms @ (SIGMA_TABLE @ r @ (2*i))\n  y = ms @ (SIGMA_TABLE @ r @ (2*i+1))\n  [a,b,c,d] = vals\n  a1 =  a + b + x\n  d1 = (d ^ a1) >>> R1\n  c1 =  c + d1\n  b1 = (b ^ c1) >>> R2\n  a2 =  a1 + b1 + y\n  d2 = (d1 ^ a2) >>> R3\n  c2 =  c1 + d2\n  b2 = (b1 ^ c2) >>> R4\n\n\/\/ Section 3.2: Compression function\nF : State -> Block -> Counter -> Bit -> State\nF h ms t f =  h ^ (take (vs!0)) ^ (drop (vs!0))\n where\n  v   = h # IV ^ (zero # [t0,t1,f0,zero])\n  [t1,t0] = split t : [2][64]\n  f0 = [f | _ <- [0..63] : [_][6]]\n  vs = [v] # [ round i ms v' | v' <- vs | i <- [0..11] ]\n\n\/\/ Sub-function of F (first for loop)\nround : [4] -> Block -> LocalState -> LocalState\nround r ms v = vs ! 0\n  where\n  vs = [v] # [ G r i v' ix ms\n                | v'   <- vs\n                | i    <- [0..7]\n                | ix   <- [ [0,4,8,12],  [1,5,9,13]\n                          , [2,6,10,14], [3,7,11,15]\n                          , [0,5,10,15], [1,6,11,12]\n                          , [2,7,8,13],  [3,4,9,14] ]\n              ]\n \/\/ ix (ms @ (s @ sIx1)) (ms @ (s @ sIx2))\n \/\/               | sIx1 <- [0,2,4,6,8,10,12,14] : [8][4]\n \/\/               | sIx2 <- [1,3,5,7,9,11,13,15] : [8][4]\n \/\/             ]\n\n\/\/ Section 3.3: Padding\n\/\/ Recall kk == key bytes  (0)\n\/\/        nn == hash bytes (64)\n\/\/        ll == input bytes (ceiling $ len \/ 8)\n\/\/        bb == block bytes (128, 1024 bits)\n\/\/        dd == nr Blocks\n\nblake2b : {ll,dd}\n         (fin ll, fin dd\n         , dd == (max 1 ((ll+127)\/128)) - 1\n         \/\/ ^^^ ugly  We'd like , dd == (ll-1)\/128  but then we can't hash the empty string\n         , 128 >= width ll\n         )\n          => [ll][8]\n          -> [512]\nblake2b m = blake2Finish ({ state = (hs!0).state, counter = `ll}) lastBlock\n where\n\n fullBlocks : [dd]Block\n fullBlocks = [mkBlock b | b <- split (take (join m))]\n\n partialBlock = drop `{128*dd} m\n\n lastBlock : Block\n lastBlock  =\n    if (`ll == (zero:[128]))\n        then zero \/\/ Special case full zero block for empty messages\n        else mkBlock ((split (join (partialBlock # (zero : [inf][8]))))@0)\n\n h : Context\n h  = { state = [IV@0 ^ `0x01010040] # drop `{1} IV, counter = 0 }\n\n hs : [dd+1]Context\n hs = [h] # [blake2Update h' dX |  h' <- hs | dX <- fullBlocks]\n\nblake2Update : Context -> Block -> Context\nblake2Update ctx d = { state = newState, counter = newCount }\n  where newState = F ctx.state d newCount False\n        newCount = ctx.counter + (128 : [128])\n\npostprocess : {ll} (128 >= ll, 128 >= width ll) => Counter -> [ll][8] -> Block\npostprocess c m =\n    if c == 0 \/\\ `ll == (zero:[128])\n        then zero\n        else split (join m # zero)\n\n\/\/ The final round of blake\nblake2Finish : Context -> Block -> [512]\n\/\/ blake2Finish ctx b = ctx.state@0 # zero\nblake2Finish ctx b = join [ reverseBytes w | w <- F ctx.state b ctx.counter True ]\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/  Utilities\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nmkBlock x = reverse (split (reverseBytes x))\n\nreverseBytes x = join (reverse (bytes x))\n\nbytes x = split x : [_] [8]\n\n\ntestZeros =\n  and [ blake2b (zero : [128][8]) == 0x865939e120e6805438478841afb739ae4250cf372653078a065cdcfffca4caf798e6d462b65d658fc165782640eded70963449ae1500fb0f24981d7727e22c41\n      , blake2b (zero : [0][8]) == 0x786A02F742015903C6C6FD852552D272912F4740E15847618A86E217F71F5419D25E1031AFEE585313896444934EB04B903A685B1448B755D56F701AFE9BE2CE ]\n\ntestZerosLarge =\n  and [ blake2b (zero : [129][8]) == 0xa60edba343e7a6933c14d203d2e535f35e6deb6c8a4f8e624c1a6f6e2612860447cb4c37e5aa11bcf03b7c3eea7228eb8b998f922794f2d1b8f2dc63f03bd3fa\n      ]\n\ntestKATs =\n  and [ blake2b \"The quick brown fox jumps over the lazy dog\" == 0xA8ADD4BDDDFD93E4877D2746E62817B116364A1FA7BC148D95090BC7333B3673F82401CF7AA2E4CB1ECD90296E3F14CB5413F8ED77BE73045B13914CDCD6A918\n      ]\n\nproperty katsPass = and [ testZeros, testZerosLarge, testKATs ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Generator\/DRBG.cry","filetype":"cry","content":"\/**\n * @copyright Galois Inc.\n * @author Nichole Schimanski <nls@galois.com>\n * @author Marcella Hastings <marcella@galois.com>\n * @author Ryan Scott <rscott@galois.com>\n * www.cryptol.net\n*\/\n\nmodule Primitive::Keyless::Generator::DRBG where\n\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 as AES256\n\ntype keylen   = AES256::KeySize type blocklen = 128 type seedlen  = 384 \/\/ bits, 384 bits fixed by table 3 for AES-256\ntype reseed_limit = 2 ^^ 35 \/\/ max number of bytes to generate before reseeding\n\ntype blocksize = 16 \/\/ blocklen \/ 8\ntype keysize = 32 \/\/ keylen \/ 8\ntype seedsize = 48\n\ntype cipher_ctx = { key : [keylen] }\n\nblock_encrypt : [keylen] -> [blocklen] -> [blocklen]\nblock_encrypt key data = AES256::encrypt key data\n\ntype s2n_drbg =\n  { bytes_used : [64]\n  , ctx : cipher_ctx\n  , v : [blocklen]\n  }\n\ndrbg_generate_internal : {n, blocks}\n                         ( fin n, fin blocks, n >= 1, n <= 8192\n                         , n == blocklen * blocks)\n                      => s2n_drbg\n                      -> ([n], s2n_drbg)\ndrbg_generate_internal drbg =\n  (join [ block_encrypt drbg.ctx.key (drbg.v + i) | i <- [1 .. blocks]], drbg')\n    where drbg' = { bytes_used = drbg.bytes_used + `(blocks * blocksize)\n                  , ctx = drbg.ctx\n                  , v = drbg.v + `blocks\n                  }\n\ndrbg_instantiate : {ps_size}\n                   (fin ps_size)\n                => [seedlen]\n                -> [ps_size]\n                -> s2n_drbg\ndrbg_instantiate entropy ps = drbg_reseed zero entropy ps'\n  where\n    \/* pad ps with zeros if needed to reach seedlen\n       otherwise truncate to seedlen *\/\n    ps' = take `{seedlen} (ps # (zero : [seedlen]))\n\n\/* Should bytes used be reset before the update? s2n doesn't\n   it seems like the NIST spec counts that update as the first\n\n   we limit ps_size to a maximum of seedlen because this is an\n   implementation specific choice made by s2n*\/\ndrbg_reseed : {ps_size}\n              (ps_size <= seedlen)\n           => s2n_drbg\n           -> [seedlen]\n           -> [ps_size]\n\t   -> s2n_drbg\ndrbg_reseed drbg entropy ps = drbg''\n  where\n    drbg' = drbg_update (entropy ^ (ps # zero)) drbg\n    drbg'' = { v = drbg'.v, ctx = drbg'.ctx, bytes_used = 0}\n\ndrbg_uninstantiate : s2n_drbg -> s2n_drbg\ndrbg_uninstantiate drbg = zero\n\n\/* This is the spec of the s2n code, in that it reseeds automatically\n   if reseed is required. This is in opposition to the spec, which\n   requires an error code.\n\n   We are curious about why s2n_drbg counts a number of bytes used,\n   while the spec tracks a number of calls to generate. We don't\n   belive that this is buggy behavior, since if we call the maximum\n   size with generate each time, we will reseed before the spec would\n   require it. *\/\ndrbg_generate : {n, blocks} (fin n, fin blocks, n >= 1, n <= 8192,\n                             blocks * blocklen >= n,\n                             (blocks - 1) * blocklen <= n - 1) =>\n                s2n_drbg -> [seedlen] -> Bit ->\n                ([n], s2n_drbg)\ndrbg_generate drbg entropy reseed_p = (take enc_result, drbg_out)\n  where\n    \/\/ Re-seed if we have exceeded the limit, or if reseed_p is set\n    drbg_r =\n      if reseed_p \\\/ drbg.bytes_used + `n * 8 + `blocklen * 8 >= `reseed_limit then\n        drbg_reseed drbg entropy (zero : [256])\n      else drbg\n    \/\/ Encrypt v+1, v+2, ..., v + ceil (n \/ blocklen)\n    (enc_result, drbg_v) = drbg_generate_internal `{blocks=blocks} drbg_r\n    \/\/ Update the drbg state\n    drbg_out = drbg_update zero drbg_v\n\n\/* What is ctr_len? We think it is >= blocklen, so\n   we go to the else branch of 2.1 every time *\/\ndrbg_update : [seedlen] -> s2n_drbg -> s2n_drbg\ndrbg_update data drbg = result\n  where\n    \/\/ NOTE: blocklen * seedlen \/ blocklen is seedlen in our case, but might be\n    \/\/ different if seedlen isn't a multiple of blocklen\n    type blocks = (seedlen + blocklen -1)\/blocklen\n    \/\/ Encrypt v+1, v+2, ..., v + ceil (seedlen \/ blocklen)\n    (enc_result, _) = drbg_generate_internal `{blocks=blocks} drbg\n    \/\/ XOR the additional input data with the first bits of enc_result\n    data_xor = (take enc_result) ^ data\n    \/\/ Return the first half of data_xor as the new key, and the last half of it\n    \/\/ as the new value for v\n    result = { bytes_used = drbg.bytes_used + (`blocks * `blocksize)\n             , ctx = { key = take data_xor }\n             , v = drop data_xor\n             }\n\n\n\/* Example test vectors from\n\n   https:\/\/csrc.nist.gov\/Projects\/Cryptographic-Algorithm-Validation-Program\/Random-Number-Generators\n\n   for CTR_DRBG.\n*\/\n\n\/* [AES-256 no df]\n   [PredictionResistance = False]\n   [EntropyInputLen = 384]\n   [NonceLen = 0]\n   [PersonalizationStringLen = 0]\n   [AdditionalInputLen = 0]\n   [ReturnedBitsLen = 512] <- value of type parameter n\n*\/\n\n\n\ntestInstantiate0 = {entropy = 0xe4bc23c5089a19d86f4119cb3fa08c0a4991e0a1def17e101e4c14d9c323460a7c2fb58e0b086c6c57b55f56cae25bad,\n                    pString = zero : [0],\n                        Key = 0xb7b3a93ecfdf2f61c622ad3afb6bff818736a09c9391157e1902d10a79d0db12,\n                               V = 0x0e4fb6443cae46188617aad8bfe46e23}\n\ntestInstantiatedrbg0 = drbg_instantiate`{ps_size=0} testInstantiate0.entropy testInstantiate0.pString\n\ntestInstantiate0Pass = testInstantiatedrbg0.v == testInstantiate0.V \/\\ testInstantiatedrbg0.ctx.key == testInstantiate0.Key\n\ntestReseed0 = {entropyReseed = 0xfd85a836bba85019881e8c6bad23c9061adc75477659acaea8e4a01dfe07a1832dad1c136f59d70f8653a5dc118663d6,\n                          Key = 0xd230044c2594510d195ffe9923de8848bdbd19f24d0e7558b28e55b2d4de7841,\n                                V = 0xe18637ff12f514f37adc2013a40f38c1}\n\ntestReseed0Pass = drbgreseed.v == testReseed0.V \/\\ drbgreseed.ctx.key == testReseed0.Key\n                where drbgreseed = drbg_reseed`{ps_size=0} testInstantiatedrbg0 testReseed0.entropyReseed zero\n\ntestGenerate0 = {      Key = 0xec871bb7a4f2c45dccdd0e514a21628959aa21e9643934f619b2709b3e38697c,\n                       V   = 0xd8bbe7bfc60bfb710f39acd1088c9f41}\n\ntestGeneratedrbg0 = (drbg_generate`{n=512} testInstantiatedrbg0 testReseed0.entropyReseed True).1\n\ntestGenerate0Pass = testGeneratedrbg0.v == testGenerate0.V testGenerateSnd0 = {returnedBits = 0xb2cb8905c05e5950ca31895096be29ea3d5a3b82b269495554eb80fe07de43e193b9e7c3ece73b80e062b1c1f68202fbb1c52a040ea2478864295282234aaada,\n                       Key = 0xe728308a0e92cbacb269d12246d8e2d24cf5fcc678aa09564132e4972c456eda,\n                       V   = 0xc95f38da34ecb65ebf8b34c32bc215a5}\n\ntestGenerateSnd0Pass = and [ result == testGenerateSnd0.returnedBits\n                           , drbg.ctx.key == testGenerateSnd0.Key\n                           , drbg.v == testGenerateSnd0.V ]\n                     where (result,drbg) = drbg_generate`{n=512} testGeneratedrbg0 zero False\n\n\nproperty testsPass = and [testInstantiate0Pass, testReseed0Pass, testGenerate0Pass, testGenerateSnd0Pass]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Specification.cry","filetype":"cry","content":"\/*\n * Implementation of the secure hash algorithms known as SHA2 from [FIPS-180-4].\n *\n * This implementation does not support SHA-1. It does support:\n * - SHA-224\n * - SHA-256\n * - SHA-384\n * - SHA-512\n * - SHA-512\/224\n * - SHA-512\/256\n *\n * References\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Specification where\n\nparameter\n    \/**\n     * Length of words, in bits, that are used during hashing.\n     *\n     * The specification defines words to be either 32 bits (for\n     * SHA-224 and SHA-256) or 64 bits (for SHA-384, SHA-512, and\n     * SHA-512\/t for any valid `t`).\n     * [FIPS-180-4] Section 1, Figure 1.\n     *\/\n    type w : #\n    type constraint (w % 32 == 0, 32 <= w, 64 >= w)\n\n    \/**\n     * Length of the message digest produced by the hash algorithm.\n     *\n     * Allowable values for each word size `w` are defined in [FIPS-180-4]\n     * Section 1, Figure 1.\n     *\n     * The spec does not explicitly require that the digest size is a multiple\n     * of 8, but all the allowable sizes are; adding this explicit constraint\n     * allows us to define a hash function that operates over bytes.\n     *\/\n    type DigestSize : #\n    type constraint (8 * w >= DigestSize, DigestSize % 8 == 0)\n\n    \/**\n     * Initial hash value.\n     * These are defined in [FIPS-180-4] Section 5.3.\n     *\/\n    H0 : [8][w]\n\n\/**\n * Upper bound on the width of messages that can be processed.\n * [FIPS-180-4] Section 1, Figure 1, \"Message Size (bits)\"\n *\/\ntype MessageUpperBound = 2 * w\ntype constraint ValidMessageLength L = width L <= MessageUpperBound\n\n\/**\n * Length of the hash digest.\n *\n * This is made public to instantiate the `HashInterface`.\n *\/\ntype DigestLength = DigestSize\n\n\/**\n * Security strength (in bits) of the hash function.\n * @see NIST SP 800-107 (to be withdrawn): https:\/\/csrc.nist.gov\/pubs\/sp\/800\/107\/r1\/final\n * @see Hash functions webpage: https:\/\/csrc.nist.gov\/projects\/hash-functions\n *\n * This is made public to instantiate the `HashInterface`.\n *\/\ntype SecurityStrength = DigestSize \/ 2\n\nprivate\n    \/**\n     * Size of blocks of data used in hashing, measured in bits.\n     *\n     * This is denoted `m` in the spec. [FIPS-180-4] Section 1, Figure 1.\n     *\/\n    type BlockSize = 16 * w\n\n    \/**\n     * `ScheduleLength` is fixed based on `w`: 64 when `w = 32` and 80 when `w = 64`.\n     * We encode this using the relation `48 + w\/2`.\n     *\n     * It is not explicitly defined with this name in the spec. You can see it used\n     * in several places:\n     * - The constant `K` has `ScheduleLength` words ([FIPS-180-4] Section\n     *   4.2.2 and 4.2.3)\n     * - The message schedule `W` has length `ScheduleLength` ([FIPS-180-4]\n     *   Section 6.2.2 #1 and Section 6.4.2 #1)\n     *\/\n    type ScheduleLength = 48 + w \/ 2\n\n    \/**\n     * Circular rotate left operation.\n     * [FIPS-180-4] Section 2.2.2 and Section 3.2 #5.\n     *\/\n    ROTL : {n} (n < w) => [w] -> [w]\n    ROTL x = x <<< `n\n\n    \/**\n     * Circular rotate right operation.\n     * [FIPS-180-4] Section 2.2.2 and Section 3.2 #4.\n     *\/\n    ROTR : {n} (n < w) => [w] -> [w]\n    ROTR x = x >>> `n\n\n    \/**\n     * Circular rotations have a specific kind of circularity.\n     * [FIPS-180-4] Section 3.2 #6.\n     *\n     * We check this for a sampling of `n`s.\n     * ```repl\n     * :prove rotationEquivalenceRelationsHold`{0}\n     * :prove rotationEquivalenceRelationsHold`{1}\n     * :prove rotationEquivalenceRelationsHold`{w-1}\n     * :prove rotationEquivalenceRelationsHold`{w\/2}\n     * ```\n     *\/\n    rotationEquivalenceRelationsHold : {n} (n < w) => [w] -> Bool\n    property rotationEquivalenceRelationsHold x = left && right where\n        left = ROTL`{n} x == ROTR`{(w - n) % w} x\n        right = ROTR`{n} x == ROTL`{(w - n) % w} x\n\n    \/**\n     * Right shift operation.\n     * [FIPS-180-4] Section 2.2.2 and Section 3.2 #3\n     *\/\n    SHR : {n} (n < w) => [w] -> [w]\n    SHR x = x >> `n\n\n    \/**\n     * The default Cryptol representation of hex digits and bit strings matches\n     * the requirements of the spec.\n     * [FIPS-180-4] Section 3.1, #1.\n     * ```repl\n     * :prove hexDigitsEncodeCorrectly\n     * ```\n     *\/\n    property hexDigitsEncodeCorrectly = (0x7 == 0b0111) && (0xa == 0b1010)\n\n    \/**\n     * The default Cryptol representation of hex words and bit strings matches\n     * the requirements of the spec.\n     * [FIPS-180-4] Section 3.1, #2.\n     * ```repl\n     * :prove wordsEncodeCorrectly\n     * ```\n     *\/\n    property wordsEncodeCorrectly = short && long where\n        short = 0xa103fe23 == 0b10100001000000111111111000100011\n        long = 0xa103fe2332ef301a == 0b1010000100000011111111100010001100110010111011110011000000011010\n\n    \/**\n     * The default Cryptol representation of integers and hex words matches\n     * the requirements of the spec.\n     * [FIPS-180-4] Section 3.1, #3.\n     * ```repl\n     * :prove integersEncodeCorrectly\n     * ```\n     *\/\n    property integersEncodeCorrectly = 291 == 0x00000123\n\n    \/**\n     * The first logical function for the SHA family.\n     * [FIPS-180-4] Section 4.1.2, Equation 4.2 and Section 4.1.3, Equation 4.8.\n     *\/\n    Ch : [w] -> [w] -> [w] -> [w]\n    Ch x y z = (x && y) ^ (~x && z)\n\n    \/**\n     * The second logical function for the SHA family.\n     * [FIPS-180-4] Section 4.1.2, Equation 4.3 and Section 4.1.3, Equation 4.9.\n     *\/\n    Maj : [w] -> [w] -> [w] -> [w]\n    Maj x y z = (x && y) ^ (x && z) ^ (y && z)\n\n    \/**\n     * The third logical function for the SHA family.\n     * [FIPS-180-4] Section 4.1.2, Equation 4.4 and Section 4.1.3, Equation 4.10.\n     *\/\n    Sigma0: [w] -> [w]\n    Sigma0 x\n        | w == 32 => ROTR`{ 2} x ^ ROTR`{13} x ^ ROTR`{22} x\n        | w == 64 => ROTR`{28} x ^ ROTR`{34} x ^ ROTR`{39} x\n\n    \/**\n     * The fourth logical function for the SHA family.\n     * [FIPS-180-4] Section 4.1.2, Equation 4.5 and Section 4.1.3, Equation 4.11.\n     *\/\n    Sigma1: [w] -> [w]\n    Sigma1 x\n        | w == 32 => ROTR`{ 6} x ^ ROTR`{11} x ^ ROTR`{25} x\n        | w == 64 => ROTR`{14} x ^ ROTR`{18} x ^ ROTR`{41} x\n\n    \/**\n     * The fifth logical function for the SHA family.\n     * [FIPS-180-4] Section 4.1.2, Equation 4.6 and Section 4.1.3, Equation 4.12.\n     *\/\n    sigma0: [w] -> [w]\n    sigma0 x\n        | w == 32 => ROTR`{7} x ^ ROTR`{18} x ^ SHR`{3} x\n        | w == 64 => ROTR`{1} x ^ ROTR`{ 8} x ^ SHR`{7} x\n\n    \/**\n     * The sixth logical function for the SHA family.\n     * [FIPS-180-4] Section 4.1.2, Equation 4.7 and Section 4.1.3, Equation 4.13.\n     *\/\n    sigma1: [w] -> [w]\n    sigma1 x\n        | w == 32 => ROTR`{17} x ^ ROTR`{19} x ^ SHR`{10} x\n        | w == 64 => ROTR`{19} x ^ ROTR`{61} x ^ SHR`{ 6} x\n\n    \/**\n     * The SHA family uses a sequence of constant `w`-bit words, which represent\n     * the first `w` bits of the fractional parts of the cube roots of the first\n     * `ScheduleLength` prime numbers.\n     *\n     * [FIPS-180-4] Section 4.2.2 and 4.2.3.\n     *\/\n    K : [ScheduleLength][w]\n    K | w == 32 => [\n        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]\n      | w == 64 => [\n        0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n        0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n        0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n        0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n        0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n        0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n        0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n        0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n        0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n        0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n        0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n        0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n        0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n        0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n        0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n        0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n        0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n        0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n        0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n        0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817]\n\n\n    \/**\n     * Number of bits used to encode the length of the message for padding.\n     * [FIPS-180-4] Section 5.1.\n     *\/\n    type LengthBits = 2 * w\n    \/**\n     * Number of blocks needed to hold the padded version of a message of length L.\n     * [FIPS-180-4] Section 5.1.\n     *\/\n    type NumBlocks L = (L + 1 + LengthBits) \/^ BlockSize\n\n    \/**\n     * Deterministically pad a message to a multiple of the block size.\n     *\n     * [FIPS-180-4] Section 5.1.1 and 5.1.2.\n     *\n     * The constraint is not explicitly noted in Section 5.1, but all\n     * messages to be hashed must not exceed the valid message length.\n     *\/\n    pad : {L} (ValidMessageLength L) => [L] -> [NumBlocks L * BlockSize]\n    pad M = M # 0b1 # zero # (`L : [LengthBits])\n\n    \/**\n     * The example used to demonstrate padding in the spec works.\n     * [FIPS-180-4] Section 5.1.1 and Section 5.1.2.\n     * ```repl\n     * :prove paddingExampleWorks\n     * ```\n     *\/\n    paddingExampleWorks : Bool\n    paddingExampleWorks\n        | w == 32 => pad (join \"abc\") == (0b01100001 # 0b01100010 # 0b01100011\n            # 0b1 # (zero : [423]) # (zero : [59]) # 0b11000)\n        | w == 64 => pad (join \"abc\") == (0b01100001 # 0b01100010 # 0b01100011\n            # 0b1 # (zero : [871]) # (zero : [123]) # 0b11000)\n\n    \/**\n     * The message and its padding must be parsed into `N` blocks.\n     * [FIPS-180-4] Section 5.2.\n     *\/\n    parse : {N} () => [N * BlockSize] -> [N][BlockSize]\n    parse M = split M\n\n\n\/**\n * Secure hash function.\n *\n * All the SHA functions (excluding SHA-1) share the same structure.\n * The primary differences can be handled through Cryptol's built-in\n * polymorphism:\n * - The word sizes are different;\n * - The length of the message schedule and subsequent number of iterations\n *   over the working variables are different; and\n * - The digest length is different.\n *\n * [FIPS-180-4] Section 6.2 - 6.7.\n * The hash functionality itself is primarily described in Sections 6.2 and\n * 6.4. The correct truncation for other bit lengths is in the other sections.\n *\/\nhash: {l} (ValidMessageLength l) => [l] -> [DigestSize]\nhash M = take (join (digest ! 0)) where\n    digest = [H0] # [Hi'\n        where\n            \/\/ Step 1. Prepare the message schedule.\n            Ws = messageSchedule (split Mi)\n\n            \/\/ Step 2. Initialize the eight working variables with the\n            \/\/ previous hash value.\n            letters = [(Hi0, Hi1, Hi2, Hi3, Hi4, Hi5, Hi6, Hi7)] # [\n                \/\/ Step 3. Update temporary and working variables...\n                variableUpdate l Kt Wt\n                | l <- letters\n\n                \/\/ ...for t=0 to `ScheduleLength`.\n                | Wt <- Ws\n                | Kt <- K\n            ]\n            (a, b, c, d, e, f, g, h) = letters ! 0\n\n            \/\/ Step 4. Compute the next intermediate hash value.\n            \/\/ Note that in the spec, this is denoted H^(i).\n            Hi' = [a + Hi0, b + Hi1, c + Hi2, d + Hi3, e + Hi4, f + Hi5, g + Hi6, h + Hi7]\n\n        \/\/ Each message block is processed in order.\n        | Mi <- parse (pad M)\n\n        \/\/ An intermediate hash digest is computed at each iteration.\n        \/\/ Note that in the spec, these are denoted H^(i-1)_j for j = 0..7.\n        | [Hi0, Hi1, Hi2, Hi3, Hi4, Hi5, Hi6, Hi7] <- digest\n    ]\n\n    \/\/ Step 1. Prepare the message schedule.\n    messageSchedule : [16][w] -> [ScheduleLength][w]\n    messageSchedule Mi = take W where\n        W : [inf][w]\n        W = Mi # [ sigma1 w2 + w7 + sigma0 w15 + w16\n            \/\/ The spec indexes these by counting from the other direction.\n            \/\/ We can't do that here because it's an infinite sequence.\n            \/\/ Note that 15 - the drop parameter is the index in the spec.\n            | w16 <- W\n            | w15 <- drop`{1} W\n            | w7  <- drop`{9} W\n            | w2  <- drop`{14} W\n        ]\n\n    \/\/ Convenience type to describe the set of working variables a - h.\n    type LetterVars = ([w], [w], [w], [w], [w], [w], [w], [w])\n\n    \/\/ Step 3. Update temporary and working variables (one iteration).\n    variableUpdate : LetterVars -> [w] -> [w] -> LetterVars\n    variableUpdate (a, b, c, d, e, f, g, h) Kt Wt =\n        (a', b', c', d', e', f', g', h')\n        where\n            T1 = h + Sigma1 e + Ch e f g + Kt + Wt\n            T2 = Sigma0 a + Maj a b c\n            h' = g\n            g' = f\n            f' = e\n            e' = d + T1\n            d' = c\n            c' = b\n            b' = a\n            a' = T1 + T2\n\n\/**\n * Secure hash function, computed over bytes.\n *\n * This is not explicitly part of the spec, but many applications represent\n * their input and output over byte strings (rather than bit strings as used\n * in the spec itself).\n *\/\nhashBytes: {l} (ValidMessageLength (8 * l)) => [l][8] -> [DigestSize \/ 8][8]\nhashBytes M = groupBy`{8} (hash (join M))\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/KeccakBitOrdering.cry","filetype":"cry","content":"\/**\n * Functions for converting bit string representations used in Keccak.\n *\n * This has methods for converting between the standard bit ordering in Cryptol\n * (big endian, or most significant bit first (MSB)) and the bit ordering\n * used in Keccak (bytes in MSB order, but the bits in each byte are in\n * least significant bit first (LSB) order).\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA3::KeccakBitOrdering where\n\/**\n * Deprecated!!\n * Splits a list of bits into bytes, using little-endian bit order.\n *\/\ntoBytes : {n} (fin n) => [8*n] -> [n][8]\ntoBytes s = reverse (split (reverse s))\n\n\/**\n * Deprecated!!\n * Joins a list of bytes into a list of bits, using little-endian bit order.\n *\/\nfromBytes : {n} (fin n) => [n][8] -> [8*n]\nfromBytes bs = reverse (join (reverse bs))\n\n\/**\n * This converts between a bit vector in MSB order and a bit vector in SHA-3\n * bit ordering (the bytes are in MSB order; the bits in each byte are in LSB\n * order).\n *\n * For arbitrary-length strings, the conversion is symmetric. This can be used\n * to convert from SHA-3 strings into MSB strings, or from MSB strings into\n * SHA-3 strings.\n *\n * This function does not have an explicit equivalent in the [FIPS-202]. It\n * differs from the conversion functions in Appendix B.1 in several ways:\n * - The h2b and b2h functions expect the non-SHA-3 bit vector to be a\n *   hexadecimal string with an even number of digits. This function\n *   can handle a non-SHA-3 bit vector of any length (including infinite\n *   length).\n * - The h2b and b2h functions take a separate parameter `n` specifying the\n *   \"actual\" length of the non-SHA-3 bit vector. `h2b` truncates the SHA-3 bit\n *   vector to exactly `n` bits; `b2h` pads the non-SHA-3 bit vector to a\n *   multiple of 8 bits. This function assumes the input bit vector\n *   has no padding and that the output bit vector is exactly the same length\n *   as the input bit vector.\n * - `b2h` and `h2b` require finite input. This function allows infinite input.\n *   This isn't relevant for `h2b` since all the SHA3 functions take finite\n *   input, but it allows callers of the extendable output SHAKE functions to\n *   interact lazily with an infinite stream instead of specifying the output\n *   length at call time.\n *\n * [FIPS-202] does not specify when these conversion functions are expected to\n * be used. The CAVP test vectors provided by NIST use the format consumed by\n * `h2b` and `b2h` of hexadecimal strings with an even number of digits.\n * However, we anticipate that many applications will produce exact-length\n * messages to use with SHA-3 functions (e.g. they will not pad their inputs\n * to a multiple of 8 bits).\n *\n * Sources:\n * A blog post with some references to other versions of the spec, explaining\n * the overall bit ordering scheme:\n * @see https:\/\/cryptologie.net\/article\/387\/byte-ordering-and-bit-numbering-in-keccak-and-sha-3\/\n * The CAVP test vectors from NIST:\n * @see https:\/\/csrc.nist.gov\/projects\/cryptographic-algorithm-validation-program\/secure-hashing#sha3vsha3vss\n * The CSAG examples and intermediate values from NIST:\n * @see https:\/\/csrc.nist.gov\/projects\/cryptographic-standards-and-guidelines\/example-values#Hashing\n *\/\nreverseBitOrdering : {m} [m] -> [m]\nreverseBitOrdering msg\n    | m == inf => join (map reverse (groupBy`{8} msg))\n    | fin m => (flipped_full_bytes # flipped_remainder) where\n        \/\/ This is number of bits in the set of \"complete\" bytes in the input\n        \/\/ There are `m % 8` bits remaining.\n        type Bytes = 8 * (m \/ 8)\n        flipped_full_bytes = join (map reverse (groupBy`{each=8, parts=m \/ 8} (take`{Bytes} msg)))\n        flipped_remainder = reverse (drop`{Bytes} msg)\n\n\/**\n * The conversion between SHA-3 strings and MSB strings is its own inverse.\n * ```repl\n * :prove reverseBitOrderingInvolutes`{100}\n * ```\n *\/\nreverseBitOrderingInvolutes : {m} (fin m) => [m] -> Bit\nproperty reverseBitOrderingInvolutes msg = reReverse == msg where\n    reReverse = reverseBitOrdering (reverseBitOrdering msg)\n\n\/**\n * This computes the truncation step from `h2b`.\n *\n * This is designed to be used in applications where the input for a SHA-3\n * function is provided in the even-number-of-hex-digits format described in\n * [FIPS-202] Appendix B.1.\n *\/\ntruncate : {n, m} (fin m, fin n, m >= n, m % (2 * HexDigit) == 0) => [m] -> [n]\ntruncate msg = reverseBitOrdering (take (reverseBitOrdering msg))\n\n\/**\n * The `reverseBitOrdering` function is the same as `h2b` when:\n * - there's no padding on the message (e.g. in `h2b`, the output length `n` is\n *   the same as the input length `2 * m * HexDigit`); and\n * - the input length is finite.\n *\n * ```repl\n * :prove reverseMatchesh2b`{10}\n * :prove reverseMatchesh2b`{100}\n * ```\n *\/\nreverseMatchesh2b : {m} (fin m, m > 0) => [2 * m * HexDigit] -> Bool\nproperty reverseMatchesh2b msg = h2b msg == reverseBitOrdering msg\n\n\/**\n * If there is padding on the message passed to `h2b`, truncating that input\n * and passing to `reverseBitOrdering` is the same as passing directly to `h2b`.\n *\n * ```repl\n * :prove truncateAndReverseMatchesh2b`{3, 17}\n * :prove truncateAndReverseMatchesh2b`{3, 18}\n * :prove truncateAndReverseMatchesh2b`{3, 19}\n * :prove truncateAndReverseMatchesh2b`{3, 20}\n * :prove truncateAndReverseMatchesh2b`{3, 21}\n * :prove truncateAndReverseMatchesh2b`{3, 22}\n * :prove truncateAndReverseMatchesh2b`{3, 23}\n * :prove truncateAndReverseMatchesh2b`{3, 24}\n *\/\ntruncateAndReverseMatchesh2b : {m, n} (fin m, m > 0, n > 0, 2 * HexDigit * m >= n) => [2 * m * HexDigit] -> Bool\nproperty truncateAndReverseMatchesh2b msg = h2b_result == rt_result where\n    h2b_result = h2b`{n} msg\n    rt_result = reverseBitOrdering (truncate`{n} msg)\n\n\/**\n * The `reverseBitOrdering` function is the same as `b2h` if:\n * - there's no padding needed on the message (e.g. the message length `n`\n *   divides evenly by 8 (an even number of hex digits)); and\n * - the output length is finite.\n * ```repl\n * :prove reverseMatchesb2h`{10}\n * :prove reverseMatchesb2h`{100}\n * ```\n *\/\nreverseMatchesb2h : {n} (fin n, n > 0) => [2 * n * HexDigit] -> Bool\nreverseMatchesb2h msg = b2h msg == reverseBitOrdering msg\n\n\/**\n * If there is padding needed for the message produced by `b2h`, calling the\n * `truncate` function on that output is the same as calling\n * `reverseBitOrdering`.\n *\n * ```repl\n * :prove reverseAndTruncateMatchesb2h`{17}\n * :prove reverseAndTruncateMatchesb2h`{18}\n * :prove reverseAndTruncateMatchesb2h`{19}\n * :prove reverseAndTruncateMatchesb2h`{20}\n * :prove reverseAndTruncateMatchesb2h`{21}\n * :prove reverseAndTruncateMatchesb2h`{22}\n * :prove reverseAndTruncateMatchesb2h`{23}\n * :prove reverseAndTruncateMatchesb2h`{24}\n *\/\nreverseAndTruncateMatchesb2h : {n} (fin n, n > 0) => [n] -> Bool\nproperty reverseAndTruncateMatchesb2h bits = b2h_result == rev_result where\n    b2h_result = truncate`{n} (b2h bits)\n    rev_result = reverseBitOrdering bits\n\n\/*\n * A hex digit is represented in Cryptol as a 4-bit vector.\n *\/\ntype HexDigit = 4\n\n\/**\n * Converts a hexadecimal string with an even number of digits into a SHA-3\n * string.\n *\n * The bit ordering expected by Keccak has bytes in MSB order, and the bits in\n * each byte in LSB order. (Cryptol's default interprets both bits and bytes\n * in MSB order).\n *\n * [FIPS-202] Appendix B.1, Algorithm 10.\n *\/\nh2b: {n, m} (fin m, m > 0, n > 0, n <= 8 * m) => [2 * m * HexDigit] -> [n]\nh2b msg = S where\n    \/\/ Step 1.\n    H = groupBy`{HexDigit} msg\n    \/\/ Type conversion: expand each 4-bit digit into an 8-bit vector to support\n    \/\/ subsequent operations.\n    H8 = map zext H : [2 * m][8]\n    \/\/ Step 2a.\n    hs = [16 * H8 @ (2 * i) + H8 @ (2 * i + 1) | i <- [0..m-1]]\n    \/\/ Step 2b.\n    \/\/ Cryptol defaults to MSB order; this step arranges the bits in LSB order.\n    bs = map reverse hs\n    \/\/ Step 3.\n    T = join bs\n        S = take`{n} T\n\n\/**\n * This is the example in [FIPS-202] Appendix B, Table 5.\n * ```repl\n * :prove h2bExampleWorks\n * ```\n *\/\nproperty h2bExampleWorks = h2b`{14} H == S where\n    H = 0xA32E\n    S = 0b11000101011101\n\n\/**\n * Converts a SHA-3 string into a hexadecimal string with an even number of\n * digits.\n *\n * [FIPS-202] Appendix B.1, Algorithm 11.\n *\n * Note that this is not a particularly efficient way to do this in Cryptol.\n * Cryptol does not distinguish between bit vectors and hexadecimal strings,\n * so some of the transformations in this function are a little arbitrary.\n *\/\nb2h : {n} (fin n, n > 0) => [n] -> [2 * (n \/^ 8) * HexDigit]\nb2h S = H where\n    \/\/ Step 1: we use Cryptol's `n syntax to get the value of the type.\n    \/\/ Step 2. See `zero_length_is_correct` for an explanation of the type.\n    T = S # (zero : [(8 - (n % 8)) % 8]) \/\/ Equivalently, -n % 8.\n    type m = n \/^ 8\n    \/\/ Step 3.\n    b = [[ T@(8 * i + j) | j <- [0..7]] | i <- [0..m-1]]\n    \/\/ Step 4a.\n    h = [reverse bs | bs <- b]\n    \/\/ Step 4b.\n    Hs = [split`{2, HexDigit} hi | hi <- h]\n    H = join (join Hs)\n\n\/**\n * Helper property to prove the equivalence from b2h is correct.\n * This exists because we can't use negative numbers in types.\n * ```repl\n * :prove zero_length_is_correct\n * ```\n *\/\nzero_length_is_correct : Integer -> Bool\nproperty zero_length_is_correct n = (-n) % 8 == (8 - (n % 8)) % 8\n\n\/**\n * Prove these things invert each other for inputs that \"fill\" the hex string.\n * ```repl\n * :prove h2bAndb2hInvert`{1}\n * :prove h2bAndb2hInvert`{10}\n * :prove h2bAndb2hInvert`{100}\n * :prove h2bAndb2hInvert`{1000}\n * ```\n *\/\nh2bAndb2hInvert : {m} (fin m, m > 0) => [2 * m * HexDigit] -> Bool\nproperty h2bAndb2hInvert msg = b2h (h2b`{2 * m * HexDigit} msg) == msg\n\n\/**\n * Prove these things invert each other for inputs that are padded.\n * In fact, they're not guaranteed to invert each other because there's no\n * standard for the padding on h2b -- the \"extra\" bytes that are between `n`\n * and `8m` get truncated in h2b, and are replaced specifically with 0s in b2h.\n * So it's possible to have different hexadecimal strings that parse as the\n * same SHA-3 strings.\n *\n * That said, it still seems useful to demonstrate that if the padding is all\n * zeros, the input itself is still preserved between the two functions.\n * So, we take inputs of a \"short\" length (e.g. a length that is not divisible\n * by 8), then pad them to the correct length (`hexMsg`), then convert to bits\n * and back.\n *\n * We pad the strings using our `reverseBitOrdering` function; the padding goes\n * to the \"inside\" of the last byte. This matches the convention in the CAVP\n * test vectors. E.g. if `-` is the actual message and `P` is the padding, a\n * vector with 3 bits of padding looks like:\n * `-------- -------- -------- PPP-----`\n *\n * The type parameters are:\n * - `m`: the number of pairs of hex digits in the input string\n * - `n`: the number of actual bits in the input string\n *\n * So, there are 8 potential padding lengths (0 through 7 bits of padding).\n * Here's a set of tests checking all the padding lengths for a string of\n * 3 pairs of hex digits; it will work for any number of pairs.\n * ```repl\n * type pairs = 3\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 7}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 6}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 5}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 4}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 3}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 2}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 1}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 0}\n * ```\n *\/\nh2bAndb2hInvertForShortStrings : {m, n} (fin m, m > 0, n > 0, n \/^ (2 * HexDigit) == m) => [n] -> Bool\nproperty h2bAndb2hInvertForShortStrings msg = b2h (h2b`{n} hexMsg) == hexMsg where\n    hexMsg = reverseBitOrdering ((reverseBitOrdering msg) # zero) : [2 * m * HexDigit]\n\n\/**\n * This is the arguably simpler version of `h2bAndb2hInvertForShortStrings`\n * where we start on the bits side instead of the hex side...\n *\n * ```repl\n * type pairs = 3\n * :prove b2hAndh2bInvert`{8 * pairs - 7}\n * :prove b2hAndh2bInvert`{8 * pairs - 6}\n * :prove b2hAndh2bInvert`{8 * pairs - 5}\n * :prove b2hAndh2bInvert`{8 * pairs - 4}\n * :prove b2hAndh2bInvert`{8 * pairs - 3}\n * :prove b2hAndh2bInvert`{8 * pairs - 2}\n * :prove b2hAndh2bInvert`{8 * pairs - 1}\n * :prove b2hAndh2bInvert`{8 * pairs - 0}\n * ```\n *\/\nb2hAndh2bInvert: {n} (fin n, n > 0) => [n] -> Bool\nproperty b2hAndh2bInvert msg = h2b (b2h msg) == msg\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Specification.cry","filetype":"cry","content":"\/**\n * Specification of the Keccak (SHA-3) hash function.\n *\n * [FIPS-202]: National Institute of Standards and Technology. SHA-3 Standard:\n *     Permutation-Based Hash and Extendable-Output Functions. (Department of\n *     Commerce, Washington, D.C.), Federal Information Processing Standards\n *     Publication (FIPS) NIST FIPS 202. August 2015.\n *     @see https:\/\/dx.doi.org\/10.6028\/NIST.FIPS.202\n *\n * @copyright Galois, Inc. 2013 - 2024\n * @author David Lazar <lazard@galois.com>\n * @author Marcella Hastings <marcella@galois.com>\n *\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Specification where\n\nparameter\n    \/**\n     * Width: the fixed length of the strings that are permuted.\n     *\n     * The type constraint restricts `b` to the valid permutation widths:\n     * 25, 50, 100, 200, 400, 800, and 1600.\n     * In particular, the final constraint enforces that `b \/ 25` is exactly a\n     * power of two, so 0 and any other multiple of 25 are invalid.\n     *\n     * [FIPS-202] Section 3 (intro).\n     *\/\n    type b : #\n    type constraint (fin b, b % 25 == 0, b <= 1600, (2 ^^ (lg2 (b \/ 25))) * 25 == b)\n\n    \/**\n     * Rounds: the number of iterations of an internal transformation (any\n     * positive integer).\n     * [FIPS-202] Section 3 (intro).\n     *\/\n    type nr : #\n    type constraint (fin nr, nr > 0)\n\n    \/**\n     * Capacity parameter for the sponge construction.\n     * [FIPS-202] Section 4.\n     *\/\n    type c : #\n    type constraint (fin c, c < b, c > 0)\n\n\/**\n * Keccak family of sponge functions.\n *\n * At this time, the implementation is not generic with respect to the sponge\n * construction; this implementation \"inlines\" the sponge algorithm (Alg 8)\n * with the specific functions for Keccak (Sec 5.2).\n * [FIPS-202] Section 4, Algorithm 8; instantiated as in Section 5.2.\n *\/\nKeccak : {d, m} (fin m) => [m] -> [d]\nKeccak M = digest where\n    \/\/ Step 1.\n    P = M # pad `{x = r, m = m}\n    \/\/ Step 2. Note than `len(P)` is not necessarily _exactly_ `m + 2`; that's\n    \/\/ the minimum length of `P`. We use round-up division `\/^` to compute the\n    \/\/ correct number of `r`-length strings.\n    type n = (m + 2) \/^ r\n    \/\/ Step 3. `c` is a parameter for this module.\n    \/\/ Step 4. Ps = P_0, ..., P_{n-1}.\n    Ps = split P : [n][r]\n    \/\/ Step 5.\n    S = zero : [b]\n    \/\/ Step 6. We create a list `Ss` instead of overwriting the variable `S`.\n    Ss = [S] # [Keccak_p (S' ^ (Pi # (zero : [c]))) | Pi <- Ps | S' <- Ss]\n    \/\/ Steps 7 - 10. This step is sometimes known as \"squeeze\".\n    \/\/ The truncation in Step 8 is handled here with `take`{r}`\n    \/\/ The truncation in Step 9 is below with `take`{front=d, back=inf}`.\n    extend : [b] -> [inf]\n    extend Z = (take`{r} Z) # extend (Keccak_p Z)\n    digest = take`{front=d, back=inf} (extend (Ss ! 0))\n\nprivate\n    \/**\n     * Rate parameter for the sponge construction.\n     * [FIPS-202] Section 4.\n     *\/\n    type r = b - c\n\n    \/**\n     * State width of the permutation.\n     * [FIPS-202] Section 3.1.\n     *\/\n    type w = b \/ 25\n\n    \/**\n     * The binary logarithm of the lane size; used to determine the size of\n     * the round constant.\n     * [FIPS-202] Section 3.1.\n     *\/\n    type ell = lg2 w\n\n    \/**\n     * State for Keccak-p[b, nr], represented as an array.\n     * [FIPS-202] Section 3.1.\n     *\/\n    type State = [5][5][w]\n\n    \/**\n     * Convert a string into a state array.\n     * [FIPS-202] Section 3.1.2.\n     *\n     * Note: The spec describes this in terms of all three coordinates\n     * `(x, y, z)`. Since the lanes determined by a pair `(x, y)` are composed\n     * of consecutive bits, we don't index into them separately; instead, we\n     * separate `S` into 25 lanes of length `w` and then place those lanes in\n     * the correct order according to the `(x, y)` coordinates.\n     * For ease of implementation of the subsequent step mappings, the bits of\n     * each lane are reversed.\n     *\/\n    unflatten : [b] -> State\n    unflatten S = [[ Lanes@((5 * y + x))\n        | y <- [0..4]]\n        | x <- [0..4]] where\n        Lanes = map reverse (split`{25} S)\n\n    \/**\n     * Convert a string into a state array, but without indexing.\n     * Equivalent to [FIPS-202] Section 3.1.2.\n     *\/\n    unflatten_noindex : [b] -> State\n    unflatten_noindex S = transpose (groupBy (reverse (groupBy`{w} (reverse S))))\n\n    \/**\n     * ```repl\n     * :prove unflattens_match\n     * ```\n     *\/\n    property unflattens_match S = unflatten S == unflatten_noindex S\n\n    \/**\n     * Convert a state array into a string.\n     * [FIPS-202] Section 3.1.3.\n     *\/\n    flatten : State -> [b]\n    flatten A = S where\n        \/\/ No explicit appending or joining is needed to compute the Lanes.\n        \/\/ But we do need to accomodate the lane reversal that happened in the\n        \/\/ inverse `unflatten` function.\n        Lanes = [[ reverse (A@i@j)\n            | j <- [0..4]]\n            | i <- [0..4]]\n        Planes = [ Lanes@0@j # Lanes@1@j # Lanes@2@j # Lanes@3@j # Lanes@4@j\n            | j <- [0..4]]\n        S = join Planes\n\n    \/**\n     * Convert a state array into a string, but without indexing.\n     * Equivalent to [FIPS-202] Section 3.1.3.\n     *\/\n    flatten_noindex : State -> [b]\n    flatten_noindex A = reverse (join (reverse (join (transpose A))))\n\n    \/**\n     * ```repl\n     * :prove flattens_match\n     * ```\n     *\/\n    property flattens_match A = flatten A == flatten_noindex A\n\n    \/**\n     * One of the step mappings that's part of a round of Keccak-p.\n     *\n     * The effect of this mapping is to XOR each bit in the state with the\n     * parity of two columns in the array. `C` computes the parities, `D`\n     * combines two of the parities for each column, and `A'` completes the\n     * transformation.\n     * [FIPS-202] Section 3.2.1.\n     *\/\n    \u03b8 : State -> State\n    \u03b8 A = A' where\n        C = [ A@x@0 ^ A@x@1 ^ A@x@2 ^ A@x@3 ^ A@x@4\n            | x <- [0..4]]\n        D = [ C @ ((x - 1) % 5) ^ (C @ ((x + 1) % 5) <<< 1)\n            | x <- [0..4]]\n        A' = [[ A@x@y ^ D@x\n            | y <- [0..4]]\n            | x <- [0..4] ]\n\n    \/**\n     * One of the step mappings that's part of a round of Keccak-p.\n     *\n     * The effect of this mapping is to rotate the bits of each lane by a\n     * an _offset_ (computed in `set_lane`) that depends on the `x` and `y`\n     * coordinates of that lane.\n     * [FIPS-202] Section 3.2.2.\n     *\/\n    \u03c1 : State -> State\n    \u03c1 A = A' where\n        \/\/ Step 1.\n        A1 = [[ if (x == 0) && (y == 0) then A@0@0 else zero\n            | y <- [0..4]]\n            | x <- [0..4]]\n                As = [((1,0), A1)] #\n            [ ((y, (2*x + 3*y) % 5), set_lane x y t Ai)\n            | ((x, y), Ai) <- As\n            | t <- [0..23]]\n        (_, A') = As ! 0\n\n        \/\/ Step 3a. Update the lane defined by x' and y'.\n        set_lane x' y' t Ai = [[\n            if (x' == x) && (y' == y) then A@x@y <<< ((t+1)*(t+2)\/2)\n            else Ai@x@y\n            | y <- [0..4]]\n            | x <- [0..4]]\n\n    \/**\n     * Optimized and hard-coded version of `\u03c1`.\n     *\n     * This optimizes the hard-codable parts of `\u03c1` in the following ways:\n     * - Pre-computes the offsets `(t+1)*(t+2) \/ 2`\n     * - Pre-computes the corresponding sequence of lane indexes (e.g. the\n     *   series defined by `(y, (2x + 3y) % 5))`\n     * - Re-orders the offsets and the lane indexes to be in the same order\n     *   that we get if we iterate over the lanes generated by `join A` (e.g.\n     *   (0,0), (0,1), (0,2), ...)\n     * - Maps directly over A, rotating each lane by the expected offset,\n     *   instead of iteratively updating the lanes\n     *\n     * This provides a 2x speedup.\n     *\n     * Equivalent to [FIPS-202] Section 3.2.2, Algorithm 2.\n     *\/\n    \u03c1_hardcoded : State -> State\n    \u03c1_hardcoded A = A' where\n        A' = groupBy [ a <<< offset | a <- join A | offset <- t_offsets]\n\n        \/\/ This is technically equivalent to Table 2, but we index in the\n        \/\/ \"normal\" way e.g. the top-left corner is (0, 0) and the bottom-right\n        \/\/ is (4, 4), unlike the the table.\n        \/\/ We also write these in hex instead of base-10.\n        t_offsets = [\n            0x000, 0x024, 0x003, 0x069, 0x0d2,\n            0x001, 0x12c, 0x00a, 0x02d, 0x042,\n            0x0be, 0x006, 0x0ab, 0x00f, 0x0fd,\n            0x01c, 0x037, 0x099, 0x015, 0x078,\n            0x05b, 0x114, 0x0e7, 0x088, 0x04e\n        ]\n\n    \/**\n     * Prove that the hardcoded version of `\u03c1` is correct.\n     * ```repl\n     * :prove hardcoded_rho_is_correct\n     * ```\n     *\/\n    property hardcoded_rho_is_correct A = \u03c1 A == \u03c1_hardcoded A\n\n    \/**\n     * One of the step mappings that's part of a round of Keccak-p.\n     *\n     * The effect of this mapping is to rearrange the position of the lanes,\n     * based on an offset of the `x` and `y` coordinates.\n     * [FIPS-202] Section 3.2.3.\n     *\/\n    \u03c0 : State -> State\n    \u03c0 A = [[ A @((x + 3 * y) % 5) @x\n        | y <- [0..4]]\n        | x <- [0..4]]\n\n    \/**\n     * One of the step mappings that's part of a round of Keccak-p.\n     *\n     * The effect of this mapping is to XOR each bit with a non-linear function\n     * of two other bits in its row.\n     * [FIPS-202] Section 3.2.4.\n     *\n     * Note: in the first line, XOR 1 on a single bit is equivalent to bitwise\n     * NOT. Since we operate over the whole slice defined by each z-coordinate,\n     * it's nicer to use `~`. You can see the NOT gates in Figure 6.\n     *\/\n    \u03c7 : State -> State\n    \u03c7 A = [[ A @x @y ^ (~A @((x + 1) % 5) @y && A @((x + 2) % 5) @y)\n        | y <- [0..4]]\n        | x <- [0..4]]\n\n    \/**\n     * Compute the round constant for the `t`th lane.\n     *\n     * [FIPS-202] Section 3.2.5, Algorithm 5.\n     *\/\n    rc : Integer -> Bit\n    rc t = if (t % 255) == 0 then 1 \/\/ Step 1.\n         else Rs @ (t') @0          where\n                          Rs = [0b10000000] # [lfsr R | R <- Rs ]\n             \/\/ Step 3. Linear feedback shift register.\n             \/\/ The truncation in step f is done manually in the return value.\n             lfsr : [8] -> [8]\n             lfsr Rin = [R0, R@1, R@2, R@3, R4, R5, R6, R@7]\n                 where\n                     R = 0b0 # Rin\n                     R0 = R@0 ^ R@8\n                     R4 = R@4 ^ R@8\n                     R5 = R@5 ^ R@8\n                     R6 = R@6 ^ R@8\n             \/\/ Cryptol's SMT interface disallows index by symbolic `Integer`.\n             \/\/ To faciliate proofs, we convert to a bitvector.\n             \/\/ Justification: for all integers i,\n             \/\/ (i % 255) % 256 == (i % 255)\n             t' = fromInteger (t % 255) : [8]\n\n    \/**\n     * Hardcode the round constant values.\n     *\n     * Since the `rc` function doesn't depend on any of the functor parameters,\n     * this hardcoded value is correct for all instantiations.\n     * We computed the value `constants` with:\n     * ```cryptol\n     * [rc i | i <- [0..255]]\n     * ```\n     *\n     * This provides a 4x speedup.\n     *\n     * Equivalent to [FIPS-202] Section 3.2.5, Algorithm 5.\n     *\/\n    rc_hardcoded : Integer -> Bit\n    rc_hardcoded t = constants @ (t') where\n        constants = join [\n            0x80b1e87f90a7d57062b32fde6ee54a25,\n            0xa339e361175edf0d35b504ec9303a471\n        ]\n        \/\/ Cryptol's SMT interface disallows index by symbolic `Integer`.\n        \/\/ To faciliate proofs, we convert to a bitvector.\n        \/\/ Justification: for all integers i,\n        \/\/ (i % 255) % 256 == (i % 255)\n        t' = fromInteger (t % 255) : [8]\n\n    \/*\n     * Some properties justifying the conversion of `Integer -> [8]`\n     * in `rc` and `rc_hardcoded`\n     *\/\n    private\n        \/**\n        * A fact about modular arithmetic:\n        *   For any integers `i`, `m`, `n`, such that `m > 0` and `m < n`,\n        *   `i mod m mod n == i mod m`\n        *   I.e., the modular reduction is equivalent to the smaller modulus.\n        *\/\n        index_eq: {ix} (Integral ix, Cmp ix, Literal 0 ix) => ix -> ix -> ix -> Bit\n        index_eq i m n = m > 0 ==> m <= n ==> (i % m) % n == (i % m)\n\n        \/**\n        * An instance of the fact above for Cryptol `Integer`.\n        * ```repl\n        * :prove index_eq_int\n        * ```\n        *\/\n        property index_eq_int = index_eq `{Integer}\n\n        \/**\n        * A consequence of the property above is that reducing an integer\n        * mod 255 and then converting it to an `[8]` is always in `Z 255`.\n        * ```repl\n        * :prove value_bound\n        * ```\n        *\/\n        value_bound: Integer -> Bit\n        property value_bound i = (fromInteger (i % 255) : [8]) < 255\n\n    \/**\n     * Prove that the hardcoded round constants are correct.\n     * ```repl\n     * :prove round_constants_correctly_hardcoded\n     * ```\n     *\/\n    property round_constants_correctly_hardcoded t = rc_hardcoded t == rc t\n\n    \/**\n     * One of the step mappings that's part of a round of Keccak-p.\n     *\n     * The effect is to modify some of the bits of the Lane defined by\n     * `(0, 0)` according to the round index.\n     * [FIPS-202] Section 3.2.5, Algorithm 6.\n     *\/\n    \u03b9 : State -> Integer -> State\n    \u03b9 A ir = A'' where\n        \/\/ Step 1.\n        A' = A\n        \/\/ Step 2.\n        RC0 = zero : [w]\n        \/\/ Step 3. 0 is the identity for XOR, so we iteratively set the\n        \/\/ `2^j-1`th element by XORing the previously-set bits of RC with the\n        \/\/ correct value at the desired index.\n        RCs = [RC0] # [RC' ^ (zext`{w} [rc_hardcoded (toInteger j + 7 * ir)] << (2^^j - 1))\n            | RC' <- RCs\n            | j <- [0..ell] ]\n        RC = (RCs ! 0) : [w]\n                A'' = [[ if (x == 0) && (y == 0) then A'@0@0 ^ RC else A'@x@y\n            | y <- [0..4]]\n            | x <- [0..4]]\n\n    \/**\n     * Padding rule `pad10*1`.\n     *\n     * This function produces padding e.g. a string with an appropriate length\n     * to append to another string.\n     * [FIPS-202] Section 5.1.\n     *\n     * Note: The spec says the output length is a positive multiple of `x` and\n     * defines it to be, basically: `(- m - 2) mod x + 2`. We can't encode this\n     * exactly as-is in the type signature because Cryptol doesn't support\n     * negative numbers in types (`-m`). Instead, we do the following:\n     *      (m + 2)           : The minimum length of the original message and\n     *                        : the padding\n     *      (m + 2) \/^ x      : The multiplier of `x` that determines the\n     *                        : ultimate length of the message + padding\n     * x * ((m + 2) \/^ x)     : The total length of the message + padding\n     * x * ((m + 2) \/^ x) - m : The total length of the padding alone\n     *\/\n    pad : {x, m} (fin x, fin m, x >= 1) => [x * ((m + 2) \/^ x) - m]\n    pad = [1] # zero # [1]\n\n    \/**\n     * The Keccak-p[b, nr] permutation.\n     * [FIPS-202] Section 3.3, Algorithm 7.\n     *\/\n    Keccak_p : [b] -> [b]\n    Keccak_p S = S' where\n        \/\/ The round transformation is defined in [FIPS-202] Section 3.3.\n        Rnd A ir = \u03b9 (\u03c7 (\u03c0 (\u03c1_hardcoded (\u03b8 A)))) ir\n\n        \/\/ Step 1.\n        A0 = unflatten_noindex S\n        \/\/ Step 2.\n        \/\/ The round index `ir` is allowed to be negative, but Cryptol types\n        \/\/ must be non-negative. Thus we iterate over the number of rounds and\n        \/\/ compute the round index as a value, rather than a type.\n        As = [A0] # [ Rnd A ir where\n                ir = 12 + 2 * `ell - r\n            | A <- As\n            | r <- [nr, nr - 1 .. 1]]\n        \/\/ Step 3.\n        S' = flatten_noindex (As ! 0)\n\n    \/**\n     * Keccak-f family of permutations.\n     *\n     * This specializes `Keccak-p` to the case where `nr = 12 + 2*ell`; we\n     * enforce this in the type constraint on this function.\n     * [FIPS-202] Section 3.4.\n     *\/\n    Keccak_f : (nr == 12 + 2 * ell) => [b] -> [b]\n    Keccak_f = Keccak_p\n\n\/**\n * See https:\/\/keccak.team\/files\/Keccak-reference-3.0.pdf, Section 1.2\n * ```repl\n * :prove unflatten_correct\n * ```\n *\/\nunflatten_correct : [12] -> [12] -> [12] -> [b] -> Bit\nproperty unflatten_correct x y z p =\n    x < 5 ==> y < 5 ==> z < (`w:[12]) ==>\n    p@((5*y + x)*`w + z) == unflatten p @ x @ y ! z\n\n\/**\n * Flatten and unflatten must be each other's inverses.\n * ```repl\n * :prove flatten_correct\n * ```\n *\/\nproperty flatten_correct s = unflatten (flatten s) == s\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/SHA3.cry","filetype":"cry","content":"module Primitive::Keyless::Hash::SHA3::SHA3 where\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\nimport Primitive::Keyless::Hash::SHA3::Specification where\n    type b = 1600\n    type nr = 24\n    type c = 2 * digest\n\nparameter\n    \/**\n     * Digest length -- that is, the length of the output of the hash function.\n     *\n     * The spec allows the 5 FIPS-approved digest lengths : 160, 224, 256, 384,\n     * and 512 bits. The constraint here is looser than that requirement; the\n     * restriction that 8 divides the digest length is to allow the byte-wise\n     * `hashBytes` function.\n     *\/\n    type digest : #\n    type constraint (fin digest, digest % 8 == 0, digest >= 224, digest <= 512)\n\n\/**\n * Length of the hash digest.\n *\n * This is made public to instantiate the `HashInterface`.\n *\/\ntype DigestLength = digest\n\n\/**\n * There is no upper bound on the message length for SHA3 hashes.\n *\/\ntype MessageUpperBound = inf\n\n\/**\n * Security strength (in bits) of the hash function.\n * [FIPS-202] Appendix A.1, Table 4.\n * @see Hash functions webpage: https:\/\/csrc.nist.gov\/projects\/hash-functions#security-strengths\n *\n * This is made public to instantiate the `HashInterface`.\n *\/\ntype SecurityStrength = DigestLength \/ 2\n\n\/**\n * SHA-3 hash function specification.\n * [FIPS-202] Section 6.1.\n *\n * Note that the specification of `c` is above, in the instantiation of the\n * `Keccak` module.\n *\n * This expects input and produces output in the bit ordering used by the\n * `Keccak` spec, where bytes are in MSB order and the bits in each byte are\n * in LSB order. Use the `KeccakBitOrdering::toBytes` function to transform\n * the input and output to Cryptol-standard MSB order\n *\/\nsha3 : {n} (fin n) => [n] -> [digest]\nsha3 M = Keccak`{d=digest} (M # 0b01)\n\n\/**\n * SHA-3 hash function specification.\n * [FIPS-202] Section 6.1.\n *\n * Note that the specification of `c` is above, in the instantiation of the\n * `keccak` module.\n *\n * This expects input and output in MSB order. It handles conversion to and\n * from the bit ordering expected by `Keccak`. If input is provided in the\n * format described in [FIPS-202] Appendix B (a hex string with an even\n * number of digits and an actual length `n`), use the `KOB::truncate` function\n * to get the correct input.\n *\/\nhash : {n} (fin n) => [n] -> [digest]\nhash M = KBO::reverseBitOrdering (Keccak`{d=digest} ((KBO::reverseBitOrdering M) # 0b01))\n\n\/**\n * SHA-3 hash function specification over byte-delimited inputs.\n *\n * This expects input and output in MSB order. It handles conversion to and\n * from the bit ordering expected by `Keccak`. If input is provided in the\n * format described in [FIPS-202] Appendix B (a hex string with an even\n * number of digits and an actual length `n`), use the `KOB::truncate` function\n * to get the correct input.\n *\/\nhashBytes : {m} (fin m) => [m][8] -> [digest \/ 8][8]\nhashBytes M = split (hash (join M))\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA1\/Specification.cry","filetype":"cry","content":"module Primitive::Keyless::Hash::SHA1::Specification where\n\n\/**\n* `l` is the length of the message in bits.\n* For SHA1, `l` < 2 ^^ 64.\n*\n* References:\n* Sections 1, 2.2.1 [FIPS-180-4]\n*\/\ntype constraint ValidMessageLength l = (l < 2 ^^ 64)\n\n\/**\n* `w` is the number of bits in a word.\n* The word size for SHA1 is `32`.\n*\n* References:\n* Sections 1 Figure 1, 2.2.1 [FIPS-180-4]\n*\n*\/\ntype w = 32\n\n\/**\n * `m` is the number of bits in a message block.\n * The block size for SHA1 is `512`.\n *\n * References:\n # Section 1 Figure 1 [FIPS-180-4]\n *\/\ntype m = 512\n\n\/**\n * `BlockSize` is a convenient alias for `m`.\n *\/\ntype BlockSize = m\n\n\/**\n * The message digest size for SHA1 is `160` bits.\n *\n * References:\n # Section 1 Figure 1 [FIPS-180-4]\n *\/\ntype DigestSize = 160\n\n\/**\n * Compute SHA1 over a bit string of valid length.\n *\/\nhash: {l} (ValidMessageLength l) => [l] -> [DigestSize]\nhash M = sha1 M\n\n\/**\n * Many applications have a byte oriented interface to\n * SHA1. Define it for the user's convenience.\n *\/\nhashBytes: {l} (ValidMessageLength (8 * l)) => [l][8] -> [DigestSize \/ 8][8]\nhashBytes M = groupBy`{8} (hash (join M))\n\nprivate\n\n  \/**\n   * `ROTL^n` is left rotation by `n`.\n   *\/\n  ROTL: {n} (n < w) => [w] -> [w]\n  ROTL x = x <<< `n\n\n  \/**\n   * `Ch` is a function on three words.\n   * Its abbreviation is not expanded, however, it\n   * could be appropriately called \"choose\".\n   *\n   * References:\n   * Section 4.1.1 [FIPS-180-4]\n   *\/\n  Ch: [w] -> [w] -> [w] -> [w]\n  Ch x y z = (x && y) ^ (~x && z)\n\n  \/**\n   * `Parity` is a function on three words.\n   *\n   * References:\n   * Section 4.1.1 [FIPS-180-4]\n   *\/\n  Parity: [w] -> [w] -> [w] -> [w]\n  Parity x y z = x ^ y ^ z\n\n  \/**\n   * `Maj` is a function on three words.\n   * Its abbreviation is not expanded, however, it\n   * could be appropriately called \"majority vote\".\n   *\n   * References:\n   * Section 4.1.1 [FIPS-180-4]\n   *\/\n  Maj: [w] -> [w] -> [w] -> [w]\n  Maj x y z = (x && y) ^ (x && z) ^ (y && z)\n\n  \/**\n   * SHA1 is composed of `80` functions `f_t`.\n   * Each `f_t` is one of the functions `Ch`,\n   * `Maj`, or `Parity` depending on `t`.\n   *\n   * References:\n   * Section 4.1.1 [FIPS-180-4]\n   *\/\n  f: {t} (t <= 79) => [w] -> [w] -> [w] -> [w]\n  f x y z | t <= 19 => Ch x y z\n          | t <= 39 => Parity x y z\n          | t <= 59 => Maj x y z\n          | t <= 79 => Parity x y z\n\n  \/**\n   * SHA1 uses `80` constants parameterized by `t`.\n   *\n   * References:\n   * Section 4.2.1 [FIPS-180-4]\n   *\/\n  K: {t} (t <= 79) => [w]\n  K | t <= 19 => 0x5a827999\n    | t <= 39 => 0x6ed9eba1\n    | t <= 59 => 0x8f1bbcdc\n    | t <= 79 => 0xca62c1d6\n\n  \/**\n    * Number of bits used to encode the length of the message for padding.\n    * [FIPS-180-4] Section 5.1. This definition was taken verbatim\n    * from the SHA2 cryptol specification.\n    *\/\n  type LengthBits = 2 * w\n\n  \/**\n    * Number of blocks needed to hold the padded version of a message of length L.\n    * [FIPS-180-4] Section 5.1. This definition was taken verbatim\n    * from the SHA2 cryptol specification.\n    *\/\n  type NumBlocks L = (L + 1 + LengthBits) \/^ BlockSize\n\n  \/**\n    * Deterministically pad a message to a multiple of the block size.\n    *\n    * [FIPS-180-4] Section 5.1.1 and 5.1.2.\n    *\n    * The constraint is not explicitly noted in Section 5.1, but all\n    * messages to be hashed must not exceed the valid message length.\n    *\n    * This definition was taken verbatim from the SHA2 cryptol specification.\n    *\/\n  pad : {L} (ValidMessageLength L) => [L] -> [NumBlocks L * BlockSize]\n  pad M = M # 0b1 # zero # (`L : [LengthBits])\n\n  \/**\n    * The message and its padding must be parsed into `N` blocks.\n    * [FIPS-180-4] Section 5.2.\n    *\/\n  parse : {N} () => [N * BlockSize] -> [N][BlockSize]\n  parse M = split M\n\n  \/**\n   * Convenience type.\n   *\/\n  type LetterVars = ([w], [w], [w], [w], [w])\n\n  \/**\n   * The initial hash value for SHA1 is described in\n   * [FIPS-180-4] Section 5.3.1\n   *\/\n  H0: LetterVars\n  H0 = (  0x67452301\n        , 0xefcdab89\n        , 0x98badcfe\n        , 0x10325476\n        , 0xc3d2e1f0\n        )\n\n  \/**\n   * Computation of SHA1.\n   * The message is padded and parsed.\n   * Then each block is mixed with the mixing function, updating the\n   * intermdiate hash. When all blocks have been processed, the final\n   * state is the hash of the message.\n   *\/\n  sha1: {l} (ValidMessageLength l) => [l] -> [DigestSize]\n  sha1 M = h0 # h1 # h2 # h3 # h4\n    where\n      \/\/ Step 1: The message is padded and parsed.\n      M_t = parse (pad M)\n      \/\/ Step 2: Each block is processed in order.\n      \/\/ The final message digest is the output.\n      (h0, h1, h2, h3, h4) = foldl sha1Block H0 M_t\n\n  \/**\n   * The SHA1 message schedule is recursively defined in terms of the\n   * `w` words that make up the message block.\n   *\n   * References:\n   * [FIPS-180-4] Section 6.1.2 Part 1\n   *\/\n  messageSchedule: [BlockSize] -> [80][w]\n  messageSchedule M_t = W\n    where\n      W = (groupBy `{w} M_t) # [\n          ROTL `{1} (W@(t-3) ^ W@(t-8) ^ W@(t-14) ^ W@(t-16))\n          | t <- [16..79]\n          ]\n\n  \/**\n   * The SHA1 hash state is iteratively mixed\n   * according to the following formula.\n   *\n   * References:\n   * [FIPS-180-4] Section 6.1.2 Part 3\n   *\/\n  mixOne: {t} (t <= 79) => LetterVars -> [w] -> LetterVars\n  mixOne (a, b, c, d, e) W_t = (a', b', c', d', e')\n    where\n      T = ROTL `{5} a + f `{t} b c d + e + K `{t} + W_t\n      e' = d\n      d' = c\n      c' = ROTL `{30} b\n      b' = a\n      a' = T\n\n  \/**\n   * The SHA1 hash state is mixed over `t` ranging\n   * from `0` to `79` inclusive. This implementation\n   * is meant to be evocative of a \"for loop\" or `foldl`,\n   * but also tracks the type information `t`.\n   *\n   * References:\n   * [FIPS-180-4] Section 6.1.2 Part 3\n   *\/\n  mix: {t} (t <= 79) => LetterVars -> [80][w] -> LetterVars\n  mix h W | t < 79 => mix `{t + 1} (mixOne `{t} h (W@`t)) W\n          | t == 79 => mixOne `{t} h (W@`t)\n\n  \/**\n   * SHA1 hashes computed over a state of `5` `32` bit words.\n   * Each `m` bit block is processed in-order.\n   * This function computes SHA1 on one block.\n   *\n   * References:\n   * [FIPS-180-4] Section 6.1.2\n   *\/\n  sha1Block: LetterVars -> [BlockSize] -> LetterVars\n  sha1Block (h0, h1, h2, h3, h4) M_t = (a + h0, b + h1, c + h2, d + h3, e + h4)\n    where\n      W = messageSchedule M_t\n      (a, b, c, d, e) = mix `{0} (h0, h1, h2, h3, h4) W\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/SHA384.cry","filetype":"cry","content":"module Primitive::Keyless::Hash::SHA2Internal::SHA384 = Primitive::Keyless::Hash::SHA2Internal::SHA where\n\ntype wp = 64\n\ntype digest_size = 384\n\ntype j = 80\n\nH0 = [ 0xcbbb9d5dc1059ed8, 0x629a292a367cd507, 0x9159015a3070dd17, 0x152fecd8f70e5939,\n       0x67332667ffc00b31, 0x8eb44a8768581511, 0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4]\n\nK = [ 0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n      0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n      0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n      0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n      0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n      0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n      0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n      0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n      0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n      0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n      0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n      0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n      0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n      0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n      0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n      0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n      0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n      0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n      0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n      0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817]\n\nSIGMA_0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA_1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma_0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma_1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/SHA256.cry","filetype":"cry","content":"module Primitive::Keyless::Hash::SHA2Internal::SHA256 = Primitive::Keyless::Hash::SHA2Internal::SHA where\n\ntype wp = 32\n\ntype digest_size = 256\n\ntype j = 64\n\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]\n\nSIGMA_0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nSIGMA_1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\nsigma_0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\nsigma_1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/Equivalence.cry","filetype":"cry","content":"\/**\n * Properties demonstrating equivalence of the spec-adherent `SHA2`\n * implementation and the alternative `SHA2Internal` implementation.\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA2Internal::Equivalence where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA_256\nimport Primitive::Keyless::Hash::SHA2Internal::SHA256 as SHAI_256\n\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 as SHA_384\nimport Primitive::Keyless::Hash::SHA2Internal::SHA384 as SHAI_384\n\n\/**\n * The `internal` version of SHA256 matches the spec-adherent version.\n * ```repl\n * :exhaust sha256ImplsAreEquivalent`{10}\n * :check sha256ImplsAreEquivalent`{256}\n * ```\n *\/\nsha256ImplsAreEquivalent : {m} (fin m, width m <= SHA_256::MessageUpperBound) => [m] -> Bit\nproperty sha256ImplsAreEquivalent m = SHA_256::hash m == SHAI_256::sha m\n\n\/**\n * The byte-wise APIs for the two SHA256 implementations match.\n * ```repl\n * :exhaust sha256BytewiseImplsAreEquivalent`{1}\n * :check sha256BytewiseImplsAreEquivalent`{256}\n * ```\n *\/\nsha256BytewiseImplsAreEquivalent : {m} (fin m, width (8 * m) <= SHA_256::MessageUpperBound) => [m][8] -> Bit\nproperty sha256BytewiseImplsAreEquivalent m = join (SHA_256::hashBytes m) == SHAI_256::SHAImp m\n\n\/**\n * The `internal` version of SHA384 matches the spec-adherent version.\n * ```repl\n * :exhaust sha384ImplsAreEquivalent`{10}\n * :check sha384ImplsAreEquivalent`{256}\n * ```\n *\/\nsha384ImplsAreEquivalent : {m} (fin m, width m <= SHA_384::MessageUpperBound) => [m] -> Bit\nproperty sha384ImplsAreEquivalent m = SHA_384::hash m == SHAI_384::sha m\n\n\/**\n * The byte-wise APIs for the two SHA384 implementations match.\n * ```repl\n * :exhaust sha384BytewiseImplsAreEquivalent`{1}\n * :check sha384BytewiseImplsAreEquivalent`{256}\n * ```\n *\/\nsha384BytewiseImplsAreEquivalent : {m} (fin m, width (8 * m) <= SHA_384::MessageUpperBound) => [m][8] -> Bit\nproperty sha384BytewiseImplsAreEquivalent m = join (SHA_384::hashBytes m) == SHAI_384::SHAImp m\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/SHA.cry","filetype":"cry","content":"module Primitive::Keyless::Hash::SHA2Internal::SHA where\n\nimport Array\nimport Common::ByteArray\n\nsha : {L} (2 * w >= width L) => [L] -> [digest_size]\nsha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))\n\nparameter\n\n  \/** Word size\n    Specifications are based on word size w, rather than digest size (8 * w)\n    or block size (m == 16 * w), in order to avoid confusing Cryptol's type\n    constraint verifier with integer division.\n  *\/\n\n  type wp : #\n  type constraint (fin wp, wp >= 2, 32 >= width wp)\n\n  type digest_size : #\n  type constraint (fin digest_size, 8*wp >= digest_size)\n\n  \/** The number of iterations in the hash computation\n  (i.e. the number of words in K) *\/\n\n  type j : #\n  type constraint (fin j, j >= 17)\n\n  H0 : [8][wp]\n  K  : [j][wp]\n\n  \/* FIPS 180-4 defines lowercase and uppercase\n      (respective to the Greek alphabet) sigma functions for SHA-256 and SHA-512.\n      (4.4)-(4.7) SHA-224, SHA-256 (w==32)\n      (4.10)-(4.13) SHA-384, SHA-512, SHA-512\/224, SHA-512\/256 (w==64) *\/\n\n  SIGMA_0 : [wp] -> [wp]\n  SIGMA_1 : [wp] -> [wp]\n  sigma_0 : [wp] -> [wp]\n  sigma_1 : [wp] -> [wp]\n\n\/\/ Export some of the parameters\nSHAH0 = H0\nS0 = SIGMA_0\nS1 = SIGMA_1\ns0 = sigma_0\ns1 = sigma_1\ntype digestSize = digest_size\n\n\/**\n * The security strength of a hash function is the minimum of its collision\n * resistance strength, preimage resistance strength, and second preimage\n * resistance strength. For the SHA2 family of hash functions, the smallest\n * of these is the collision resistance strength.\n *\n * [SP-800-107r1] Section 4.2, Table 1.\n *\/\ntype securityStrength = digest_size \/ 2\n\n\/\/ Export Ch, Maj and the block function to be used in SAW proofs\n\/** (4.1) (w==32), (4.2) (w==32), (4.8) (w==64) *\/\nCh : [wp] -> [wp] -> [wp] -> [wp]\nCh x y z = (x && y) ^ (~x && z)\n\n\n\/** (4.1) (w==32), (4.3) (w==32), (4.9) (w==64) *\/\nMaj : [wp] -> [wp] -> [wp] -> [wp]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nprocessBlock_Common : [8][wp] -> [16][wp] -> [8][wp]\nprocessBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)\n\n\nprivate\n  type w = wp\n\n  \/** block size corresponding to word size for all SHA algorithms in\n      FIPS 180-4 *\/\n  type block_size = 16 * w\n\n  type num_blocks L     = (L+1+2*w) \/^ block_size\n  type padded_size L    = num_blocks L * block_size\n\n\n  \/**\n    5.1 Padding the Message\n    5.1.1 SHA-1, SHA-224 and SHA-256 (w==32)\n    5.1.2 SHA-384, SHA-512, SHA-512\/224 and SHA-512\/256 (w==64)\n\n  The constraint ensure that the message size, `L`, fits within a\n  (2 * w)-bit word (consistent w\/ Figure 1)\n  *\/\n  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]\n  pad M = M # 0b1 # zero # (`L : [2*w])\n\n  \/**\n    5.2 Parsing the Message\n    5.2.1 SHA-1, SHA-224 and SHA-256 (w==32)\n    5.2.2 SHA-384, SHA-512, SHA-512\/224 and SHA-512\/256 (w==64)\n  *\/\n  parse : {m} [m * block_size] -> [m][block_size]\n  parse = split\n\n  \/**\n  SHA-256 and SHA-512 (and their respective derivatives) use a similar\n  message schedule that can be expressed in the same way relative to their\n  respective sigma functions.\n\n    6.2.2 SHA-256 Hash Computation (w==32, j=64)\n    6.4.2 SHA-512 Hash Computation (w==64, j=80)\n  *\/\n  messageSchedule_Common : [16][w] -> [j][w]\n  messageSchedule_Common Mi = take W\n    where\n    W : [inf][_]\n    W = Mi # [ w1 + s0 w2 + w3 + s1 w4\n             | w1 <- W\n             | w2 <- drop`{1} W\n             | w3 <- drop`{9} W\n             | w4 <- drop`{14} W\n             ]\n\n\n  \/**\n  Amazon S2N's SHA-256 specification includes a compression routine intended\n  to reflect typical implementations.  This same compression routine applies\n  to SHA-512, modulo respective constants, sigma functions,\n  and message schedules.\n  *\/\n\n  compress_Common : [8][w] -> [j][w] -> [8][w]\n  compress_Common H W =\n        [ (as ! 0) + (H @ 0),\n      (bs ! 0) + (H @ 1),\n      (cs ! 0) + (H @ 2),\n      (ds ! 0) + (H @ 3),\n      (es ! 0) + (H @ 4),\n      (fs ! 0) + (H @ 5),\n      (gs ! 0) + (H @ 6),\n      (hs ! 0) + (H @ 7)\n    ]\n    where\n      T1 = [h + S1 e + Ch e f g + k_t + w_t\n                | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]\n      T2 = [ S0 a + Maj a b c | a <- as | b <- bs | c <- cs]\n      hs = take`{j + 1}([H @ 7] # gs)\n      gs = take`{j + 1}([H @ 6] # fs)\n      fs = take`{j + 1}([H @ 5] # es)\n      es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])\n      ds = take`{j + 1}([H @ 3] # cs)\n      cs = take`{j + 1}([H @ 2] # bs)\n      bs = take`{j + 1}([H @ 1] # as)\n      as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n\n  SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]\n  SHA_2_Common' blocks = hash ! 0\n    where\n    hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ SHA imperative specification\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/*\n * This section contains an SHA specification that more closely matches the\n * BoringSSL C implementation to simplify SAW correctness proofs of the\n * implementation.\n *\/\n\n\/\/\/\/\/\/\/\/ Imperative top level \/\/\/\/\/\/\/\/\n\ntype SHAState = { h : [8][w]\n                , block : [w * 2][8]\n                , n : [32]\n                , sz : [w * 2]\n                }\n\n\/\/ Initial state for SHA\nSHAInit : SHAState\nSHAInit = { h = H0\n          , block = zero\n          , n = 0\n          , sz = 0\n          }\n\n\/\/ Process message being hashed, iteratively updating the SHA state with the\n\/\/ input message.\nSHAUpdate : {n} (fin n) => SHAState -> [n][8] -> SHAState\nSHAUpdate sinit bs = ss!0\n  where ss = [sinit] # [ SHAUpdate1 s b | s <- ss | b <- bs ]\n\n\/\/ Add padding and size and process the final block.\nSHAFinal : SHAState -> [digest_size]\nSHAFinal s = take (join (processBlock_Common h b'))\n  \/\/ Because the message is always made up of bytes, and the size is a\n  \/\/ fixed number of bytes, the 1 pad will always be at least a byte.\n  where s' = SHAUpdate1 s 0x80\n        \/\/ Don't need to add zeros. They're already there. Just update\n        \/\/ the count of bytes in this block. After adding the 1 pad, there\n        \/\/ are two possible cases: the size will fit in the current block,\n        \/\/ or it won't.\n        (h, b) = if s'.n <= (`w*2 - (`w\/4)) then (s'.h, s'.block)\n                 else (processBlock_Common s'.h (split (join s'.block)), zero)\n        b' = split (join b || (zero # s.sz))\n\n\/\/ Imperative SHA implementation\nSHAImp : {n} (fin n) => [n][8] -> [digest_size]\nSHAImp msg = SHAFinal (SHAUpdate SHAInit msg)\n\n\nprivate\n\n  \/\/ SHAUpdate1 updates a single byte at position s.n in s.block and return a\n  \/\/ new state to pass to subsequent updates.  If s.n is 128, updates position 0\n  \/\/ to b and zeros the remainder of the block, setting s.n to 1 for the next\n  \/\/ update.\n  SHAUpdate1 : SHAState -> [8] -> SHAState\n  SHAUpdate1 s b =\n    if s.n == (2 * `w - 1)\n      then { h = processBlock_Common s.h (split (join (update s.block s.n b)))\n           , block = zero\n           , n = 0\n           , sz = s.sz + 8\n           }\n      else { h = s.h\n           , block = update s.block s.n b\n           , n = s.n + 1\n           , sz = s.sz + 8\n           }\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ SHA imperative specification - SMT Array\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\ntype SHAState_Array =\n  { h : [8][w]\n  , block : ByteArray\n  , n : [32]\n  , sz : [w * 2]\n  }\n\nSHAInit_Array : SHAState_Array\nSHAInit_Array =\n  { h = H0\n  , block = arrayConstant 0\n  , n = 0\n  , sz = 0\n  }\n\nSHAUpdate_Array : (w >= 32) => SHAState_Array -> ByteArray -> [64] -> SHAState_Array\nSHAUpdate_Array state data len =\n  if state.n != 0\n    then if len < 2 * `w - n\n      then state'\n      else state''\n    else state'''\n where\n   n = 0 # state.n\n   state' = { h = state.h, block = block', n = drop n', sz = state.sz + (0 # len) * 8 }\n    where\n      block' = arrayCopy state.block n data 0 len\n      n' = n + len\n   state'' = { h = h'', block = block''', n = drop n''', sz = state.sz + (0 # len) * 8 }\n    where\n      h' = processBlock state.h (arrayCopy state.block n data 0 (2 * `w - n)) 0\n      block' = arrayCopy state.block n data 0 (2 * `w - n)\n      index' = 2 * `w - n\n      len' = len - (2 * `w - n)\n      (h'', index'', len'') = if len' >= 2 * `w\n        then\n          ( (processBlocks h' (arrayCopy (arrayConstant 0) 0 data index' ((len' \/ (2 * `w)) * (2 * `w))) 0 (len' \/ (2 * `w)))\n          , index' + len' - (len' % (2 * `w))\n          , len' % (2 * `w)\n          )\n        else (h', index', len')\n      (block''', n''') = if len'' != 0\n        then ((arrayCopy block' 0 data index'' len''), len'')\n        else (block', 0)\n   state''' = { h = h'', block = block''', n = drop n''', sz = state.sz + (0 # len) * 8 }\n    where\n      (h'', index'', len'') = if len >= 2 * `w\n        then\n          ( (processBlocks state.h data 0 (len \/ (2 * `w)))\n          , len - (len % (2 * `w))\n          , len % (2 * `w)\n          )\n        else (state.h, 0, len)\n      (block''', n''') = if len'' != 0\n        then ((arrayCopy state.block 0 data index'' len''), len'')\n        else (state.block, n)\n\nSHAFinal_Array : (w >= 32) => SHAState_Array -> [digest_size]\nSHAFinal_Array state = take (join h''')\n  where\n    n = 0 # state.n\n    block' = arrayUpdate state.block n 0x80\n    n' = n + 1\n    (h'', block'', n'') = if n' > 2 * `w - `w \/ 4\n      then ((processBlock state.h (arraySet block' n' 0 (2 * `w - n')) 0), (arraySet block' n' 0 (2 * `w - n')), 0)\n      else (state.h, block', n')\n    h''' = processBlock\n      h''\n      (arrayRangeUpdate\n        (arraySet block'' n'' 0 (2 * `w - `w \/ 4 - n''))\n        (2 * `w - `w \/ 4)\n        (split`{parts=(w+3)\/4} (0 # state.sz)))\n      0\n\n\/\/ Imperative SHA implementation\nSHAImp_Array : (w >= 32) => ByteArray -> [64] -> [digest_size]\nSHAImp_Array msg len = SHAFinal_Array (SHAUpdate_Array SHAInit_Array msg len)\n\n\nprocessBlocks : [8][w] -> ByteArray -> [64] -> [64] -> [8][w]\nprocessBlocks [a, b, c, d, e, f, g, h] data index n = processBlock [a', b', c', d', e', f', g', h'] data index'\n  where\n    (a', b', c', d', e', f', g', h', index') = processBlocksLoop n data a b c d e f g h index\n\nprocessBlock : [8][w] -> ByteArray -> [64] -> [8][w]\nprocessBlock h block index =\n  processBlock_Common h (split (join (arrayRangeLookup block index)))\n\nprocessBlocksLoop : [64] -> ByteArray -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [64] -> ([w], [w], [w], [w], [w], [w], [w], [w], [64])\nprocessBlocksLoop num data a b c d e f g h index = if (index + 2 * `w) < (num * 2 * `w)\n  then processBlocksLoop num data a' b' c' d' e' f' g' h' (index + 2 * `w)\n  else (a, b, c, d, e, f, g, h, index)\n  where\n    [a', b', c', d', e', f', g', h'] = (processBlock [a, b, c, d, e, f, g, h] data index)\n\narrayRangeEqual_arrayRangeLookup_lemma : {n} (fin n, n >= 1, n <= 1000) => ByteArray -> ByteArray -> Bit\narrayRangeEqual_arrayRangeLookup_lemma a b = arrayRangeEqual a 0 b 0 `n == (arrayRangeLookup`{n=n} a 0 == arrayRangeLookup b 0)\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA384.cry","filetype":"cry","content":"\/**\n * Test vectors for SHA384 as specified in [FIPS-180-4].\n *\n * These vectors were originally specified in [CSG-SHA], but we also used the\n * convenient collected test vectors page from David Ireland.\n * @see DI Management https:\/\/www.di-mgt.com.au\/sha_testvectors.html\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\n * [CSG-SHA]: National Institute of Standards and Technology. Example\n *     algorithms - Secure hashing.\n *     @see http:\/\/csrc.nist.gov\/groups\/ST\/toolkit\/examples.html\n *     @see https:\/\/csrc.nist.gov\/csrc\/media\/projects\/cryptographic-standards-and-guidelines\/documents\/examples\/sha_all.pdf\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA384 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 as SHA384\n\n\/**\n * ```repl\n * :prove abcWorks\n * ```\n *\/\nproperty abcWorks = SHA384::hash (join \"abc\") == output where\n    output = join [\n        0xcb00753f45a35e8b, 0xb5a03d699ac65007, 0x272c32ab0eded163,\n        0x1a8b605a43ff5bed, 0x8086072ba1e7cc23, 0x58baeca134c825a7\n    ]\n\n\n\/**\n * ```repl\n * :prove emptyStringWorks\n * ```\n *\/\nproperty emptyStringWorks = SHA384::hash [] == output where\n    output = join [\n        0x38b060a751ac9638, 0x4cd9327eb1b1e36a, 0x21fdb71114be0743,\n        0x4c0cc7bf63f6e1da, 0x274edebfe76f65fb, 0xd51ad2f14898b95b\n    ]\n\n\/**\n * ```repl\n * :prove alphabet448\n * ```\n *\/\nproperty alphabet448 = SHA384::hash input == output where\n    input = join \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    output = join [\n        0x3391fdddfc8dc739, 0x3707a65b1b470939, 0x7cf8b1d162af05ab,\n        0xfe8f450de5f36bc6, 0xb0455a8520bc4e6f, 0x5fe95b1fe3c8452b\n    ]\n\n\/**\n * ```repl\n * :prove alphabet896\n * ```\n *\/\nproperty alphabet896 = SHA384::hash input == output where\n    input = join \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n    output = join [\n        0x09330c33f71147e8, 0x3d192fc782cd1b47, 0x53111b173b3b05d2,\n        0x2fa08086e3b0f712, 0xfcc7c71a557e2db9, 0x66c3e9fa91746039\n    ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA224.cry","filetype":"cry","content":"\/**\n * Test vectors for SHA224 as specified in [FIPS-180-4].\n *\n * These vectors were originally specified in [CSG-SHA], but we also used the\n * convenient collected test vectors page from David Ireland.\n * @see DI Management https:\/\/www.di-mgt.com.au\/sha_testvectors.html\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\n * [CSG-SHA]: National Institute of Standards and Technology. Example\n *     algorithms - Secure hashing.\n *     @see http:\/\/csrc.nist.gov\/groups\/ST\/toolkit\/examples.html\n *     @see https:\/\/csrc.nist.gov\/csrc\/media\/projects\/cryptographic-standards-and-guidelines\/documents\/examples\/sha_all.pdf\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA224 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 as SHA224\n\n\/**\n * ```repl\n * :prove abcWorks\n * ```\n *\/\nproperty abcWorks = SHA224::hash (join \"abc\") == output where\n    output = join [\n        0x23097d22, 0x3405d822, 0x8642a477, 0xbda255b3,\n        0x2aadbce4, 0xbda0b3f7, 0xe36c9da7\n    ]\n\n\/**\n * ```repl\n * :prove emptyStringWorks\n * ```\n *\/\nproperty emptyStringWorks = SHA224::hash [] == output where\n    output = join [\n        0xd14a028c, 0x2a3a2bc9, 0x476102bb, 0x288234c4,\n        0x15a2b01f, 0x828ea62a, 0xc5b3e42f\n    ]\n\n\/**\n * ```repl\n * :prove alphabet448\n * ```\n *\/\nproperty alphabet448 = SHA224::hash input == output where\n    input = join \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    output = join [\n        0x75388b16, 0x512776cc, 0x5dba5da1, 0xfd890150,\n        0xb0c6455c, 0xb4f58b19, 0x52522525\n    ]\n\n\/**\n * ```repl\n * :prove alphabet896\n * ```\n *\/\nproperty alphabet896 = SHA224::hash input == output where\n    input = join \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n    output = join [\n        0xc97ca9a5, 0x59850ce9, 0x7a04a96d, 0xef6d99a9,\n        0xe0e0e2ab, 0x14e6b8df, 0x265fc0b3\n    ]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA256_FFI.cry","filetype":"cry","content":"\/**\n * Test for SHA256 FFI implementation.\n *\n * We test the SHA256 FFI implementation by comparing its output to the Cryptol\n * implementation's output.\n *\n * @copyright Galois, Inc\n * @author Alex J. Malozemoff <amaloz@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA256 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI as SHA256_FFI\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n\/**\n * ```repl\n * :check FFIAndCryptolAreEqual`{l=1000}\n * ```\n *\/\nFFIAndCryptolAreEqual : {l} (SHA256::ValidMessageLength (8 * l))\n    => [l][8] -> Bool\nproperty FFIAndCryptolAreEqual M = ffi == cryptol where\n    ffi = SHA256_FFI::hashBytes M\n    cryptol = SHA256::hashBytes M\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA512_256.cry","filetype":"cry","content":"\/**\n * Instantiation of the secure hash algorithm SHA-512\/256 as specified in\n * [FIPS-180-4], Section 6.7.\n *\n * @copyright Galois, Inc\n * @author John Christensen <jchristensen@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\n\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA512_256 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 256\n\n    \/\/ Per [FIPS-180-4], are the results of executing the SHA-512\/t IV\n    \/\/ Generation function with `t=256`.\n    \/\/ Ref: Section 5.3.6.2\n    H0 = [\n        0x22312194FC2BF72C\n      , 0x9F555FA3C84C64C2\n      , 0x2393B86B6F53B151\n      , 0x963877195940EABD\n      , 0x96283EE2A88EFFE3\n      , 0xBE5E1E2553863992\n      , 0x2B0199FC2C85B8AA\n      , 0x0EB72DDC81C52CA2\n    ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA384.cry","filetype":"cry","content":"\/**\n * Instantiation of the secure hash algorithm SHA-384 as specified in\n * [FIPS-180-4], Section 5.3.4.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 384\n\n    \/\/ Per [FIPS-180-4], these are the the first sixty-four bits of the\n    \/\/ fractional parts of the square roots of the 9th - 16th prime numbers.\n    H0 = [\n        0xcbbb9d5dc1059ed8, 0x629a292a367cd507,\n        0x9159015a3070dd17, 0x152fecd8f70e5939,\n        0x67332667ffc00b31, 0x8eb44a8768581511,\n        0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4\n    ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA224.cry","filetype":"cry","content":"\/**\n * Instantiation of the secure hash algorithm SHA-224 as specified in\n * [FIPS-180-4], Section 5.3.3.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 32\n\n    type DigestSize = 224\n\n    \/\/ Per [FIPS-180-4], these are the first 32 bits of the fractional\n    \/\/ parts of the square roots of the first 8 prime numbers.\n    H0 = [\n        0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n        0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n    ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA256.cry","filetype":"cry","content":"\/**\n * Instantiation of the secure hash algorithm SHA-256 as specified in\n * [FIPS-180-4], Section 5.3.3.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 32\n\n    type DigestSize = 256\n\n    \/\/ Per [FIPS-180-4], these are the first 32 bits of the fractional\n    \/\/ parts of the square roots of the first 8 prime numbers.\n    H0 = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n    ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA512_224.cry","filetype":"cry","content":"\/**\n * Instantiation of the secure hash algorithm SHA-512\/224 as specified in\n * [FIPS-180-4], Section 6.6.\n *\n * @copyright Galois, Inc\n * @author John Christensen <jchristensen@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\n\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA512_224 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 224\n\n    \/\/ Per [FIPS-180-4], are the results of executing the SHA-512\/t IV\n    \/\/ Generation function with `t=224`.\n    \/\/ Ref: Section 5.3.6.1.\n    H0 = [\n       0x8C3D37C819544DA2\n     , 0x73E1996689DCD4D6\n     , 0x1DFAB7AE32FF9C82\n     , 0x679DD514582F9FCF\n     , 0x0F6D2B697BD44DA8\n     , 0x77E36F7304C48942\n     , 0x3F9D85A86A1D36C8\n     , 0x1112E6AD91D692A1\n    ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA512.cry","filetype":"cry","content":"\/**\n * Instantiation of the secure hash algorithm SHA-512 as specified in\n * [FIPS-180-4], Section 5.3.5.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA512 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 512\n\n    \/\/ Per [FIPS-180-4], these are the the first sixty-four bits of the\n    \/\/ fractional parts of the square roots of the first 8 prime numbers.\n    H0 = [\n        0x6a09e667f3bcc908, 0xbb67ae8584caa73b,\n        0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n        0x510e527fade682d1, 0x9b05688c2b3e6c1f,\n        0x1f83d9abfb41bd6b, 0x5be0cd19137e2179\n    ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA256_FFI.cry","filetype":"cry","content":"\/**\n * FFI instantiation of the secure hash algorithm SHA-256 as specified in\n * [FIPS-180-4], Section 5.3.3.\n *\n * The FFI implementation is taken from\n * https: * domain free of any restrictions.\n *\n * To use, you must compile the associated `SHA256_FFI.c` file according to your\n * operating system:\n *\n * \u2022 Linux: cc -fPIC -shared SHA256_FFI.c -o SHA256_FFI.so\n * \u2022 macOS: cc -dynamiclib SHA256_FFI.c -o SHA256_FFI.dylib\n * \u2022 Windows: cc -fPIC -shared SHA256_FFI.c -o SHA256_FFI.dll\n *\n * In addition, you need to be using Cryptol with FFI enabled.\n *\n * @copyright Galois, Inc.\n * @author Alex J Malozemoff <amaloz@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI where\n    import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n    \/**\n     * Re-export of `SHA256::MessageUpperBound`.\n     *\/\n    type MessageUpperBound = SHA256::MessageUpperBound\n\n    \/\/ Cryptol FFI does not support bit respresentation types, and hence\n    \/\/ the below `hash` function is not supported in FFI.\n    \/\/\n    \/\/ foreign hash : {l} (SHA256::ValidMessageLength l)\n    \/\/     => [l] -> [SHA256::DigestLength]\n\n    \/**\n     * Secure hash function, computed over bytes.\n     *\n     * This is not explicitly part of the spec, but many applications represent\n     * their input and output over byte strings (rather than bit strings as used\n     * in the spec itself).\n     *\/\n    foreign hashBytes : {l} (SHA256::ValidMessageLength (8 * l))\n        => [l][8] -> [SHA256::DigestLength \/ 8][8]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_512.cry","filetype":"cry","content":"\/**\n * Tests of the SHA3_512 hash function.\n *\n * Test vectors drawn from the NIST Cryptographic Algorithm Validation Program.\n * This program includes test vectors that can be used to spot-check an\n * implementation. It includes tests for bitwise inputs (where the input length\n * is any nonnegative integer) and for bytewise inputs (where the input length\n * is a multiple of 8).\n * @see CAVP. https:\/\/csrc.nist.gov\/projects\/cryptographic-algorithm-validation-program\/secure-hashing#sha3vsha3vss\n * @see SHA3 bitwise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bittestvectors.zip\n * @see SHA3 bytewise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bytetestvectors.zip\n *\n * Some of the bitwise tests in this file use the `KOP::truncate` function. The\n * CAVP vectors use the format described in [FIPS-202] Appendix B, where inputs\n * to SHA3 are provided as hex strings with an even number of digits and a\n * length parameter. The `h2b` function for processing such inputs has an\n * implicit truncation step. We've written the SHA3 spec to take arbitrary bit\n * vectors, but this assumes that the length of the input is its actual length.\n * The `truncate` function is written to support the even-hex-digit format and\n * must be called on an input before passing it to SHA3.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n * @editor Iavor Diatchki <diatchki@galois.com>\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_512 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 as SHA3_512\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t1\n * ```\n *\/\nproperty t1 = SHA3_512::hash [] == output where\n    output = join [\n        0xa69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a6,\n        0x15b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26\n    ]\n\n\/**\n * This is from the bytewise tests.\n * ```repl\n * :prove t72\n * ```\n *\/\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_512::hash input == output\n    hashBytesWorks = SHA3_512::hashBytes (split input) == split output\n    input = 0x3d6093966950abd846\n    output = join [\n        0x53e30da8b74ae76abf1f65761653ebfbe87882e9ea0ea564addd7cfd5a652457,\n        0x8ad6be014d7799799ef5e15c679582b791159add823b95c91e26de62dcb74cfa\n    ]\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t100\n * ```\n *\/\nproperty t100 = SHA3_512::hash input == output where\n    input = KBO::truncate`{100} 0xd404d8e31f8091709122025a0c\n    output = join [\n        0xa5ce9e2523788040eab94f0a2467efc2a1e6d4ea74e9248f97f94ce1407f0c88,\n        0x2e6b0578d98a7067d98c79b2b1dd2cb76393e6356061146637e5240d34ed6955\n    ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHAKE128.cry","filetype":"cry","content":"\/**\n * CAVP test vectors for SHAKE128, and a demonstration on how to use\n * the `KeccakBitOrdering` module.\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHAKE128 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128\n\n\/**\n * The CAVP test vectors provide input in MSB order as hex strings with an\n * even number of digits; each test is for a specific bit-length input.\n * This aligns with the encoding scheme described in [FIPS-202] Appendix B.\n *\n * The SHAKE-128 API does not require inputs to be encoded in that\n * format. In order to use the `xof` function, we need to truncate the \"padding\"\n * bits that are used to extend the input into an even number of hex digits\n * (e.g. a multiple of 8 bits).\n *\n * @see https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/shakebittestvectors.zip\n *\/\ncomputeCavpTestVector : {k, l} (fin k, fin l) => [8 * (k \/^ 8)] -> [l] -> Bool\ncomputeCavpTestVector msg expectedResult = result == expectedResult where\n    result = xof (KBO::truncate`{k, 8 * (k \/^ 8)} msg)\n\n\/**\n * ```repl\n * :prove k0\n * ```\n *\/\nproperty k0 = computeCavpTestVector`{0} [] expected_result where\n    expected_result = join [\n        0x7f9c2ba4e88f827d616045507605853e,\n        0xd73b8093f6efbc88eb1a6eacfa66ef26,\n        0x3cb1eea988004b93103cfb0aeefd2a68,\n        0x6e01fa4a58e8a3639ca8a1e3f9ae57e2\n    ]\n\n\/**\n * ```repl\n * :prove k1\n * ```\n *\/\nproperty k1 = computeCavpTestVector`{1} 0x00 expected_result where\n    expected_result = join [\n        0xe78b86559a9ccdc72288bf7bcf8e11d5,\n        0x74543a2922978913a02be149e89d03ca,\n        0xe63d2c36e2cf6906791b187d7e371d4f,\n        0x21ebe59dcfc249a510b82255a18250dd\n    ]\n\/**\n * ```repl\n * :prove k2\n * ```\n *\/\nproperty k2 = computeCavpTestVector`{2} 0x03 expected_result where\n    expected_result = join [\n        0xf6b6c4093f0a2ceba61b9f2c2fea2ca2,\n        0x38ce9005edcd588c380405070532ddd0,\n        0x0cbd3a3a7448017d874c52c9e383fa3d,\n        0xb1c184e023181fcc8550f53ac92feca5\n    ]\n\n\/**\n * ```repl\n * :prove k3\n * ```\n *\/\nproperty k3 = computeCavpTestVector`{3} 0x06 expected_result where\n    expected_result = join [\n        0x178afb3be00c33b682f0c920520699e3,\n        0xb7e4c360274fd8b41cdeaa8d3c675bdc,\n        0x079be55d4513e7479aa903169430f0a0,\n        0xbf60169becd0ff9ff3ff6be24bc6fd83\n    ]\n\n\/**\n * This is one of the CAVP test vectors from `SHAKE128ShortMsg.rsp`.\n * ```repl\n * :prove k265\n * ```\n *\/\nproperty k265 = computeCavpTestVector`{265} msg expected_output where\n    msg = 0xa4fb52a45c1e49e1805ccbe419ef3c57b773d84eaa478ed07536129480572e080d01\n    expected_output = 0xf5e3f9934cfa817d75e8db5dce000977\n\n\/**\n * This is one of the CAVP test vectors from `SHAKE128ShortMsg.rsp`.\n * ```repl\n * :prove k266\n * ```\n *\/\nproperty k266 = computeCavpTestVector`{266} msg expectedResult where\n    msg = 0x01de90ca986e1abd50d28ad9f82cc77b45ebd99d19fa4bab0437d3930c27351ca900\n    expectedResult = 0xc47bb657d4f474cd5fa0f29537b85a7a\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_384.cry","filetype":"cry","content":"\/**\n * Tests of the SHA3_384 hash function.\n *\n * Test vectors drawn from the NIST Cryptographic Algorithm Validation Program.\n * This program includes test vectors that can be used to spot-check an\n * implementation. It includes tests for bitwise inputs (where the input length\n * is any nonnegative integer) and for bytewise inputs (where the input length\n * is a multiple of 8).\n * @see CAVP. https:\/\/csrc.nist.gov\/projects\/cryptographic-algorithm-validation-program\/secure-hashing#sha3vsha3vss\n * @see SHA3 bitwise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bittestvectors.zip\n * @see SHA3 bytewise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bytetestvectors.zip\n *\n * Some of the bitwise tests in this file use the `KOP::truncate` function. The\n * CAVP vectors use the format described in [FIPS-202] Appendix B, where inputs\n * to SHA3 are provided as hex strings with an even number of digits and a\n * length parameter. The `h2b` function for processing such inputs has an\n * implicit truncation step. We've written the SHA3 spec to take arbitrary bit\n * vectors, but this assumes that the length of the input is its actual length.\n * The `truncate` function is written to support the even-hex-digit format and\n * must be called on an input before passing it to SHA3.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n * @editor Iavor Diatchki <diatchki@galois.com>\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_384 where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384 as SHA3_384\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t1\n * ```\n *\/\nproperty t1 = SHA3_384::hash [] == output where\n    output = join [\n        0x0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61,\n        0x995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004\n    ]\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t64\n * ```\n *\/\nproperty t64 = SHA3_384::hash 0x72189b5f18121fb7 == output where\n    output = join [\n        0xb5be454e64fb00d8ebf23cece42fdcf20e88bb5067ab17c2,\n        0x19068b1533eb485341a84a933f837d9abd65b62604936469\n    ]\n\n\/**\n * This is from the bytewise tests.\n * ```repl\n * :prove t72\n * ```\n *\/\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_384::hash input == output\n    hashBytesWorks = SHA3_384::hashBytes (split input) == split output\n    input = 0xa36e5a59043b6333d7\n    output = join [\n        0xbd045661663436d07720ff3c8b6f922066dfe244456a56ca,\n        0x46dfb3f7e271116d932107c7b04cc7c60173e08d0c2e107c\n    ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHAKE256.cry","filetype":"cry","content":"\/**\n * CAVP test vectors for SHAKE256.\n *\n * These can be downloaded from:\n * @see https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/shakebittestvectors.zip\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\n\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\n\n\/**\n * ```repl\n * :prove k5\n * ```\n *\/\nproperty k5 = xof [] == expected_result where\n    expected_result = join [\n        0x46b9dd2b0ba88d13233b3feb743eeb24,\n        0x3fcd52ea62b81b82b50c27646ed5762f,\n        0xd75dc4ddd8c0f200cb05019d67b592f6,\n        0xfc821c49479ab48640292eacb3b7c4be\n    ]\n\n\/**\n * ```repl\n * :prove k6\n * ```\n *\/\nproperty k6 = xof 0b0 == expected_result where\n    expected_result = join [\n        0x1e20b13f3bdb730d286913335c092bce,\n        0xc0eb1aff2798c05736faa93bd665807a,\n        0x48ed7652aefd600427e9f797d647b9b3,\n        0x55d30410d71b8e275a676545600f1c35\n    ]\n\n\/**\n * ```repl\n * :prove k7\n * ```\n *\/\nproperty k7 = xof 0b11 == expected_result where\n    expected_result = join [\n        0x4f86b0eb85f7a9f6dc38b622706948ad,\n        0xb2beb6dd6911b5e9d865fd1f9667b5c0,\n        0x2a0dbb39c488b040a18ff3885f04ef95,\n        0x7c98f3948e6b7959a9b8950ffd6345d5\n    ]\n\n\/**\n * ```repl\n * :prove k8\n * ```\n *\/\nproperty k8 = xof 0b110 == expected_result where\n    expected_result = join [\n        0x27b5f40b3645215e370472ebb06817ae,\n        0xbddbe2cbd3a9a3ba3914da88e5853e70,\n        0x83630e6d51d7a009017d8176c3067329,\n        0xbec8e5f65591d65c5894c40132f1a2ab\n    ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_224.cry","filetype":"cry","content":"\/**\n * Tests of the SHA3_224 hash function.\n *\n * Test vectors drawn from the NIST Cryptographic Algorithm Validation Program.\n * This program includes test vectors that can be used to spot-check an\n * implementation. It includes tests for bitwise inputs (where the input length\n * is any nonnegative integer) and for bytewise inputs (where the input length\n * is a multiple of 8).\n * @see CAVP. https:\/\/csrc.nist.gov\/projects\/cryptographic-algorithm-validation-program\/secure-hashing#sha3vsha3vss\n * @see SHA3 bitwise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bittestvectors.zip\n * @see SHA3 bytewise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bytetestvectors.zip\n *\n * Some of the bitwise tests in this file use the `KOP::truncate` function. The\n * CAVP vectors use the format described in [FIPS-202] Appendix B, where inputs\n * to SHA3 are provided as hex strings with an even number of digits and a\n * length parameter. The `h2b` function for processing such inputs has an\n * implicit truncation step. We've written the SHA3 spec to take arbitrary bit\n * vectors, but this assumes that the length of the input is its actual length.\n * The `truncate` function is written to support the even-hex-digit format and\n * must be called on an input before passing it to SHA3.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n * @editor Iavor Diatchki <diatchki@galois.com>\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_224 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224 as SHA3_224\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t1\n * ```\n *\/\nproperty t1 = SHA3_224::hash [] ==\n    0x6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t5\n * ```\n *\/\nproperty t5 = SHA3_224::hash (KBO::truncate`{5} 0x1f) ==\n    0x65ad282dcf9642a2facc1e7545c58f3b17523e795fee58e4d21b10bf\n\n\/**\n * This is from the bytewise tests.\n * ```repl\n * :prove t72\n * ```\n *\/\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_224::hash input == output\n    hashBytesWorks = SHA3_224::hashBytes (split input) == split output\n    input = 0xb29373f6f8839bd498\n    output = 0xe02a13fa4770f824bcd69799284878f19bfdc833ac6d865f28b757d0\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t512\n * ```\n *\/\nproperty t512 = SHA3_224::hash input == output where\n    input = join [\n        0xfc286db63e69d24c6962bb515cc32c86,\n        0x67ed0c08ba9f331d1dd2c42de2e1bd0f,\n        0x18edcc870280650cc87011ce6b0709f7,\n        0xfe60033114144c69751717d315dc152f\n    ]\n    output = 0x157fd9f423a498868e233d9d64631f61aa5e8fbc23df413f7826c962\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_256.cry","filetype":"cry","content":"\/**\n * Tests of the SHA3_256 hash function.\n *\n * Test vectors drawn from the NIST Cryptographic Algorithm Validation Program.\n * This program includes test vectors that can be used to spot-check an\n * implementation. It includes tests for bitwise inputs (where the input length\n * is any nonnegative integer) and for bytewise inputs (where the input length\n * is a multiple of 8).\n * @see CAVP. https:\/\/csrc.nist.gov\/projects\/cryptographic-algorithm-validation-program\/secure-hashing#sha3vsha3vss\n * @see SHA3 bitwise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bittestvectors.zip\n * @see SHA3 bytewise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bytetestvectors.zip\n *\n * Some of the bitwise tests in this file use the `KOP::truncate` function. The\n * CAVP vectors use the format described in [FIPS-202] Appendix B, where inputs\n * to SHA3 are provided as hex strings with an even number of digits and a\n * length parameter. The `h2b` function for processing such inputs has an\n * implicit truncation step. We've written the SHA3 spec to take arbitrary bit\n * vectors, but this assumes that the length of the input is its actual length.\n * The `truncate` function is written to support the even-hex-digit format and\n * must be called on an input before passing it to SHA3.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n * @editor Iavor Diatchki <diatchki@galois.com>\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_256 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 as SHA3_256\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t1\n * ```\n *\/\nproperty t1 = SHA3_256::hash [] ==\n    0xa7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t7\n * ```\n *\/\nproperty t7 = SHA3_256::hash (KBO::truncate`{7} 0x0b) ==\n    0x9e5f8c800689fa5168fc5fbfeca8bd5b3668ffd6f08143e2e396b9ae0f9b443e\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t8\n * ```\n *\/\nproperty t8 = SHA3_256::hash 0x6a ==\n    0xf35e560e05de779f2669b9f513c2a7ab81dfeb100e2f4ee1fb17354bfa2740ca\n\n\/**\n * This is from the bytewise tests.\n * ```repl\n * :prove t72\n * ```\n *\/\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_256::hash input == output\n    hashBytesWorks = SHA3_256::hashBytes (split input) == split output\n    input = 0xfb8dfa3a132f9813ac\n    output = 0xfd09b3501888445ffc8c3bb95d106440ceee469415fce1474743273094306e2e\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t235\n * ```\n *\/\nproperty t235 = SHA3_256::hash input == output where\n    input = KBO::truncate`{235} (join [\n        0xd03d466ab65db8e5131a414637174b,\n        0x646d0612977d194dcb75b910d2a903\n    ])\n    output = join [\n        0x06413eb50e238e09843aa51b0b5fb7ca,\n        0x52b87db7d71f384b5b93f57843c89f37\n    ]\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_512.cry","filetype":"cry","content":"\/**\n * Instantiation of SHA3-512.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 512\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHAKE128.cry","filetype":"cry","content":"module Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128 where\nimport Primitive::Keyless::Hash::SHA3::Specification where\n    type b = 1600\n    type nr = 24\n    \/\/ The capacity is double the security level, so this provides a security\n    \/\/ level of 128 (as the name suggests).\n    type c = 256\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\n\/**\n * SHAKE128 extendable-output function.\n * [FIPS-202] Section 6.2.\n *\n * This supports any output length `d`, including infinite length.\n *\n * Note that the specification of `c` is above, in the instantiation of the\n * `keccak` module.\n *\n * This expects input and produces output in the bit ordering used by the\n * `Keccak` spec, where bytes are in MSB order and the bits in each byte are\n * in LSB order. Use the `KeccakBitOrdering::toBytes` function to transform\n * the input and output to Cryptol-standard MSB order:\n * ```repl\n * join (KBO::toBytes (shake128 (join (KBO::toBytes 0x49ae)))) == 0x88c605024011d2f7bc28b3d40fa0f100\n * ```\n *\/\nshake128 : {d, m} (fin m) => [m] -> [d]\nshake128 M = Keccak (M # 0b1111)\n\n\/**\n * SHAKE128 extendable-output function.\n * [FIPS-202] Section 6.2.\n *\n * This supports any output length `d`, including infinite length.\n *\n * This expects input and output in MSB order. It handles conversion to and\n * from the bit ordering expected by `Keccak`. If input is provided in the\n * format described in [FIPS-202] Appendix B (a hex string with an even\n * number of digits and an actual length `n`), use the `KOB::truncate` function\n * to get the correct input:\n * ```repl\n * xof 0x49ae == 0x88c605024011d2f7bc28b3d40fa0f100\n * xof (KBO::truncate`{15} 0xc310) == 0x0c963b6211057ecbb66cca211be09cdd\n * ```\n *\/\nxof : {d, m} (fin m) => [m] -> [d]\nxof M = KBO::reverseBitOrdering (Keccak ((KBO::reverseBitOrdering M) # 0b1111))\n\n\/**\n * SHAKE128 extendable-output function over byte-delimited inputs.\n *\n * Note that `d` is specified in _bits_. The `dBytes` parameter allows us to\n * have infinite output. The alternative approach, requiring `d % 8 == 0`,\n * is only possible when `d` is finite due to a type constraint on\n * the mod operation.\n *\/\nxofBytes : {d, m, dBytes} (fin m, dBytes * 8 == d) => [m][8] -> [dBytes][8]\nxofBytes M = split (xof (join M))\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_384.cry","filetype":"cry","content":"\/**\n * Instantiation of SHA3-384.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 384\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_224.cry","filetype":"cry","content":"\/**\n * Instantiation of SHA3-224.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 224\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_256.cry","filetype":"cry","content":"\/**\n * Instantiation of SHA3-256.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 256\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA1\/Tests\/SHA1.cry","filetype":"cry","content":"\/**\n * Tests for SHA-1.\n * Some of these test vectors are taken from [NIST-VECTORS].\n *\n * References:\n * [NIST-VECTORS]: Untitled Appendix FIPS 180-2\n * @see https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/SHA1.pdf\n *\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA1::Tests::SHA1 where\n\nimport Primitive::Keyless::Hash::SHA1::Specification as SHA1\n\n\/**\n * ```repl\n * :prove emptyStringWorks\n * ```\n *\/\nproperty emptyStringWorks = SHA1::hash [] == r\n  where\n    r = 0xda39a3ee5e6b4b0d3255bfef95601890afd80709\n\n\/**\n * ```repl\n * :prove sample1Works\n * ```\n *\/\nproperty sample1Works = SHA1::hashBytes \"abc\" ==\n                        split 0xA9993E364706816ABA3E25717850C26C9CD0D89D\n\n\/**\n * ```repl\n * :prove sample2Works\n * ```\n *\/\nproperty sample2Works = SHA1::hashBytes \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\" ==\n                        split 0x84983E441C3BD26EBAAE4AA1F95129E5E54670F1\n\n\/**\n* `l` is the length of the message in bits.\n* For SHA1, `l` < 2 ^^ 64.\n*\n* References:\n* Sections 1, 2.2.1 [FIPS-180-4]\n*\/\ntype constraint ValidMessageLength l = (l < 2 ^^ 64)\n\n\/**\n * ```repl\n * :prove interfaceEquivalence `{1}\n *\/\ninterfaceEquivalence: {l} (ValidMessageLength (8*l)) => [8*l] -> Bit\nproperty interfaceEquivalence x = SHA1::hash `{l*8} x == join (SHA1::hashBytes `{l} (split x))\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA1\/Tests\/CAVPShortByte.cry","filetype":"cry","content":"\/**\n * Tests for SHA-1.\n * These test vectors are taken from the Cryptographic Algorithm Validation\n * Program (CAVP) sample files.\n * @see https:\/\/csrc.nist.gov\/Projects\/Cryptographic-Algorithm-Validation-Program\/Secure-Hashing#shavs\n *\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\/\n\nmodule Primitive::Keyless::Hash::SHA1::Tests::CAVPShortByte where\n\nimport Primitive::Keyless::Hash::SHA1::Specification as SHA1\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase0\n * ```\n *\/\nproperty testCase0 = SHA1::hash `{ l = 0 } msg == md\n  where\n    msg = take 0x00\n    md = 0xda39a3ee5e6b4b0d3255bfef95601890afd80709\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase1\n * ```\n *\/\nproperty testCase1 = SHA1::hash `{ l = 8 } msg == md\n  where\n    msg = take 0x36\n    md = 0xc1dfd96eea8cc2b62785275bca38ac261256e278\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase2\n * ```\n *\/\nproperty testCase2 = SHA1::hash `{ l = 16 } msg == md\n  where\n    msg = take 0x195a\n    md = 0x0a1c2d555bbe431ad6288af5a54f93e0449c9232\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase3\n * ```\n *\/\nproperty testCase3 = SHA1::hash `{ l = 24 } msg == md\n  where\n    msg = take 0xdf4bd2\n    md = 0xbf36ed5d74727dfd5d7854ec6b1d49468d8ee8aa\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase4\n * ```\n *\/\nproperty testCase4 = SHA1::hash `{ l = 32 } msg == md\n  where\n    msg = take 0x549e959e\n    md = 0xb78bae6d14338ffccfd5d5b5674a275f6ef9c717\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase5\n * ```\n *\/\nproperty testCase5 = SHA1::hash `{ l = 40 } msg == md\n  where\n    msg = take 0xf7fb1be205\n    md = 0x60b7d5bb560a1acf6fa45721bd0abb419a841a89\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase6\n * ```\n *\/\nproperty testCase6 = SHA1::hash `{ l = 48 } msg == md\n  where\n    msg = take 0xc0e5abeaea63\n    md = 0xa6d338459780c08363090fd8fc7d28dc80e8e01f\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase7\n * ```\n *\/\nproperty testCase7 = SHA1::hash `{ l = 56 } msg == md\n  where\n    msg = take 0x63bfc1ed7f78ab\n    md = 0x860328d80509500c1783169ebf0ba0c4b94da5e5\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase8\n * ```\n *\/\nproperty testCase8 = SHA1::hash `{ l = 64 } msg == md\n  where\n    msg = take 0x7e3d7b3eada98866\n    md = 0x24a2c34b976305277ce58c2f42d5092031572520\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase9\n * ```\n *\/\nproperty testCase9 = SHA1::hash `{ l = 72 } msg == md\n  where\n    msg = take 0x9e61e55d9ed37b1c20\n    md = 0x411ccee1f6e3677df12698411eb09d3ff580af97\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase10\n * ```\n *\/\nproperty testCase10 = SHA1::hash `{ l = 80 } msg == md\n  where\n    msg = take 0x9777cf90dd7c7e863506\n    md = 0x05c915b5ed4e4c4afffc202961f3174371e90b5c\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase11\n * ```\n *\/\nproperty testCase11 = SHA1::hash `{ l = 88 } msg == md\n  where\n    msg = take 0x4eb08c9e683c94bea00dfa\n    md = 0xaf320b42d7785ca6c8dd220463be23a2d2cb5afc\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase12\n * ```\n *\/\nproperty testCase12 = SHA1::hash `{ l = 96 } msg == md\n  where\n    msg = take 0x0938f2e2ebb64f8af8bbfc91\n    md = 0x9f4e66b6ceea40dcf4b9166c28f1c88474141da9\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase13\n * ```\n *\/\nproperty testCase13 = SHA1::hash `{ l = 104 } msg == md\n  where\n    msg = take 0x74c9996d14e87d3e6cbea7029d\n    md = 0xe6c4363c0852951991057f40de27ec0890466f01\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase14\n * ```\n *\/\nproperty testCase14 = SHA1::hash `{ l = 112 } msg == md\n  where\n    msg = take 0x51dca5c0f8e5d49596f32d3eb874\n    md = 0x046a7b396c01379a684a894558779b07d8c7da20\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase15\n * ```\n *\/\nproperty testCase15 = SHA1::hash `{ l = 120 } msg == md\n  where\n    msg = take 0x3a36ea49684820a2adc7fc4175ba78\n    md = 0xd58a262ee7b6577c07228e71ae9b3e04c8abcda9\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase16\n * ```\n *\/\nproperty testCase16 = SHA1::hash `{ l = 128 } msg == md\n  where\n    msg = take 0x3552694cdf663fd94b224747ac406aaf\n    md = 0xa150de927454202d94e656de4c7c0ca691de955d\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase17\n * ```\n *\/\nproperty testCase17 = SHA1::hash `{ l = 136 } msg == md\n  where\n    msg = take 0xf216a1cbde2446b1edf41e93481d33e2ed\n    md = 0x35a4b39fef560e7ea61246676e1b7e13d587be30\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase18\n * ```\n *\/\nproperty testCase18 = SHA1::hash `{ l = 144 } msg == md\n  where\n    msg = take 0xa3cf714bf112647e727e8cfd46499acd35a6\n    md = 0x7ce69b1acdce52ea7dbd382531fa1a83df13cae7\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase19\n * ```\n *\/\nproperty testCase19 = SHA1::hash `{ l = 152 } msg == md\n  where\n    msg = take 0x148de640f3c11591a6f8c5c48632c5fb79d3b7\n    md = 0xb47be2c64124fa9a124a887af9551a74354ca411\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase20\n * ```\n *\/\nproperty testCase20 = SHA1::hash `{ l = 160 } msg == md\n  where\n    msg = take 0x63a3cc83fd1ec1b6680e9974a0514e1a9ecebb6a\n    md = 0x8bb8c0d815a9c68a1d2910f39d942603d807fbcc\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase21\n * ```\n *\/\nproperty testCase21 = SHA1::hash `{ l = 168 } msg == md\n  where\n    msg = take 0x875a90909a8afc92fb7070047e9d081ec92f3d08b8\n    md = 0xb486f87fb833ebf0328393128646a6f6e660fcb1\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase22\n * ```\n *\/\nproperty testCase22 = SHA1::hash `{ l = 176 } msg == md\n  where\n    msg = take 0x444b25f9c9259dc217772cc4478c44b6feff62353673\n    md = 0x76159368f99dece30aadcfb9b7b41dab33688858\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase23\n * ```\n *\/\nproperty testCase23 = SHA1::hash `{ l = 184 } msg == md\n  where\n    msg = take 0x487351c8a5f440e4d03386483d5fe7bb669d41adcbfdb7\n    md = 0xdbc1cb575ce6aeb9dc4ebf0f843ba8aeb1451e89\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase24\n * ```\n *\/\nproperty testCase24 = SHA1::hash `{ l = 192 } msg == md\n  where\n    msg = take 0x46b061ef132b87f6d3b0ee2462f67d910977da20aed13705\n    md = 0xd7a98289679005eb930ab75efd8f650f991ee952\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase25\n * ```\n *\/\nproperty testCase25 = SHA1::hash `{ l = 200 } msg == md\n  where\n    msg = take 0x3842b6137bb9d27f3ca5bafe5bbb62858344fe4ba5c41589a5\n    md = 0xfda26fa9b4874ab701ed0bb64d134f89b9c4cc50\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase26\n * ```\n *\/\nproperty testCase26 = SHA1::hash `{ l = 208 } msg == md\n  where\n    msg = take 0x44d91d3d465a4111462ba0c7ec223da6735f4f5200453cf132c3\n    md = 0xc2ff7ccde143c8f0601f6974b1903eb8d5741b6e\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase27\n * ```\n *\/\nproperty testCase27 = SHA1::hash `{ l = 216 } msg == md\n  where\n    msg = take 0xcce73f2eabcb52f785d5a6df63c0a105f34a91ca237fe534ee399d\n    md = 0x643c9dc20a929608f6caa9709d843ca6fa7a76f4\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase28\n * ```\n *\/\nproperty testCase28 = SHA1::hash `{ l = 224 } msg == md\n  where\n    msg = take 0x664e6e7946839203037a65a12174b244de8cbc6ec3f578967a84f9ce\n    md = 0x509ef787343d5b5a269229b961b96241864a3d74\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase29\n * ```\n *\/\nproperty testCase29 = SHA1::hash `{ l = 232 } msg == md\n  where\n    msg = take 0x9597f714b2e45e3399a7f02aec44921bd78be0fefee0c5e9b499488f6e\n    md = 0xb61ce538f1a1e6c90432b233d7af5b6524ebfbe3\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase30\n * ```\n *\/\nproperty testCase30 = SHA1::hash `{ l = 240 } msg == md\n  where\n    msg = take 0x75c5ad1f3cbd22e8a95fc3b089526788fb4ebceed3e7d4443da6e081a35e\n    md = 0x5b7b94076b2fc20d6adb82479e6b28d07c902b75\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase31\n * ```\n *\/\nproperty testCase31 = SHA1::hash `{ l = 248 } msg == md\n  where\n    msg = take 0xdd245bffe6a638806667768360a95d0574e1a0bd0d18329fdb915ca484ac0d\n    md = 0x6066db99fc358952cf7fb0ec4d89cb0158ed91d7\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase32\n * ```\n *\/\nproperty testCase32 = SHA1::hash `{ l = 256 } msg == md\n  where\n    msg = take 0x0321794b739418c24e7c2e565274791c4be749752ad234ed56cb0a6347430c6b\n    md = 0xb89962c94d60f6a332fd60f6f07d4f032a586b76\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase33\n * ```\n *\/\nproperty testCase33 = SHA1::hash `{ l = 264 } msg == md\n  where\n    msg = take 0x4c3dcf95c2f0b5258c651fcd1d51bd10425d6203067d0748d37d1340d9ddda7db3\n    md = 0x17bda899c13d35413d2546212bcd8a93ceb0657b\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase34\n * ```\n *\/\nproperty testCase34 = SHA1::hash `{ l = 272 } msg == md\n  where\n    msg = take 0xb8d12582d25b45290a6e1bb95da429befcfdbf5b4dd41cdf3311d6988fa17cec0723\n    md = 0xbadcdd53fdc144b8bf2cc1e64d10f676eebe66ed\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase35\n * ```\n *\/\nproperty testCase35 = SHA1::hash `{ l = 280 } msg == md\n  where\n    msg = take 0x6fda97527a662552be15efaeba32a3aea4ed449abb5c1ed8d9bfff544708a425d69b72\n    md = 0x01b4646180f1f6d2e06bbe22c20e50030322673a\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase36\n * ```\n *\/\nproperty testCase36 = SHA1::hash `{ l = 288 } msg == md\n  where\n    msg = take 0x09fa2792acbb2417e8ed269041cc03c77006466e6e7ae002cf3f1af551e8ce0bb506d705\n    md = 0x10016dc3a2719f9034ffcc689426d28292c42fc9\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase37\n * ```\n *\/\nproperty testCase37 = SHA1::hash `{ l = 296 } msg == md\n  where\n    msg = take 0x5efa2987da0baf0a54d8d728792bcfa707a15798dc66743754406914d1cfe3709b1374eaeb\n    md = 0x9f42fa2bce6ef021d93c6b2d902273797e426535\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase38\n * ```\n *\/\nproperty testCase38 = SHA1::hash `{ l = 304 } msg == md\n  where\n    msg = take 0x2836de99c0f641cd55e89f5af76638947b8227377ef88bfba662e5682babc1ec96c6992bc9a0\n    md = 0xcdf48bacbff6f6152515323f9b43a286e0cb8113\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase39\n * ```\n *\/\nproperty testCase39 = SHA1::hash `{ l = 312 } msg == md\n  where\n    msg = take 0x42143a2b9e1d0b354df3264d08f7b602f54aad922a3d63006d097f683dc11b90178423bff2f7fe\n    md = 0xb88fb75274b9b0fd57c0045988cfcef6c3ce6554\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase40\n * ```\n *\/\nproperty testCase40 = SHA1::hash `{ l = 320 } msg == md\n  where\n    msg = take 0xeb60c28ad8aeda807d69ebc87552024ad8aca68204f1bcd29dc5a81dd228b591e2efb7c4df75ef03\n    md = 0xc06d3a6a12d9e8db62e8cff40ca23820d61d8aa7\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase41\n * ```\n *\/\nproperty testCase41 = SHA1::hash `{ l = 328 } msg == md\n  where\n    msg = take 0x7de4ba85ec54747cdc42b1f23546b7e490e31280f066e52fac117fd3b0792e4de62d5843ee98c72015\n    md = 0x6e40f9e83a4be93874bc97cdebb8da6889ae2c7a\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase42\n * ```\n *\/\nproperty testCase42 = SHA1::hash `{ l = 336 } msg == md\n  where\n    msg = take 0xe70653637bc5e388ccd8dc44e5eace36f7398f2bac993042b9bc2f4fb3b0ee7e23a96439dc01134b8c7d\n    md = 0x3efc940c312ef0dfd4e1143812248db89542f6a5\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase43\n * ```\n *\/\nproperty testCase43 = SHA1::hash `{ l = 344 } msg == md\n  where\n    msg = take 0xdd37bc9f0b3a4788f9b54966f252174c8ce487cbe59c53c22b81bf77621a7ce7616dcb5b1e2ee63c2c309b\n    md = 0xa0cf03f7badd0c3c3c4ea3717f5a4fb7e67b2e56\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase44\n * ```\n *\/\nproperty testCase44 = SHA1::hash `{ l = 352 } msg == md\n  where\n    msg = take 0x5f485c637ae30b1e30497f0fb7ec364e13c906e2813daa34161b7ac4a4fd7a1bddd79601bbd22cef1f57cbc7\n    md = 0xa544e06f1a07ceb175a51d6d9c0111b3e15e9859\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase45\n * ```\n *\/\nproperty testCase45 = SHA1::hash `{ l = 360 } msg == md\n  where\n    msg = take 0xf6c237fb3cfe95ec8414cc16d203b4874e644cc9a543465cad2dc563488a659e8a2e7c981e2a9f22e5e868ffe1\n    md = 0x199d986ed991b99a071f450c6b1121a727e8c735\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase46\n * ```\n *\/\nproperty testCase46 = SHA1::hash `{ l = 368 } msg == md\n  where\n    msg = take 0xda7ab3291553c659873c95913768953c6e526d3a26590898c0ade89ff56fbd110f1436af590b17fed49f8c4b2b1e\n    md = 0x33bac6104b0ad6128d091b5d5e2999099c9f05de\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase47\n * ```\n *\/\nproperty testCase47 = SHA1::hash `{ l = 376 } msg == md\n  where\n    msg = take 0x8cfa5fd56ee239ca47737591cba103e41a18acf8e8d257b0dbe8851134a81ff6b2e97104b39b76e19da256a17ce52d\n    md = 0x76d7db6e18c1f4ae225ce8ccc93c8f9a0dfeb969\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase48\n * ```\n *\/\nproperty testCase48 = SHA1::hash `{ l = 384 } msg == md\n  where\n    msg = take 0x57e89659d878f360af6de45a9a5e372ef40c384988e82640a3d5e4b76d2ef181780b9a099ac06ef0f8a7f3f764209720\n    md = 0xf652f3b1549f16710c7402895911e2b86a9b2aee\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase49\n * ```\n *\/\nproperty testCase49 = SHA1::hash `{ l = 392 } msg == md\n  where\n    msg = take 0xb91e64235dbd234eea2ae14a92a173ebe835347239cff8b02074416f55c6b60dc6ced06ae9f8d705505f0d617e4b29aef9\n    md = 0x63faebb807f32be708cf00fc35519991dc4e7f68\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase50\n * ```\n *\/\nproperty testCase50 = SHA1::hash `{ l = 400 } msg == md\n  where\n    msg = take 0xe42a67362a581e8cf3d847502215755d7ad425ca030c4360b0f7ef513e6980265f61c9fa18dd9ce668f38dbc2a1ef8f83cd6\n    md = 0x0e6730bc4a0e9322ea205f4edfff1fffda26af0a\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase51\n * ```\n *\/\nproperty testCase51 = SHA1::hash `{ l = 408 } msg == md\n  where\n    msg = take 0x634db92c22010e1cbf1e1623923180406c515272209a8acc42de05cc2e96a1e94c1f9f6b93234b7f4c55de8b1961a3bf352259\n    md = 0xb61a3a6f42e8e6604b93196c43c9e84d5359e6fe\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase52\n * ```\n *\/\nproperty testCase52 = SHA1::hash `{ l = 416 } msg == md\n  where\n    msg = take 0xcc6ca3a8cb391cd8a5aff1faa7b3ffbdd21a5a3ce66cfaddbfe8b179e4c860be5ec66bd2c6de6a39a25622f9f2fcb3fc05af12b5\n    md = 0x32d979ca1b3ed0ed8c890d99ec6dd85e6c16abf4\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase53\n * ```\n *\/\nproperty testCase53 = SHA1::hash `{ l = 424 } msg == md\n  where\n    msg = take 0x7c0e6a0d35f8ac854c7245ebc73693731bbbc3e6fab644466de27bb522fcb99307126ae718fe8f00742e6e5cb7a687c88447cbc961\n    md = 0x6f18190bd2d02fc93bce64756575cea36d08b1c3\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase54\n * ```\n *\/\nproperty testCase54 = SHA1::hash `{ l = 432 } msg == md\n  where\n    msg = take 0xc5581d40b331e24003901bd6bf244aca9e9601b9d81252bb38048642731f1146b8a4c69f88e148b2c8f8c14f15e1d6da57b2daa9991e\n    md = 0x68f525feea1d8dbe0117e417ca46708d18d7629a\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase55\n * ```\n *\/\nproperty testCase55 = SHA1::hash `{ l = 440 } msg == md\n  where\n    msg = take 0xec6b4a88713df27c0f2d02e738b69db43abda3921317259c864c1c386e9a5a3f533dc05f3beeb2bec2aac8e06db4c6cb3cddcf697e03d5\n    md = 0xa7272e2308622ff7a339460adc61efd0ea8dabdc\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase56\n * ```\n *\/\nproperty testCase56 = SHA1::hash `{ l = 448 } msg == md\n  where\n    msg = take 0x0321736beba578e90abc1a90aa56157d871618f6de0d764cc8c91e06c68ecd3b9de3824064503384db67beb7fe012232dacaef93a000fba7\n    md = 0xaef843b86916c16f66c84d83a6005d23fd005c9e\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase57\n * ```\n *\/\nproperty testCase57 = SHA1::hash `{ l = 456 } msg == md\n  where\n    msg = take 0xd0a249a97b5f1486721a50d4c4ab3f5d674a0e29925d5bf2678ef6d8d521e456bd84aa755328c83fc890837726a8e7877b570dba39579aabdd\n    md = 0xbe2cd6f380969be59cde2dff5e848a44e7880bd6\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase58\n * ```\n *\/\nproperty testCase58 = SHA1::hash `{ l = 464 } msg == md\n  where\n    msg = take 0xc32138531118f08c7dcc292428ad20b45ab27d9517a18445f38b8f0c2795bcdfe3ffe384e65ecbf74d2c9d0da88398575326074904c1709ba072\n    md = 0xe5eb4543deee8f6a5287845af8b593a95a9749a1\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase59\n * ```\n *\/\nproperty testCase59 = SHA1::hash `{ l = 472 } msg == md\n  where\n    msg = take 0xb0f4cfb939ea785eabb7e7ca7c476cdd9b227f015d905368ba00ae96b9aaf720297491b3921267576b72c8f58d577617e844f9f0759b399c6b064c\n    md = 0x534c850448dd486787b62bdec2d4a0b140a1b170\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase60\n * ```\n *\/\nproperty testCase60 = SHA1::hash `{ l = 480 } msg == md\n  where\n    msg = take 0xbd02e51b0cf2c2b8d204a026b41a66fbfc2ac37ee9411fc449c8d1194a0792a28ee731407dfc89b6dfc2b10faa27723a184afef8fd83def858a32d3f\n    md = 0x6fbfa6e4edce4cc85a845bf0d228dc39acefc2fa\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase61\n * ```\n *\/\nproperty testCase61 = SHA1::hash `{ l = 488 } msg == md\n  where\n    msg = take 0xe33146b83e4bb671392218da9a77f8d9f5974147182fb95ba662cb66011989c16d9af104735d6f79841aa4d1df276615b50108df8a29dbc9de31f4260d\n    md = 0x018872691d9b04e8220e09187df5bc5fa6257cd9\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase62\n * ```\n *\/\nproperty testCase62 = SHA1::hash `{ l = 496 } msg == md\n  where\n    msg = take 0x411c13c75073c1e2d4b1ecf13139ba9656cd35c14201f1c7c6f0eeb58d2dbfe35bfdeccc92c3961cfabb590bc1eb77eac15732fb0275798680e0c7292e50\n    md = 0xd98d512a35572f8bd20de62e9510cc21145c5bf4\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase63\n * ```\n *\/\nproperty testCase63 = SHA1::hash `{ l = 504 } msg == md\n  where\n    msg = take 0xf2c76ef617fa2bfc8a4d6bcbb15fe88436fdc2165d3074629579079d4d5b86f5081ab177b4c3f530376c9c924cbd421a8daf8830d0940c4fb7589865830699\n    md = 0x9f3ea255f6af95c5454e55d7354cabb45352ea0b\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase64\n * ```\n *\/\nproperty testCase64 = SHA1::hash `{ l = 512 } msg == md\n  where\n    msg = take 0x45927e32ddf801caf35e18e7b5078b7f5435278212ec6bb99df884f49b327c6486feae46ba187dc1cc9145121e1492e6b06e9007394dc33b7748f86ac3207cfe\n    md = 0xa70cfbfe7563dd0e665c7c6715a96a8d756950c0\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Scheme\/RSAES_OAEP.cry","filetype":"cry","content":"module Primitive::Asymmetric::Scheme::RSAES_OAEP where\n\nimport Primitive::Asymmetric::Cipher::RSA\n\nparameter\n  type k : #\n  type constraint (fin k, k >= 1)\n\n  type hLen : # \/\/ Number of octets returned by chosen hash function\n  type constraint (fin hLen, hLen >= 1)\n\n  hash : {a} (2 * hLen >= width (8 * a) ) => [a][8] -> [8 * hLen]\n\n  type KeySize = k * 8\n  n : [KeySize]\n  e : [KeySize]\n  d : [KeySize]\n\n\n\nRSAES_OAEP_ENCRYPT : {l,mLen}\n                   (fin l, fin mLen\n                   , l>=0\n                   , 2 * hLen >= width (8 * l)                    , 2 * hLen >= width (8 * ( k - hLen + 3))                    , k >= mLen+2*hLen+2\n                   , 2^^32*hLen >= k - hLen - 1                    )\n                   => [256] \/\/ Seed for random number\n                   -> [mLen][8]\n                   -> [l][8]\n                   -> [k][8]\nRSAES_OAEP_ENCRYPT rand M L = I2OSP`{k} c \/\/ Return k-octet cipher text\n                   where\n                    EM = EME_OAEP_encode rand (M, L)   \/\/ Pad message M with optional label L to k octets\n                    m  = (zero # OS2IP EM) : [KeySize]  \/\/ Take k-octet padded message EM to int of width KeySize\n                    c  = RSAEP ((n, e), m)   \/\/ Encrypt integer m\n\n\n\n\nRSAES_OAEP_DECRYPT : {l}\n                   (fin l\n                   , l>=0\n                   , 2 * hLen >= width (8 * l)                    , 2 * hLen >= width (8 * (k - hLen + 3))                    , k >= 2 * hLen + 2\n                   , 2^^32*hLen >= k - hLen - 1 \/\/ Required for use of MGF1\n                   ) => [k][8] -> [l][8] -> ([k - hLen - 1][8], [width (k - hLen - 1)])\nRSAES_OAEP_DECRYPT C L = if c < 0 \\\/ c >= n then error \"decryption error\"\n                         else M\n                   where\n                    c  = OS2IP C\n                    m  = RSADP ((n,d),c)\n                    EM = I2OSP`{k} m\n                    M  = EME_OAEP_decode (EM, L)\n\n\nRSAES_OAEP_Correct : {l,mLen}\n                   (fin l, fin mLen\n                   , 2 * hLen >= width (8 * l)                    , 2 * hLen >= width (8 * (k - hLen + 3))                    , k >= mLen+2*hLen+2\n                   , 2^^32*hLen >= k - hLen - 1 \/\/ Required for use of MGF1\n                   )\n                   => [256] \/\/ Seed for random number\n                   -> [l][8]\n                   -> [mLen][8]\n                   -> Bit\nproperty RSAES_OAEP_Correct r l m = (RSAES_OAEP_DECRYPT (RSAES_OAEP_ENCRYPT r m l) l).0 == m#(zero:[_][8])\n\n\n\nEME_OAEP_encode : {l,mLen}\n         (fin l,fin mLen\n         , l >= 0\n         , 2 * hLen >= width (8 * l) \/\/ Required for using hash\n         , 2 * hLen >= width (8 * ( k - hLen + 3)) \/\/ Required for using hash in MGF\n         , k >= mLen + 2 * hLen + 2\n         , 2^^32*hLen >= k - hLen - 1 \/\/ Required use of MGF1\n         )\n         => [256] \/\/ Seed for random number\n         -> ([mLen][8], [l][8])\n         -> [k][8]\nEME_OAEP_encode rseed (M,L) = (zero : [1][8]) # maskedSeed # maskedDB \/\/ value of EM\n         where\n          lHash      = split (hash L) : [hLen][8]\n          PS         = (zero:[(k-mLen-2*hLen-2)][8]) \/\/ This may be (zero:[0][8])\n          DB         = lHash # PS # [(1:[8])] # M\n          seed       = random rseed : [hLen][8]\n          dbMask     = MGF1`{maskLen=(k-hLen-1)} seed\n          maskedDB   = DB ^ dbMask\n          seedMask   = MGF1`{maskLen=hLen} maskedDB\n          maskedSeed = seed ^ seedMask\n\n\n\n\nEME_OAEP_decode : {l}\n         (fin l\n         , l>=0\n         , 2*hLen >= width (8 * l) \/\/ Required for using hash\n         , 2*hLen >= width (8 * ( k - hLen + 3)) \/\/ Required for using hash in MGF\n         , k >= 2 * hLen + 2\n         , 2^^32*hLen >= k - hLen - 1 \/\/ Required for using MGF1\n         ) => ([k][8], [l][8]) -> ([k - hLen - 1][8], [width (k - hLen - 1)])\nEME_OAEP_decode (EM,L) = if Y != zero then error \"decryption error\"\n                         | lHash' != lHash then error \"decryption error\"\n                         else (Mpadded,mLen)\n                where\n                  Y          = head EM\n                  maskedSeed = take`{hLen} (drop`{1} EM)\n                  maskedDB   = drop`{hLen+1} EM\n                  seedMask   = MGF1`{maskLen=hLen} maskedDB\n                  seed       = seedMask ^ maskedSeed\n                  dbMask     = MGF1`{maskLen=k-hLen-1} seed\n                  DB         = maskedDB ^ dbMask \/\/ lHash' # (zero:[_][8]) # [(1:[8])] # M\n                  lHash'     = take`{hLen} DB \/\/ This should equal hash L\n                  lHash      = split (hash L) : [_][8]\n                  (Mpadded,mLen) = extractMsg DB \/\/ Original msg is take`{mLen} Mpadded\n\nprivate\n    extractMsg : {a} (fin a, a >= 1) =>  [a][8] -> ([a][8],[width a])\n    extractMsg DB = (Mpadded, mLen)\n                where\n                 init    = {removedPad = False,\n                            padMsg     = DB,\n                            idx        = (`a:[width a])}\n                 ys      = [init] # [ if (~y.removedPad \/\\ x==(1:[8]) )\n                                          then {removedPad = True,\n                                                padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                idx        = y.idx - 1}\n                                          | y.removedPad\n                                          then y\n                                          else {removedPad = False,\n                                                padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                idx        = y.idx - 1}\n                                    | x <- DB\n                                    | y <- ys ]\n                 Mpadded = (ys!0).padMsg\n                 mLen    = (ys!0).idx\n\n\n\n\nMGF1 : {maskLen,l,counterMax}\n       (fin hLen, fin l, fin maskLen\n       , hLen >= 1\n       , maskLen >= 1\n       , 2*hLen >= width (8 * (4 + l))\n       , 2^^32 * hLen >= maskLen\n       , counterMax == maskLen\/^hLen - 1 \/\/ (ceiling maskLen\/hLen) - 1\n       )\n       => [l][8] \/\/ MGF Seed\n       -> [maskLen][8]\nMGF1 mgfSeed = take`{maskLen} Ts\n     where\n\n      Cs = map (\\counter -> I2OSP`{xLen=4} counter) ([0..counterMax]:[_][32])\n      Ts = join [ split (hash (mgfSeed # c)) : [_][8] | c <- Cs]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Scheme\/RSAES_PKCS1_v1_5.cry","filetype":"cry","content":"\/*\n * This module implements an RSA encryption scheme\n * with the EME-PCKS1-v1_5 encoding method desribed in\n * section 7.2 of\n *\n * PKCS #1: RSA Cryptography Specifications Version 2.2\n *\n * See also:\n * https:\/\/tools.ietf.org\/html\/rfc8017\n *\n * @copyright Galois Inc. 2018\n * @author Nichole Schimanski <nls@galois.com>\n * www.cryptol.net\n *\/\n\nmodule Primitive::Asymmetric::Scheme::RSAES_PKCS1_v1_5 where\n\nimport Primitive::Asymmetric::Cipher::RSA\n\nparameter\n\n  type k : #\n  type constraint (fin k, k >= 11)\n\n\n  type KeySize = k * 8\n  n : [KeySize]\n  e : [KeySize]\n  d : [KeySize]\n\n\n\n\n\n\n\nRSAES_PKCS1_v1_5_Encrypt : {mLen} (mLen <= k - 11, mLen >= 1)\n                         => [k-mLen-3][8] -> [mLen][8] -> [k][8]\nRSAES_PKCS1_v1_5_Encrypt rand M = I2OSP`{k} c\n                         where\n                          PS = rand \/\/ Needs to be random _nonzero_ octets\n                          EM = ( zero : [1][8] ) # [( 1 : [8])] # PS # ( zero : [1][8] ) # M\n                          m  = OS2IP EM\n                          c  = RSAEP ((n,e),m)\n\n\nRSAES_PKCS1_v1_5_Decrypt : [k][8] -> ([k][8],[width k])\nRSAES_PKCS1_v1_5_Decrypt C = if c >= n then error \"decryption error\" else (Mp,idx)                          where\n                          c        = OS2IP C\n                          m        = RSADP ((n,d),c)\n                          EM       = I2OSP`{k} m\n                          (Mp,idx) = EME_PKCS1_v1_5_decode EM\n\n\n\n\nRSAES_PKCS1_Correct : {mLen} (mLen <= k - 11, mLen >= 1) =>\n                    [k-mLen-3][8] -> [mLen][8] -> Bit\nproperty RSAES_PKCS1_Correct rand M = take`{mLen} ((D ( E rand M ) ).0) == M\n         where\n          D = RSAES_PKCS1_v1_5_Decrypt\n          E = RSAES_PKCS1_v1_5_Encrypt\n\n\n\n\nprivate\n\n        EME_PKCS1_v1_5_decode : [k][8] -> ([k][8],[width k])\n        EME_PKCS1_v1_5_decode EM = if (ys!0).removedPad == False then error \"decryption error\"\n                                    | firstOctet != zero then error \"decryption error\"\n                                    | secondOctet != (1:[8]) then error \"decryption error\"\n                                    | mLen + 11 > `k then error \"decryption error\"\n                                   else (Mpadded, mLen)\n                   where\n                    firstOctet  = EM@0\n                    secondOctet = EM@1\n                    init        = {removedPad = False,\n                                   padMsg     = (tail EM)#(zero:[1][8]),\n                                   idx        = (`k-1):[width k]}\n                    ys          = [init] # [ if (~y.removedPad \/\\ x==zero)\n                                             then {removedPad = True,\n                                                   padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                   idx        = y.idx - 1}\n                                             | y.removedPad\n                                             then y\n                                             else {removedPad = False,\n                                                   padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                   idx        = y.idx - 1}\n                                       | x <- tail EM\n                                       | y <- ys ]\n                    Mpadded     = (ys!0).padMsg\n                    mLen        = (ys!0).idx\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/RSA_PSS.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::RSA_PSS where\n\nimport Common::utils\n\nparameter\n  type hLen : # \/\/ Number of octets returned by chosen hash function\n  type constraint (fin hLen, hLen >= 1)\n\n  \/**\n   * Some hash functions have an upper bound on the message length they support.\n   *\n   * Most uses of `hash` here are on a fixed input made of 8 bytes of padding\n   * an `hLen`-byte hashed message, and an `hLen`-byte salt. The type constraint\n   * enforces that all such calls are on valid-length inputs.\n   *\/\n  type MessageUpperBound : #\n  type constraint (width (8 * (hLen + hLen + 8)) <= MessageUpperBound)\n\n  hash : {n} (fin n, width (8 * n) <= MessageUpperBound) => [n][8] -> [8 * hLen]\n\nMGF1 : {seedLen, maskLen} (fin seedLen, fin maskLen, width (8 * seedLen + 32) <= MessageUpperBound) => [seedLen][8] -> [maskLen][8]\nMGF1 seed = take (join [ split (hash (seed # (split c))) | c <- [(0 : [32]) ...] ])\n\n\nPSS_mgf1_encode : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> [hLen][8] -> [emLen][8]\nPSS_mgf1_encode mHash salt = EM'\n  where\n    M' = (zero : [8][8]) # mHash # salt\n    H = split (hash M')\n    DB = (zero : [emLen - 2 * hLen - 2][8]) # [0x01] # salt\n    dbMask = MGF1 H\n    maskedDB = DB ^ dbMask\n    EM = maskedDB # H # [0xbc]\n    EM' = update EM 0 ((EM @ 0) && 0x7f)\n\nPSS_mgf1_verify : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> [emLen][8] -> Bit\nPSS_mgf1_verify mHash EM = 0xbc == byte_0xbc \/\\ 0 == (maskedDB @ 0) && 0x80 \/\\ (zero : [emLen - 2 * hLen - 2][8]) == padding \/\\ 0x01 == byte_0x01 \/\\ H == H'\n  where\n    (maskedDB # H # [byte_0xbc]) = EM\n    dbMask = MGF1 H\n    DB = maskedDB ^ dbMask\n    DB' = update DB 0 ((DB @ 0) && 0x7f)\n    padding # [byte_0x01] # salt = DB'\n    M' = (zero : [8][8]) # mHash # salt\n    H' = split (hash M')\n\n\nRSA_sign : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> [hLen][8] -> Integer -> Integer -> Integer\nRSA_sign mHash salt d n = (exp (integerFromBV (join (PSS_mgf1_encode`{emLen} mHash salt))) d) % n\n\nRSA_verify : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> Integer -> Integer -> Integer -> Bit\nRSA_verify mHash sig e n = sig < n \/\\ PSS_mgf1_verify`{emLen} mHash (split (integerToBV ((exp sig e) % n)))\n\n\nexp : Integer -> Integer -> Integer\nexp = (^^)\n\nphi : Integer -> Integer\nphi = undefined\n\nrad : Integer -> Integer\nrad = undefined\n\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/RSA_PSS_SHA384.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::RSA_PSS_SHA384 = Primitive::Asymmetric::Signature::RSA_PSS where\n\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 as SHA384\n\ntype hLen = 48\nhash m = join (SHA384::hashBytes m)\ntype MessageUpperBound = SHA384::MessageUpperBound\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Cipher\/RSA.cry","filetype":"cry","content":"module Primitive::Asymmetric::Cipher::RSA where\n\nimport Common::mod_arith\n\n\/\/ Integer-to-Octet-String primitive\nI2OSP : {xLen,int} (fin int, fin xLen, int<=xLen*8, xLen>=1) =>\n      [int] -> [xLen][8]\nI2OSP x = split ((zero # x):[xLen*8]) : [xLen][8]\n\n\/\/ Octet-String-to-Integer primitive\nOS2IP : {xLen} (fin xLen) => [xLen][8] -> [xLen*8]\nOS2IP xs = join xs\n\nI2OSConversionCorrect : {xLen} (fin xLen, xLen>=1) => [xLen][8] -> Bit\nproperty I2OSConversionCorrect xs = I2OSP (OS2IP xs) == xs\n\n\n\/\/ RSA encryption primitive\nRSAEP : {K} (fin K, K >= 1) => (([K],[K]),[K]) -> [K]\nRSAEP ((n, e), m) = if (m < zero \\\/ m > (n-1)) then error \"message representative out of range\"\n                    else c\n      where c = mod_pow (n,m,e)\n\n\/\/ RSA decryption primitive\nRSADP : {K} (fin K, K >= 1) => (([K],[K]),[K]) -> [K]\nRSADP ((n, d), c) = if (c < 0 \\\/ c > (n-1)) then error \"ciphertext representative out of range\"\n                    else m\n      where m = mod_pow (n,c,d)\n\n\nRSACorrect : {K} (fin K, K >= 1) => [K] -> [K] -> [K] -> [K] -> Bit\nproperty RSACorrect e d n msg = ( msg >= zero \/\\ msg < n ) ==> RSADP ((n,d), RSAEP ((n,e), msg)) == msg\n\nrsaTest = {n = 0xbad47a84c1782e4dbdd913f2a261fc8b65838412c6e45a2068ed6d7f16e9cdf4462b39119563cafb74b9cbf25cfd544bdae23bff0ebe7f6441042b7e109b9a8afaa056821ef8efaab219d21d6763484785622d918d395a2a31f2ece8385a8131e5ff143314a82e21afd713bae817cc0ee3514d4839007ccb55d68409c97a18ab62fa6f9f89b3f94a2777c47d6136775a56a9a0127f682470bef831fbec4bcd7b5095a7823fd70745d37d1bf72b63c4b1b4a3d0581e74bf9ade93cc46148617553931a79d92e9e488ef47223ee6f6c061884b13c9065b591139de13c1ea2927491ed00fb793cd68f463f5f64baa53916b46c818ab99706557a1c2d50d232577d1 : [2048]\n           , d = 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010001 : [2048]\n           , e = 0x40d60f24b61d76783d3bb1dc00b55f96a2a686f59b3750fdb15c40251c370c65cada222673811bc6b305ed7c90ffcb3abdddc8336612ff13b42a75cb7c88fb936291b523d80acce5a0842c724ed85a1393faf3d470bda8083fa84dc5f31499844f0c7c1e93fb1f734a5a29fb31a35c8a0822455f1c850a49e8629714ec6a2657efe75ec1ca6e62f9a3756c9b20b4855bdc9a3ab58c43d8af85b837a7fd15aa1149c119cfe960c05a9d4cea69c9fb6a897145674882bf57241d77c054dc4c94e8349d376296137eb421686159cb878d15d171eda8692834afc871988f203fc822c5dcee7f6c48df663ea3dc755e7dc06aebd41d05f1ca2891e2679783244d068f : [2048]\n           , M = 0x70992c9d95a4908d2a94b3ab9fa1cd643f120e326f9d7808af50cac42c4b0b4eeb7f0d4df303a568fbfb82b0f58300d25357645721bb71861caf81b27a56082c80a146499fb4eab5bde4493f5d00f1a437bbc360dfcd8056fe6be10e608adb30b6c2f7652428b8d32d362945982a46585d2102ef7995a8ba6e8ad8fd16bd7ae8f53c3d7fcfba290b57ce7f8f09c828d6f2d3ce56f131bd9461e5667e5b73edac77f504dac4f202a9570eb4515b2bf516407db831518db8a2083ec701e8fd387c430bb1a72deca5b49d429cf9deb09cc4518dc5f57c089aa2d3420e567e732102c2c92b88a07c69d70917140ab3823c63f312d3f11fa87ba29da3c7224b4fb4bc : [2048]\n           , C = 0x7e65b998a05f626b028c75dc3fbf98963dce66d0f4c3ae4237cff304d84d8836cb6bad9ac86f9d1b8a28dd70404788b869d2429f1ec0663e51b753f7451c6b4645d99126e457c1dac49551d86a8a974a3131e9b371d5c214cc9ff240c299bd0e62dbc7a9a2dad9fa5404adb00632d36332d5be6106e9e6ec81cac45cd339cc87abbe7f89430800e16e032a66210b25e926eda243d9f09955496ddbc77ef74f17fee41c4435e78b46965b713d72ce8a31af641538add387fedfd88bb22a42eb3bda40f72ecad941dbffdd47b3e77737da741553a45b630d070bcc5205804bf80ee2d51612875dbc4796960052f1687e0074007e6a33ab8b2085c033f9892b6f74 : [2048] }\n\nproperty testsPass = rsaTest.M == RSADP ((rsaTest.n, rsaTest.d), rsaTest.C)\n\n\/\/Integer-based implementation\n\ngenRSAKeys : (Integer,Integer) -> (Integer,Integer,Integer) \/\/ (n,e,d)\ngenRSAKeys (p,q) = (p*q,e,d)\n           where nTotient = lcm (p-1) (q-1)\n                 e        = 65537 \/\/ 2^16+1, commonly used public key exponent\n                 d        = inv e nTotient\n\nprivate\n    gcd : Integer -> Integer -> Integer\n    gcd x y =  gcd' x y\n        where gcd' a b = if b == zero then a else gcd' b (a%b)\n\n\n    lcm : Integer -> Integer -> Integer\n    lcm x y =  if (x == zero \\\/ y == zero) then zero else (x \/ (gcd x y)) * y\n\n\n    inv : Integer -> Integer -> Integer \/\/ Note, k and m MUST be coprime\n    inv k m = (inv' m k).1 % m\n      where\n        inv' n x = if x==1 then (zero, 1) else (r', q' - r' * q)\n          where\n            (q,  r)  = (n\/x, n%x)\n            (q', r') = inv' x r\n\n\nrsaEncrypt : (Integer,Integer,Integer) -> Integer\nrsaEncrypt (msg,e,n) = (msg^^e)%n\n\nrsaDecrypt : (Integer,Integer,Integer) -> Integer\nrsaDecrypt (ct,d,n) = (ct^^d)%n\n\n\/\/ :prove IntegerRSACorrectKeyGen 49979693 67867967\n\/\/ :check IntegerRSACorrectKeyGen 49979693 67867967\nIntegerRSACorrectKeyGen : Integer -> Integer -> Integer -> Bit\nproperty IntegerRSACorrectKeyGen p q msg = ( msg >= zero \/\\ msg < n ) ==>\n         rsaDecrypt (rsaEncrypt (msg,e,n),d,n) == msg\n         where (n,e,d) = genRSAKeys (p,q)\n\n\/\/ :prove IntegerRSACorrect 7 103 143\n\/\/ :check IntegerRSACorrect 7 103 143\n\/\/ :check IntegerRSACorrect (toInteger e) (toInteger d) (toInteger n)\nIntegerRSACorrect : Integer -> Integer -> Integer -> Integer -> Bit\nproperty IntegerRSACorrect e d n msg = ( msg >= zero \/\\ msg < n ) ==>\n         rsaDecrypt (rsaEncrypt (msg,e,n),d,n) == msg\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/ML_DSA.cry","filetype":"cry","content":"\/**\n * ML-DSA (CRYSTALS-Dilithium) signature scheme.\n *\n * This provides an algorithm for digital signatures with non-repudiation,\n * designed to be secure against an adversary with a large-scale quantum\n * computer.\n *\n * This module implements the ML-DSA family of external functions in [FIPS-204]\n * Section 5.\n *\n * There are some requirements around the use of this algorithm that cannot be\n * enforced by Cryptol! See [FIPS-204] Section 3.6 for further details.\n * - The seed `\u03be` used in `KeyGen` must be fresh (i.e. not previously used) and\n *   must be  generated with an approved RBG with suitable security strength!\n * - The value `rnd` used in the hedged variant of `Sign` should be generated\n *   by an approved RBG, but could be generated with an alternative method\n *   to maintain some protection against side-channel attacks and fault attacks\n *   on deterministic signatures.\n * - Potentially sensitive intermediate values computed in key generation and\n *   signing must be destroyed as soon as it is no longer needed.\n *\n * Other requirements from Section 3.6 can be enforced using Cryptol (this\n * implementation enforces public-key and signature length checks, and does not\n * use floating-point arithmetic).\n *\n * References:\n * [FIPS-204]: National Institute of Standards and Technology. Module-Lattice-\n *     Based Digital Signature Standard. (Department of Commerce, Washington,\n *     D.C.), Federal Information Processing Standards Publication (FIPS) NIST\n *     FIPS 204. August 2024.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.204\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\nimport interface Primitive::Asymmetric::Signature::ML_DSA::Parameters as P\nimport Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification { interface P }\n\n\/**\n * Generate a public-private key pair.\n * [FIPS-204] Section 5.1, Algorithm 1.\n *\n * This diverges from the spec: since Cryptol does not support random number\n * generation, this function takes the randomness `\u03be` as a parameter. This value\n * must be generated in a cryptographic module using an approved random bit\n * generator (RBG).\n *\/\nKeyGen : Option ([32]Byte) -> Option (PublicKey, PrivateKey)\nKeyGen maybe_\u03be = case maybe_\u03be of\n    None -> None\n    Some \u03be -> Some (KeyGen_internal \u03be)\n\n\/**\n * Generate an ML-DSA signature.\n * [FIPS-204] Section 5.2, Algorithm 2.\n *\n * This diverges from the spec: since Cryptol does not support random number\n * generation, this function takes the randomness `rnd` as a parameter. This\n * value must be generated in a cryptographic module using an approved random\n * bit generator (RBG).\n *\n * Note: The type parameter `c` is equivalent to `|ctx|` in the spec.\n *\/\nSign : {m, c} (fin m, fin c) =>\n    PrivateKey -> [m] -> [c]Byte -> Option ([32]Byte) -> Option (Signature)\nSign sk M ctx maybe_rnd\n    \/\/ Steps 1 - 3.\n    | c > 255 => None\n    \/\/ Steps 5 - 8.\n    | c <= 255 => case maybe_rnd of\n        None -> None\n        Some rnd -> sigma where\n            \/\/ Step 10. We use `join` instead of `BytesToBits`, which produces\n            \/\/ the same byte string, but with the bits in each byte reversed.\n            \/\/ I think we have to do this to support the later call to `HBits`,\n            \/\/ which expects the bit-order and byte-order to be the same.\n            M' = join (IntegerToBytes`{1} 0 # IntegerToBytes`{1} `c # ctx) # M\n            \/\/ Step 11.\n            sigma = Some (Sign_internal sk M' rnd)\n\n\/**\n * Verify a signature for a message.\n * [FIPS-204] Section 5.3, Algorithm 3.\n *\/\nVerify : {m, c} (fin m, fin c) =>\n    PublicKey -> [m] -> Signature -> [c]Byte -> Option Bool\nVerify pk M sigma ctx\n    | c > 255 => None\n    | c <= 255 => Some (Verify_internal pk M' sigma) where\n        \/\/ Step 10. We use `join` instead of `BytesToBits`, which produces\n        \/\/ the same byte string, but with the bits in each byte reversed.\n        \/\/ I think we have to do this to support the later call to `HBits`,\n        \/\/ which expects the bit-order and byte-order to be the same.\n        M' = join (IntegerToBytes`{1} 0 # IntegerToBytes`{1} `c # ctx) # M\n\n\n\/\/ We expose the internal functions for testing purposes only.\nsubmodule TestAPI where\n    import Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification { interface P } as Spec\n\n    KeyGen_internal = Spec::KeyGen_internal\n    Sign_internal = Spec::Sign_internal\n    Verify_internal = Spec::Verify_internal\n\n\/**\n * Correctness property for MLDSA: A signature on a message generated under a\n * valid keypair must be valid.\n * This takes about 6 minutes.\n * ```repl\n * :set tests=3\n * :check MLDSAIsCorrect`{10}\n * ```\n * Note: This correctness property should also be covered by the KATs in the\n * `Tests\/` directory.\n *\/\nMLDSAIsCorrect : {m} (fin m) => [32]Byte -> [32]Byte -> [m] -> [255]Byte -> Bit\nproperty MLDSAIsCorrect \u03be rnd M ctx = sigVerifies where\n    maybe_keys = KeyGen (Some \u03be)\n    maybe_sigVerifies = case maybe_keys of\n        None -> None\n        Some keys -> case (Sign sk M ctx (Some rnd)) of\n                None -> None\n                Some sig -> Verify pk M sig ctx\n            where (pk, sk) = keys\n    sigVerifies = case maybe_sigVerifies of\n        None -> False\n        Some v -> v\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Specification.cry","filetype":"cry","content":"\/**\n * ML-DSA (CRYSTALS-Dilithium) signature scheme components.\n *\n * This provides an algorithm for digital signatures with non-repudiation,\n * designed to be secure against an adversary with a large-scale quantum\n * computer.\n *\n * This executable specification matches the final version of [FIPS-204].\n * This file _excludes_ the external functions in Section 5.\n *\n * References:\n * [FIPS-204]: National Institute of Standards and Technology. Module-Lattice-\n *     Based Digital Signature Standard. (Department of Commerce, Washington,\n *     D.C.), Federal Information Processing Standards Publication (FIPS) NIST\n *     FIPS 204. August 2024.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.204\n * [NTT-Guide]: Ardianto Satriawan, Rella Mareta, and Hanho Lee. A Complete\n *     Beginner Guide to the Number Theoretic Transform (NTT). Cryptology\n *     ePrint Archive. 2024.\n *     @see https:\/\/eprint.iacr.org\/2024\/585.pdf\n *\n * @copyright Galois Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ML_DSA::Specification where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128 as SHAKE128\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256 as SHAKE256\n\n\/**\n * The set {0, 1, ..., 255} of integers represented by a byte, denoted \ud835\udd39 in\n * the spec.\n * [FIPS-204] Section 2.3, \"\ud835\udd39\".\n *\/\ntype Byte = [8]\n\n\/**\n * The `bitlen` function defined in the spec is equivalent to the Cryptol\n * built-in `width` function on types. We use `width` throughout this\n * executable spec so that we can operate over types.\n * [FIPS-204] Section 2.3, \"bitlen a\".\n * ```repl\n * :prove bitlenIsWidth\n * ```\n *\/\nproperty bitlenIsWidth = (`(width 32) == 6) && (`(width 31) == 5)\n\n\/**\n * Ring defined as the product of 256 elements in `Z q`, used for NTT.\n * [FIPS-204] Section 2.3 and Section 2.4.1.\n *\/\ntype Tq = [256](Z q)\n\n\/**\n * Ring of single-variable polynomials over the integers mod `X^256 + 1`.\n * [FIPS-204] Section 2.3 and Section 2.4.1.\n *\n * The `i`th element of this list represents the coefficient for the degree-`i`\n * term.\n *\/\ntype R = [256]Integer\n\n\/**\n * The ring of single-variable polynomials over the integers mod 2, modulo\n * `X^256 + 1`.\n * [FIPS-204] Section 2.3 and Section 2.4.1.\n *\n * We represent individual elements in `\u2124_2` as bits, so this is just a bit\n * array.\n *\/\ntype R2 = [256]\n\n\/**\n * The ring of single-variable polynomials over the integers mod `q`, modulo\n * `X^256 + 1`.\n * [FIPS-204] Section 2.3 and Section 2.4.1.\n *\/\ntype Rq = [256](Z q)\n\n\/**\n * Compute the centered-mod function (denoted `mod\u00b1` in the spec).\n * [FIPS-204] Section 2.3, \"mod\u00b1\".\n *\/\nmodPlusMinus : {\u03b1} (fin \u03b1) => Z q -> Integer\nmodPlusMinus m = m' where\n    m_int = (fromZ m) % `\u03b1\n    m' = if m_int > (`\u03b1 \/ 2) then m_int - `\u03b1\n        else m_int\n\n\/**\n * The `mod\u00b1` function satisfies the functionality described in the spec.\n * [FIPS-204] Section 2.3, \"mod\u00b1\".\n *\n * The lower bound computes `\u2212\u2308\ud835\udefc\/2\u2309` by simplifying the ceiling division\n * equation `\u2308a \/ b\u2309 = (a + b - 1) \/ b`.\n *\n * The parameters chosen here are all the values of `\u03b1` used in the spec.\n * ```repl\n * :prove modPlusMinusWorks`{2^^d}\n * :prove modPlusMinusWorks`{q}\n * :prove modPlusMinusWorks`{2 * \u03b32}\n * ```\n *\/\nmodPlusMinusWorks : {\u03b1} (fin \u03b1) => Z q -> Bit\nproperty modPlusMinusWorks m = inRange && congruent where\n    m' = modPlusMinus`{\u03b1} m\n    lower_bound = - ((`\u03b1 + 1) \/ 2)\n    inRange = (lower_bound < m') && (m' <= (`\u03b1 \/ 2))\n    congruent = ((fromZ m) % `\u03b1) == (m' % `\u03b1)\n\n\/**\n * Compute the infinity norm over a list of elements in `Rq`.\n * [FIPS-204] Section 2.3, \"\u2016\u22c5\u2016\u221e\".\n *\/\ninfNormRq : {m} (fin m) => [m]Rq -> Integer\ninfNormRq w = maxList [ maxList [ abs (modPlusMinus`{q} wij)\n    | wij <- wi]\n    | wi <- w]\n\n\/**\n * Compute the infinity norm over a list of elements in `R`.\n * [FIPS-204] Section 2.3, \"\u2016\u22c5\u2016\u221e\".\n *\/\ninfNormR : {m} (fin m) => [m]R -> Integer\ninfNormR w = maxList [ maxList [ abs wij | wij <- wi] | wi <- w]\n\n\/**\n * Typecasts elements in `R` to `Rq` by taking the unique congruence class\n * modulo `q` tht contains each coefficient.\n * [FIPS-204] Section 2.4.1.\n *\/\ncastToRq : {m} (fin m) => [m]R -> [m]Rq\ncastToRq v = [map fromInteger vi | vi <- v]\n\nprivate\n    \/**\n     * Compute the max of a list of non-negative elements, as in\n     * [FIPS-204] Section 2.3, \"\u2016\u22c5\u2016\u221e\".\n     *\/\n    maxList : {n, a} (fin n, Literal 0 a, Cmp a) => [n]a -> a\n    maxList list = foldl max 0 list\n\n\/**\n * Apply `NTT` and `NTTInv` entry-wise over a vector of polynomials.\n * [FIPS-204] Section 2.5.\n *\n * The spec overloads the names `NTT` and `NTTInv` for both the single\n * application to a polynomial in `Rq` and the vector application to every\n * entry in a vector. Since Cryptol does not support user-defined overloaded\n * names, we define the following functions.\n *\/\nNTT_Vec = map NTT\nNTTInv_Vec = map NTTInv\n\n\/**\n * Wrapper function around SHAKE256, specifying the length `l` in bytes.\n * [FIPS-204] Section 3.7.\n *\n * The spec also defines a 3-part API for interacting with `H` (`Init`,\n * `Absorb`, `Squeeze`); we simulate this by generating an infinite output\n * and lazily taking things from it for each call to `Squeeze`, as described\n * in the same section.\n *\/\nH : {l, m} (fin m) => [m][8] -> [l][8]\nH str = SHAKE256::xofBytes`{8 * l} str\n\n\/**\n * Wrapper function around SHAKE256 that takes bit strings as input.\n * [FIPS-204] Section 3.7.\n *\n *\n *\/\nHBits : {l, m} (fin m) => [m] -> [l][8]\nHBits str = split (SHAKE256::xof`{8 * l} (str))\n\n\/**\n * Wrapper function around SHAKE128, specifying the length `l` in bytes.\n * [FIPS-204] Section 3.7.\n *\n * The spec also defines a 3-part API for interacting with `G` (`Init`,\n * `Absorb`, `Squeeze`); we simulate this by generating an infinite output\n * and lazily taking things from it for each call to `Squeeze`, as described\n * in the same section.\n *\/\nG : {l, m} (fin m) => [m][8] -> [l][8]\nG str = SHAKE128::xofBytes`{8 * l} str\n\n\/\/ [FIPS-204] Section 4 is largely defined in this interface.\nimport interface Primitive::Asymmetric::Signature::ML_DSA::Parameters\n\n\/**\n * A 512th root of unity in `Z_q`.\n * [FIPS-204] Section 4, Table 1.\n *\/\n\u03b6 : Z q\n\u03b6 = 1753\n\n\/**\n * Number of dropped bits from `t` (this compresses the public key for\n * a performance optimization).\n * [FIPS-204] Section 4, Table 1.\n *\/\ntype d = 13\n\n\/**\n * Allowable error range for signature components. In signing, this is used to\n * determine if a candidate signature is valid.\n * [FIPS-204] Section 4, Table 1.\n *\/\n\u03b2 = `(\u03b7 * \u03c4) : Integer\n\n\/**\n * Public key for the ML-DSA scheme.\n * [FIPS-204] Section 5.1, Algorithm 1 (and throughout).\n *\/\ntype PublicKey = [32 + 32 * k * (width (q - 1) - d)]Byte\n\n\/**\n * Private key for the ML-DSA scheme.\n * [FIPS-204] Section 5.1, Algorithm 1 (and throughout).\n *\/\ntype PrivateKey = [32 + 32 + 64 + 32 * ((k + ell) * width (2 * \u03b7) + d * k)]Byte\n\n\/**\n * Signature generated by the ML-DSA scheme.\n * [FIPS-204] Section 5.2, Algorithm 2 (and throughout).\n *\/\ntype Signature = [\u03bb \/ 4 + ell * 32 * (1 + width (\u03b31 - 1)) + \u03c9 + k]Byte\n\n\/**\n * Generate a public-private key pair from a seed.\n * [FIPS-204] Section 6.1, Algorithm 6.\n *\n * Warning: This interface must not be made available to applications (other\n * than for testing purposes)! Implementations must manually verify that this\n * interface is not public.\n * The randomness `\u03be` passed to this function should be generated by a\n * cryptographic module.\n *\/\nKeyGen_internal : [32]Byte -> (PublicKey, PrivateKey)\nKeyGen_internal \u03be = (pk, sk) where\n    \/\/ Step 1.\n    (\u03c1 # \u03c1' # K) = H`{128} (\u03be # IntegerToBytes`{1} `k # IntegerToBytes`{1} `ell)\n\n    \/\/ Step 3.\n    A_hat = ExpandA \u03c1\n        (s1, s2) = ExpandS \u03c1'\n\n    \/\/ Explicitly typecast vectors in `R` to `Rq`.\n    s1' = castToRq s1\n    s2' = castToRq s2\n\n    \/\/ Step 5.\n    t = NTTInv_Vec (A_hat \u2218\u2218 NTT_Vec s1') + s2'\n    \/\/ Step 6.\n    (t1, t0) = Power2Round t\n\n    \/\/ Step 8.\n    pk = pkEncode \u03c1 t1\n    \/\/ Step 9.\n    tr = H`{64} pk\n    \/\/ Step 10.\n    sk = skEncode \u03c1 K tr s1 s2 t0\n\n\n\/**\n * Deterministic algorithm to generate a signature for a formatted message `M'`.\n * [FIPS-204] Section 6.2, Algorithm 7.\n *\n * Warning: This interface must not be made available to applications (other\n * than for testing purposes)! Implementations must manually verify that this\n * interface is not public.\n * The randomness `rnd` passed to this function should be generated by a\n * cryptographic module.\n *\/\nSign_internal : {m} (fin m) => PrivateKey -> [m] -> [32]Byte -> Signature\nSign_internal sk M' rnd = \u03c3 where\n    \/\/ Step 1.\n    (\u03c1, K, tr, s1, s2, t0) = skDecode sk\n\n    \/\/ Steps 2 - 5.\n    s1_hat = NTT_Vec (castToRq s1)\n    s2_hat = NTT_Vec (castToRq s2)\n    t0_hat = NTT_Vec (castToRq t0)\n    A_hat = ExpandA \u03c1\n\n    \/\/ Step 6. We use `join` instead of `BytesToBits`, which produces the same\n    \/\/ byte string, but with the bits in each byte reversed. I think we have to\n    \/\/ do this to support the call to `HBits`, which expects the bit-order and\n    \/\/ byte-order to be the same.\n    \u03bc = HBits`{64} (join tr # M')\n\n    \/\/ Step 7.\n    \u03c1''= H`{64} (K # rnd # \u03bc)\n\n    \/\/ Steps 10 - 32. The rejection sampling loop in the spec is implemented\n    \/\/ here using recursion.\n    rejection_sample: Integer -> ([\u03bb \/ 4]Byte, ([ell]Rq, [k]R2))\n    rejection_sample \u03ba = case maybe_zh of\n            Some zh -> (c_til, zh)\n            None -> rejection_sample (\u03ba + `ell)\n        where\n            y = castToRq (ExpandMask \u03c1'' \u03ba)\n            w = NTTInv_Vec (A_hat \u2218\u2218 (NTT_Vec y))\n            w1 = HighBits w\n            c_til = H`{\u03bb \/ 4} (\u03bc # w1Encode w1)\n            [c] = castToRq [(SampleInBall c_til)]\n            c_hat = NTT c\n            cs1 = NTTInv_Vec (c_hat \u2218 s1_hat)\n            cs2 = NTTInv_Vec (c_hat \u2218 s2_hat)\n            z = y + cs1\n            r0 = LowBits (w - cs2)\n            maybe_zh = if (infNormRq z >= `\u03b31 - \u03b2) || (infNormR r0 >= `\u03b32 - \u03b2)\n                then None\n                else maybe_zh' where\n                    ct0 = NTTInv_Vec (c_hat \u2218 t0_hat)\n                    h = MakeHint (-ct0) (w - cs2 + ct0)\n                    maybe_zh' =\n                        if (infNormRq ct0 >= `\u03b32) || (numberOf1sInh > `\u03c9)\n                        then None\n                        else Some (z, h)\n\n                    \/\/ Compute the number of 1s in the hint by converting each\n                    \/\/ bit to an integer and summing them.\n                    numberOf1sInh = sum [if b then 1 else 0 | b <- join h]\n\n        (c_tilFinal, (zFinal, hFinal)) = rejection_sample 0\n\n    \/\/ In Step 33, `modPlusMinus` is applied componentwise to the vector `z`.\n    modPlusMinus_Vec v = [map modPlusMinus`{q} vi | vi <- v]\n\n        \u03c3 = sigEncode c_tilFinal (modPlusMinus_Vec zFinal) hFinal\n\n\/**\n * Internal function to verify a signature for a formatted message.\n * [FIPS-204] Section 6.3, Algorithm 8.\n *\n * This interface should not be provided to applications (other than for\n * testing purposes).\n *\n * If an implementation accepts inputs for the public key or the signature of\n * any length other than those defined by `PublicKey` and `Signature`, this\n * function should reject them.\n *\/\nVerify_internal : {m} (fin m) => PublicKey -> [m] -> Signature -> Bool\nVerify_internal pk M' \u03c3 = isValid where\n        (rho, t1) = pkDecode pk\n    (c_til, z, h) = sigDecode \u03c3\n\n    \/\/ Step 5.\n    A_hat = ExpandA rho\n    \/\/ Step 6.\n    tr = H`{64} pk\n    \/\/ Step 7. We use `join` instead of `BytesToBits`, which produces the same\n    \/\/ byte string, but with the bits in each byte reversed. I think we have to\n    \/\/ do this to support the call to `HBits`, which expects the bit-order and\n    \/\/ byte-order to be the same.\n    mu = HBits`{64} (join tr # M')\n\n    \/\/ Step 8.\n    [c] = castToRq [(SampleInBall c_til)]\n\n    \/\/ These casts are implicit in Step 9 in the sepc.\n    t1' = castToRq t1\n    z' = castToRq z\n    \/\/ The spec uses the shorthand `t1 * 2^d`; in Cryptol, we need to create\n    \/\/ a matrix with the same dimensions as `t1` where every element is `2^d`.\n    two_d = repeat (repeat (2^^`d))\n\n    \/\/ Step 9.\n    wApprox' = NTTInv_Vec (A_hat \u2218\u2218 NTT_Vec z' - (NTT c \u2218 NTT_Vec (t1' * two_d)))\n\n    \/\/ Steps 3 - 4, 10 - 13.\n    isValid = case h of\n        None -> False\n        Some h' -> (infNormR z < `\u03b31 - \u03b2) && (c_til == c_til') where\n            w1' = UseHint h' wApprox'\n            c_til' = H`{\u03bb \/ 4} (mu # w1Encode w1')\n\n\/**\n * Compute a base-2 representation of the input mod `2^\u03b1` using little-endian\n * order.\n * [FIPS-204] Section 7.1, Algorithm 9.\n *\/\nIntegerToBits : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]\nIntegerToBits x = y' where\n    \/\/ Step 3. Compute the value of each `y_i`.\n    y = [x' % 2 | x' <- xs' | i <- [0..\u03b1 - 1]]\n\n    \/\/ Step 4. Compute value of `x'` at each iteration of the loop.\n    \/\/ In Cryptol, integer division takes the floor by default.\n    xs' = [x] # [x' \/ 2 | x' <- xs']\n\n    \/\/ Cryptol-specific conversion: convert each Integer-typed bit to an actual\n    \/\/ bit and join into a single vector.\n    y' = join [(fromInteger yi) : [1] | yi <- y]\n\n\/**\n * Compute the integer value expressed by a bit string using little-endian\n * order.\n * [FIPS-204] Section 7.1, Algorithm 10.\n *\/\nBitsToInteger : {\u03b1} (fin \u03b1, \u03b1 > 0) => [\u03b1] -> Integer\nBitsToInteger y = xs ! 0 where\n    \/\/ Cryptol-specific conversion: separate the input into \u03b1 1-bit vectors,\n    \/\/ then convert each to an integer.\n    y' = map toInteger (split`{\u03b1} y)\n\n    \/\/ Steps 1 - 4. Compute the value of `x` at each iteration of the loop.\n    xs = [0] # [2 * x + y' @ (`\u03b1 - i)\n        | x <- xs\n        | i <- [1..\u03b1]]\n\n\/**\n * The integer \/ bit conversion functions must invert each other.\n * This is not explicit in the spec, but we define the property anyway.\n * The parameter choices are approximately the same as some of the use cases\n * in the spec.\n * ```repl\n * :check BitsToIntegersInverts`{44}\n * :exhaust BitsToIntegersInverts`{10}\n * ```\n *\/\nBitsToIntegersInverts : {\u03b1} (fin \u03b1, \u03b1 > 0) => [\u03b1] -> Bit\nproperty BitsToIntegersInverts x = IntegerToBits (BitsToInteger x) == x\n\n\/**\n * Compute a base-256 representation of `x mod 256^\u03b1` using little-endian byte\n * order.\n * [FIPS-204] Section 7.1, Algorithm 11.\n *\/\nIntegerToBytes : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]Byte\nIntegerToBytes x = y where\n        y = [fromInteger (x' % 256) | x' <- xs' | i <- [0..\u03b1 - 1]]\n\n    \/\/ Step 4. Compute the value of `x'` at each iteration of the loop.\n    xs' = [x] # [x' \/ 256 | x' <- xs']\n\n\/**\n * Convert a bit string into a byte string using little-endian order.\n * [FIPS-204] Section 7.1, Algorithm 12.\n *\/\nBitsToBytes : {\u03b1} (fin \u03b1) => [\u03b1]Bit -> [\u03b1 \/^ 8]Byte\nBitsToBytes y\n    \/\/ A zero-length input will produce a zero-length output.\n    | \u03b1 == 0 => zero\n    | \u03b1 > 0 => z where\n        \/\/ Compute the values of `y[i]` and `i` at each iteration of the loop.\n        \/\/ To simplify the next step, this also:\n        \/\/ - Groups the `y[i]` bits into sets of 8 for each `z[\u230ai \/ 8\u230b]`, and\n        \/\/ - Pads each bit of `y[i]` into a byte to support subsequent operations.\n        y' = groupBy`{8} ([(zext [yi], i)\n            | yi <- y\n            | i <- [0..\u03b1 - 1]] # zero)\n\n        \/\/ Steps 2 - 4. We compute the `y` terms separately then `sum` them\n        \/\/ for each byte in `z`.\n        z = [sum [yi * (2 ^^ (i % 8))\n                | (yi, i) <- yi8]\n            | yi8 <- y']\n\n\/**\n * Convert a byte string into a bit string using little-endian order.\n * [FIPS-204] Section 7.1, Algorithm 13.\n *\/\nBytesToBits : {\u03b1} (fin \u03b1) => [\u03b1]Byte -> [8 * \u03b1]Bit\nBytesToBits z\n    | \u03b1 == 0 => []\n    | \u03b1 > 0 => join [[ y8ij where\n            \/\/ Step 4. Taking the last bit is the same as modding by 2. (See\n            \/\/ `mod2IsFinalBit`).\n            y8ij = zi' ! 0\n            \/\/ Step 5. Shifting right is the same as the iterative\n            \/\/ division (see `div2IsShiftR`). This accounts for all the\n            \/\/ divisions \"up to this point\" (e.g. none when `j = 0`), which\n            \/\/ is why we use `zi'` to evaluate `y8ij` above.\n            zi' = zi >> j\n        \/\/ Step 3.\n        | j <- [0..7]]\n        \/\/ Step 2. We iterate over `z` directly instead of indexing into it.\n        | zi <- z ]\n\nprivate\n    \/**\n     * The iterative division by 2 in `BytesToBits` is the same as shifting\n     * right.\n     * ```repl\n     * :prove div2IsShiftR\n     * ```\n     *\/\n    div2IsShiftR : Byte -> Bit\n    div2IsShiftR C = take (d2 C) == shl where\n        \/\/ Note: division here is floor'd by default.\n        d2 c = [c] # d2 (c \/ 2)\n        shl = [C >> j | j <- [0..7]]\n\n\/**\n * The conversions between bits and bytes are each others' inverses, for\n * lengths that are a multiple of 8.\n * This isn't explicit in the spec, but we include the property anyway.\n * This takes ~10 seconds.\n * ```repl\n * :prove B2B2BInverts`{320}\n * :prove B2B2BInverts`{32 * 44}\n * ```\n *\/\nB2B2BInverts : {\u03b1} (fin \u03b1) => [8 * \u03b1] -> Bit\nproperty B2B2BInverts y = BytesToBits (BitsToBytes y) == y\n\n\/**\n * Generate an element in the integers mod `q` or a failure indicator.\n * [FIPS-204] Section 7.1, Algorithm 14.\n *\/\nCoeffFromThreeBytes : Byte -> Byte -> Byte -> Option (Z q)\nCoeffFromThreeBytes b0 b1 b2 = maybe_z where\n        b2' = if b2 > 127 then b2 - 128 else b2\n\n    \/\/ We have to explicitly expand the byte strings to support the\n    \/\/ operations in the next step. 32 bits gives us plenty of space.\n    [bq0, bq1, bq2'] = map zext`{32} [b0, b1, b2']\n\n    \/\/ Step 5.\n    z = 2^^16 * bq2' + 2^^8 * bq1 + bq0\n\n    \/\/ Step 6 - 7. We have to convert `z` into `Z q` manually in the successful\n    \/\/ case -- note that we can't do it sooner because otherwise the condition\n    \/\/ is moot.\n    maybe_z = if z < `q then Some (toZ z) else None\n\n    toZ : [32] -> Z q\n    toZ b = fromInteger (toInteger b)\n\n\/**\n * Generate an element of {-\u03b7, -\u03b7 + 1, ..., \u03b7} or a failure indicator.\n * [FIPS-204] Section 7.1, Algorithm 15.\n *\/\nCoeffFromHalfByte : [4] -> Option Integer\nCoeffFromHalfByte b =\n    if (`\u03b7 == 2) && (b < 15) then Some (2 - (toInteger b % 5))\n    else\n        if (`\u03b7 == 4) && (b < 9) then Some (4 - toInteger b)\n        else None\n\n\/**\n * Encode a polynomial `w` into a byte string.\n * [FIPS-204] Section 7.1, Algorithm 16.\n *\n * This function assumes that all the coefficients of `w` are in the range\n * `[0, b]`.\n *\/\nSimpleBitPack : {b} (fin b, width b > 0) => R -> [32 * width b]Byte\nSimpleBitPack w = BitsToBytes z where\n    z = join [IntegerToBits`{width b} (w@i) | i <- [0..255]]\n\n\/**\n * Encode a polynomial `w` into a byte string.\n * [FIPS-204] Section 7.1, Algorithm 17.\n *\n * This function assumes that all the coefficients of `w` are in the range\n * `[-a, b]`.\n *\/\nBitPack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    R -> [32 * width (a + b)]Byte\nBitPack w = BitsToBytes z where\n    z = join [IntegerToBits`{width (a + b)} (`b - w@i) | i <- [0..255]]\n\n\/**\n * Reverses the procedure `SimpleBitPack`.\n * [FIPS-204] Section 7.1, Algorithm 18.\n *\n * For some choices of `b`, there are inputs that will cause this function to\n * output polynomials whose coefficients are not in the range `[0, b]`.\n *\/\nSimpleBitUnpack : {b} (fin b, width b > 0) => [32 * width b]Byte -> R\nSimpleBitUnpack v = w where\n    type c = width b\n    z = BytesToBits v\n    \/\/ Separate `z` into the sets `[z[ic], z[ic + 1], ... , z[ic + c - 1]]` for\n    \/\/ `i` in the range `[0..255]`.\n    z_ics = split z : [256][c]\n    w = [BitsToInteger`{c} (z_ics@i) | i <- [0..255]]\n\n\/**\n * `SimpleBitUnpack` reverses `SimpleBitPack`.\n * To ensure the precondition for `SimpleBitPack`, we take the input as an set\n * of integers mod `b` and convert to integers.\n * [FIPS-204] Section 7.1, comment on Algorithm 18.\n * ```repl\n * :check SimplePackingInverts`{10}\n * ```\n *\/\nSimplePackingInverts : {b} (fin b, width b > 0) => [256](Z b) -> Bit\nproperty SimplePackingInverts w_inRange = simplePackInverts where\n    w = map fromZ w_inRange\n    simplePackInverts = SimpleBitUnpack`{b} (SimpleBitPack`{b} w) == w\n\n\/**\n * Reverse the procedure `BitPack`.\n * [FIPS-204] Section 7.1, Algorithm 19.\n *\n * For some choices of `a` and `b`, there are malformed byte strings that will\n * cause this function to output polynomials whose coefficients are not in the\n * range `[-a, b]`.\n *\/\nBitUnpack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    [32 * width (a + b)]Byte -> R\nBitUnpack v = w where\n    type c = width (a + b)\n    z = BytesToBits v\n\n    \/\/ Split `z` into the sets `[z[ic], z[ic + 1], ... , z[ic + c - 1]]` for\n    \/\/ `i` in the range `[0..255]`.\n    z_ics = split z : [256][c]\n\n    w = [`b - BitsToInteger`{c} (z_ics@i)| i <- [0..255]]\n\n\/**\n * `BitUnpack` reverses `BitPack`.\n * To ensure the precondition for `BitPack`, we take the input as an set\n * of integers mod `a + b `, convert to integers, then shift them down to the\n * interval `[-a, b]`.\n * [FIPS-204] Section 7.1, comment on Algorithm 19.\n * ```repl\n * :check PackingInverts`{10, 10}\n * ```\n *\/\nPackingInverts : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    [256](Z (a + b)) -> Bit\nproperty PackingInverts w_inRange = packInverts where\n    \/\/ Shift from `[0, a + b]` to `[-a, b]`.\n    w = [(fromZ wi) - `a | wi <- w_inRange]\n    packInverts = BitUnpack`{a, b} (BitPack`{a, b} w) == w\n\n\/**\n * Encode a polynomial vector `h` with binary coefficients into a byte string.\n * [FIPS-204] Section 7.1, Algorithm 20.\n *\/\nHintBitPack : [k]R2 -> [\u03c9 + k]Byte\nHintBitPack h = yFinal where\n    \/\/ Step 1.\n    y0 = zero : [\u03c9 + k]Byte\n    \/\/ Step 2.\n    Index0 = 0\n    \/\/ Steps 3 - 11. This builds a list with all the intermediate values of\n    \/\/ `y` and `Index`...\n    yAndIndex = [(y0, Index0)] # [ (y'', Index') where\n            \/\/ Steps 5 - 8.\n            (y', Index') = if (h @i @j) != 0 then\n                    (update y Index j, Index + 1)\n                else (y, Index)\n\n            \/\/ Step 10.\n            y'' = if j == 255 then\n                    update y' (`\u03c9 + i) Index'\n                else y'\n        | (y, Index) <- yAndIndex\n        \/\/ Step 3 - 4.\n        | i <- [0..k-1], j <- [0..255]\n    ]\n    \/\/ Step 12. ...we return the last `y`.\n    (yFinal, _) = yAndIndex ! 0\n\n\/**\n * Reverses the procedure `HintBitPack`.\n * [FIPS-204] Section 7.1, Algorithm 21.\n *\n * This diverges slightly from the spec:\n * - To simplify updating `h`, we treat it as a single array of size `256k`.\n *   We separate it into the correct `[k]R2` representation in the final step.\n *   We access the array in \"the natural way\" -- that is, in Step 12, the\n *   element `h[i]_y[Index]` is at index `i * 256 + y[Index]` in our array.\n * - We cannot \"return early\" when we encounter an error case. Instead, we use\n *   options to indicate whether a failure has occurred and skip further\n *   computation when the option is `None`.\n * - The for loop in Step 3 is executed with a list comprehension. The while\n *   loop in Step 7 is executed with recursion. The for loop in Step 16 is\n *   executed with recursion.\n *\/\nHintBitUnpack : [\u03c9 + k]Byte -> Option ([k]R2)\nHintBitUnpack y = hFinal where\n    \/\/ Step 1.\n    h0 = zero : [k * 256]\n    \/\/ Step 2.\n    Index0 = 0\n\n    \/\/ Step 3. Construct a list comprising the values of `h` and `Index`\n    \/\/ at the end of each iteration of the loop in Steps 3 - 15.\n    hAndIndexes = [Some (h0, Index0)] # [\n            \/\/ Call Steps 4-5 if we haven't encountered an error yet.\n            case maybe_hAndIndex of\n                Some hAndIndex -> Step4_5 hAndIndex i\n                None -> None\n        | maybe_hAndIndex <- hAndIndexes\n        | i <- [0..k-1]\n    ]\n\n    \/\/ Steps 4 - 5.\n    Step4_5 (h, Index) i = if (y@(`\u03c9 + i) < Index) || (y@(`\u03c9 + i) > `\u03c9) then\n            None\n        else Step6_15 (h, Index) i\n\n    \/\/ Steps 6 - 15.\n    Step6_15 (h, Index) i = Step7_14 (h, Index) where\n        \/\/ Step 6.\n        First = Index\n\n        \/\/ Steps 7 - 14.\n        Step7_14 (h', Index') =\n            \/\/ Step 7 (condition).\n            if Index' < (y@(`\u03c9 + i)) then\n                \/\/ Step 8 - 11.\n                \/\/ The `\/\\` is a short-cutting `and`, equivalent to the nested\n                \/\/ `if` statements in the spec.\n                if ((Index' > First) \/\\ (y@(Index' - 1) >= y@Index')) then None\n                \/\/ Step 7 (recursive call -- equivalent to continuing the loop).\n                else Step7_14\n                    \/\/ Step 12.\n                    (update h' (i*256 + (toInteger (y@Index'))) 1,\n                    \/\/ Step 13.\n                    Index' + 1)\n            \/\/ If the loop condition is no longer true, return the current\n            \/\/ values of `h` and `Index`.\n            else Some (h', Index')\n\n    \/\/ Get the values of `h` and `Index` after the loop in Steps 3 - 15.\n    maybe_hAndIndex' = hAndIndexes ! 0\n\n    \/\/ Step 16 - 20.\n    hFinal = case maybe_hAndIndex' of\n        Some hAndIndex -> if checkLeftoverBytes then\n                \/\/ This `split` converts back to the spec-adherent\n                \/\/ representation of `h`.\n                Some (split`{k} h)\n            else None\n            where\n                (h, Index) = hAndIndex\n                \/\/ This helper reads any \"leftover\" bytes (e.g. beyond `Index`)\n                \/\/ in the first `\u03c9` bytes of `y`; it returns `True` if all of\n                \/\/ them are zero.\n                checkLeftoverBytes = and [i >= Index ==> y@i == 0\n                    | i <- [0..\u03c9 - 1]]\n\n        None -> None\n\n\/**\n * Verify that `HintBitUnpack` is the reverse of `HintBitPack`.\n *\n * This takes a list of indexes indicating the non-zero elements and constructs\n * a valid, sparse `h` -- rejection sampling is not a valid option because\n * sparse-enough `h`s were too rare.\n *\n * We test the case where we have the maximum number of 1s, a medium number, and\n * a case where at least one vector should have no non-zero terms at all.\n * In practice, the hint may fall anywhere in this range.\n * This takes about 1 minute.\n * ```repl\n * :check HintPackingInverts`{\u03c9}\n * :check HintPackingInverts`{\u03c9 \/ 2}\n * :check HintPackingInverts`{3}\n * ```\n *\n * Note that this does not test the error cases for `HintBitUnpack`.\n *\/\nHintPackingInverts : {w} (w <= \u03c9) => [w][lg2 (256 * k)] -> Bit\nproperty HintPackingInverts h_Indexes =\n    case HintBitUnpack (HintBitPack h) of\n        Some h' -> h == h'\n        None -> False\n    where\n        h = buildHint h_Indexes\n\nprivate\n    \/**\n     * Creates a hint with `w` non-zero entries at the indices specified in\n     * the parameter.\n     * This is for testing functions that take a hint as a parameter and assume\n     * it is appropriately sparse.\n     *\/\n    buildHint : {w} (w <= \u03c9) => [w][lg2 (256 * k)] -> [k]R2\n    buildHint h_Indexes = h where\n        h = split`{k} [if elem idx h_Indexes then 1 else 0 | idx <- [0..(256 * k) - 1]]\n\n\/**\n * Encode a public key for ML-DSA into a byte string.\n * [FIPS-204] Section 7.2, Algorithm 22.\n *\n * This assumes that `t1` has coefficients in the range\n * `[0, 2^(bitlen(q-1) - d) - 1]`.\n *\/\npkEncode : [32]Byte -> [k]R -> PublicKey\npkEncode \u03c1 t1 = pk where\n    pk = \u03c1 # join [SimpleBitPack`{2 ^^ (width (q - 1) - d) - 1} (t1@i) | i <- [0..k-1]]\n\n\/**\n * Reverse the procedure `pkEncode`.\n * [FIPS-204] Section 7.2, Algorithm 23.\n *\n * This produces a `t1` with coefficients in the range\n * `[0, 2^(bitlen(q-1) - d) - 1]`.\n *\/\npkDecode : PublicKey -> ([32]Byte, [k]R)\npkDecode pk = (\u03c1, t1) where\n    \/\/ Step 1. We split off the single `\u03c1` byte, then separate the remaining\n    \/\/ bytes into the `k` components as described.\n    (\u03c1 # zBytes) = pk\n    z = split zBytes\n    \/\/ Steps 2 - 4.\n    t1 = [SimpleBitUnpack`{2 ^^ (width (q - 1) - d) - 1} (z@i) | i <- [0..k-1]]\n\nprivate\n    \/**\n     * `pkDecode` must reverse the procedure `pkEncode`.\n     * This takes about 30s.\n     * ```repl\n     * :set tests=20\n     * :check pkCodingInverts\n     * ```\n     *\/\n    pkCodingInverts : [32]Byte -> [k][256][width (q - 1) - d] -> Bit\n    pkCodingInverts \u03c1 t1_inRange = inverts where\n        \/\/ `t1_inRange` is typed to ensure that all the coefficients will be\n        \/\/ in the range `[0, 2^^(width (q-1)-d) - 1]`.\n        t1 = [map toInteger t1_i | t1_i <- t1_inRange]\n        (\u03c1', t1') = pkDecode (pkEncode \u03c1 t1)\n        inverts = (\u03c1 == \u03c1') && (t1 == t1')\n\n\/**\n * Encodes a secret key for ML-DSA into a byte string.\n * [FIPS-204] Secetion 7.2, Algorithm 24.\n *\/\nskEncode : [32]Byte -> [32]Byte -> [64]Byte -> [ell]R -> [k]R -> [k]R\n    -> PrivateKey\nskEncode \u03c1 K tr s1 s2 t0 = sk9 where\n    \/\/ Note: `sk#` indicates the value of `sk` at Step `#`.\n    \/\/ Step 1.\n    sk1 = \u03c1 # K # tr\n    \/\/ Steps 2 - 4.\n    sk3 = sk1 # join [BitPack`{\u03b7, \u03b7} (s1@i) | i <- [0..ell-1]]\n    \/\/ Steps 5 - 7.\n    sk6 = sk3 # join [BitPack`{\u03b7, \u03b7} (s2@i) | i <- [0..k-1]]\n    \/\/ Steps 8 - 10.\n    sk9 = sk6 #\n        join [BitPack`{2^^(d - 1) - 1, 2^^(d - 1)} (t0@i) | i <- [0..k-1]]\n\n\/**\n * Reverse the procedure `skEncode`.\n * [FIPS-204] Section 7.2, Algorithm 25.\n *\n * Warning: there exist malformed inputs that can cause `skDecode` to return\n * values that are not in the correct range! `skDecode` must only be run on\n * inputs that come from trusted sources!\n *\/\nskDecode : PrivateKey -> ([32]Byte, [32]Byte, [64]Byte, [ell]R, [k]R, [k]R)\nskDecode sk = (\u03c1, K, tr, s1, s2, t0) where\n    \/\/ Step 1. We split off the six components, then further separate `y`, `z`,\n    \/\/ and `w` into their two dimensions.\n    (\u03c1 # K # tr # yBytes # zBytes # wBytes) = sk\n    y = split`{ell} yBytes\n    z = split`{k} zBytes\n    w = split`{k} wBytes\n\n    \/\/ Steps 2 - 4.\n    s1 = [BitUnpack`{\u03b7, \u03b7} (y@i) | i <- [0..ell-1]]\n    \/\/ Steps 5 - 7.\n    s2 = [BitUnpack`{\u03b7, \u03b7} (z@i) | i <- [0..k-1]]\n    \/\/ Steps 8 - 10.\n    t0 = [BitUnpack`{2^^(d - 1) - 1, 2^^(d - 1)} (w@i) | i <- [0..k-1]]\n\nprivate\n    \/**\n     * The `skDecode` function must be the inverse of `skEncode`.\n     * [FIPS-204] Section 7.3, comment on Algorithm 25.\n     *\n     * This test enforces the range requirements on the inputs to\n     * `skEncode` by taking parameters in the integers mod groups, then\n     * converting to unbounded integers and shifting to be in the expected\n     * range.\n     *\n     * This takes about 1 minute.\n     * ```repl\n     * :set tests=20\n     * :check skCodingInverts\n     * ```\n     *\/\n    skCodingInverts : [32]Byte -> [32]Byte -> [64]Byte\n        -> [ell][256](Z (2 * \u03b7))\n        -> [k][256](Z (2 * \u03b7))\n        -> [k][256](Z (2 ^^ d - 1))\n        -> Bit\n    skCodingInverts \u03c1 K tr s1_inRange s2_inRange t0_inRange = inverts where\n        \/\/ Adjust to be in the correct range and of the correct type.\n        s1 = [[(fromZ s1_ij) - `\u03b7 | s1_ij <- s1_j ] | s1_j <- s1_inRange]\n        s2 = [[(fromZ s2_ij) - `\u03b7 | s2_ij <- s2_j ] | s2_j <- s2_inRange]\n        t0 = [[(fromZ t0_ij) - (2 ^^ (`d-1) - 1)\n            | t0_ij <- t0_j ]\n            | t0_j <- t0_inRange]\n\n        (\u03c1', K', tr', s1', s2', t0') = skDecode (skEncode \u03c1 K tr s1 s2 t0)\n        inverts = (\u03c1 == \u03c1') && (K == K') && (tr == tr')\n            && (s1 == s1') && (s2 == s2') && (t0 == t0')\n\n\/**\n * Encode a signature into a byte string.\n * [FIPS-204] Section 7.3, Algorithm 26.\n *\n * The parameter `z` must have coefficients in `[-\u03b31 + 1, \u03b31]`.\n *\/\nsigEncode : [\u03bb \/ 4]Byte -> [ell]R -> [k]R2 -> Signature\nsigEncode c_til z h = \u03c3 where\n    \/\/ Note that `\u03c3#` indicates the value of `\u03c3` at Step `#`.\n    \/\/ Step 1.\n    \u03c31 = c_til\n    \/\/ Step 2 - 4.\n    \u03c33 = \u03c31 # join [BitPack`{\u03b31 - 1, \u03b31} (z@i) | i <- [0..ell-1]]\n    \/\/ Step 5.\n    \u03c3 = \u03c33 # HintBitPack h\n\n\/**\n * Reverse the procedure `sigEncode`.\n * [FIPS-204] Section 7.3, Algorithm 27.\n *\/\nsigDecode : Signature -> ([\u03bb \/ 4]Byte, [ell]R, Option ([k]R2))\nsigDecode \u03c3 = (c_til, z, h) where\n    \/\/ Step 1. We separate into bytes, then further split `x` into its two\n    \/\/ dimensions.\n    (c_til # xBytes # y) = \u03c3\n    x = split`{ell} xBytes\n\n    \/\/ Step 2 - 4.\n    z = [BitUnpack`{\u03b31 - 1, \u03b31} (x@i) | i <- [0..ell-1]]\n    \/\/ Step 5.\n    h = HintBitUnpack y\n\nprivate\n    \/**\n     * `sigDecode` must be the reverse of `sigEncode`.\n     * [FIPS-204] Section 7.3, comment on Algorithm 27.\n     *\n     * The parameter `w` defines the number of non-zero entries in the hint.\n     * It can be any number in the range `[0, \u03c9 - 1]`. In practice, it's\n     * dependent on many factors, so we choose the middle of the range for convenience.\n     * This takes about 45 seconds.\n     * ```repl\n     * :set test=20\n     * :check sigCodingInverts`{\u03c9 \/ 2}\n     * ```\n     *\/\n    sigCodingInverts : {w} (w < \u03c9) =>\n        [\u03bb \/ 4]Byte -> [ell][256](Z (2 * \u03b31 - 1)) -> [w][lg2 (256 * k)] -> Bit\n    property sigCodingInverts c_til z_inRange h_Indexes = inverts where\n        \/\/ The coefficients of `z` must be in the range `[-\u03b31 + 1, \u03b31]`.\n        \/\/ Convert to correct type and adjust them to the correct range.\n        z = [[(fromZ zij) - (`\u03b31 - 1) | zij <- zi ] | zi <- z_inRange]\n\n        \/\/ The hint must not have more than `\u03c9` non-zero indexes. `buildHint`\n        \/\/ makes sure this is true.\n        h = buildHint h_Indexes\n\n        (c_til', z', maybe_h') = sigDecode (sigEncode c_til z h)\n        h_matches = case maybe_h' of\n            Some h' -> h == h'\n            None -> False\n        inverts = (c_til == c_til') && (z == z') && h_matches\n\/**\n * Encode a polynomial vector `w1` into a byte string.\n * [FIPS-204] Section 7.3, Algorithm 28.\n *\n * The polynomial coordinates of `w1` must be in the range\n * `[0, (q - 1) \/ (2 * \u03b32) - 1]`.\n *\/\nw1Encode : [k]R -> [32 * k * width ((q - 1) \/ (2 * \u03b32) - 1)]Byte\nw1Encode w1 = w1_til where\n    w1_til = join\n        [SimpleBitPack`{(q - 1) \/ (2 * \u03b32) - 1} (w1@i) | i <- [0..k-1]]\n\n\/**\n * Sample a polynomial in `R` with coefficients from `{-1, 0, 1}` and Hamming\n * weight `\u03c4`.\n * [FIPS-204] Section 7.3, Algorithm 29.\n *\/\nSampleInBall : [\u03bb \/ 4]Byte -> R\nSampleInBall \u03c1 = cFinal where\n    \/\/ Step 1.\n    c0 = zero\n    \/\/ Steps 2 - 3.\n    ctx_0 = H`{inf} \u03c1\n        ((s : [8]Byte) # ctx_1) = ctx_0\n    \/\/ Step 5.\n    h = BytesToBits s\n\n    \/\/ Steps 7 - 10. Uses recursion instead of a loop to sample bytes from the\n    \/\/ hash stream, returning the first one that's in the range `[0, i]`.\n    sample : [inf]Byte -> Byte -> (Byte, [inf]Byte)\n    sample ([j] # ctx) i =\n        if j > i then\n            sample ctx i\n        else (j, ctx)\n\n    \/\/ Steps 6 - 13. Computes the value of `c` and the updated `ctx` at each\n    \/\/ iteration of the loop.\n    cAndCtx = [(c0, ctx_1)] # [(c'', ctx') where\n                        (j, ctx') = sample ctx (fromInteger i)\n            \/\/ Step 11.\n            c' = update c i (c@j)\n            \/\/ Step 12. In Cryptol, we need to manually convert the exponent\n            \/\/ from a `Bit` to a numeric type.\n            hi\u03c4 = if (h @ (i + `\u03c4 - 256)) then 1 else 0 : Integer\n            c'' = update c' j ((-1)^^hi\u03c4)\n\n        | i <- [256 - \u03c4..255]\n        | (c, ctx) <- cAndCtx]\n\n    (cFinal, _) = cAndCtx ! 0\n\n\/**\n * Sample a polynomial in the ring `Tq`.\n * [FIPS-204] Section 7.3, Algorithm 30.\n *\/\nRejNTTPoly : [34]Byte -> Tq\nRejNTTPoly \u03c1 = a_hat where\n        ctx0 = G \u03c1\n\n    \/\/ Step 4, 11. The `take` here replaces the loop condition.\n    a_hat = take`{256} (sample ctx0)\n\n    sample : [inf][8] -> [inf](Z q)\n    sample GSqueeze = a_hat' where\n        \/\/ Step 5. This pops the first 3 bytes off the pseudorandom stream.\n        (s, ctx) = splitAt`{3} GSqueeze\n\n        \/\/ Step 6.\n        a_hat_j = CoeffFromThreeBytes (s@0) (s@1) (s@2)\n\n        \/\/ Step 7 - 9. The recursive call here replaces the `while` loop.\n        a_hat' = case a_hat_j of\n            Some aj -> [aj] # (sample ctx)\n            \/\/ In the spec, the sample `a_hat_j` is always added to the list,\n            \/\/ and `j` is only increased if the sample was not rejected (so a\n            \/\/ rejected value is overwritten in the next iteration). Here,\n            \/\/ we only add `a_hat_j` if it's valid.\n            None -> sample ctx\n\n\/**\n * Sample an element in `R` with coefficients in the range [-\u03b7, \u03b7].\n * [FIPS-204] Section 7.3, Algorithm 31.\n *\/\nRejBoundedPoly: [66]Byte -> R\nRejBoundedPoly \u03c1 = a where\n    \/\/ Steps 2 - 3.\n    ctx0 = H \u03c1\n\n    \/\/ Step 4, 17. The `take` replaces the loop condition.\n    a = take`{256} (sample ctx0)\n\n    sample : [inf][8] -> [inf]Integer\n    sample HSqueeze = a' where\n        \/\/ Step 5. This pops one byte off the pseudorandom stream.\n        ([z] # ctx) = HSqueeze\n\n        \/\/ Step 6 - 8. We use Cryptol-native functions instead of dividing\n        \/\/ and modding `z`. See `TakeAndDropAreDivAndMod` for the equivalence.\n        z0 = CoeffFromHalfByte (drop`{4} z)\n        z1 = CoeffFromHalfByte (take`{4} z)\n\n        \/\/ Step 8 - 15. The recursive calls replace the `while` loop.\n        \/\/ In order to make the types work, we have to mash the two conditions\n        \/\/ together and make exactly one recursive call.\n        a' = case z0 of\n            Some z0' -> case z1 of\n                Some z1' -> [z0', z1'] # (sample ctx)\n                None -> [z0'] # (sample ctx)\n            None -> case z1 of\n                Some z1' -> [z1'] # (sample ctx)\n                None -> sample ctx\n\n\/**\n * Given a byte, the `take` function is equivalent to dividing by 16, and the\n * `drop` function is equivalent to taking the value mod 16.\n *\n * We prefer the Cryptol functions because they automatically convert from a\n * byte to a 4-bit value, which we need to call `CoeffFromHalfByte`. Here, we\n * use `zext` pad the 4-bit-vector, so we can compare it to the byte.\n * ```repl\n * :prove TakeAndDropAreDivAndMod\n * ```\n *\/\nTakeAndDropAreDivAndMod : [8] -> Bool\nproperty TakeAndDropAreDivAndMod z = dropIsMod && takeIsDiv where\n    dropIsMod = z % 16 == zext (drop`{4} z)\n    \/\/ Division of bit vectors in Cryptol automatically takes the floor.\n    takeIsDiv = z \/ 16 == zext (take`{4} z)\n\n\/**\n * Sample a `k x l` matrix of elements of `T_q`.\n * [FIPS-204] Section 7.3, Algorithm 32.\n *\/\nExpandA : [32]Byte -> [k][ell]Tq\nExpandA \u03c1 = A_hat where\n    A_hat = [[RejNTTPoly \u03c1' where\n            \u03c1' = \u03c1 # IntegerToBytes`{1} s # IntegerToBytes`{1} r\n        | s <- [0..ell - 1]]\n        | r <- [0..k - 1]]\n\n\/**\n * Sample vectors in `R^ell` and `R^k`, each with polynomial coordinates whose\n * coefficients are in the interval `[-\u03b7 , \u03b7]`.\n * [FIPS-204] Section 7.3, Algorithm 33.\n *\/\nExpandS : [64]Byte -> ([ell]R, [k]R)\nExpandS \u03c1 = (s1, s2) where\n    s1 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} r) | r <- [0..ell-1]]\n    s2 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} (r + `ell)) | r <- [0..k-1]]\n\n\/**\n * Sample a vector in `R^ell` such that each polynomial in `y` has coefficients\n * in the range `[-\u03b31 + 1, \u03b31]`.\n * [FIPS-204] Section 7.3, Algorithm 34.\n *\n * Note: This function requires that `\u03bc` is non-negative.\n *\/\nExpandMask : [64]Byte -> Integer -> [ell]R\nExpandMask \u03c1 \u03bc = y where\n    type c = 1 + width (\u03b31 - 1)\n\n    y = [BitUnpack`{\u03b31 - 1, \u03b31} v where\n            \u03c1' = \u03c1 # IntegerToBytes`{2} (\u03bc + r)\n            v = H`{32 * c} \u03c1'\n        | r <- [0..ell - 1]]\n\n\/**\n * Decompose a set of integers mod `q` into a pair `(r1, r0)` such that\n * `r === r1 * 2^d + r0 mod q`.\n *\n * This applies the `Power2Round` function (Algorithm 35) coefficientwise to\n * the polynomials in the vectors, per the description at the beginning of\n * [FIPS-204] Section 7.4.\n *\/\nPower2Round : [k]Rq -> ([k]R, [k]R)\nPower2Round r_vec = (r1_vec, r0_vec) where\n    \/\/ [FIPS-204] Section 7.4, Algorithm 35.\n    Power2Round_Single : Z q -> (Integer, Integer)\n    Power2Round_Single r = (r1, r0) where\n        r_plus = r\n        r0 = modPlusMinus`{2^^d} r_plus\n        r1 = ((fromZ r_plus) - r0) \/ (2^^`d)\n\n    \/\/ Apply the function coefficientwise to every polynomial.\n    zipped_r1r0 : [k][256](Integer, Integer)\n    zipped_r1r0 = [map Power2Round_Single r | r <- r_vec]\n\n        r1_vec = [[r1_j | (r1_j, _) <- ri] | ri <- zipped_r1r0]\n    r0_vec = [[r0_j | (_, r0_j) <- ri] | ri <- zipped_r1r0]\n\nprivate\n    \/**\n     * Property demonstrating that `Power2Round` does what it says it's\n     * supposed to do in the definition.\n     * [FIPS-204] Section 7.4, comment on Algorithm 35.\n     * ```repl\n     * :check power2RoundSatisfiesDefinition\n     * ```\n     *\/\n    power2RoundSatisfiesDefinition r_vec = validDecomp where\n        (r1_vec, r0_vec)= Power2Round r_vec\n        isValid (r, (r1, r0)) = (r1 * 2^^`d + r0) % `q == (fromZ r)\n        validDecomp = and [ and (map isValid (zip rs (zip r1s r0s)))\n            | r1s <- r1_vec\n            | r0s <- r0_vec\n            | rs <- r_vec]\n\n\/**\n * Decompose a set of integers mod `q` into a pair `(r1, r0)` such that\n * `r === r1 (2 \u03b32) + r0 mod q`.\n *\n * This applies the `Decompose` function (Algorithm 36) coefficientwise to\n * the polynomials in the vectors, per the description at the beginning of\n * [FIPS-204] Section 7.4.\n *\/\nDecompose : [k]Rq -> ([k]R, [k]R)\nDecompose r_vec = (r1_vec, r0_vec) where\n    \/\/ [FIPS-204] Section 7.4, Algorithm 36.\n    Decompose_Single : Z q -> (Integer, Integer)\n    Decompose_Single r = (r1, r0') where\n        r_plus = r\n        r0 = modPlusMinus`{2 * \u03b32} r_plus\n        (r1, r0') = if (fromZ r_plus) - r0 == `q - 1 then\n                (0, r0 - 1)\n            else\n                (((fromZ r_plus) - r0) \/ (2 * `\u03b32), r0)\n\n    \/\/ Apply the function coefficientwise to every polynomial.\n    zipped_r1r0 : [k][256](Integer, Integer)\n    zipped_r1r0 = [map Decompose_Single r | r <- r_vec]\n\n        r1_vec = [[r1_j | (r1_j, _) <- ri] | ri <- zipped_r1r0]\n    r0_vec = [[r0_j | (_, r0_j) <- ri] | ri <- zipped_r1r0]\n\nprivate\n    \/**\n     * Property demonstrating that `Decompose` does what it says it's\n     * supposed to do in the definition.\n     * [FIPS-204] Section 7.4, comment on Algorithm 36.\n     * ```repl\n     * :check decomposeSatisfiesDefinition\n     * ```\n     *\/\n    decomposeSatisfiesDefinition r_vec = validDecomp where\n        (r1_vec, r0_vec)= Decompose r_vec\n        isValid (r, (r1, r0)) = (r1 * 2 * `\u03b32 + r0) % `q == (fromZ r)\n        validDecomp = and [ and (map isValid (zip rs (zip r1s r0s)))\n            | r1s <- r1_vec\n            | r0s <- r0_vec\n            | rs <- r_vec]\n\n\/**\n * Returns `r1` from the output of `Decompose`.\n * [FIPS-24] Section 7.4, Algorithm 37.\n *\n * This applies the `HighBits` function (Algorithm 37) coefficientwise to\n * the polynomials in the vectors, per the description at the beginning of\n * Section 7.4.\n *\/\nHighBits : [k]Rq -> [k]R\nHighBits r = r1 where\n    (r1, _) = Decompose r\n\n\/**\n * Returns `r0` from the output of `Decompose`.\n * [FIPS-24] Section 7.4, Algorithm 38.\n *\n * This applies the `LowBits` function (Algorithm 38) coefficientwise to\n * the polynomials in the vectors, per the description at the beginning of\n * Section 7.4.\n *\/\nLowBits : [k]Rq -> [k]R\nLowBits r = r0 where\n    (_, r0) = Decompose r\n\n\/**\n * Compute the hint bits indiciating whether adding `z` to `r` alters the high\n * bits of `r`.\n * [FIPS-204] Section 7.4, Algorithm 39.\n *\n * This applies the `MakeHint` function coefficientwise to the polynomials in the\n * vectors, per the description at the beginning of Section 7.4. The `HighBits`\n * function operates over vectors of polynomials; then we compare the vectors of\n * high bits coefficientwise.\n *\/\nMakeHint : [k]Rq -> [k]Rq -> [k]R2\nMakeHint z_vec r_vec = hint where\n    r1_vec = HighBits r_vec\n    v1_vec = HighBits (r_vec + z_vec)\n\n    hint = [[r1 != v1\n        | r1 <- r1s | v1 <- v1s]\n        | r1s <- r1_vec | v1s <- v1_vec]\n\n\/**\n * Return the high bits of `r` adjusted according to hint `h`.\n * [FIPS-204] Section 7.4, Algorithm 40.\n *\n * This applies the `UseHint` function coefficientwise to the polynomials in\n * the vectors, per the description at the beginning of Section 7.4.\n *\/\nUseHint : [k]R2 -> [k]Rq -> [k]R\nUseHint h_vec r_vec = r1'_vec where\n    \/\/ Step 1.\n    m = (`q - 1) \/ (2 * `\u03b32)\n    \/\/ Step 2.\n    (r1_vec, r0_vec) = Decompose r_vec\n\n    \/\/ Steps 3 - 5. This takes the decomposed integers instead of the original\n    \/\/ element in `Z q`.\n    adjustHighBits r1 r0 h =\n        if (h == 1) && (r0 > 0) then (r1 + 1) % m\n        | (h == 1) && (r0 <= 0) then (r1 - 1) % m\n        else r1\n\n    \/\/ Apply the function coefficientwise to the decomposed polynomials.\n    r1'_vec = [[adjustHighBits r1 r0 h\n            | r1 <- r1s | r0 <- r0s | h <- hs]\n        | r1s <- r1_vec | r0s <- r0_vec | hs <- h_vec]\n\nprivate\n    \/**\n     * The output of `UseHint` must be within the range `[0, (q-1) \/ (2*\u03b32)]`.\n     * [FIPS-204] Section 7.4, comment on Algorithm 40.\n     *\n     * ```repl\n     * :check useHintIsInRange\n     * ```\n     * Alternately, this takes about 1 hour to prove.\n     *\/\n    property useHintIsInRange h_vec r_vec = r1InRange where\n        r1_vec = UseHint h_vec r_vec\n        inRange r1 = (0 <= r1) && (r1 <= (`q - 1) \/ (2 * `\u03b32))\n        \/\/ Apply check coefficientwise to the polynomial vector.\n        r1InRange = and [and (map inRange r1s) | r1s <- r1_vec]\n\n\/**\n * Number theoretic transform: compute the \"NTT representation\" in\n * `T_q` of a polynomial in `R_q`.\n *\n * This is equivalent to [FIPS-204] Section 7.5, Algorithm 41. That particular\n * formulation is difficult to implement in Cryptol. Instead, we use the naive\n * NTT implementation described in [NTT-Guide] Section 3.3.2, Equation 16. Note\n * that [NTT-Guide] uses different notation: their `\u03c8` is our `\u03b6`; their `a`\n * is our `f`; and we set their `n = 256`.\n *\n * There is one divergence between [NTT-Guide] and [FIPS-204]: the spec uses\n * bit-reversed indexes for the NTT representation, but the guide does not.\n *\n * @design Marcella Hastings <marcella@galois.com>: This is neither efficient\n * nor obviously spec-adherent. We should aim to make it at least one of those.\n * Ideally we will consolidate all the NTT implementations across the cryptol-\n * specs repo into a single common, validated (by some means...) implementation\n * and import it for use here and elsewhere.\n * @see https: *\/\nNTT : Rq -> Tq\nNTT f = [f_hat_j j | j <- bitrev_indexes] where\n    f_hat_j j = sum [ (\u03b6 ^^ (2 * i * j + i)) * fi | i <- [0..255] | fi <- f]\n\n    \/\/ Rearrange the indexes so that the NTT representation is in\n    \/\/ bit-reversed-index order.\n    bitrev_indexes = map toInteger (map reverse [0..255 : [8]])\n\n\/**\n * Inverse of the number theoretic transform: converts from the \"NTT\n * representation\" in `T_q` to a polynomial in `R_q`.\n *\n * This is equivalent to [FIPS-204] Section 7.5, Algorithm 42. That particular\n * formulation is difficult to implement in Cryptol. Instead, we use the naive\n * NTT implementation described in [NTT-Guide] Section 3.3.3, Equation 18. Note\n * that [NTT-Guide] uses different notation: their `\u03c8` is our `\u03b6`; their `a`\n * is our `f`; and we set their `n = 256`.\n *\n * There is one divergence between [NTT-Guide] and [FIPS-204]: the spec uses\n * bit-reversed indexes for the NTT representation, but the guide does not.\n *\n * @design Marcella Hastings <marcella@galois.com>: This is neither efficient\n * nor obviously spec-adherent. We should aim to make it at least one of those.\n * Ideally we will consolidate all the NTT implementations across the cryptol-\n * specs repo into a single common, validated (by some means...) implementation\n * and import it for use here and elsewhere.\n * @see https: *\/\nNTTInv : Tq -> Rq\nNTTInv f_hat = [f_i j * inv_root | j <- [0..255]] where\n    inv_root = recip 256 : Z q\n    inv_\u03b6 = recip \u03b6\n    f_i j = sum [ (inv_\u03b6 ^^ (2 * i * j + j)) * f_hat_j\n        | i <- [0..255]\n        | f_hat_j <- indexReversedFHat]\n\n    \/\/ Rearrange the NTT representation to bit-reverse the indexes.\n    bitrev_indexes = map reverse [0..255 : [8]]\n    indexReversedFHat = [f_hat@i | i <- bitrev_indexes]\n\nprivate\n    \/**\n     * This property demonstrates that `NTTInv` inverts `NTT`.\n     * This takes about 20s to check.\n     * ```repl\n     * :set tests=20\n     * :check NTT_Inverts\n     * ```\n     * Alternately, this proves in ~8 min with Z3 v4.13.3.\n     *\/\n    NTT_Inverts : Rq -> Bit\n    property NTT_Inverts f =  NTTInv (NTT f) == f\n\n    \/**\n     * This property demonstrates that `NTT` inverts `NTTInv`.\n     * This takes about 20s to check.\n     * ```repl\n     * :set tests=20\n     * :check NTTInv_Inverts\n     * ```\n     *\/\n    NTTInv_Inverts : Tq -> Bit\n    property NTTInv_Inverts f =  NTT (NTTInv f) == f\n\n\/**\n * Compute the sum of two elemetns in `Tq`.\n * [FIPS-204] Section 7.6, Algorithm 44.\n *\/\nAddNTT : Tq -> Tq -> Tq\nAddNTT a b = c where\n    c = [a@i + b@i | i <- [0..255]]\n\n\/**\n * The definition of addition in the spec is the same as the built-in addition\n * operator in Cryptol!\n * ```repl\n * :prove addNTTisPlus\n * ```\n *\/\nproperty addNTTisPlus a b = AddNTT a b == a + b\n\n\/**\n * Compute the product of two elements in `Tq`.\n * [FIPS-204] Section 7.6, Algorithm 45.\n *\/\nMultiplyNTT : Tq -> Tq -> Tq\nMultiplyNTT a b = c where\n    c = [a@i * b@i | i <- [0..255]]\n\n\/**\n * The definition of multiplication in the spec is the same as the built-in\n * multiplication (*) operator in Cryptol!\n * ```repl\n * :prove multiplyNTTisStar\n * ```\n *\/\nproperty multiplyNTTisStar a b = MultiplyNTT a b == a * b\n\n\/**\n * Compute the sum of two vectors over `Tq`\n * [FIPS-204] Section 7.6, Algorithm 46.\n *\/\nAddVectorNTT : {l} (fin l, l > 0) => [l]Tq -> [l]Tq -> [l]Tq\nAddVectorNTT v w = u where\n    u = [AddNTT (v@i) (w@i) | i <- [0..l-1]]\n\n\/**\n * The defintion of vector addition in the spec is the same as the built-in\n * addition operator in Cryptol!\n * There's only one NTT vector addition that I could find in the spec and it's\n * between vectors of length `k`:\n * ```repl\n * :prove addVectorNTTisPlus`{k}\n * ```\n *\/\naddVectorNTTisPlus : {r} (fin r, r > 0) => [r]Tq -> [r]Tq -> Bit\nproperty addVectorNTTisPlus v w = AddVectorNTT v w == v + w\n\n\/**\n * Compute the product of a scalar and a vector over `Tq`.\n * [FIPS-204] Section 7.6, Algorithm 47.\n *\/\nScalarVectorNTT : {l} (fin l, l > 0) => Tq -> [l]Tq -> [l]Tq\nScalarVectorNTT c v = w where\n    w = [MultiplyNTT c (v@i) | i <- [0..l-1]]\n\n\/**\n * Custom operator for computing the product of a scalar and a vector.\n *\n * The spec overloads the ring operator `\u2218` to mean several operations,\n * in `Tq`, including the product of two elements, the product of a scalar\n * and a vector, and the product of a matrix and a vector.\n * Cryptol does not support user-defined overloaded symbols, so we define\n * `\u2218` to be the function with the most usage in the spec.\n *\n * This implements a more efficient version of `ScalarVectorNTT`.\n *\/\n(\u2218) : {l} (fin l, l > 0) => Tq -> [l]Tq -> [l]Tq\n(\u2218) c v = [c * vi | vi <- v]\n\n\/**\n * The optimized scalar vector multiplication operator `\u2218` is equivalent to\n * `ScalarVectorNTT`.\n *\n * These parameters are the only ones used for this operation in the spec:\n * ```repl\n * :prove ringIsScalarVectorNTT`{k}\n * :prove ringIsScalarVectorNTT`{ell}\n * ```\n *\/\nringIsScalarVectorNTT : {l} (fin l, l > 0) => Tq -> [l]Tq -> Bit\nproperty ringIsScalarVectorNTT c v = c \u2218 v == ScalarVectorNTT c v\n\n\/**\n * Compute the product of a matrix and a vector over `Tq`.\n * [FIPS-204] Section 7.6, Algorithm 48.\n *\n * Note: The spec defines this operation for a matrix with dimensions\n * `k x ell`, where `k` and `ell` are natural numbers. This actually overloads\n * those names, since they're also the dimensions that are part of the\n * parameterization of the algorithm. In fact, we only ever use this\n * function for the matrix `A_hat` with dimensions `k x ell` (the parameters).\n * So, this isn't implemented over arbitrary matrix dimensions, although I\n * think it could be.\n *\/\nMatrixVectorNTT : [k][ell]Tq -> [ell]Tq -> [k]Tq\nMatrixVectorNTT M v = w where\n    \/\/ We use the `sum` built-in function instead of iteratively applying\n    \/\/ `AddNTT`. See `addNTTisPlus` property for the equivalence.\n    w = [sum [ MultiplyNTT (M@i@j) (v@j)\n        | j <- [0..ell-1]]\n        | i <- [0..k-1] ]\n\n\/**\n * Custom operator for computing the product of a matrix and a vector.\n *\n * The spec overloads the ring operator `\u2218` to mean several operations in\n * `Tq`. In this executable spec, we define `\u2218` to mean scalar-vector\n * multiplication. Cryptol does not support user-defined overloaded symbols,\n * but for readability, it's nice to have an infix operator for this function.\n *\n * This implements a more efficient verison of `ScalarVectorNTT`.\n *\/\n(\u2218\u2218) : [k][ell]Tq -> [ell]Tq -> [k]Tq\n(\u2218\u2218) M v = [sum [Mij * vj | Mij <- Mi | vj <- v] | Mi <- M]\n\n\/**\n * The optimized matrix vector multiplication operator `\u2218\u2218` is equivalent to\n * `MatrixVectorNTT`.\n * ```repl\n * :prove doubleRingIsMatrixVectorNTT\n * ```\n *\/\ndoubleRingIsMatrixVectorNTT : [k][ell]Tq -> [ell]Tq -> Bit\nproperty doubleRingIsMatrixVectorNTT M v = (M \u2218\u2218 v) == MatrixVectorNTT M v\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/OptimizedSpecification.cry","filetype":"cry","content":"\/**\n * Optimized implementation of the ML-DSA (CRYSTALS-Dilithium) signature scheme.\n *\n * This implementation deviates from the specification in favor of performance.\n *\n * @copyright Galois Inc\n * @author Marios Georgiou <marios@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification where\n\nimport interface Primitive::Asymmetric::Signature::ML_DSA::Parameters as P\nimport Primitive::Asymmetric::Signature::ML_DSA::Specification { interface P }  as Spec\n\ntype q = P::q\ntype \u03c9 = P::\u03c9\ntype k = P::k\ntype ell = P::ell\ntype \u03b7 = P::\u03b7\ntype \u03bb = P::\u03bb\ntype \u03b31 = P::\u03b31\ntype \u03b32 = P::\u03b32\ntype \u03c4 = P::\u03c4\n\ntype Byte = Spec::Byte\n\ntype Tq = Spec::Tq\ntype R = Spec::R\ntype R2 = Spec::R2\ntype Rq = Spec::Rq\n\nmodPlusMinus : {\u03b1} (fin \u03b1) => Z q -> Integer\nmodPlusMinus = Spec::modPlusMinus`{\u03b1}\n\ninfNormRq = Spec::infNormRq\n\ninfNormR = Spec::infNormR\n\ncastToRq = Spec::castToRq\n\nNTT_Vec = Spec::NTT_Vec\n\nNTTInv_Vec = Spec::NTTInv_Vec\n\nH = Spec::H\n\nHBits = Spec::HBits\n\nG = Spec::G\n\n\u03b6 = Spec::\u03b6\n\ntype d = Spec::d\n\n\u03b2 = Spec::\u03b2\n\ntype PublicKey = Spec::PublicKey\n\ntype PrivateKey = Spec::PrivateKey\n\ntype Signature = Spec::Signature\n\n\/**\n * This is almost identical to `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file but H`{64} is replaced by H to avoid compilation\n * errors.\n *\/\nKeyGen_internal : [32]Byte -> (PublicKey, PrivateKey)\nKeyGen_internal \u03be = (pk, sk) where\n    \/\/ Step 1.\n    (\u03c1 # \u03c1' # K) = H (\u03be # IntegerToBytes`{1} `k # IntegerToBytes`{1} `ell)\n\n    \/\/ Step 3.\n    A_hat = ExpandA \u03c1\n        (s1, s2) = ExpandS \u03c1'\n\n    \/\/ Explicitly typecast vectors in `R` to `Rq`.\n    s1' = castToRq s1\n    s2' = castToRq s2\n\n    \/\/ Step 5.\n    t = NTTInv_Vec (A_hat \u2218\u2218 NTT_Vec s1') + s2'\n    \/\/ Step 6.\n    (t1, t0) = Power2Round t\n\n    \/\/ Step 8.\n    pk = pkEncode \u03c1 t1\n    \/\/ Step 9.\n    tr = H pk\n    \/\/ Step 10.\n    sk = skEncode \u03c1 K tr s1 s2 t0\n\n\/**\n * ```repl\n * :set tests=3\n * :check KeyGen_internalEquivalence\n * ```\n *\/\nKeyGen_internalEquivalence : [32]Byte -> Bit\nproperty KeyGen_internalEquivalence \u03be = Spec::KeyGen_internal \u03be == KeyGen_internal \u03be\n\nSign_internal = Spec::Sign_internal\n\nVerify_internal = Spec::Verify_internal\n\nIntegerToBits : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]\nIntegerToBits x = reverse (fromInteger x)\n\n\/**\n * ```repl\n * :check IntegerToBitsEquivalence`{44}\n * ```\n *\/\nIntegerToBitsEquivalence : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> Bit\nproperty IntegerToBitsEquivalence x = Spec::IntegerToBits`{\u03b1} x == IntegerToBits`{\u03b1} x\n\nBitsToInteger y = toInteger (reverse y)\n\n\/**\n * ```repl\n * :check BitsToIntegerEquivalence`{44}\n * :exhaust BitsToIntegerEquivalence`{10}\n * ```\n *\/\nBitsToIntegerEquivalence : {\u03b1} (fin \u03b1, \u03b1 > 0) => [\u03b1] -> Bit\nproperty BitsToIntegerEquivalence x = Spec::BitsToInteger x == BitsToInteger x\n\nIntegerToBytes : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]Byte\nIntegerToBytes x = reverse (split (fromInteger x))\n\n\/**\n * ```repl\n * :check IntegerToBytesEquivalence`{44}\n * ```\n *\/\nIntegerToBytesEquivalence : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> Bit\nproperty IntegerToBytesEquivalence x = Spec::IntegerToBytes`{\u03b1} x == IntegerToBytes`{\u03b1} x\n\nBitsToBytes : {\u03b1} (fin \u03b1) => [\u03b1]Bit -> [\u03b1 \/^ 8]Byte\nBitsToBytes y = map reverse (split (y # zero))\n\n\/**\n * ```repl\n * :prove BitsToBytesEquivalence`{320 * 8}\n * :prove BitsToBytesEquivalence`{32 * 44 * 8}\n * ```\n *\/\nBitsToBytesEquivalence : {\u03b1} (fin \u03b1) => [\u03b1]Bit -> Bit\nproperty BitsToBytesEquivalence x = Spec::BitsToBytes x == BitsToBytes x\n\nBytesToBits : {\u03b1} (fin \u03b1) => [\u03b1]Byte -> [8 * \u03b1]Bit\nBytesToBits z = join (map reverse z)\n\n\/**\n * ```repl\n * :prove BytesToBitsEquivalence`{320}\n * :prove BytesToBitsEquivalence`{32 * 44}\n * ```\n *\/\nBytesToBitsEquivalence : {\u03b1} (fin \u03b1) => [\u03b1]Byte -> Bit\nproperty BytesToBitsEquivalence x = Spec::BytesToBits x == BytesToBits x\n\nB2B2BInverts = Spec::B2B2BInverts\n\nCoeffFromThreeBytes = Spec::CoeffFromThreeBytes\n\nCoeffFromHalfByte = Spec::CoeffFromHalfByte\n\nSimpleBitPack : {b} (fin b, width b > 0) => R -> [32 * width b]Byte\nSimpleBitPack w = BitsToBytes (join (map IntegerToBits`{width b} w))\n\n\/**\n * ```repl\n * :check SimpleBitPackEquivalence`{10}\n * ```\n *\/\nSimpleBitPackEquivalence : {b} (fin b, width b > 0) => R -> Bit\nproperty SimpleBitPackEquivalence w = Spec::SimpleBitPack`{b} w == SimpleBitPack`{b} w\n\nBitPack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    R -> [32 * width (a + b)]Byte\nBitPack w = BitsToBytes (join (map (\\x -> IntegerToBits`{width (a + b)} (`b - x)) w))\n\n\/**\n * ```repl\n * :check BitPackEquivalence`{10, 10}\n * ```\n *\/\nBitPackEquivalence : {a, b} (fin a, fin b, width (a + b) > 0) => R -> Bit\nproperty BitPackEquivalence w = Spec::BitPack`{a, b} w == BitPack`{a, b} w\n\nSimpleBitUnpack : {b} (fin b, width b > 0) => [32 * width b]Byte -> R\nSimpleBitUnpack v = map BitsToInteger (split (BytesToBits v))\n\n\/**\n * ```repl\n * :check SimpleBitUnpackEquivalence`{10}\n * ```\n *\/\nSimpleBitUnpackEquivalence : {b} (fin b, width b > 0) => [32 * width b]Byte -> Bit\nproperty SimpleBitUnpackEquivalence v = Spec::SimpleBitUnpack`{b} v == SimpleBitUnpack`{b} v\n\nBitUnpack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    [32 * width (a + b)]Byte -> R\nBitUnpack v = map (\\x -> `b - BitsToInteger x) (split (BytesToBits v))\n\n\/**\n * ```repl\n * :check BitUnpackEquivalence`{10, 10}\n * ```\n *\/\nBitUnpackEquivalence : {a, b} (fin a, fin b, width (a + b) > 0) => [32 * width (a + b)]Byte -> Bit\nproperty BitUnpackEquivalence v = Spec::BitUnpack`{a, b} v == BitUnpack`{a, b} v\n\nHintBitPack = Spec::HintBitPack\n\nHintBitUnpack = Spec::HintBitUnpack\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\npkEncode : [32]Byte -> [k]R -> PublicKey\npkEncode \u03c1 t1 = pk where\n    pk = \u03c1 # join [SimpleBitPack`{2 ^^ (width (q - 1) - d) - 1} (t1@i) | i <- [0..k-1]]\n\n\/**\n * ```repl\n * :check pkEncodeEquivalence\n * ```\n *\/\npkEncodeEquivalence : [32]Byte -> [k]R -> Bit\nproperty pkEncodeEquivalence \u03c1 t1 = Spec::pkEncode \u03c1 t1 == pkEncode \u03c1 t1\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\npkDecode : PublicKey -> ([32]Byte, [k]R)\npkDecode pk = (\u03c1, t1) where\n    \/\/ Step 1. We split off the single `\u03c1` byte, then separate the remaining\n    \/\/ bytes into the `k` components as described.\n    (\u03c1 # zBytes) = pk\n    z = split zBytes\n    \/\/ Steps 2 - 4.\n    t1 = [SimpleBitUnpack`{2 ^^ (width (q - 1) - d) - 1} (z@i) | i <- [0..k-1]]\n\n\/**\n * ```repl\n * :check pkDecodeEquivalence\n * ```\n *\/\npkDecodeEquivalence : PublicKey -> Bit\nproperty pkDecodeEquivalence pk = Spec::pkDecode pk == pkDecode pk\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nskEncode : [32]Byte -> [32]Byte -> [64]Byte -> [ell]R -> [k]R -> [k]R\n    -> PrivateKey\nskEncode \u03c1 K tr s1 s2 t0 = sk9 where\n    \/\/ Note: `sk#` indicates the value of `sk` at Step `#`.\n    \/\/ Step 1.\n    sk1 = \u03c1 # K # tr\n    \/\/ Steps 2 - 4.\n    sk3 = sk1 # join [BitPack`{\u03b7, \u03b7} (s1@i) | i <- [0..ell-1]]\n    \/\/ Steps 5 - 7.\n    sk6 = sk3 # join [BitPack`{\u03b7, \u03b7} (s2@i) | i <- [0..k-1]]\n    \/\/ Steps 8 - 10.\n    sk9 = sk6 #\n        join [BitPack`{2^^(d - 1) - 1, 2^^(d - 1)} (t0@i) | i <- [0..k-1]]\n\n\/**\n * ```repl\n * :check skEncodeEquivalence\n * ```\n *\/\nskEncodeEquivalence : [32]Byte -> [32]Byte -> [64]Byte -> [ell]R -> [k]R -> [k]R -> Bit\nproperty skEncodeEquivalence \u03c1 K tr s1 s2 t0 = Spec::skEncode \u03c1 K tr s1 s2 t0 == skEncode \u03c1 K tr s1 s2 t0\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nskDecode : PrivateKey -> ([32]Byte, [32]Byte, [64]Byte, [ell]R, [k]R, [k]R)\nskDecode sk = (\u03c1, K, tr, s1, s2, t0) where\n    \/\/ Step 1. We split off the six components, then further separate `y`, `z`,\n    \/\/ and `w` into their two dimensions.\n    (\u03c1 # K # tr # yBytes # zBytes # wBytes) = sk\n    y = split`{ell} yBytes\n    z = split`{k} zBytes\n    w = split`{k} wBytes\n\n    \/\/ Steps 2 - 4.\n    s1 = [BitUnpack`{\u03b7, \u03b7} (y@i) | i <- [0..ell-1]]\n    \/\/ Steps 5 - 7.\n    s2 = [BitUnpack`{\u03b7, \u03b7} (z@i) | i <- [0..k-1]]\n    \/\/ Steps 8 - 10.\n    t0 = [BitUnpack`{2^^(d - 1) - 1, 2^^(d - 1)} (w@i) | i <- [0..k-1]]\n\n\/**\n * ```repl\n * :check skDecodeEquivalence\n * ```\n *\/\nskDecodeEquivalence : PrivateKey -> Bit\nproperty skDecodeEquivalence sk = Spec::skDecode sk == skDecode sk\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nsigEncode : [\u03bb \/ 4]Byte -> [ell]R -> [k]R2 -> Signature\nsigEncode c_til z h = \u03c3 where\n    \/\/ Note that `\u03c3#` indicates the value of `\u03c3` at Step `#`.\n    \/\/ Step 1.\n    \u03c31 = c_til\n    \/\/ Step 2 - 4.\n    \u03c33 = \u03c31 # join [BitPack`{\u03b31 - 1, \u03b31} (z@i) | i <- [0..ell-1]]\n    \/\/ Step 5.\n    \u03c3 = \u03c33 # HintBitPack h\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nsigDecode : Signature -> ([\u03bb \/ 4]Byte, [ell]R, Option ([k]R2))\nsigDecode \u03c3 = (c_til, z, h) where\n    \/\/ Step 1. We separate into bytes, then further split `x` into its two\n    \/\/ dimensions.\n    (c_til # xBytes # y) = \u03c3\n    x = split`{ell} xBytes\n\n    \/\/ Step 2 - 4.\n    z = [BitUnpack`{\u03b31 - 1, \u03b31} (x@i) | i <- [0..ell-1]]\n    \/\/ Step 5.\n    h = HintBitUnpack y\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nw1Encode : [k]R -> [32 * k * width ((q - 1) \/ (2 * \u03b32) - 1)]Byte\nw1Encode w1 = w1_til where\n    w1_til = join\n        [SimpleBitPack`{(q - 1) \/ (2 * \u03b32) - 1} (w1@i) | i <- [0..k-1]]\n\n\/**\n * ```repl\n * :check w1EncodeEquivalence\n * ```\n *\/\nw1EncodeEquivalence : [k]R -> Bit\nproperty w1EncodeEquivalence w1 = Spec::w1Encode w1 == w1Encode w1\n\n\/**\n * This is almost identical to `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file but H`{inf} is replaced by H to avoid compilation\n * errors.\n *\/\nSampleInBall : [\u03bb \/ 4]Byte -> R\nSampleInBall \u03c1 = cFinal where\n    \/\/ Step 1.\n    c0 = zero\n    \/\/ Steps 2 - 3.\n    ctx_0 = H \u03c1\n        ((s : [8]Byte) # ctx_1) = ctx_0\n    \/\/ Step 5.\n    h = BytesToBits s\n\n    \/\/ Steps 7 - 10. Uses recursion instead of a loop to sample bytes from the\n    \/\/ hash stream, returning the first one that's in the range `[0, i]`.\n    sample : [inf]Byte -> Byte -> (Byte, [inf]Byte)\n    sample ([j] # ctx) i =\n        if j > i then\n            sample ctx i\n        else (j, ctx)\n\n    \/\/ Steps 6 - 13. Computes the value of `c` and the updated `ctx` at each\n    \/\/ iteration of the loop.\n    cAndCtx = [(c0, ctx_1)] # [(c'', ctx') where\n                        (j, ctx') = sample ctx (fromInteger i)\n            \/\/ Step 11.\n            c' = update c i (c@j)\n            \/\/ Step 12. In Cryptol, we need to manually convert the exponent\n            \/\/ from a `Bit` to a numeric type.\n            hi\u03c4 = if (h @ (i + `\u03c4 - 256)) then 1 else 0 : Integer\n            c'' = update c' j ((-1)^^hi\u03c4)\n\n        | i <- [256 - \u03c4..255]\n        | (c, ctx) <- cAndCtx]\n\n    (cFinal, _) = cAndCtx ! 0\n\n\/**\n * ```repl\n * :set tests=3\n * :check SampleInBallEquivalence\n * ```\n *\/\nSampleInBallEquivalence : [\u03bb \/ 4]Byte -> Bit\nproperty SampleInBallEquivalence \u03c1 = Spec::SampleInBall \u03c1 == SampleInBall \u03c1\n\nRejNTTPoly = Spec::RejNTTPoly\n\nRejBoundedPoly = Spec::RejBoundedPoly\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nExpandA : [32]Byte -> [k][ell]Tq\nExpandA \u03c1 = A_hat where\n    A_hat = [[RejNTTPoly \u03c1' where\n            \u03c1' = \u03c1 # IntegerToBytes`{1} s # IntegerToBytes`{1} r\n        | s <- [0..ell - 1]]\n        | r <- [0..k - 1]]\n\n\/**\n * ```repl\n * :set tests=3\n * :check ExpandAEquivalence\n * ```\n *\/\nExpandAEquivalence : [32]Byte -> Bit\nproperty ExpandAEquivalence \u03c1 = Spec::ExpandA \u03c1 == ExpandA \u03c1\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nExpandS : [64]Byte -> ([ell]R, [k]R)\nExpandS \u03c1 = (s1, s2) where\n    s1 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} r) | r <- [0..ell-1]]\n    s2 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} (r + `ell)) | r <- [0..k-1]]\n\n\/**\n * ```repl\n * :set tests=5\n * :check ExpandSEquivalence\n * ```\n *\/\nExpandSEquivalence : [64]Byte -> Bit\nproperty ExpandSEquivalence \u03c1 = Spec::ExpandS \u03c1 == ExpandS \u03c1\n\n\/**\n * This is almost identical to `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file but H`{32 * c} is replaced by H to avoid compilation\n * errors. Moreover, the type of `c` is not used so it's removed.\n *\/\nExpandMask : [64]Byte -> Integer -> [ell]R\nExpandMask \u03c1 \u03bc = y where\n\n    y = [BitUnpack`{\u03b31 - 1, \u03b31} v where\n            \u03c1' = \u03c1 # IntegerToBytes`{2} (\u03bc + r)\n            v = H \u03c1'\n        | r <- [0..ell - 1]]\n\n\/**\n * ```repl\n * :set tests=5\n * :check ExpandMaskEquivalence\n * ```\n *\/\nExpandMaskEquivalence : [64]Byte -> Integer -> Bit\nproperty ExpandMaskEquivalence \u03c1 \u03bc = Spec::ExpandMask \u03c1 \u03bc == ExpandMask \u03c1 \u03bc\n\nPower2Round = Spec::Power2Round\n\nDecompose = Spec::Decompose\n\nHighBits = Spec::HighBits\n\nLowBits = Spec::LowBits\n\nMakeHint = Spec::MakeHint\n\nUseHint = Spec::UseHint\n\nNTT = Spec::NTT\n\nNTTInv = Spec::NTTInv\n\nAddNTT = Spec::AddNTT\n\nMultiplyNTT = Spec::MultiplyNTT\n\nAddVectorNTT = Spec::AddVectorNTT\n\nScalarVectorNTT = Spec::ScalarVectorNTT\n\nMatrixVectorNTT = Spec::MatrixVectorNTT\n\n(\u2218\u2218) : [k][ell]Tq -> [ell]Tq -> [k]Tq\n(\u2218\u2218) M v = [sum [Mij * vj | Mij <- Mi | vj <- v] | Mi <- M]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Parameters.cry","filetype":"cry","content":"interface module Primitive::Asymmetric::Signature::ML_DSA::Parameters where\n    \/**\n     * Modulus defining the ring used throughout the protocol.\n     * [FIPS-204] Section 4, Table 1.\n     *\/\n    type q = 8380417\n\n    \/**\n     * Hamming weight of the mask sampled in signing.\n     *\n     * The spec describes this as \"number of \u00b11s in polynomial `c`\", where `c`\n     * is the verifier's challenge.\n     * [FIPS-204] Section 4, Table 1.\n     *\n     * The type constraints are drawn from [FIPS-204] Section 7.3, Algorithm\n     * 29; the first is implicit in Step 6, and the second is explicit in the\n     * algorithm description.\n     *\/\n    type \u03c4 : #\n    type constraint (0 < \u03c4, \u03c4 <= 64)\n\n    \/**\n     * Collision strength of the commitment hash `c~` component of a signature.\n     * [FIPS-204] Section 4, Table 1.\n     *\n     * The type constraint is drawn from [FIPS-204] Section 7.3, Algorithm 29;\n     * it's implicit that the hash function `H` requires a finite input, so the\n     * length of the input seed, and thus of `\u03bb`, must be finite.\n     *\/\n    type \u03bb : #\n    type constraint (fin \u03bb)\n\n    \/**\n     * Coefficient range of the commitment mask `y` used in signing.\n     * [FIPS-204] Section 4, Table 1.\n     *\n     * The first type constraint, which claims that `\u03b31` must be a power of 2,\n     * is drawn from [FIPS-203] Section 7.2, Algorithm 27.\n     * The second is a true statement (when `\u03b31` is a power of 2, so for all\n     * valid parameter sets for ML-DSA) that is hard to infer. It's stated\n     * explicitly here because the two expressions are used interchangeably in\n     * the spec. Note that `width x = lg2 (x + 1)`:\n     * ```math\n     *    1 + width (\u03b31 - 1) = 1 + lg2 (\u03b31).\n     *    width (\u03b31 - 1 + \u03b31) = lg2 (2 * \u03b31) = 1 + lg2 (\u03b31).\n     * ```\n     *\/\n    type \u03b31 : #\n    type constraint (fin \u03b31, 2 ^^ (lg2 \u03b31) == \u03b31)\n    type constraint (1 + width (\u03b31 - 1) == width (\u03b31 - 1 + \u03b31))\n\n    \/**\n     * Low-order rounding range; this defines how to round the signer's\n     * commitment `w`.\n     * [FIPS-204] Section 4, Table 1.\n     *\n     * The first type constraint is drawn from [FIPS-204] Section 7.4. The\n     * primary constraint we wish to encode is that `2 * \u03b32` divides `q - 1`;\n     * to express this, we must also require that \u03b32 is non-zero.\n     * The second type constraint is drawn from Algorithm 28 -- the type\n     * argument to `SimpleBitPack` must have positive width.\n     *\/\n    type \u03b32 : #\n    type constraint (\u03b32 > 0, (q - 1) % (2 * \u03b32) == 0)\n    type constraint (width ((q - 1) \/ (2 * \u03b32) - 1) > 0)\n\n    \/**\n     * Dimensions of the matrix `A`, which is part of the public key.\n     * [FIPS-204] Section 4, Table 1.\n     *\/\n    type k : #\n    type ell : #\n    type constraint (fin k, fin ell, k > 0, ell > 0)\n\n    \/**\n     * Private key range; the private key is a polynomial whose coefficients\n     * are all in a range defined by \u03b7.\n     * [FIPS-204] Section 4, Table 1.\n     *\n     * The type constraint (that \u03b7 must be in the set {2, 4}) is drawn from\n     * [FIPS-204] Section 7.1, Algorithm 15.\n     *\/\n    type \u03b7 : #\n    type constraint (\u03b7 % 2 == 0, 2 <= \u03b7, \u03b7 <= 4)\n\n    \/**\n     * Maximum Hamming weight for the hint component of a signature.\n     * [FIPS-204] Section 4, Table 1.\n     *\n     * The constraints are drawn from [FIPS-204] Algorithm 21:\n     * - `\u03c9 > 0`: in Step 16, we have to be able to compute `\u03c9 - 1`.\n     * - `width \u03c9 <= 8`: This is an implementation artifact from Step 4. We\n     *   compare `\u03c9` to an element in `y`, which is a byte. Cryptol will\n     *   default to fitting `\u03c9` into in a byte. This is always true with the\n     *   allowable parameter sets. If a new parameter set is released with a\n     *   much larger `\u03c9`, we can modify the implementation to remove this\n     *   constraint without affecting functionality.\n     *\/\n    type \u03c9 : #\n    type constraint (fin \u03c9, \u03c9 > 0, width \u03c9 <= 8)\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/UnconstrainedSpec.cry","filetype":"cry","content":"\/*\nECDSA as specified in [FIPS-186-5] Section 6.\n\n\u26a0 This implementation is complete except for constraints on the size of the\ninput parameters ([FIPS-186-5] Section 6.1.1)! Using this implementation will\nallow invalid combinations of parameters. Consider using `Specification.cry`\ninstead.\n\nThis implementation omits some parts of the original specification:\n- The spec makes recommendations for domain parameter management which is out\n  of scope for this implementation. (6.1.2)\n- The spec associates an ECDSA key pair `(d, Q)` with a specific set of domain\n  parameters. This implementation does not include any details of generation,\n  management, or association of private and public keys. (6.2)\n- The spec requires that a new secret random number `k` is generated for each\n  digital signature. This implementation does not handle secure generation or\n  handling of the secret random number. \u26a0 \ufe0f\ufe0f\ufe0f\ufe0fWarning \u26a0: incorrect generation or\n  management of `k` can cause catastrophic failures of the signature scheme,\n  including revealing the private key! Implementors must manually verify that\n  their implementations satisfy this component of the spec. (6.3)\n\n\n[FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n  Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n  Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n  August 2015.\n  @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n[FIPS-186-5]: National Institute of Standards and Technology. Digital\n  Signature Standard (DSS). (Department of Commerce, Washington, D.C.),\n  Federal Information Processing Standards Publication (FIPS) NIST FIPS 186-5.\n  February 2023.\n  @see https:\/\/doi.org\/10.6028\/NIST.FIPS.186-5\n\n@copyright Galois, Inc\n@author Marcella Hastings <marcella@galois.com>\n*\/\n\nmodule Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec where\n\n\/**\n * ECDSA digital signature generation and verification requires domain\n * parameters that are generated in accordance with [FIPS-186-5] Section 6.1.1.\n * The instantiation of this interface must meet those criteria!\n *\/\nimport interface Common::EC::ECInterface as EC\n\n\/**\n * ECDSA digital signature generation and verification requires an approved\n * hash function or XOF (extendable-output function).\n * This implementation currently fixes the hash function to SHA256, as\n * specified in [FIPS-180-4].\n *\/\nimport interface Primitive::Keyless::Hash::HashInterface as Hash\n\n\/**\n * ECDSA signature generation algorithm.\n * [FIPS-186-5] Section 6.4.1\n *\n * This deviates from the original spec in several ways:\n * 1a. The per-message secret number `k` is passed as a parameter instead of\n *    being generated using an approved procedure.\n *    \u26a0\ufe0f Warning \u26a0\ufe0f: This deviation means that adherence to this spec cannot\n *    detect a catastrophic secret-number-reuse implementation mistake!\n *    Implementors must manually verify that secret numbers are chosen\n *    according to an approved procedure; are protected from unauthorized\n *    disclosure and modification; and are not reused over time.\n * 1b. The spec requires that if `r` or `s` are 0 and `k` is not generated\n *    deterministically, then the computation should repeat until a valid `k`\n *    is found. This implementation fails if either value is 0, because Cryptol\n *    cannot produce a new random value for `k`.\n * 2. The spec requires that `k` and its inverse are securely destroyed in\n *    step 10. Cryptol does not have any way to express this. Implementors\n *    must manually verify that they have removed those values from memory.\n * 3. The spec requires the hash function to be passed as an input. In this\n *    implementation, it is fixed to be SHA256 (from the SHA2 family). This is\n *    due to lack of an appropriate hash-function interface, not for any\n *    technical reason. We also introduce the `width` constraint on `m` that\n *    ensures it is short enough to be processable by SHA256.\n * 4. The spec describes the domain parameters as an input to this function.\n *    In this implementation, we encode the domain parameters in the\n *    `ECInterface` included in this module, so they aren't passed explicitly.\n *\n * Other important notes:\n * - The private key `d` passed as input must be generated as specified in\n *   [FIPS-186-5] Section 6.2.1. Implementors must manually verify that this\n *   is the case.\n *\n * Inputs:\n * M : [m]. Bit string `M` to be signed.\n * d : Z n. Private key in the interval [1, n-1].\n * k : Z n. Per-message secret number in the interval [1, n-1].\n *\n * Outputs:\n * (r, s) : A pair of integers, each in the interval [1, n-1].\n *      or failure (`None`) if:\n *      - the inputs `d` and `k` were not in the correct interval;\n *      - the outputs `r` or `s` were 0 for the given inputs;\n *\n * In all inputs and outputs, `n` is the order of the base point `G` for the\n * elliptic curve specified in the `PFEC` interface.\n *\/\nsign : {m} (fin m, width m < Hash::MessageUpperBound) =>\n    [m] -> Z EC::n -> Z EC::n -> Option (Z EC::n, Z EC::n)\nsign M d k = if inputsInRange then maybe_rs else None\n    where\n                inputsInRange = (0 != d) && (0 != k)\n\n        \/\/ Steps 1 - 2.\n        e = hashAndTruncate M\n\n        \/\/ Step 3. k is passed as a parameter because Cryptol cannot generate\n        \/\/ random numbers.\n\n        \/\/ Step 4.\n        \/\/ This uses a Cryptol-native method to compute the multiplicative\n        \/\/ inverse of `k`.\n        k_inv = recip k\n\n        \/\/ Step 5.\n        R = EC::scmul (fromZ k) EC::G\n\n        \/\/ Step 6 (the case expression).\n        \/\/ This would fail (returns `None`) if `R` is the point at\n        \/\/ infinity. In fact, that case is impossible because `[k]G = 0` if and\n        \/\/ only if `k = n`, which can't happen by definition.\n        maybe_rs = case EC::xCoord R of\n            \/\/ Step 11.\n            \/\/ This fails (returns `None`) if `r` or `s` are invalid.\n            Some xR -> if (r != 0) && (s != 0) then Some (r, s) else None\n                where\n                    \/\/ Step 7.\n                    \/\/ Cryptol's `fromZ` method matches [SP-800-186] Appendix F.1.\n                    r1 = fromZ xR\n                    \/\/ Step 8.\n                    r = fromInteger r1\n                    \/\/ Step 9. The `mod n` is implicit here because these are\n                    \/\/ all of type `Z n`.\n                    s = k_inv * (e + r * d)\n\n            None -> None \/\/ Impossible!\n\n\/**\n * ECDSA signature verification algorithm.\n * [FIPS-186-5] Section 6.4.2.\n *\n * Requirements:\n * - The public key `Q` passed as input must be generated as specified in\n *   [FIPS-186-5] Section 6.2.1. Implementors must manually verify that this\n *   is the case.\n *\n * Inputs:\n * M : [m]. Message `M`.\n * (r, s) : (Z n, Z n). A signature.\n * Q : Point. Purported signature verification key.\n *\n * Outputs:\n * Accept (True) or reject (False) the signature over `M` as originating from\n * the owner of public key `Q`.\n *\n * In all inputs and outputs, `n` is the order of the base point `G` for the\n * elliptic curve specified in the `PFEC` interface.\n *\/\nverify : {m} (fin m, width m < Hash::MessageUpperBound) =>\n    [m] -> (Z EC::n, Z EC::n) -> EC::Point -> Bool\nverify M (r, s) Q = inputsInRange && rMatches\n    where\n        \/\/ Step 1.\n        inputsInRange = (0 != r) && (0 != s)\n\n                e = hashAndTruncate M\n\n        \/\/ Step 4.\n        \/\/ This uses a Cryptol-native method to compute the multiplicative\n        \/\/ inverse of `s`.\n        s_inv = recip s\n\n        \/\/ Step 5.\n        u = e * s_inv\n        v = r * s_inv\n\n        \/\/ Step 6.\n        R_1 = EC::twin_mul (fromZ u) EC::G (fromZ v) Q\n\n        \/\/ Step 7. `xCoord` retrieves the x-coordinate of `R_1`.\n        rMatches = case EC::xCoord R_1 of\n            \/\/ Step 9.\n            Some xR -> r1 == r where\n                \/\/ Step 8.\n                \/\/ This converts to an integer mod `n`.\n                r1 = fromInteger (fromZ xR)\n            None -> False\n\n\/**\n * Evaluates the public key given a private key `d`.\n *\n * This implementation does not describe the method for generating the private\n * key `d`. However, in [FIPS-186-5] Appendix A.2, given a valid private key\n * candidate `d`, Section A.2.1 Process Step 5 and Section A.2.2 Process Step 5\n * define how to evaluate the public key `Q`.\n *\n *\/\npublicKey : Z EC::n -> EC::Point\npublicKey d = EC::scmul (fromZ d) EC::G\n\n\/**\n * A signature over a message created with a private key must verify over\n * the corresponding public key.\n * [FIPS-186-5] Section 3.3.\n * ```repl\n * :check signAndVerifyIsCorrect`{64}\n * ```\n *\/\nsignAndVerifyIsCorrect : {m} (fin m, width m < Hash::MessageUpperBound) =>\n    [m] -> Z EC::n -> Z EC::n -> Bool\nproperty signAndVerifyIsCorrect M d k = verification\n    where\n        Q = publicKey d\n        signature = sign M d k\n        verification = case signature of\n            Some (r, s) -> verify M (r, s) Q\n            None -> False\n\nprivate\n    \/**\n     * Hash a message and convert it to an integer mod `n`.\n     *\/\n    hashAndTruncate : {m} (fin m, width m < Hash::MessageUpperBound) => [m] -> Z EC::n\n    hashAndTruncate M = e\n        where\n            H = Hash::hash M\n            e' = take`{min (width EC::n) Hash::DigestLength} H\n            \/\/ Cryptol's default bitstring-to-integer `toInteger` conversion\n            \/\/ matches the routine specified in [FIPS-186-5] Appendix B.2.1.\n            \/\/ We further convert it to an element in `Z n` to support the modular\n            \/\/ operations later in the protocol.\n            e = fromInteger (toInteger e')\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Specification.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::Specification where\n\n\/**\n * ECDSA digital signature generation and verification requires domain\n * parameters that are generated in accordance with [FIPS-186-5] Section 6.1.1.\n * The instantiation of this interface must meet those criteria!\n *\/\nimport interface Common::EC::ECInterface as EC\n\n\/**\n * ECDSA digital signature generation and verification requires an approved\n * hash function or XOF (extendable-output function).\n *\/\nimport interface Primitive::Keyless::Hash::HashInterface as Hash\n\n\/**\n * The unconstrained spec is instantiated with the same curve and hash function\n * specified here.\n *\/\nimport Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec\n    { EC = interface EC , Hash = interface Hash } as USpec\n\n\/**\n * The standard specifies four ranges for the bit length of `n` (the order of\n * the elliptic curve). The minimum allowable bit length is 224.\n * [FIPS-186-5] Section 6.1.1, Table 1.\n *\/\ninterface constraint (width EC::n >= 224)\n\n\/**\n * For an elliptic curve of order `n`, the comparable security strength of\n * ECDSA is approximately `len(n)\/2`.\n * [FIPS-186-5] Section 6.1.1, Table 1.\n *\/\ntype ECSecurityStrength = (width EC::n \/ 2)\n\n\/**\n * The security strength for the hash function shall not be less than the\n * security strength associated with the curve.\n * [FIPS-186-5] Section 6.1.1.\n *\/\ninterface constraint (ECSecurityStrength <= Hash::SecurityStrength)\n\n\/\/ Documentation for the public interface of this API can be found in\n\/\/ `UnconstrainedSpec.cry`.\nsign = USpec::sign\nverify = USpec::verify\npublicKey = USpec::publicKey\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Specification.cry","filetype":"cry","content":"\/**\n * XMSS: eXtended Merkle Signature Scheme.\n *\n * XMSS is a hash-based stateful digital signature scheme defined in\n * [RFC-8391]. It builds on top of the WOTS+ one-time signature scheme,\n * also defined in [RFC-8391]. XMSS (and WOTS+) provide digital signatures\n * under the security of some underlying cryptographic hash function, and\n * require no additional conjectured hardness assumption. In addition,\n * XMSS (and WOTS+) are side-channel resistant and withstand existing\n * quantum attacks.\n *\n * On the other hand, XMSS is a _stateful_ signature scheme, and thus has\n * an upper bound on the number of signatures able to be produced by a given\n * secret key. In addition, one must be careful not to reuse the secret key\n * state across multiple signing operations.\n *\n * References:\n * [RFC-8391]: Andreas Huelsing, Denis Butin, Stefan-Lukas Gazdag, Joost\n *     Rijneveld, and Aziz Mohaisen. XMSS: eXtended Merkle Signature Scheme.\n *     Internet Requests for Comments (RFC) 8391. May 2018.\n *     @see https:\/\/datatracker.ietf.org\/doc\/rfc8391\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n * @author Alex J Malozemoff <amaloz@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::XMSS::Specification where\n\nimport interface Primitive::Asymmetric::Signature::XMSS::Parameters\nimport interface Primitive::Asymmetric::Signature::WOTS::Interface as WOTS\n\ninterface constraint (n == WOTS::n)\n\n\/**\n * Types defined for WOTS+ that are relevant to XMSS.\n *\/\ntype Address = WOTS::Address\ntype Byte = WOTS::Byte\ntype Seed = WOTS::Seed\n\nprivate\n    \/**\n     * Set the `type` word (in the 4th position) in an `Address`.\n     * This setter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    setType : Address -> Word -> Address\n    setType address value = take`{3 * 4} address # split value # drop`{4 * 4} address\n\n\/**\n * A word is a 32-bit sequence used to define hash addresses.\n * [RFC-8391] Section 2.5.\n *\/\ntype Word = [32]\n\n\/**\n * Address scheme for randomizing hash function calls in the L-tree.\n *\n * The address breaks down 7 components, each 1 word long unless specified.\n * 1. Layer address\n * 2-3. Tree address (2 Words)\n * 4. Type (fixed at 1)\n * 5. L-tree address\n * 6. Tree height\n * 7. Tree index\n * 8. keyAndMask\n *\n * Note that this isn't defined in terms of the `Word` type because it's\n * operated on by things that require arrays of bytes.\n *\n * [RFC-8391] Section 2.5.\n *\/\ntype LTreeAddress = [8 * 4]Byte\n\nprivate\n    \/**\n     * Set the `L-tree address` word (the 5th position) in a `LTreeAddress`.\n     * This setter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    setLTreeAddress : LTreeAddress -> Word -> LTreeAddress\n    setLTreeAddress address value = take`{4 * 4} address # (split value) # drop`{5 * 4} address\n\n    \/**\n     * Set the `tree height` word (in the 6th position) in an `LTreeAddress`.\n     * This setter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    setTreeHeight : LTreeAddress -> Word -> LTreeAddress\n    setTreeHeight address value = take`{5 * 4} address # (split value) # drop`{6 * 4} address\n\n    \/**\n     * Get the `tree height` word (in the 6th position) in an `LTreeAddress`.\n     * This getter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    getTreeHeight : LTreeAddress -> Word\n    getTreeHeight address = value where\n        value = join (take`{1 * 4} (drop`{5 * 4} address))\n\n    \/**\n     * Test `setTreeHeight` and `getTreeHeight`.\n     * ```repl\n     * :prove test_tree_height_getter_setter\n     * ```\n     *\/\n    property test_tree_height_getter_setter ADRS i = i' == i where\n        ADRS' = setTreeHeight ADRS i\n        i' = getTreeHeight ADRS'\n\n    \/**\n     * Set the `tree index` word (in the 7th position) in an `LTreeAddress`.\n     * This setter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    setTreeIndex : LTreeAddress -> Word -> LTreeAddress\n    setTreeIndex address value = take`{6 * 4} address # (split value) # drop`{7 * 4} address\n\n    \/**\n     * Get the `tree index` word (in the 7th position) in an `LTreeAddress`.\n     * This getter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    getTreeIndex : LTreeAddress -> Word\n    getTreeIndex address = join (take`{1 * 4} (drop`{6 * 4} address))\n\n    \/**\n     * Test `setTreeIndex` and `getTreeIndex`.\n     * ```repl\n     * :prove test_tree_index_getter_setter\n     * ```\n     *\/\n    property test_tree_index_getter_setter ADRS i = i' == i where\n        ADRS' = setTreeIndex ADRS i\n        i' = getTreeIndex ADRS'\n\n    \/**\n    * Set the `keyAndMask` word (the 8th position) in an `LTreeAddress`.\n    * This setter is defined implicitly in the spec.\n    *\n    * [RFC-8391] Section 2.7.\n    *\/\n    setKeyAndMask : LTreeAddress -> Word -> LTreeAddress\n    setKeyAndMask address value = take`{7 * 4} address # split value\n\n\/**\n * Address scheme for the main tree hash addresses.\n *\n * The address breaks down 7 components, each 1 word long unless specified.\n * 1. Layer address\n * 2-3. Tree address (2 Words)\n * 4. Type (fixed at 2)\n * 5. Padding (fixed at 0)\n * 6. Tree height\n * 7. Tree index\n * 8. keyAndMask\n *\n * Note that this isn't defined in terms of the `Word` type because it's\n * operated on by things that require arrays of bytes.\n *\n * [RFC-8391] Section 2.5.\n *\/\ntype HashTreeAddress = [8 * 4]Byte\n\n\/**\n * An XMSS private key.\n *\n * An XMSS private key contains an algorithm OID [Errata-8424], `2^^h` WOTS+\n * private keys, the leaf index of the next WOTS+ private key that has not yet\n * been used, an `n`-byte key to generate pseudorandom values for randomized\n * message hashing, the `n`-byte root node of the tree and `SEED`, the n-byte\n * public seed used to pseudorandomly generate bitmasks and hash function keys.\n *\n * [RFC-8391] Section 4.1.3.\n * [Errata-8424] @see https:\/\/www.rfc-editor.org\/errata\/eid8424\n *\/\ntype PrivateKey = {\n    oid: [32],\n    wots_sks: [2^^h]WOTS::PrivateKey,\n    idx: Word,\n    SK_PRF: [n]Byte,\n    root: [n]Byte,\n    seed: Seed\n}\n\nprivate\n    \/**\n     * Set the index in a private key.\n     * This setter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    setIdx : PrivateKey -> Word -> PrivateKey\n    setIdx SK idx = { SK | idx = idx }\n\n    \/**\n     * Take as input an XMSS private key `SK` and an integer `i` and output the\n     * `i`th WOTS+ private key.\n     *\n     * [RFC-8391] Section 4.1.3.\n     *\/\n    getWOTS_SK : PrivateKey -> Word -> WOTS::PrivateKey\n    getWOTS_SK SK i = SK.wots_sks @ i\n\n\/**\n * An XMSS public key.\n *\n * The XMSS public key consists of the root of the binary hash tree and the\n * seed `SEED`, both also stored in the private key. It also includes an\n * object identifier `oid` to identify the specific XMSS instantiation.\n *\n * [RFC-8391] Section 4.1.7.\n *\/\ntype PublicKey = {\n    oid: [32],\n    root: [n]Byte,\n    seed: Seed\n}\n\n\/**\n * An XMSS signature.\n *\n * An XMSS signature is a `(4 + n + (len + h) * n)`-byte string consisting\n * of:\n * -  the index `idx_sig` of the used WOTS+ key pair (4 bytes),\n * -  a byte string `r` used for randomized message hashing (n bytes),\n * -  a WOTS+ signature `sig_ots` (len * n bytes), and\n * -  the so-called authentication path `auth` for the leaf associated\n *    with the used WOTS+ key pair (h * n bytes).\n *\n * [RFC-8391] Section 4.1.8.\n *\/\ntype Signature = {\n    idx_sig: Word,\n    r: [n]Byte,\n    sig_ots: WOTS::Signature,\n    auth: [h][n]Byte\n}\n\nprivate\n    \/**\n     * Set the `OTS address` word (the 5th position) in a `WOTS::OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    setOTSAddress : WOTS::OTSHashAddress -> Word -> WOTS::OTSHashAddress\n    setOTSAddress address value = take`{4 * 4} address # (split value) # drop`{5 * 4} address\n\n    \/**\n     * `RAND_HASH` - Randomized tree hashing.\n     *\n     * `RAND_HASH` takes as input two n-byte values `LEFT` and `RIGHT` that\n     * represent the left and the right halves of the hash function input, the\n     * seed `SEED` used as key for `PRF`, and the address `ADRS` of this hash\n     * function call.  `RAND_HASH` first uses `PRF` with `SEED` and `ADRS` to\n     * generate a key `KEY` and `n`-byte bitmasks `BM_0`, `BM_1`.  Then, it\n     * returns the randomized hash `H(KEY, (LEFT XOR BM_0) || (RIGHT XOR\n     * BM_1))`.\n     *\n     *   Input:  n-byte value LEFT, n-byte value RIGHT, seed SEED,\n     *           address ADRS\n     *   Output: n-byte randomized hash\n     *\n     *   ADRS.setKeyAndMask(0);\n     *   KEY = PRF(SEED, ADRS);\n     *   ADRS.setKeyAndMask(1);\n     *   BM_0 = PRF(SEED, ADRS);\n     *   ADRS.setKeyAndMask(2);\n     *   BM_1 = PRF(SEED, ADRS);\n     *\n     *   return H(KEY, (LEFT XOR BM_0) || (RIGHT XOR BM_1));\n     *\n     * [RFC-8391] Section 4.1.4, Algorithm 7.\n     *\/\n    RAND_HASH : [n]Byte -> [n]Byte -> Seed -> LTreeAddress -> [n]Byte\n    RAND_HASH LEFT RIGHT SEED ADRS = hash where\n        ADRS' = setKeyAndMask ADRS 0\n        KEY = WOTS::PRF SEED ADRS'\n        ADRS'' = setKeyAndMask ADRS' 1\n        BM_0 = WOTS::PRF SEED ADRS''\n        ADRS''' = setKeyAndMask ADRS'' 2\n        BM_1 = WOTS::PRF SEED ADRS'''\n        hash = H KEY ((LEFT ^ BM_0) # (RIGHT ^ BM_1))\n\n    \/**\n     * Helper function for `ltree` for computing `pk`.\n     *\n     * This corresponds to the `for`-loop in Algorithm 8:\n     *\n     *   for ( i = 0; i < floor(len' \/ 2); i++ ) {\n     *     ADRS.setTreeIndex(i);\n     *     pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n     *   }\n     *\n     * [RFC-8391] Section 4.1.5, Algorithm 8.\n     *\/\n    ltree_pk : {len', half_floor} (\n            fin len',\n            \/*\n             * We iterate over `i \u2208 [0..floor(len' \/ 2) - 1]`, so we need `len'\n             * > 1`.\n             *\/\n            len' > 1,\n            half_floor == len' \/ 2, \/\/ Equivalent to `floor(len' \/ 2)`\n            \/*\n             * The `tree index` is a word in `LTreeAddress`, so since we call\n             * `setTreeIndex` on `i \u2208 [0 .. half_floor - 1]` we need that the\n             * width of `half_floor - 1` fits in a word.\n             *\/\n            width (half_floor - 1) <= 32\n\n        ) => [len'][n]Byte -> Seed -> LTreeAddress -> [half_floor][n]Byte\n    ltree_pk pk SEED ADRS = pk' where\n        pk' = [ pk_i where\n                ADRS' = setTreeIndex ADRS i\n                pk_i = RAND_HASH (pk @ (2 * i)) (pk @ (2 * i + 1)) SEED ADRS'\n              | i <- [0..half_floor - 1]\n              ]\n\n    \/**\n     * Recursive version of `ltree`.\n     *\n     * This corresponds to the `while`-loop in Algorithm 8:\n     *\n     *   while ( len' > 1 ) {\n     *     \/\/ This `for`-loop is implemented by `ltree_pk`.\n     *     for ( i = 0; i < floor(len' \/ 2); i++ ) {\n     *       ADRS.setTreeIndex(i);\n     *       pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n     *     }\n     *     if ( len' % 2 == 1 ) {\n     *       pk[floor(len' \/ 2)] = pk[len' - 1];\n     *     }\n     *    len' = ceil(len' \/ 2);\n     *    ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     *  }\n     *\n     * [RFC-8391] Section 4.1.5, Algorithm 8.\n     *\/\n    ltree' : {len', half_floor, half_ceil} (\n            fin len',\n            len' >= 1,\n            half_floor == len' \/ 2, \/\/ Equivalent to `floor(len' \/ 2)`\n            width half_floor <= 32,\n            half_ceil == len' \/^ 2  \/\/ Equivalent to `ceil(len' \/ 2)`\n        ) => [len'][n]Byte -> Seed -> LTreeAddress -> [n]Byte\n    ltree' pk SEED ADRS\n        \/*\n         * The base case. Return the only value in `pk`.\n         *\/\n        | len' == 1 => pk @ 0\n        \/*\n         * The `while`-loop condition for when `len' % 2 == 0`.\n         *\n         * In this case, we do not need to append `pk[len' - 1]` to the end of\n         * `pk`.\n         *\/\n        | (len' > 1, len' % 2 == 0) => result where\n            pk' = ltree_pk pk SEED ADRS\n            ADRS' = setTreeHeight ADRS ((getTreeHeight ADRS) + 1)\n            result = ltree'`{half_ceil} pk' SEED ADRS'\n        \/*\n         * The `while`-loop condition for when `len' % 2 == 1`.\n         *\n         * In this case, we need to append `pk[len' - 1]` to the end of `pk`.\n         *\/\n        | (len' > 1, len' % 2 == 1) => result where\n            pk' = (ltree_pk pk SEED ADRS) # split (pk ! 0)\n            ADRS' = setTreeHeight ADRS ((getTreeHeight ADRS) + 1)\n            result = ltree'`{half_ceil} pk' SEED ADRS'\n\n    \/**\n     * `ltree` - unbalanced binary hash tree.\n     *\n     * To compute the leaves of the binary hash tree, a so-called L-tree is\n     * used.  An L-tree is an unbalanced binary hash tree, distinct but similar\n     * to the main XMSS binary hash tree.  The algorithm `ltree` takes as input\n     * a WOTS+ public key pk and compresses it to a single n-byte value pk[0].\n     * It also takes as input an L-tree address ADRS that encodes the address of\n     * the L-tree and the seed SEED.\n     *\n     * Note: We implement `ltree` using recursion instead of the `while`-loop as\n     * specified in Algorithm 8.\n     *\n     *   Input: WOTS+ public key pk, seed SEED, address ADRS (Note: [Errata-5572])\n     *   Output: n-byte compressed public key value pk[0]\n     *\n     *   unsigned int len' = len;\n     *   ADRS.setTreeHeight(0);\n     *   while ( len' > 1 ) {\n     *     for ( i = 0; i < floor(len' \/ 2); i++ ) {\n     *       ADRS.setTreeIndex(i);\n     *       pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n     *     }\n     *     if ( len' % 2 == 1 ) {\n     *       pk[floor(len' \/ 2)] = pk[len' - 1];\n     *     }\n     *     len' = ceil(len' \/ 2);\n     *     ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     *   }\n     *   return pk[0];\n     *\n     * [RFC-8391] Section 4.1.5, Algorithm 8.\n     * [Errata-5572] @see https:     *\/\n    ltree : WOTS::PublicKey -> Seed -> LTreeAddress -> [n]Byte\n    ltree pk SEED ADRS = result where\n        ADRS' = setTreeHeight ADRS 0\n        result = ltree'`{WOTS::len} pk SEED ADRS'\n\n    \/**\n     * The \"base case\" for `treeHash`.\n     *\n     * This computes the nodes for all entries in the tree corresponding to the\n     * level associated with the start index `s`. That is, if `s` corresponds to\n     * the leftmost leaf of a sub-tree, `treeHash_base` returns a list of all\n     * the nodes (and corresponding addresses) at the same level as `s`.\n     *\n     * This roughly corresponds to the `for`-loop in `treeHash`.\n     *\n     * [RFC-8391] Section 4.1.6, Algorithm 9.\n     *\/\n    treeHash_base : {t} (\n            \/\/ The target node height.\n            fin t,\n            \/\/ The target height must be less than or equal the height of the\n            \/\/ XMSS tree itself.\n            t <= h\n        ) => PrivateKey -> Word -> Address -> [2^^t]([n]Byte, Address)\n    treeHash_base SK s ADRS = if s % (2^^`t) != 0\n        then error \"Invalid `s`: `s % (1 << t) == 0` must hold\"\n        else base where\n            SEED = SK.seed\n            base = [ (node, ADRS''') where\n                     ADRS' = setOTSAddress (setType ADRS 0) (s + i)\n                     pk = WOTS::genPK (getWOTS_SK SK (s + i)) SEED ADRS'\n                     ADRS'' = setLTreeAddress (setType ADRS' 1) (s + i)\n                     node = ltree pk SEED ADRS''\n                     ADRS''' = setTreeIndex (setTreeHeight (setType ADRS'' 2) 0) (i + s)\n                   | i <- [0..2^^t - 1]\n                   ]\n\n    \/**\n     * The \"induction step\" for `treeHash`.\n     *\n     * This takes a list of `2^^t` elements and combines them to produce a\n     * single element by pairwise hashing elements using `RAND_HASH`.\n     *\n     * This roughly corresponds to the `while`-loop in `treeHash`.\n     *\n     * [RFC-8391] Section 4.1.6, Algorithm 9.\n     *\/\n    treeHash_combine : {t} (\n            fin t\n        ) => [2^^t]([n]Byte, Address) -> Seed -> ([n]Byte, Address)\n    treeHash_combine list SEED\n        | t == 0 => list @ 0\n        | t >= 1 => treeHash_combine list' SEED where\n            list' = [ (node, ADRS') where\n                      ADRS = setTreeIndex a.1 ((getTreeIndex b.1 - 1) \/ 2)\n                      node = RAND_HASH a.0 b.0 SEED ADRS\n                      ADRS' = setTreeHeight ADRS (getTreeHeight ADRS + 1)\n                    | [a, b] <- groupBy`{2} list\n                    ]\n\n    \/**\n     * The `treeHash` algorithm.\n     *\n     * This implementation does not closely mimic the algorithm in [RFC-8391].\n     * That algorithm utilizes a stack which is difficult to implement in\n     * Cryptol. Instead, we implement `treeHash` \"level-by-level\". To explain\n     * this, we first step back and explain the goal of `treeHash`.\n     *\n     * At a high level, `treeHash` takes a leftmost leaf of a sub-tree of height\n     * `t`, and computes the root node of that sub-tree. This can be done in two\n     * ways, which essentially boils down to a breadth-first versus depth-first\n     * approach. The breadth-first way is to first compute all the nodes at the\n     * same level as the leftmost leaf, use those nodes to compute the parent\n     * nodes at the next level, etc., until the root is reached. The depth-first\n     * way is to use a stack to store nodes as they are computed so we can\n     * continually complete sub-trees as we process all the nodes on the same\n     * level as `s`.\n     *\n     * The `treeHash` algorithm in [RFC-8391] does the computation in a\n     * depth-first manner, using a stack to store state. In this implementation,\n     * we use the breadth-first approach.\n     *\n     *   Input: XMSS private key SK, start index s, target node height t,\n     *          address ADRS\n     *   Output: n-byte root node - top node on Stack\n     *\n     *   if( s % (1 << t) != 0 ) return -1;\n     *   for ( i = 0; i < 2^t; i++ ) {\n     *     SEED = getSEED(SK);\n     *     ADRS.setType(0);   \/\/ Type = OTS hash address\n     *     ADRS.setOTSAddress(s + i);\n     *     pk = WOTS_genPK (getWOTS_SK(SK, s + i), SEED, ADRS);\n     *     ADRS.setType(1);   \/\/ Type = L-tree address\n     *     ADRS.setLTreeAddress(s + i);\n     *     node = ltree(pk, SEED, ADRS);\n     *     ADRS.setType(2);   \/\/ Type = hash tree address\n     *     ADRS.setTreeHeight(0);\n     *     ADRS.setTreeIndex(i + s);\n     *     while ( Top node on Stack has same height t' as node ) {\n     *        ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) \/ 2);\n     *        node = RAND_HASH(Stack.pop(), node, SEED, ADRS);\n     *        ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     *     }\n     *     Stack.push(node);\n     *   }\n     *   return Stack.pop();\n     *\n     * [RFC-8391] Section 4.1.6, Algorithm 9.\n     *\/\n    treeHash : {t} (\n            \/\/ The target node height.\n            fin t,\n            \/\/ The target height must be less than or equal the height of the\n            \/\/ XMSS tree itself.\n            t <= h\n        ) => PrivateKey -> Word -> Address -> [n]Byte\n    treeHash SK s ADRS = if s % (2^^`t) != 0\n        then error \"Invalid `s`: `s % (1 << t) == 0` must hold\"\n        else node.0 where\n            list = treeHash_base`{t} SK s ADRS\n            node = treeHash_combine list SK.seed\n\n\/**\n * `keyGen` - Generate an XMSS key pair.\n *\n * This differs from the algorithm in [RFC-8391] in several ways.\n *\n * - We do not do any randomness generation, but rather require all random\n *   values to be inputs to key generation. This includes the 2^^h WOTS+\n *   private keys `wots_sks`, the secret key to the PRF `SK_PRF`, and the\n *   seed `SEED`.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure security, XMSS requires that the WOTS+ private\n * keys, PRF secret key, and seed are generated uniformly at random. This\n * specification does not verify the generation of those values;\n * implementors must manually verify that the values are chosen\n * appropriately.\n *\n *   Input: No input\n *   Output: XMSS private key SK, XMSS public key PK\n *\n *   \/\/ Example initialization for SK-specific contents\n *   idx = 0;\n *   for ( i = 0; i < 2^h; i++ ) {\n *     wots_sk[i] = WOTS_genSK();\n *   }\n *   initialize SK_PRF with a uniformly random n-byte string;\n *   setSK_PRF(SK, SK_PRF);\n *\n *   \/\/ Initialization for common contents\n *   initialize SEED with a uniformly random n-byte string;\n *   setSEED(SK, SEED);\n *   setWOTS_SK(SK, wots_sk));\n *   ADRS = toByte(0, 32);\n *   root = treeHash(SK, 0, h, ADRS);\n *\n *   SK = idx || wots_sk || SK_PRF || root || SEED;\n *   PK = OID || root || SEED;\n *   return (SK || PK);\n *\n * [RFC-8391] Section 4.1.7, Algorithm 10 (called `XMSS_keyGen` in the\n * spec).\n *\/\nkeyGen : [2^^h]WOTS::PrivateKey -> [n]Byte -> Seed -> (PrivateKey, PublicKey)\nkeyGen wots_sks SK_PRF SEED = (SK, PK) where\n    SK_no_root = { oid = oid, idx = 0 : Word, wots_sks = wots_sks, SK_PRF = SK_PRF, root = zero : [n]Byte, seed = SEED }\n    ADRS = zero \/\/ Equivalent to `WOTS::toByte`{32} 0`.\n    root = treeHash`{h} SK_no_root 0 ADRS\n    SK = { SK_no_root | root = root }\n    PK = { oid = oid, root = root, seed = SEED }\n\nprivate\n    \/**\n     * Helper function for `buildAuth`.\n     *\n     * This computes the `j`th entry in the `auth` list, corresponding to the\n     * body of the `for`-loop in the algorithm in Section 4.1.9:\n     *\n     *   k = floor(i \/ (2^j)) XOR 1;\n     *   auth[j] = treeHash(SK, k * 2^j, j, ADRS);\n     *\n     * [RFC-8391] Section 4.1.9.\n     *\/\n    buildAuth_j : {j} (\n            fin j,\n            \/\/ The `for`-loop body is over values `j \u2208 [0..h-1]`.\n            j >= 0,\n            j <= h - 1\n        ) => PrivateKey -> Word -> Address -> [n]Byte\n    buildAuth_j SK i ADRS = auth_j where\n        k = i \/ 2^^`j ^ 1 \/\/ Equivalent to `floor(i \/ (2^j)) XOR 1`\n        auth_j = treeHash`{j} SK (k * 2^^`j) ADRS\n\n    \/**\n     * Recursive version of `buildAuth`.\n     *\n     * This corresponds to the `for`-loop in the algorithm in Section 4.1.9:\n     *\n     *   for ( j = 0; j < h; j++ ) {\n     *     k = floor(i \/ (2^j)) XOR 1;\n     *     auth[j] = treeHash(SK, k * 2^j, j, ADRS);\n     *   }\n     *\n     * [RFC-8391] Section 4.1.9.\n     *\/\n    buildAuth' : {j} (\n            fin j,\n            j < h\n        ) => PrivateKey -> Word -> Address -> [j + 1][n]Byte\n    buildAuth' SK i ADRS\n        | j == 0 => [ buildAuth_j`{0} SK i ADRS ]\n        | j > 0  => list # [ buildAuth_j`{j} SK i ADRS ] where\n            list = buildAuth'`{j - 1} SK i ADRS\n\n    \/**\n     * `buildAuth` - Compute the authentication path for the i^th WOTS+ key\n     * pair.\n     *\n     * Note: We implement `buildAuth` using recursion instead of the `for`-loop.\n     *\n     *   Input: XMSS private key SK, WOTS+ key pair index i, ADRS\n     *   Output: Authentication path auth\n     *\n     *   for ( j = 0; j < h; j++ ) {\n     *     k = floor(i \/ (2^j)) XOR 1;\n     *     auth[j] = treeHash(SK, k * 2^j, j, ADRS);\n     *   }\n     *\n     * [RFC-8391] Section 4.1.9.\n     *\/\n    buildAuth : PrivateKey -> Word -> Address -> [h][n]Byte\n    buildAuth SK i ADRS = buildAuth'`{h - 1} SK i ADRS\n\n    \/**\n     * `treeSig` - Generate a WOTS+ signature on a message with corresponding\n     * authentication path.\n     *\n     *   Input: n-byte message M', XMSS private key SK,\n     *          signature index idx_sig, ADRS\n     *   Output: Concatenation of WOTS+ signature sig_ots and\n     *           authentication path auth\n     *\n     *   auth = buildAuth(SK, idx_sig, ADRS);\n     *   ADRS.setType(0);   \/\/ Type = OTS hash address\n     *   ADRS.setOTSAddress(idx_sig);\n     *   sig_ots = WOTS_sign(getWOTS_SK(SK, idx_sig),\n     *                       M', getSEED(SK), ADRS);\n     *   Sig = sig_ots || auth;\n     *   return Sig;\n     *\n     * [RFC-8391] Section 4.1.9, Algorithm 11.\n     *\/\n    treeSig : [n]Byte -> PrivateKey -> Word -> Address -> (WOTS::Signature, [h][n]Byte)\n    treeSig M' SK idx_sig ADRS = (sig_ots, auth) where\n        auth = buildAuth SK idx_sig ADRS\n        ADRS' = setOTSAddress (setType ADRS 0) idx_sig\n        \/\/ NOTE: The spec calls `WOTS::sign` with the wrong parameter order. [Errata-8383].\n        sig_ots = WOTS::sign M' (getWOTS_SK SK idx_sig) ADRS' SK.seed\n\n\/**\n * `sign` - Generate an XMSS signature and update the XMSS private key.\n *\n *   Input: Message M, XMSS private key SK\n *   Output: Updated SK, XMSS signature Sig\n *\n *   idx_sig = getIdx(SK);\n *   setIdx(SK, idx_sig + 1);\n *   ADRS = toByte(0, 32);\n *   byte[n] r = PRF(getSK_PRF(SK), toByte(idx_sig, 32));\n *   byte[n] M' = H_msg(r || getRoot(SK) || (toByte(idx_sig, n)), M);\n *   Sig = idx_sig || r || treeSig(M', SK, idx_sig, ADRS);\n *   return (SK || Sig);\n *\n * Note: We index into the `PrivateKey` type rather than using `getIdx`,\n * `getSK_PRF`, and `getRoot`.\n *\n * [RFC-8391] Section 4.1.9, Algorithm 12 (called `XMSS_sign` in the spec).\n *\/\nsign : {m} (\n        fin m,\n        width (PaddingWidth + 8 * m) < MessageUpperBound\n    ) => [m]Byte -> PrivateKey -> (PrivateKey, Signature)\nsign M SK = (SK', Sig) where\n    idx_sig = SK.idx\n    SK' = setIdx SK (idx_sig + 1)\n    ADRS = zero : Address \/\/ Equivalent to `WOTS::toByte`{32} 0`.\n    r = WOTS::PRF SK.SK_PRF (WOTS::toByte`{32} idx_sig)\n    M' = H_msg (r # SK.root # WOTS::toByte`{n} idx_sig) M\n    (sig_ots, auth) = treeSig M' SK idx_sig ADRS\n    Sig = { idx_sig = idx_sig, r = r, sig_ots = sig_ots, auth = auth }\n\n\/**\n * `rootFromSig` - Compute a root node from a tree signature.\n *\n *   Input: index idx_sig, WOTS+ signature sig_ots, authentication path\n *          auth, n-byte message M', seed SEED, address ADRS\n *   Output: n-byte root value node[0]\n *\n *   ADRS.setType(0);   \/\/ Type = OTS hash address\n *   ADRS.setOTSAddress(idx_sig);\n *   pk_ots = WOTS_pkFromSig(sig_ots, M', SEED, ADRS);\n *   ADRS.setType(1);   \/\/ Type = L-tree address\n *   ADRS.setLTreeAddress(idx_sig);\n *   byte[n][2] node;\n *   node[0] = ltree(pk_ots, SEED, ADRS);\n *   ADRS.setType(2);   \/\/ Type = hash tree address\n *   ADRS.setTreeIndex(idx_sig);\n *   for ( k = 0; k < h; k++ ) {\n *     ADRS.setTreeHeight(k);\n *     if ( (floor(idx_sig \/ (2^k)) % 2) == 0 ) {\n *       ADRS.setTreeIndex(ADRS.getTreeIndex() \/ 2);\n *       node[1] = RAND_HASH(node[0], auth[k], SEED, ADRS);\n *     } else {\n *       ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) \/ 2);\n *       node[1] = RAND_HASH(auth[k], node[0], SEED, ADRS);\n *     }\n *     node[0] = node[1];\n *   }\n *   return node[0];\n *\n * [RFC-8391] Section 4.1.10, Algorithm 13 (called `XMSS_rootFromSig` in the\n * spec).\n *\/\nrootFromSig : Word -> WOTS::Signature -> [h][n]Byte -> [n]Byte -> Seed -> Address -> [n]Byte\nrootFromSig idx_sig sig_ots auth M' SEED ADRS = node_0' where\n    ADRS' = setOTSAddress (setType ADRS 0) idx_sig\n    \/\/ NOTE: The spec calls `WOTS_pkFromSig` with the wrong parameter order. [Errata-8396].\n    pk_ots = WOTS::pkFromSig M' sig_ots ADRS' SEED\n    ADRS'' = setLTreeAddress (setType ADRS' 1) idx_sig\n    node_0_initial = ltree pk_ots SEED ADRS''\n    ADRS''' = setTreeIndex (setType ADRS'' 2) idx_sig\n    (node_0', _) = foldl updateNode (node_0_initial, ADRS''') [0..h-1] where\n        updateNode (node_0, adrs) k = (node_1, adrs'') where\n            adrs' = setTreeHeight adrs k\n            treeindex = getTreeIndex adrs'\n            treeindex' = if (idx_sig \/ 2^^k) % 2 == 0\n                then treeindex \/ 2\n                else (treeindex - 1) \/ 2\n            adrs'' = setTreeIndex adrs' treeindex'\n            node_1 = if (idx_sig \/ 2^^k) % 2 == 0\n                then RAND_HASH node_0 (auth @ k) SEED adrs''\n                else RAND_HASH (auth @ k) node_0 SEED adrs''\n\n\/**\n * `verify` - Verify an XMSS signature using the corresponding XMSS public key\n * and a message.\n *\n * Note: We index into the `PrivateKey` type rather than using `getSEED` and\n * index into the `PublicKey` type rather than using `getRoot`. The spec\n * also implicitly indexes into the `Signature` type which we do explicitly\n * here.\n *\n *   Input: XMSS signature Sig, message M, XMSS public key PK\n *   Output: Boolean\n *\n *   ADRS = toByte(0, 32);\n *   byte[n] M' = H_msg(r || getRoot(PK) || (toByte(idx_sig, n)), M);\n *\n *   byte[n] node = XMSS_rootFromSig(idx_sig, sig_ots, auth, M',\n *                                   getSEED(PK), ADRS);\n *   if ( node == getRoot(PK) ) {\n *     return true;\n *   } else {\n *     return false;\n *   }\n *\n * [RFC-8391] Section 4.1.10, Algorithm 14 (called `XMSS_verify` in the\n * spec).\n *\/\nverify : {m} (fin m, width (PaddingWidth + 8 * m) < MessageUpperBound)\n    => Signature -> [m]Byte -> PublicKey -> Bit\nverify Sig M PK = node == PK.root where\n    ADRS = zero \/\/ Equivalent to `WOTS::toByte`{32} 0`.\n    M' = H_msg (Sig.r # PK.root # WOTS::toByte`{n} Sig.idx_sig) M\n    node = rootFromSig Sig.idx_sig Sig.sig_ots Sig.auth M' PK.seed ADRS\n\n\/**\n * ```repl\n * :set tests = 1\n * :check XMSSInverts\n * ```\n *\/\nproperty XMSSInverts M wots_sks SK_PRF SEED = verify sig M pk where\n    (sk, pk) = keyGen wots_sks SK_PRF SEED\n    (sk', sig) = sign M sk\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Parameters.cry","filetype":"cry","content":"interface module Primitive::Asymmetric::Signature::XMSS::Parameters where\n\n\/**\n * Height of the XMSS tree.\n * [RFC-8391] Section 4.1.1.\n *\/\ntype h : #\ntype constraint (fin h)\n\/**\n * This constraint comes from the fact that 2^^h must fit within a word.\n *\n * See `treeHash` for more details.\n *\/\ntype constraint (h <= 32)\n\/**\n * The height of the XMSS tree must be at least 1.\n *\/\ntype constraint (h >= 1)\n\n\/**\n * The length (in bytes) of the message digest, as well as each node.\n * [RFC-8391] Section 4.1.1.\n *\/\ntype n : #\ntype constraint (fin n)\n\n\/**\n * A cryptographic hash function that takes a key and a message.\n * [RFC-8391] Section 4.1.2.\n *\/\nH : [n][8] -> [2 * n][8] -> [n][8]\n\n\/**\n * Maximum width in bits for a message under the hash function used to\n * instantiate `H_msg`.\n *\n * `H_msg` allows arbitrary-length messages, but in practice, the hash\n * functions used to instantiate it may limit their input to some maximum\n * width.\n *\/\ntype MessageUpperBound : #\n\n\/**\n * Width of the non-message bits passed to the hash function in `H_msg`.\n *\n * In the approved instantiations defined in [RFC-8391] and [SP-800-208],\n * this includes domain separation and a fixed-length key.\n * This is used to enforce the max message width constraint.\n *\/\ntype PaddingWidth : #\n\n\/**\n * The Object Identifier (OID) for the XMSS public key.\n *\n * See [RFC-8391] Section 8 for the specific values to set this to for a given\n * instantiation.\n *\n * [RFC-8391] Section 4.1.7.\n *\/\noid : [32]\n\n\/**\n * A cryptographic hash function that takes a key and an arbitrary-length\n * message.\n * [RFC-8391] Section 4.1.2.\n *\n * Note: Some approved instantiations of this function use hash functions that\n * have a maximum width for messages. The type constraint enforces this by\n * limiting the length of the hashed message to the maximum width.\n *\/\nH_msg : {m} (fin m, width (PaddingWidth + 8 * m) < MessageUpperBound)\n    => [3 * n][8] -> [m][8] -> [n][8]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Interface.cry","filetype":"cry","content":"\/*\n * Public interface for the WOTS+ one-time signature scheme.\n *\n * We expect that there will only be one implementation of this scheme.\n * However, to support its typical use as a component in a more complex scheme\n * (like XMSS and SPHINCS+), we want to allow other protocols to be\n * defined in terms of the generic WOTS, and then instantiated with both\n * WOTS-specific and scheme-specific parameters (and potentially with\n * additional interface constraints).\n *\n * Some documentation is duplicated between this interface and the\n * specification. This is based on the API in [RFC-8391].\n *\n * [RFC-8391]: Andreas Huelsing, Denis Butin, Stefan-Lukas Gazdag, Joost\n *     Rijneveld, and Aziz Mohaisen. XMSS: eXtended Merkle Signature Scheme.\n *     Internet Requests for Comments (RFC) 8391. May 2018.\n *     @see https:\/\/datatracker.ietf.org\/doc\/rfc8391\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\ninterface module Primitive::Asymmetric::Signature::WOTS::Interface where\n\n\/**\n * Security parameter.\n * This defines the message length, the length of a private key, the length\n * of a public key, and a signature element (in bytes).\n * [RFC-8391] Section 3.1.1.\n *\/\ntype n : #\ntype constraint (fin n)\n\n\/**\n * The Winternitz parameter. This must be either 4 or 16.\n * [RFC-8391] Section 3.1.1.\n *\n * The type constraint is a bit contrived, but it requires that\n * `w` is in the range `[0, 16]`, is divisible by 4 (`{0, 4, 8, 12, 16}`),\n * and is congruent to 1 mod 3 (`{4, 16}`).\n *\/\ntype w : #\ntype constraint (fin w, w % 4 == 0, w % 3 == 1, w <= 16)\n\n\/**\n * A keyed cryptographic hash function that takes a key and a message.\n * [RFC-8391] Section 3.1.1.1.\n *\/\nF : [n][8] -> [n][8] -> [n][8]\n\n\/**\n * A pseudorandom function that takes a key and an index.\n * [RFC-8391] Section 3.1.1.1.\n *\/\nPRF : [n][8] -> [32][8] -> [n][8]\n\n\/**\n * A length value (fixed with respect to `n` and `w`).\n * [RFC-8391] Section 3.1.1.\n *\/\ntype len_1 = (8 * n) \/^ (lg2 w)\n\n\/**\n * A length value (fixed with respect to `n` and `w`).\n * [RFC-8391] Section 3.1.1.\n *\/\n\ntype len_2 = lg2 (len_1 * (w - 1)) \/ lg2 w + 1\n\n\/**\n * The number of `n`-byte string elements in a WOTS+ private key, public key,\n * and signature.\n * [RFC-8391] Section 3.1.1.\n *\/\ntype len = len_1 + len_2\n\/**\n * This constraint comes from the fact that we set locations in `Address` to\n * functions of `len` (in particular, `len \/ 2`). These locations are 32 bits\n * in size, so we require that `width len` is no greater than 32 bits.\n *\/\ntype constraint (width len <= 32)\n\n\/**\n * A byte is a sequence of 8 bits using big-endian representation.\n * [RFC-8391] Section 2.1.\n *\/\ntype Byte = [8]\n\n\/**\n * Convert a non-negative integer to a binary representation in big-endian\n * byte order.\n * [RFC-8391] Section 2.4.\n *\n * Note: the spec is not explicit about what to do when `m < 8y` -- e.g. when\n * converting to `y` bytes means truncating the integer representation,\n * rather than padding it with 0s. We chose this behavior based on the\n * reference implementation that accompanies the spec.\n * @see https:\/\/github.com\/XMSS\/xmss-reference\/blob\/master\/utils.c#L6\n * [RFC-8391] Section 7.\n *\n * Essentially, we pad with zeros if needed (using `zext`), then `drop` any\n * unnecessary padding (and potentially also drop some bits of the original\n * integer).\n *\/\ntoByte : {y, m} (fin y, fin m) => [m] -> [y]Byte\n\n\/**\n * An n-byte value used as the key to a PRF.\n *\n * This type is not formally defined in the spec but is defined here for\n * clarity.\n *\n * [RFC-8391] Section 2.5.\n *\/\ntype Seed = [n]Byte\n\n\/**\n * Address scheme for randomizing hash function calls in the OTS scheme.\n * [RFC-8391] Section 2.5.\n *\/\ntype Address = [8 * 4]Byte\n\n\/**\n * Address scheme for randomizing hash function calls in the OTS scheme.\n * [RFC-8391] Section 2.5.\n *\n * The address breaks down 7 components, each 1 word long unless specified.\n * 1. Layer address\n * 2-3. Tree address (2 Words)\n * 4. Type (fixed at 0)\n * 5. OTS address\n * 6. Chain address\n * 7. Hash address\n * 8. keyAndMask\n *\n * Note that this isn't defined in terms of the `Word` type because it's\n * operated on by things that require arrays of bytes.\n *\/\ntype OTSHashAddress = [8 * 4]Byte\n\n\/**\n * A private, or secret, key in WOTS+ is a length `len` array of `n`-byte\n * strings.\n *\n * It represents the start nodes in a set of hash chains.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: A private key MUST be selected randomly from the uniform\n * distribution or selected using a cryptographically secure pseudorandom\n * process! Cryptol cannot verify that a `PrivateKey` was chosen suitably!\n * Implementors must independently audit private key generation!\n *\n * [RFC-8391] Section 3.1.3.\n *\n * An implementation may also use a cryptographically secure pseudorandom\n * method to generate the private key from a single `n`-byte value. See\n * [RFC-8391] Section 3.1.7 for a sample method.\n *\/\ntype PrivateKey = [len][n]Byte\n\n\/**\n * A WOTS+ public key is a length `len` array of `n`-byte strings.\n *\n * It represents the end nodes i a set of length-`w` hash chains, where the\n * start nodes are defined in the corresponding `PrivateKey`.\n *\/\ntype PublicKey = [len][n]Byte\n\n\/**\n * A WOTS+ signature.\n * [RFC-8391] Section 3.1.5.\n *\/\ntype Signature = [len][n]Byte\n\n\/**\n * Generate a WOTS+ public key from a private key.\n * [RFC-8391] Section 3.1.4, Algorithm 4 (called `WOTS_genPK` in the spec).\n * [Errata-8382] @see https:\/\/www.rfc-editor.org\/errata\/eid8382\n *\/\ngenPK : PrivateKey -> [n]Byte -> Address -> PublicKey\n\n\/**\n * Generate a signature from a private key and a message.\n * [RFC-8391] Section 3.1.5, Algorithm 5 (called `WOTS_sign` in the spec).\n *\/\nsign : [n]Byte -> PrivateKey -> Address -> [n]Byte -> Signature\n\n\/**\n * Compute a WOTS+ public key from a message and its signature.\n * [RFC-8391] Section 3.1.6, Algorithm 6 (called `WOTS_pkFromSig` in the spec).\n *\n * The result of this function must be compared to the given public key. If\n * the values are not equal, the signature MUST be rejected. This algorithm\n * does not actually reject any signatures!!\n *\/\npkFromSig : [n]Byte -> Signature -> Address -> [n]Byte -> PublicKey\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Specification.cry","filetype":"cry","content":"\/**\n * WOTS+: One-Time Signatures.\n *\n * WOTS+ is a signature scheme. A notable limitation of WOTS+ is that a given\n * key pair can produce exactly ONE signature; repeated signatures with a\n * single key pair will compromise the private key!!\n *\n * This scheme should typically be used as a component of a less limited\n * signature scheme, like XMSS or SPHINCS+.\n *\n * Warning: If a private key is used to sign two different messages, the scheme\n * becomes insecure! Cryptol cannot protect against this failure mode!\n *\n * Instantiation warnings\n * - The WOTS+ signature scheme includes a checksum. Per [RFC-8391], the\n *   checksum can fit in 32 bits _when instantiated with an approved parameter\n *   set_. This must not be instantiated with any parameter set for which the\n *   checksum does not fit in 32 bits. [RFC-8391] Section 3.1.5.\n *\n * References:\n * [RFC-8391]: Andreas Huelsing, Denis Butin, Stefan-Lukas Gazdag, Joost\n *     Rijneveld, and Aziz Mohaisen. XMSS: eXtended Merkle Signature Scheme.\n *     Internet Requests for Comments (RFC) 8391. May 2018.\n *     @see https:\/\/datatracker.ietf.org\/doc\/rfc8391\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::WOTS::Specification where\n\nparameter\n    \/**\n     * Security parameter.\n     * This defines the message length, the length of a private key, the length\n     * of a public key, and a signature element (in bytes).\n     * [RFC-8391] Section 3.1.1.\n     *\/\n    type n' : #\n    type constraint (fin n')\n\n    \/**\n     * The Winternitz parameter. This must be either 4 or 16.\n     * [RFC-8391] Section 3.1.1.\n     *\n     * The type constraint is a bit contrived, but it requires that\n     * `w` is in the range `[0, 16]`, is divisible by 4 (`{0, 4, 8, 12, 16}`),\n     * and is congruent to 1 mod 3 (`{4, 16}`).\n     *\/\n    type w' : #\n    type constraint (fin w', w' % 4 == 0, w' % 3 == 1, w' <= 16)\n\n    \/**\n     * A keyed cryptographic hash function that takes a key and a message.\n     * [RFC-8391] Section 3.1.1.1.\n     *\/\n    F' : [n'][8] -> [n'][8] -> [n'][8]\n\n    \/**\n     * A pseudorandom function that takes a key and an index.\n     * [RFC-8391] Section 3.1.1.1.\n     *\/\n    PRF' : [n'][8] -> [32][8] -> [n'][8]\n\n    \/**\n     * A length value (fixed with respect to `n` and `w`).\n     * [RFC-8391] Section 3.1.1.\n     *\n     * The type constraint is drawn from Algorithm 5, where a computed checksum\n     * of length `len_1 * (w - 1) * 2^8` must fit in 32 bits for correctness.\n     *\/\n    type len_1 = (8 * n') \/^ (lg2 w')\n    type constraint (width (len_1 * (w' - 1) * 2^^8) <= 32)\n\n    \/**\n     * A length value (fixed with respect to `n` and `w`).\n     * [RFC-8391] Section 3.1.1.\n     *\/\n\n    type len_2 = lg2 (len_1 * (w' - 1)) \/ lg2 w' + 1\n\n    \/**\n     * The number of `n`-byte string elements in a WOTS+ private key, public key,\n     * and signature.\n     * [RFC-8391] Section 3.1.1.\n     *\/\n    type len = len_1 + len_2\n\n    \/**\n     * The `len` parameter fits in 32 bits.\n     *\n     * This implicit fact about our inputs is hard for Cryptol to infer, so we\n     * state it explicitly.\n     *\n     * It is implied by the `genPK` function, which sets the chain address\n     * of an OTS hash address to an iterator that varies from 0 to `len-1`.\n     * The chain address is restricted to one 32-bit word. See [RFC-8391]\n     * Algorithm 4.\n     *\n     * This can also be observed from the computed `len` values from the valid\n     * parameter sets in Section 5.2.\n     *\/\n    type constraint (32 >= width len)\n\ntype n = n'\ntype w = w'\nF = F'\nPRF = PRF'\n\n\/**\n * A byte is a sequence of 8 bits using big-endian representation.\n * [RFC-8391] Section 2.1.\n *\/\ntype Byte = [8]\n\n\/**\n * Convert a non-negative integer to a binary representation in big-endian\n * byte order.\n * [RFC-8391] Section 2.4.\n *\n * Note: the spec is not explicit about what to do when `m < 8y` -- e.g. when\n * converting to `y` bytes means truncating the integer representation,\n * rather than padding it with 0s. We chose this behavior based on the\n * reference implementation that accompanies the spec.\n * @see https:\/\/github.com\/XMSS\/xmss-reference\/blob\/master\/utils.c#L6\n * [RFC-8391] Section 7.\n *\n * Essentially, we pad with zeros if needed (using `zext`), then `drop` any\n * unnecessary padding (and potentially also drop some bits of the original\n * integer).\n *\/\ntoByte : {y, m} (fin y, fin m) => [m] -> [y]Byte\ntoByte x = split (drop (zext`{max m (y * 8)} x))\n\n\/**\n * Ensure that `toByte`{32} 0 == zero`.\n * ```repl\n * :check toByteZeroIsZero`{32}\n * ```\n *\/\ntoByteZeroIsZero : {m} fin m => Bit\ntoByteZeroIsZero = zero == toByte`{32, m} 0\n\n\/**\n * An n-byte value used as the key to a PRF.\n *\n * This type is not formally defined in the spec but is defined here for\n * clarity.\n *\n * [RFC-8391] Section 2.5.\n *\/\ntype Seed = [n]Byte\n\n\/**\n * A word is a 32-bit sequence used to define hash addresses.\n * [RFC-8391] Section 2.5.\n *\/\ntype Word = [32]\n\n\/**\n * Address scheme for randomizing hash function calls in the OTS scheme.\n * [RFC-8391] Section 2.5.\n *\n * The address breaks down 7 components, each 1 word long unless specified.\n * 1. Layer address\n * 2-3. Tree address (2 Words)\n * 4. Type (fixed at 0)\n * 5. OTS address\n * 6. Chain address\n * 7. Hash address\n * 8. keyAndMask\n *\n * Note that this isn't defined in terms of the `Word` type because it's\n * operated on by things that require arrays of bytes.\n *\/\ntype OTSHashAddress = [8 * 4]Byte\n\n\/**\n * A private, or secret, key in WOTS+ is a length `len` array of `n`-byte\n * strings.\n *\n * It represents the start nodes in a set of hash chains.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: A private key MUST be selected randomly from the uniform\n * distribution or selected using a cryptographically secure pseudorandom\n * process! Cryptol cannot verify that a `PrivateKey` was chosen suitably!\n * Implementors must independently audit private key generation!\n *\n * [RFC-8391] Section 3.1.3.\n *\n * An implementation may also use a cryptographically secure pseudorandom\n * method to generate the private key from a single `n`-byte value. See\n * [RFC-8391] Section 3.1.7 for a sample method.\n *\/\ntype PrivateKey = [len][n]Byte\n\n\/**\n * A WOTS+ public key is a length `len` array of `n`-byte strings.\n *\n * It represents the end nodes i a set of length-`w` hash chains, where the\n * start nodes are defined in the corresponding `PrivateKey`.\n *\/\ntype PublicKey = [len][n]Byte\n\n\/**\n * Generate a WOTS+ public key from a private key.\n * [RFC-8391] Section 3.1.4, Algorithm 4 (called `WOTS_genPK` in the spec).\n * [Errata-8382] @see https:\/\/www.rfc-editor.org\/errata\/eid8382\n *\/\ngenPK : PrivateKey -> [n]Byte -> OTSHashAddress -> PublicKey\ngenPK sk SEED ADRS = pk where\n    pk = [ pki where\n            ADRSi = setChainAddress ADRS i\n            pki = chain ski 0 (`w - 1) SEED ADRSi\n        | i <- [0..len-1]\n        | ski <- sk]\n\nprivate\n    \/**\n     * Set the chain address word (in the 6th position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setChainAddress : OTSHashAddress -> Word -> OTSHashAddress\n    setChainAddress address value =\n        take`{5 * 4} address # (split value) # drop`{6 * 4} address\n\n    \/**\n     * Set the hash address word (in the 7th position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setHashAddress : OTSHashAddress -> Word -> OTSHashAddress\n    setHashAddress address value =\n        take`{6 * 4} address # (split value) # drop`{7 * 4} address\n\n    \/**\n     * Set the `keyAndMask` word (the last position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setKeyAndMask : OTSHashAddress -> Word -> OTSHashAddress\n    setKeyAndMask address value = take`{7 * 4} address # split value\n\n    \/**\n     * Chaining function that iterates `F` on the input `X`, `s` times.\n     * [RFC-8391] Section 3.1.2, Algorithm 2.\n     *\/\n    chain : [n]Byte -> Word -> Word -> [n]Byte -> OTSHashAddress -> [n]Byte\n    chain X i s SEED ADRS = return where\n        return = if s == 0 then\n                X\n            else if i + s > `w - 1 then\n                error \"Invalid `s` and `i` parameters passed to `chain`\"\n            else\n                tmp'\n        tmp = chain X i (s - 1) SEED ADRS\n\n        ADRS' = setHashAddress ADRS (i + s - 1)\n        ADRS'' = setKeyAndMask ADRS' 0\n        KEY = PRF SEED ADRS''\n        ADRS''' = setKeyAndMask ADRS'' 1\n        BM = PRF SEED ADRS'''\n\n        tmp' = F KEY (tmp ^ BM)\n\n    \/**\n     * Convert a byte string into a set of base-`w` numbers.\n     *\n     * This uses the manual bit-shifting algorithm described in the spec. The\n     * spec is not very particular about bit widths of the helper variables or\n     * the output; we made the following choices:\n     * - `total`: holds each byte of the input, so `[8]`\n     * - `in`: holds the index showing where we are in the input. We use an\n     *   `Integer`, although this could also be `[width len_X]`.\n     * - `bits`: holds the number of bits processed in the current byte. This is\n     *   never larger than 8, but due to the way we've defined the type\n     *   constraint on `w`, it's easier to leave some extra space, so `[8]`.\n     * - `basew`: The output of this function is eventually used as a parameter\n     *   to `chain`, so we pad each base-`w` number to be a `Word` (`[32]`).\n     *\n     * [RFC-8391] Section 2.6, Algorithm 1.\n     *\/\n    base_w_spec : {out_len, len_X} (\n            fin len_X,\n            out_len <= 8 * len_X \/ lg2 w)\n        => [len_X]Byte -> [out_len]Word\n    base_w_spec X = basew where\n        \/\/ Steps 8 - 13. Define how the helper variables (`total`, `in`, `bits`)\n        \/\/ are updated in each round.\n        update_helpers : ([8], Integer, [8]) -> ([8], Integer, [8])\n        update_helpers (total, in, bits) =\n            if bits == 0 then (\n                X@in,\n                in + 1,\n                8 - lg2 `w )\n            else (total, in, bits - lg2 `w)\n\n        \/\/ Step 7. Define the number of iterations we need.\n        type consumed = out_len\n\n        \/\/ Step 14. Compute the set of base-`w` numbers. `zext` converts an\n        \/\/ 8-bit value to a `Word`.\n        basew = take`{consumed} [ zext ((total >> bits) && (`w - 1))\n            \/\/ Steps 1-5. Initialize helper variables (and update them for each\n            \/\/ round). The first element is dropped because the first variable\n            \/\/ update happens before computing any output values.\n            | (total, in, bits) <- drop`{1} (iterate update_helpers (0, 0, 0))]\n\n    \/**\n     * Convert a byte string into a set of base-`w` numbers.\n     *\n     * This uses standard built-in Cryptol functions to achieve the same\n     * functionality as the spec version; rather than manually bit shifting, it\n     * regroups the bits into the desired arrangement. This is about 5x faster\n     * than the spec version.\n     *\n     * Note that this depends on the top-level type constraint restricting `w`\n     * to either 4 or 16. I am not sure the grouping would work as well if we\n     * were working in a base that was not a power of 2.\n     *\/\n    base_w : {out_len, len_X} (\n        fin len_X,\n        out_len <= 8 * len_X \/ lg2 w)\n        => [len_X]Byte -> [out_len]Word\n    base_w X = map zext (groupBy`{lg2 w} (take (join X)))\n\n    \/**\n     * Proof that the Cryptol-ish version of `base_w` matches the spec version.\n     *\n     * Parameter for the following tests are chosen based on the instantiations\n     * that appear in the spec (Algorithms 5 and 6).\n     * ```repl\n     * :prove base_wsMatch`{len_1, n * 8}\n     * type len_2_bytes = len_2 * lg2 w \/^ 8\n     * :prove base_wsMatch`{len_2, len_2_bytes}\n     * ```\n     *\/\n    base_wsMatch : {O, L} (fin L, O <= 8 * L \/ lg2 w) => [L]Byte -> Bit\n    property base_wsMatch X = base_w_spec`{O, L} X == base_w X\n\n    \/**\n     * The spec provides several examples when `w = 16`.\n     * [RFC-8391] Section 2.6.\n     * ```repl\n     * :prove base_wExamplesWork`{}\n     * ```\n     *\/\n    base_wExamplesWork : (w == 16) => Bit\n    property base_wExamplesWork = test4 && test3 && test2 where\n        test4 = base_w`{4} [0x12, 0x34] == [1, 2, 3, 4]\n        test3 = base_w`{3} [0x12, 0x34] == [1, 2, 3]\n        test2 = base_w`{2} [0x12, 0x34] == [1, 2]\n\n\n\/**\n * A WOTS+ signature.\n * [RFC-8391] Section 3.1.5.\n *\/\ntype Signature = [len][n]Byte\n\n\/**\n * Generate a signature from a private key and a message.\n * [RFC-8391] Section 3.1.5, Algorithm 5 (called `WOTS_sign` in the spec).\n *\n * The checksum in the signature algorithm must fit in 32 bits; we enforce this\n * using a constraint in the type signature; it will always be true for the\n * approved parameter sets.\n *\/\nsign : [n]Byte -> PrivateKey -> OTSHashAddress -> [n]Byte -> Signature\nsign M sk ADRS SEED = sig where\n        msg = base_w`{len_1} M\n\n        csum = sum [ `w - 1 - msg_i | msg_i <- msg ]\n\n    \/\/ Convert `csum` to base `w`.\n    csum' = csum << (8 - (`(len_2 * lg2 w) % 8))\n    type len_2_bytes = (len_2 * lg2 w) \/^ 8\n    msg' = msg # base_w`{len_2} (toByte`{len_2_bytes} csum')\n    sig = [sig_i where\n            ADRS_i = setChainAddress ADRS i\n            sig_i = chain sk_i 0 msg_i SEED ADRS_i\n        | i <- [0..len-1]\n        | sk_i <- sk\n        | msg_i <- msg' ]\n\n\/**\n * Compute a WOTS+ public key from a message and its signature.\n * [RFC-8391] Section 3.1.6, Algorithm 6 (called `WOTS_pkFromSig` in the spec).\n *\n * The result of this function must be compared to the given public key. If\n * the values are not equal, the signature MUST be rejected. This algorithm\n * does not actually reject any signatures!!\n *\/\npkFromSig : [n]Byte -> Signature -> OTSHashAddress -> [n]Byte -> PublicKey\npkFromSig M sig ADRS SEED = tmp_pk where\n        msg = base_w`{len_1} M\n\n        csum = sum [ `w - 1 - msg_i | msg_i <- msg ]\n\n    \/\/ Convert `csum` to base `w`.\n    csum' = csum << (8 - (`(len_2 * lg2 w) % 8))\n    type len_2_bytes = (len_2 * lg2 w) \/^ 8\n    msg' = msg # base_w`{len_2} (toByte`{len_2_bytes} csum')\n    tmp_pk = [tmp_pk_i where\n            ADRS_i = setChainAddress ADRS i\n            tmp_pk_i = chain sig_i msg_i (`w - 1 - msg_i) SEED ADRS_i\n        | i <- [0..len-1]\n        | sig_i <- sig\n        | msg_i <- msg' ]\n\n\/**\n * A single execution of this property takes ~2 minutes.\n * ```repl\n * :set tests = 1\n * :check WOTSisCorrect\n * ```\n *\/\nproperty WOTSisCorrect M sk ADRS SEED = tmp_pk == pk where\n    pk = genPK sk SEED ADRS\n    sig = sign M sk ADRS SEED\n    tmp_pk = pkFromSig M sig ADRS SEED\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Instantiations\/ML_DSA_65.cry","filetype":"cry","content":"\/**\n * Instantiation of the ML-DSA-65 parameter set.\n * [FIPS-204] Section 4, Table 1.\n *\n * This is in security strength category 3.\n *\n * @copyright Galois Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_65 =\n    Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\n        type q = 8380417\n        type \u03c4 = 49\n        type \u03bb = 192\n        type \u03b31 = 2 ^^ 19\n        type \u03b32 = (q - 1) \/ 32\n        type k = 6\n        type ell = 5\n        type \u03b7 = 4\n        type \u03c9 = 55\n\n\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Instantiations\/ML_DSA_87.cry","filetype":"cry","content":"\/**\n * Instantiation of the ML-DSA-87 parameter set.\n * [FIPS-204] Section 4, Table 1.\n *\n * This is in security strength category 5.\n *\n * @copyright Galois Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_87 =\n    Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\n        type q = 8380417\n        type \u03c4 = 60\n        type \u03bb = 256\n        type \u03b31 = 2 ^^ 19\n        type \u03b32 = (q - 1) \/ 32\n        type k = 8\n        type ell = 7\n        type \u03b7 = 2\n        type \u03c9 = 75\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Instantiations\/ML_DSA_44.cry","filetype":"cry","content":"\/**\n * Instantiation of the ML-DSA-44 parameter set.\n * [FIPS-204] Section 4, Table 1.\n *\n * This is in security strength category 2.\n *\n * @copyright Galois Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_44 =\n    Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\n        type q = 8380417\n        type \u03c4 = 39\n        type \u03bb = 128\n        type \u03b31 = 2 ^^ 17\n        type \u03b32 = (q - 1) \/ 88\n        type k = 4\n        type ell = 4\n        type \u03b7 = 2\n        type \u03c9 = 80\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P224_SHA224.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P224_SHA224 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA224 as ECDSA\nimport Common::utils(BVtoZ)\n\nproperty checkSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\n\/**\n * Test vector for ECDSA with curve P-224 and SHA-224 as the hash.\n * [RFC6979] Appendix A.2.4.\n * ```repl\n * :prove sampleVector\n * ```\n *\/\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0xF220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\n    k = BVtoZ 0xC1D1F2F10881088301880506805FEB4825FE09ACB6816C36991AA06D\n    expected_r = BVtoZ 0x1CDFE6662DDE1E4A1EC4CDEDF6A1F5A2FB7FBD9145C12113E6ABFD3E\n    expected_s = BVtoZ 0xA6694FD7718A21053F225D3F46197CA699D45006C06F871808F43EBC\n\n\/**\n * Test vector for ECDSA with curve P-224 and SHA-224 as the hash.\n * [RFC6979] Appendix A.2.4.\n * ```repl\n * :prove testVector\n * ```\n *\/\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0xF220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\n    k = BVtoZ 0xDF8B38D40DCA3E077D0AC520BF56B6D565134D9B5F2EAE0D34900524\n    expected_r = BVtoZ 0xC441CE8E261DED634E4CF84910E4C5D1D22C5CF3B732BB204DBEF019\n    expected_s = BVtoZ 0x902F42847A63BDC5F6046ADA114953120F99442D76510150F372A3F4\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P224_SHA3_224.cry","filetype":"cry","content":"\/*\n * Test vectors for ECDSA with curve P224 and SHA3-224.\n *\n * The only test vectors we could find for SHA3 were from the ACVP program. The\n * KATs for checking signatures didn't include the nonce `k`, which is necessary\n * to randomize the signature, so this does not include any KATs for signing;\n * only for verification.\n *\n * [ACVP]: NIST. usnistgov. GitHub repo \"ACVP-Server\".\n *     @see https:\/\/github.com\/usnistgov\/ACVP-Server\/blob\/master\/gen-val\/json-files\/ECDSA-SigGen-FIPS186-5\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P224_SHA3_224 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA3_224 as ECDSA\nimport Common::utils(BVtoZ)\nimport Common::EC::PrimeField::Instantiations::P224 as EC\n\n\/**\n * This tests the signature verification vectors for curve \"P-224\" and hashAlg\n * \"SHA3-224\" from [ACVP] \"ECDSA-SigGen-FIPS186-5\".\n * ```repl\n * :prove testVerification\n * ```\n *\/\nproperty testVerification = publicKeyWorks && sigVerWorks where\n    \/\/ Check that the provided `d` computes the expected public key.\n    publicKeyWorks = EC::affineEq (ECDSA::publicKey d) (EC::Affine qx qy)\n\n    d = BVtoZ 0x2F9D814730AF0085C942FE8B679B023C0DB5AFAC27613D7CEC883405\n    qx = BVtoZ 0x47E1E01BBE0407877C18D7B94ACFC690BDCF0AF6D6A9EC91CA59F772\n    qy = BVtoZ 0x5DA449E730C30BE4D65A605F2BA6FCBF390310E02246A9135ECE16AA\n\n    \/\/ Check that the given message-signature pairs all verify.\n    checkSigVer msg r s = ECDSA::verify msg (r, s) (ECDSA::publicKey d)\n    sigVerWorks = and [checkSigVer msg (BVtoZ r) (BVtoZ s) | (msg, r, s) <- [\n        (msg61, r61, s61),\n        (msg62, r62, s62),\n        (msg63, r63, s63),\n        (msg64, r64, s64),\n        (msg65, r65, s65),\n        (msg66, r66, s66),\n        (msg67, r67, s67),\n        (msg68, r68, s68),\n        (msg69, r69, s69),\n        (msg70, r70, s70)\n    ]]\n\n    \/\/ See \"internalProjection.json\", section \"tgId = 7\".\n    msg61 = 0x030D2C1918E8473FFCEB9A78A4331387757C8808B7D57F06A4A268DFE6178CF7236BEBD8C4F49BD73A65796973B64FBED7E38F56B95639EFE6F00DB4BF82A476540E2EF3F2EB6B05D3425EF1C465F6B25628618B8EE005525EDDC32FF96F1999563ECE6A68A6E6396E1D37BEA898CDA91F0723D91BFBB423789799D824D9220A\n    r61 = 0x3612063972B03272569A0A4860948A06544E1D21F19995880ACC0AFA\n    s61 = 0x0F6E9C94A55155AAAFE842637A84AC0C57F6CE67E721FC4CBA3FD7FD\n\n    msg62 = 0x56E761977EF6A0C1E08EA96FF909089AA451F0B4B7EEB6B8F978E4D32FACDB3158D4C96AD7FDE38B387994C1913E5B64FF8C02465137AD1F5239956181D93B744F3BAE546D0827A69742EB650E09F18ED966AC6A202A6C06293772FEA47BCD23DFA2CA82CC35CAABF62371BE3DD756C43739DC4FFC1A171ABD7A8937B31ECA08\n    r62 = 0x2ECB9ADE16CC813B56F72538C9223684761316142B6348180765DAF3\n    s62 = 0xC22705FC831663A661C2C780986F43AFAAA3B0DE46066372881D4BCA\n\n    msg63 = 0x0AD042754785A6F67D037F5CA4497F8E71653DDB721AA401AD46FE04994A0537EFFE3356FA5CF8A91C43B1F75309332D3D97BEE61C8B5E3E273CD2402EC2392EFAD266D876BC262F4C5A67D058CC3E7F872CC7D379000A56D6A913208C4403831409C39189BA59056A38E626E235E73B5D5E8531454E38BE64F093D0C2916732\n    r63 = 0x454589AD9EC014E14A6F1947D64578B31F81E6E2AA8C69584CD4EE9D\n    s63 = 0x89D832DEDC403EE2D9A899E58A556CAFAC2B236C48210927657609C6\n\n\n    msg64 = 0x07C9B2EB7CA9B7717521520D1E5CE996A415FFDE9E858288167C54B22FBF19CFC982AF2E2DD5F12C8B135AEA788BAFF48F08DE83730CC2B6F7E0C06ED64385D00CCB99CD51789F839872EA603C7A69D7EB2AF5B490259A625000A7CC588A9F75749664E1629A1F85BD6EA90D6F12B69FAD19F875B8FA6671ACFB6870FE5DF141\n    r64 = 0x546CE2F2EE8EC5CFF9A3065EF5006F37521FAD405A8069863BD4BDEB\n    s64 = 0x58AB96923D3FEE1F56D399C33DDB4324B43BC99EAC54D5464C5F5A05\n\n    msg65 = 0x4AEB2C6FDA5C7DA730348816DDB0E3910B2DD91BC8E5D9C34DBF6A8F1B5C8E251F94CC6A6642E1AD3A1B086B075160F9B7BB90BB78CF09165592B1BC0AB7C239A090683EAA9B4D9CE951EBD2FC2E56FF7B7447DE962EB687D27705B3DECBFF25ED059A5E51DC6EFF9A26EA2E57DB8E5B4690870ADDB03E3AEEB91A189BE7C3D3\n    r65 = 0x9BCCD499ED71E53C4A5AA52C357BD10B881BE82C35E62B37F99F950F\n    s65 = 0x144722D59C95D2C6A0A161EE58245A04A06F226EEC91A26F972B7FF1\n\n    msg66 = 0x19773A3F4941F74B9AB5C304B85A9C11371D63B41DDEE0B604358CD2E0A325F627D9A0C7762D5E25E3EEB8F2D276C3796C0C181E07C6D3BA3EB16CA866DA3952A7967B7CD3081D4F3B6B7BF0981F6871DEF2AC1AF6CD8DA35573CF947C99905EDE50123AE7A16C18270EEB956A282D0E46E942F73818A3BAD1631D4021455E27\n    r66 = 0xED76263F419C4595B9F688C0DD45A2F58178D37F4BFA03BF485D85AA\n    s66 = 0xA7A96CB96456F5A91DB03B430DF578AF977F6ABD89E4126E1CCC08B7\n\n    msg67 = 0xBB62A3CDC9A276156EA316F9B2224710AB35A23BEFE5E2C0C1835B4BBD4E1A91FF73D5442482C8CE19DED1C88999187DD369FC9F56BF4791A7C850927090F43F6BA092CAA01A7AA8D4F9FB367689881115CBDBB18E8632923E755F9F2A9DC71514485111AA2D48AE1A8A258951850706677A2F37A50888BDB23DF8E8C99532F9\n    r67 = 0xE92DC7F00699078E5DF2A77AD630E5AA49E54DC7723826E2BBF174D4\n    s67 = 0xBA09D6DFA3287C280CAE0D6482A36C5BBDBE4F60E80E9DD86A8EB685\n\n    msg68 = 0x698E81344C797C92BBAF6D3C6DDF344D379B2036DFD7561A341A1B5E0450FC24A3198FA256FBBB394F96E3D34DDCF148E10541AE3F048BF931D72F07B2CC289E83BB195E271552794A603B6AD087F26422CE2B2CEE80E0BD78B7B8A874059A8A01B35B3F4113160C31302F20C103B0E980A40D4D562952DEFB5A713E2183A979\n    r68 = 0x958CADFBF3BD03AE51701EB69365CA64D2D6AD620A3BDE4BD9FCE0EB\n    s68 = 0x80C3655C742F372C5162979839BF35F660ABDC52C6415E1C320FF204\n\n    msg69 = 0x85FD8580DE5605F8569A41D11A53115ABBB0D228CA9E5C992725F8392495765FEE802665A58826897B8511E4554B07FE0E48930E9B7349AC622B0805E0807E687E971C215120A34EBE6E9C134BBFC4302AD8BAA2FDF4F70BA1788549D7E5F717995CA31A7C32D6C9EB9103927FEB24E874E0EAD79818C422B1985428E98EE0C1\n    r69 = 0xCC4E52755299819099619FA4EC7BDA3D9A05EA001BB52E04F3835912\n    s69 = 0x2B809FB7A3260B6756AFD0F23A3626BD20D9D96A194EA70A99F61BE2\n\n    msg70 = 0xFEFE7D84406988E58A370770897CA87ECDDB1593BCE17358A8837C86D3BCA694F9D621DB81794A64170A5AAE23E6FCAFF487672ED5A2851FD9FFFE8ACDA0EFE5E62A57862B9D05350AEB3642014D57A60E4A26C3A18DBF515C4D7886AE544F4E4C5CFB7A8D0BF91A4A08BB95F4E26D5286ACDF1DEE3B41E1A5E49125B84F3EC5\n    r70 = 0xD36FB3D8C67486A2091C8AC6CF1BC28A29F8CCDABE99B5A1F074BEBF\n    s70 = 0x385F7A0EA55C01714D2A5BB2F5B07334AE24B2B1E91F0FF91C657639\n","variant":"hybrid","set":"holdout"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P384_SHA384.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P384_SHA384 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA384 as ECDSA\nimport Common::utils(BVtoZ)\n\nproperty checkSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\n\/**\n * Test vector for ECDSA with curve P-384 and SHA-384 as the hash.\n * [RFC6979] Appendix A.2.6.\n * ```repl\n * :prove sampleVector\n * ```\n *\/\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0x6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\n    k = BVtoZ 0x94ED910D1A099DAD3254E9242AE85ABDE4BA15168EAF0CA87A555FD56D10FBCA2907E3E83BA95368623B8C4686915CF9\n    expected_r = BVtoZ 0x94EDBB92A5ECB8AAD4736E56C691916B3F88140666CE9FA73D64C4EA95AD133C81A648152E44ACF96E36DD1E80FABE46\n    expected_s = BVtoZ 0x99EF4AEB15F178CEA1FE40DB2603138F130E740A19624526203B6351D0A3A94FA329C145786E679E7B82C71A38628AC8\n\n\/**\n * Test vector for ECDSA with curve P-384 and SHA-384 as the hash.\n * [RFC6979] Appendix A.2.6.\n * ```repl\n * :prove testVector\n * ```\n *\/\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0x6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\n    k = BVtoZ 0x015EE46A5BF88773ED9123A5AB0807962D193719503C527B031B4C2D225092ADA71F4A459BC0DA98ADB95837DB8312EA\n    expected_r = BVtoZ 0x8203B63D3C853E8D77227FB377BCF7B7B772E97892A80F36AB775D509D7A5FEB0542A7F0812998DA8F1DD3CA3CF023DB\n    expected_s = BVtoZ 0xDDD0760448D42D8A43AF45AF836FCE4DE8BE06B485E9B61B827C2F13173923E06A739F040649A667BF3B828246BAA5A5\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P521_SHA512.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P521_SHA512 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA512 as ECDSA\nimport Common::utils(BVtoZ)\n\ncheckSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\n\/**\n * Test vector for ECDSA with curve P-521 and SHA-512 as the hash.\n * [RFC6979] Appendix A.2.7.\n * ```repl\n * :prove sampleVector\n * ```\n *\/\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0x0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\n    k = BVtoZ 0x1DAE2EA071F8110DC26882D4D5EAE0621A3256FC8847FB9022E2B7D28E6F10198B1574FDD03A9053C08A1854A168AA5A57470EC97DD5CE090124EF52A2F7ECBFFD3\n    expected_r = BVtoZ 0x0C328FAFCBD79DD77850370C46325D987CB525569FB63C5D3BC53950E6D4C5F174E25A1EE9017B5D450606ADD152B534931D7D4E8455CC91F9B15BF05EC36E377FA\n    expected_s = BVtoZ 0x0617CCE7CF5064806C467F678D3B4080D6F1CC50AF26CA209417308281B68AF282623EAA63E5B5C0723D8B8C37FF0777B1A20F8CCB1DCCC43997F1EE0E44DA4A67A\n\n\/**\n * Test vector for ECDSA with curve P-521 and SHA-512 as the hash.\n * [RFC6979] Appendix A.2.7.\n * ```repl\n * :prove testVector\n * ```\n *\/\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0x0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\n    k = BVtoZ 0x16200813020EC986863BEDFC1B121F605C1215645018AEA1A7B215A564DE9EB1B38A67AA1128B80CE391C4FB71187654AAA3431027BFC7F395766CA988C964DC56D\n    expected_r = BVtoZ 0x13E99020ABF5CEE7525D16B69B229652AB6BDF2AFFCAEF38773B4B7D08725F10CDB93482FDCC54EDCEE91ECA4166B2A7C6265EF0CE2BD7051B7CEF945BABD47EE6D\n    expected_s = BVtoZ 0x1FBD0013C674AA79CB39849527916CE301C66EA7CE8B80682786AD60F98F7E78A19CA69EFF5C57400E3B3A0AD66CE0978214D13BAF4E9AC60752F7B155E2DE4DCE3\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P256_SHA256.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P256_SHA256 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA256 as ECDSA\nimport Common::utils(BVtoZ)\n\nproperty checkSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\n\/**\n * Test vector for ECDSA with curve P-256 and SHA-256 as the hash.\n * [RFC6979] Appendix A.2.5.\n * ```repl\n * :prove sampleVector\n * ```\n *\/\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0xC9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\n    k = BVtoZ 0xA6E3C57DD01ABE90086538398355DD4C3B17AA873382B0F24D6129493D8AAD60\n    expected_r = BVtoZ 0xEFD48B2AACB6A8FD1140DD9CD45E81D69D2C877B56AAF991C34D0EA84EAF3716\n    expected_s = BVtoZ 0xF7CB1C942D657C41D436C7A1B6E29F65F3E900DBB9AFF4064DC4AB2F843ACDA8\n\n\/**\n * Test vector for ECDSA with curve P-256 and SHA-256 as the hash.\n * [RFC6979] Appendix A.2.5.\n * ```repl\n * :prove testVector\n * ```\n *\/\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0xC9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\n    k = BVtoZ 0xD16B6AE827F17175E040871A1C7EC3500192C4C92677336EC2537ACAEE0008E0\n    expected_r = BVtoZ 0xF1ABB023518351CD71D881567B1EA663ED3EFCF6C5132B354F28D3B0B7D38367\n    expected_s = BVtoZ 0x019F4113742A2B14BD25926B49C649155F267E60D3814B4C0CC84250E46F0083\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P521_SHA3_512.cry","filetype":"cry","content":"\/*\n * Instantiate ECDSA with curve P-521 (also known as secp521p1) and SHA3-512.\n *\n * Note that this uses `UnconstrainedSpec` because the security strength of the hash\n * function is less than that of the elliptic curve! The overall security strength\n * of this ECDSA instantiation is approximately 256 bits.\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512 =\n    Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec {\n        EC = Common::EC::PrimeField::Instantiations::P521,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P384_SHA3_384.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA3_384 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P384,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P224_SHA224.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA224 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P224,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA224\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P224_SHA3_224.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA3_224 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P224,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P384_SHA384.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA384 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P384,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA384\n    }\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P521_SHA512.cry","filetype":"cry","content":"\/*\n * Instantiate ECDSA with curve P-521 (also known as secp521p1) and SHA512.\n *\n * Note that this uses `UnconstrainedSpec` because the security strength of the hash\n * function is less than that of the elliptic curve! The overall security strength\n * of this ECDSA instantiation is approximately 256 bits.\n *\n * @copyright Galois, Inc.\n * @author Eric Mertens <emertens@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA512 =\n    Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec {\n        EC = Common::EC::PrimeField::Instantiations::P521,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA512\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P256_SHA256.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA256 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P256,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA256\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P256_SHA3_256.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA3_256 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P256,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/ParameterSets\/XMSS_SHA2_10_256_Parameters.cry","filetype":"cry","content":"\/**\n * Definition of the approved parameter set used to instantiate\n * `XMSS_SHA2_10_256`.\n * [RFC-8391] Section 5.1.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_Parameters\nwhere\n    import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n    type n = 32\n    type h = 10\n\n    H KEY M = split (SHA256::hash ((1 : [32 * 8]) # join (KEY # M)))\n\n    \/\/ The maximum message width is defined by SHA256.\n    type MessageUpperBound = SHA256::MessageUpperBound\n\n    \/\/ The padding in this instantiation includes the domain separator (32\n    \/\/ bytes) and the key (3n bytes).\n    type PaddingWidth = (32 * 8) + (3 * n * 8)\n\n    \/\/ The OID as specified in [RFC-8391] Section 8.\n    oid = 0x00000001\n\n    H_msg KEY M = split (SHA256::hash ((2 : [32 * 8]) # join (KEY # M)))\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/ParameterSets\/XMSS_SHA2_10_256_FFI_Parameters.cry","filetype":"cry","content":"\/**\n * Definition of the approved parameter set used to instantiate\n * `XMSS_SHA2_10_256_FFI`.\n * [RFC-8391] Section 5.1.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_FFI_Parameters\nwhere\n    \/\/ Use the FFI version of SHA256.\n    import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI as SHA256\n\n    type n = 32\n    type h = 10\n\n    H KEY M = SHA256::hashBytes (split (1 : [32 * 8]) # KEY # M)\n\n    \/\/ The maximum message width is defined by SHA256.\n    type MessageUpperBound = SHA256::MessageUpperBound\n\n    \/\/ The padding in this instantiation includes the domain separator (32\n    \/\/ bytes) and the key (3n bytes).\n    type PaddingWidth = (32 * 8) + (3 * n * 8)\n\n    \/\/ The OID as specified in [RFC-8391] Section 8.\n    oid = 0x00000001\n\n    H_msg KEY M = SHA256::hashBytes (split (2 : [32 * 8]) # KEY # M)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Instantiations\/XMSS_SHA2_10_256.cry","filetype":"cry","content":"\/**\n * Instantiation of XMSS with the approved parameter set `XMSS_SHA2_10_256`.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256 =\n    Primitive::Asymmetric::Signature::XMSS::Specification {\n        Parameters = Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_Parameters,\n        WOTS = Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256\n\n    }\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Instantiations\/XMSS_SHA2_10_256_FFI.cry","filetype":"cry","content":"\/**\n * Instantiation of XMSS with the approved parameter set `XMSS_SHA2_10_256_FFI`.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256_FFI =\n    Primitive::Asymmetric::Signature::XMSS::Specification {\n        Parameters = Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_FFI_Parameters,\n        WOTS = Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256_FFI\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Instantiations\/WOTSP_SHA2_256.cry","filetype":"cry","content":"\/**\n * An instantiation of the WOTS+ one-time signature scheme.\n *\n * These parameters and naming are drawn from [SP-800-208], Section 5 (Table 9\n * and Section 5.1). The same parameters are also defined in [RFC-8391]\n * Section 5.1 (SHA2 with `n = 32`).\n *\n * References:\n * [SP-800-208]: David A. Cooper, Daniel C. Apon, Quynh H. Dang, Michael S.\n *     Davidson, Morris J. Dworkin, and Carl A. Miller. Recommendation for\n *     Stateful Hash-Based Signature Schemes. (National Institute of Standards\n *     and Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST\n *     SP 800-208. October 2020.\n *     @see https:\/\/doi.org\/10.6028\/NIST.SP.800-208\n * [RFC-8391]: Andreas Huelsing, Denis Butin, Stefan-Lukas Gazdag, Joost\n *     Rijneveld, and Aziz Mohaisen. XMSS: eXtended Merkle Signature Scheme.\n *     Internet Requests for Comments (RFC) 8391. May 2018.\n *     @see https:\/\/datatracker.ietf.org\/doc\/rfc8391\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256 =\n    Primitive::Asymmetric::Signature::WOTS::Specification where\n        import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n        type n' = 32\n        type w' = 16\n\n        F' KEY M = SHA256::hashBytes ((zero : [32][8]) # KEY # M)\n        PRF' KEY M = SHA256::hashBytes ((zero : [31][8]) # [(3 : [8])] # KEY # M)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/SphincsPlus\/3.1\/sphincsplus128f.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author Marios Georgiou <marios@galois.com>\n *\/\nmodule sphincsplus128f=specification where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\n\ntype n = 16\ntype h = 66\ntype d = 22\ntype a = 6\ntype k = 33\ntype loglogw = 2\ntype m = (k*logt+7)\/8 + (h-h\/d+7)\/8 + (h\/d+7)\/8\ntype t = 2^^a\ntype logt = a\n\nH_msg(R, PKseed, PKroot, M) =\n    groupBy(take(shake256(join R # join PKseed # join PKroot # join M)))\nPRF(Seed, ADRS) =\n    groupBy(take(shake256(join Seed # join ADRS)))\nPRF_msg(SKprf, OptRand, M) =\n    groupBy(take(shake256(join SKprf # join OptRand # join M)))\nT(PKseed, ADRS, M) =\n    groupBy(take(shake256(join PKseed # join ADRS # join M)))\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/FALCON\/1.2\/falcon_parameterized.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc.\n * @author Marios Georgiou <marios@galois.com>\n *\/\nmodule falcon_parameterized where\n\nparameter\n    type _k : #\n    type _n : #\n    type constraint (fin _k, _n == 2^^_k, _k > 0)\n    type pkbytelen : #\n    type sbytelen : #\n    type constraint (fin sbytelen)\n    type coeffs_number_of_bits : #\n    sigma : Float64\n    type Q = Rational\n    type C = (Float64,Float64)\n    Omega_phi: [_n]C\n    type constraint (8 * sbytelen >= 328)\n\n\ntype slen = 8 * sbytelen - 328\ntype q = 3 * 2^^12 + 1\n\ntype Byte = [8]Bit\ntype ZZ = Integer\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nCMul : (C, C) -> C\nCMul(x, y) = (x.0*y.0-x.1*y.1, x.0*y.1+x.1*y.0)\n\nCAdd : (C, C) -> C\nCAdd(x, y) = (x.0 + x.1, y.0 + y.1)\n\nCAddList : {n} (fin n) => [n]C -> C\nCAddList(l) = sums ! 0\n    where sums = [zero] # [CAdd(el,sums') | el <- l\n                                          | sums' <- sums\n                          ]\n\nCinv : C -> C\nCinv((a,b)) = (a\/.denominator, -(b\/.denominator)) where\n    denominator = a^^2 + b^^2\n\nConjugate : C -> C\nConjugate((x, y)) = (x, -y)\n\nPolyConj : {k, n} (ispoweroftwo k n) => Poly n C -> Poly n C\nPolyConj(f) = map Conjugate f\n\nNormalize_FFT : {k, n} (ispoweroftwo k n) => (Float64, Poly n C) -> Poly n C\nNormalize_FFT(_q, F) = dot(F, [Cinv(_q,0) | i <- [0 .. (n-1)]])\n\ntype constraint ispoweroftwo a b = (fin a, b == 2^^a)\n\ntype constraint positive_power a = (fin a, a > 0, (2*(2^^(a-1)*a)+2^^a == 2^^a*(1+a)), 2 ^^ a == 2 * 2 ^^ (a - 1))\n\n\/\/ helper function for recursive functions. Will be removed\n\/\/ when Cryptol is updated.\nresize : {m,n,a} (fin m, fin n, Zero a) => [m]a -> [n]a\nresize xs = take`{n} (xs # repeat`{inf} zero)\n\n\n\nFFT : {k, n} (ispoweroftwo k n) => Poly n C -> FFT n\nFFT(x) | k == 0 => x\n       | k >  0 => resize(join([result0,result1])) where\n            even = [x@(2*i  ) | i <- [0 .. (2^^(k-1)-1)]]\n            odd =  [x@(2*i+1) | i <- [0 .. (2^^(k-1)-1)]]\n            left = FFT`{k-1}(even)\n            right = FFT`{k-1}(odd)\n            X = join([left,right])\n            result0 = [X@i + CMul(Omega_phi@(`n*i),(X@(i+`n\/2))) | i <- [0 .. (n\/2-1)]]\n            result1 = [X@i - CMul(Omega_phi@(`n*i),(X@(i+`n\/2))) | i <- [0 .. (n\/2-1)]]\n\nFFTInv  : {k, n} (ispoweroftwo k n) => (FFT n) -> (Poly n C)\nFFTInv(x) = zero\n\n\nFFT' : {k, n} (ispoweroftwo k n) => Poly n ZZ -> FFT n\nFFT'(x) = FFT`{k}(map IntToCmplx x : (Poly n C))\n\nFFT'' : {k, n} (ispoweroftwo k n) => Poly n (Z q) -> FFT n\nFFT''(x) = FFT'`{k}(map fromZ x)\n\n\/\/ Number Theoretic Transform\nNTT : {k, n} (ispoweroftwo k n) => Poly n (Z q) -> Poly n (Z q)\nNTT(f) = zero\n\nNTTInv : {k, n} (ispoweroftwo k n) => Poly n (Z q) -> Poly n (Z q)\nNTTInv(f) = zero\n\nModInv : Z q -> Z q\nModInv(f) =  1\/. f\n\nphi : {k, n} (ispoweroftwo k n) => Poly (n+1) (Z q)\nphi = [1]#zero#[1]\n\nIntToCmplx : ZZ -> C\nIntToCmplx(x) = ((fromInteger x),zero)\n\ndot : {n} (fin n) => (FFT n, FFT n) -> FFT n\ndot(f,g) = [CMul(fi,gi) | fi <- f | gi <- g]\n\nHadamardDivision : {n} (fin n) => (FFT n, FFT n) -> FFT n\nHadamardDivision(f,g) = dot(f, (map Cinv g))\n\nPolyMul : {k, n} (ispoweroftwo k n) => ((Poly n C), (Poly n C)) -> (Poly n C)\nPolyMul(f,g) = FFTInv`{k}(dot(FFT`{k}(f), FFT`{k}(g)))\n\nPolyInv : {k, n} (ispoweroftwo k n) => (Poly n C) -> (Poly n C)\nPolyInv(f) = FFTInv`{k}(map Cinv (FFT`{k}(f)))\n\nPolyMulInZ : {k, n} (ispoweroftwo k n) => ((Poly n ZZ), (Poly n ZZ)) -> (Poly n ZZ)\nPolyMulInZ(f, g) = zero PolyDivInZ : {k, n} (ispoweroftwo k n) => ((Poly n ZZ), (Poly n ZZ)) -> (Poly n Q)\nPolyDivInZ(f, g) = zero innerProduct : {k, n} (ispoweroftwo k n) => ((Poly n C), (Poly n C)) -> C\ninnerProduct(f, g) = zero norm_sq : {k, n} (ispoweroftwo k n) => (Poly n C) -> Float64\nnorm_sq(f) = zero splitfft : {k, n} (ispoweroftwo k n, n > 2) => (FFT n) -> [2](FFT (n\/2))\nsplitfft FFTf = [resize(FFTf0), resize(FFTf1)] where\n    FFTf0 = [FFTf@(2*i  ) | i <- [0 .. (2^^(k-1)-1)]]\n    FFTf1 = [FFTf@(2*i+1) | i <- [0 .. (2^^(k-1)-1)]]\n\nmergefft : {k, n} (ispoweroftwo k n, n>=2) => [2](FFT (n\/2)) -> (FFT n)\nmergefft ([f0, f1]) = resize FFTf where\n    FFTf = join[[f0@i,f1@i] | i <- [0 .. (2^^(k-1)-1)]]\n\ntype Poly degree a = [degree]a\n\ntype FFT degree = Poly degree C\ntype NTT degree = Poly degree (Z q)\n\n\/\/ public key types\ntype publicKey = Poly _n (Z q)\ntype encodedPublicKey = [14 * _n \/^ 8 + 1]Byte\n\n\/\/ private key types\ntype privateKey = ([2][2](FFT _n), falconTree _k)\ntype encodedPrivateKey = [2*((_n+1)*coeffs_number_of_bits) + ((_n+1)*8)]Bit\n\ntype falconTree k = [2^^k*(1+k)]C\n\ngetValue : {k, n} (ispoweroftwo k n) => falconTree k -> Poly n C\ngetValue T = take`{n} T\n\n\/\/ getChildren: {k, n} (ispoweroftwo k n, positive_power k) => falconTree k -> (falconTree (k-1), falconTree (k-1))\n\/\/ getChildren T = children where\n\/\/     children = split`{2,2^^(k-1)*k} (drop`{n} T)\n\nget_leftchild : {k, n} (ispoweroftwo k n, k > 0) => falconTree k -> falconTree (k-1)\nget_leftchild T = left where\n    children = resize (drop`{n} T): [2*2^^(k-1)*k]C\n    [left, right] = split`{2,2^^(k-1)*k} children\n\nget_rightchild : {k, n} (ispoweroftwo k n, k > 0) => falconTree k -> falconTree (k-1)\nget_rightchild T = right where\n    children = resize (drop`{n} T): [2*2^^(k-1)*k]C\n    [left, right] = split`{2,2^^(k-1)*k} children\n\nnewTree : {k, n} (ispoweroftwo k n, k >= 1) => (Poly n C, falconTree (k-1), falconTree (k-1)) -> falconTree k\nnewTree(value, leftchild, rightchild) = T where\n    T = zero\n\n\/\/ The leaves contain real numbers\n\/\/ For consistency their type is C\nnewLeaf : C -> falconTree 0\nnewLeaf sigma_leaf = [sigma_leaf]\n\nget_leaves : {k, n} (ispoweroftwo k n) => falconTree k -> [2^^k]C\nget_leaves T | k == 0 => T\n             | k >  0 => resize leaves where\n                left_child = get_leftchild`{k} T : falconTree (k-1)\n                right_child = get_rightchild`{k} T : falconTree (k-1)\n                left_leaves  = get_leaves`{k-1} left_child : [2^^(k-1)]C\n                right_leaves  = get_leaves`{k-1} right_child : [2^^(k-1)]C\n                leaves = left_leaves # right_leaves : [2*2^^(k-1)]C\n\nset_leaves : {k, n} (ispoweroftwo k n) => (falconTree k, [2^^k]C) -> falconTree k\nset_leaves(T, leaves) | k == 0 => leaves\n                      | k >  0 => newTree`{k}(value, newleftchild, newrightchild) where\n                        value = getValue`{k} T\n                        leftchild = get_leftchild`{k} T\n                        rightchild = get_rightchild`{k} T\n                        [leftleaves, rightleaves] = split`{2,2^^(k-1)} (resize leaves)\n                        newleftchild = set_leaves`{k-1}(leftchild, leftleaves)\n                        newrightchild = set_leaves`{k-1}(rightchild, rightleaves)\n\nCompress : Poly _n ZZ -> [slen]\nCompress s = zero\n\nDecompress : [slen] -> Poly _n ZZ\nDecompress str = zero\n\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\nHashToPoint : {q', k, n, len} (q' <= 2^^16, q' >= 1, ispoweroftwo k n, fin len) => [len] -> Poly n (Z q')\nHashToPoint str = [c i | i <- [0..(n-1)]] where\n    k = 2^^16 \/ `q\n    c i = fromInteger(t i % `q)\n    t i = zero \/\/ phi and q are fixed so we do not parameterize this algorithm\n\/\/ f and g cannot be sampled in Cryptol so we take them as input\nKeygen : (Poly _n ZZ, Poly _n ZZ) -> (privateKey, publicKey)\nKeygen (f', g') = (sk, pk) where\n    (f, g, F, G) = NTRUGen(f', g'): (Poly _n ZZ, Poly _n ZZ, Poly _n ZZ, Poly _n ZZ)\n    B = [[map IntToCmplx g,map IntToCmplx (-f)],[map IntToCmplx G,map IntToCmplx (-F)]] : [2][2](Poly _n C)\n    Bhat = [[FFT'`{_k}(g),FFT'`{_k}(-f)],[FFT'`{_k}(G),FFT'`{_k}(-F)]] : [2][2](FFT _n)\n    GG = B * Bhat\n    T = ffLDL`{_k}(GG)\n    leaves = get_leaves`{_k} T\n    new_leaves = [(sigma\/.r_leaf,0) | (r_leaf, _) <- leaves]\n    T' = set_leaves`{_k}(T, new_leaves)\n    sk = (Bhat, T')\n    h = NTTInv`{_k}(NTT`{_k}(map fromInteger g)*(map ModInv (NTT`{_k}(map fromInteger f))))\n    pk = h\n\nN : {k, n} (ispoweroftwo k n, k > 0) => (Poly n ZZ) -> (Poly (2^^(k-1)) ZZ)\nN(f) = zero\n\nxSquared : {k, n} (ispoweroftwo k n) => (Poly n ZZ) -> (Poly (2^^(k+1)) ZZ)\nxSquared(F) = resize (join[[c,0] | c <- F])\n\nminusx : {k, n} (ispoweroftwo k n) => (Poly n ZZ) -> (Poly n ZZ)\nminusx(g) = resize (join[ [g@i, -(g@(i+1))] | i <- [0, 2 .. (n-1)]])\n\n\/\/ phi and q are fixed so we do not parameterize this algorithm\n\/\/ f and g cannot be sampled in Cryptol so we take them as input\n\/\/ We assume they pass conditions in lines 7 and 9\nNTRUGen : (Poly _n ZZ, Poly _n ZZ) -> (Poly _n ZZ, Poly _n ZZ, Poly _n ZZ, Poly _n ZZ)\nNTRUGen(f, g) = (f, g, F, G) where\n    (F, G) = NTRUSolve`{_k}(f, g)\n\nNTRUSolve : {k, n} (ispoweroftwo k n) => (Poly n ZZ, Poly n ZZ) -> (Poly n ZZ, Poly n ZZ)\nNTRUSolve(f, g) | k == 0 => ([F], [G]) where\n                                (gcd, u, v) = eGCD(f@0, g@0)\n                                (F, G) = (u*`q, v*`q)\n                | k >  0 => (_F, _G) where\n                                f' = N`{k}(f)\n                                g' = N`{k}(g)\n                                (F', G') = NTRUSolve`{k-1}(f',g')\n                                F = PolyMulInZ`{k}(xSquared`{k-1}(F'), minusx`{k}(g))\n                                G = PolyMulInZ`{k}(xSquared`{k-1}(G'), minusx`{k}(f))\n                                (_F, _G) = Reduce`{k}(f,g,F,G)\n\neGCD : (ZZ, ZZ) -> (ZZ, ZZ, ZZ)\neGCD(a, b) =\n    if a == 0\n    then (b, 0, 1)\n    else (g, t - (b \/ a) * s, s) where\n        (g, s, t) = eGCD((b%a), a)\n\nReduce : {k, n} (ispoweroftwo k n) => (Poly n ZZ, Poly n ZZ, Poly n ZZ, Poly n ZZ) -> (Poly n ZZ, Poly n ZZ)\nReduce(f,g,F,G) = (_F, _G) where\n    numerator = PolyMulInZ`{k}(F, adjoint`{k}(f)) + PolyMulInZ`{k}(G, adjoint`{k}(g))\n    denominator = PolyMulInZ`{k}(f, adjoint`{k}(f)) + PolyMulInZ`{k}(g, adjoint`{k}(g))\n    _k = map roundToEven (PolyDivInZ`{k}(numerator, denominator)): Poly n ZZ\n    F' = F - PolyMulInZ`{k}(_k,f)\n    G' = G - PolyMulInZ`{k}(_k, g)\n    (_F, _G, _) = Reduce'`{k}(_k,f,g,F',G')\n\nadjoint : {k, n} (ispoweroftwo k n) => (Poly n ZZ) -> (Poly n ZZ)\nadjoint(f) = reverse f\n\nReduce' : {k, n} (ispoweroftwo k n) => (Poly n ZZ, Poly n ZZ, Poly n ZZ, Poly n ZZ, Poly n ZZ) -> (Poly n ZZ, Poly n ZZ, Poly n ZZ)\nReduce'(_k,f,g,F,G) =\n    if _k == zero\n    then (F, G, _k)\n    else Reduce'`{k}(_k', f, g, F', G') where\n        numerator = PolyMulInZ`{k}(F, adjoint`{k}(f)) + PolyMulInZ`{k}(G, adjoint`{k}(g))\n        denominator = PolyMulInZ`{k}(f, adjoint`{k}(f)) + PolyMulInZ`{k}(g, adjoint`{k}(g))\n        _k' = map roundToEven (PolyDivInZ`{k}(numerator, denominator)): Poly n ZZ\n        F' = F - PolyMulInZ`{k}(_k',f)\n        G' = G - PolyMulInZ`{k}(_k', g)\n\none : {k, n} (ispoweroftwo k n) => FFT n\none = [(1.0,0.0) | i <- [0 .. (n-1)]]\n\nLDL : {k, n} (ispoweroftwo k n) => [2][2](FFT n) -> (([2][2](FFT n)), ([2][2](FFT n)))\nLDL(G) = (L, D) where\n    D00 = G@0@0\n    L10 = HadamardDivision(G@1@0,G@0@0): FFT n\n    D11 = G@1@1 - dot(L10,dot(PolyConj`{k}(L10),G@0@0))\n    L = [[one`{k}, zero],[L10, one`{k}]]\n    D = [[D00, zero],[zero, D11]]\n\nffLDL : {k, n} (ispoweroftwo k n, n >= 2) => ([2][2](FFT n)) -> (falconTree k)\nffLDL(G) | k == 1 => T where\n            (L, D) = LDL`{k}(G) : ([2][2](FFT n), [2][2](FFT n))\n            left_child = D@0@0 : FFT 2\n            left_leaf = newLeaf(left_child@0)             right_child = D@1@1 : FFT 2\n            right_leaf = newLeaf(right_child@0)             T = newTree`{k}(L@1@0, left_leaf, right_leaf)\n         | k >  1 => T where\n            (L, D) = LDL`{k}(G) : ([2][2](FFT n), [2][2](FFT n))\n            [d00, d01] = splitfft`{k}(D@0@0)\n            [d10, d11] = splitfft`{k}(D@1@1)\n            G0 = [[resize d00,resize d01],[resize d01, resize d00]]             G1 = [[resize d10,resize d11],[resize d11, resize d10]]\n            Tleftchild = ffLDL`{k-1}(G0)\n            Trightchild = ffLDL`{k-1}(G1)\n            T = newTree`{k}(L@1@0, Tleftchild, Trightchild)\n\n\ntype signature = ([320], [slen])\nSign : {len} (fin len) => ([len], privateKey, Integer, [320]) -> signature\nSign(m, sk, beta, r) = zero where\n    (Bhat, T) = sk\n    c = HashToPoint`{q,_k}(r#m)\n    [[FFTg,FFT_f],[FFTG,FFT_F]] = Bhat \/\/ Bhat stores them in FFT representation (some are negated)\n    t0 = Normalize_FFT`{_k}(`q, dot(FFT''`{_k,_n}(c),FFT_F))\n    t1 = Normalize_FFT`{_k}(`q, dot(FFT''`{_k,_n}(c),FFT_F))\n    tt = [t0, t1] : [2](FFT _n)\n    s_init : [slen]\n    s_init = zero\n    is_bot : [slen] -> Bit\n    is_bot(_s) = (_s == zero)\n    body' : [slen] -> [slen]\n    body'(_s) = zero where\n        ss_init = zero : FFT _n\n        norm_greater_than_beta : FFT _n -> Bit\n        norm_greater_than_beta(_ss) = norm_sq`{_k}(_ss) > (fromInteger beta)\n        body'' : FFT _n -> FFT _n\n        body''(_ss) = zero where\n            zz = ffSampling`{_k}(tt, T) : [2](FFT _n)\n            \/\/ _ss' = [ dot`{_n}((tt_ - zz_),Bhat_) | tt_ <- tt | zz_ <- zz | Bhat_ <- Bhat]\n        _ss_final = dowhile norm_greater_than_beta body'' ss_init\n    s_final = dowhile is_bot body' s_init\n\n\n\nffSampling : {k, n} (ispoweroftwo k n) => ([2](FFT n), falconTree k) -> [2](FFT n)\nffSampling(t, T) = z where\n    [t0, t1] = t\n    z = [z0, z1]\n    z0 = zero\n    z1 = zero\n\nRCDT = [\n    3024686241123004913666,\n    1564742784480091954050,\n    636254429462080897535,\n    199560484645026482916,\n    47667343854657281903,\n    8595902006365044063,\n    1163297957344668388,\n    117656387352093658,\n    8867391802663976,\n    496969357462633,\n    20680885154299,\n    638331848991,\n    14602316184,\n    247426747,\n    3104126,\n    28824,\n    198,\n    1,\n    0\n] : [19][72]\n\nBaseSampler : [72] -> ZZ\nBaseSampler(u) = z0 where\n    z0 = zero\n\nimport Float\nApproxExp : (Float64, Float64) -> [64]\nApproxExp(x, ccs) = y'' where\n    C = [\n            0x00000004741183A3,\n            0x00000036548CFC06,\n            0x0000024FDCBF140A,\n            0x0000171D939DE045,\n            0x0000D00CF58F6F84,\n            0x000680681CF796E3,\n            0x002D82D8305B0FEA,\n            0x011111110E066FD0,\n            0x0555555555070F00,\n            0x155555555581FF00,\n            0x400000000002B400,\n            0x7FFFFFFFFFFF4800,\n            0x8000000000000000\n        ]\n    y = C@0\n    z = fromInteger (floor(2^^63 * x))\n    y' = foldl (\\yy -> \\u -> C@u - (z*y)>>63) y [1 .. 12]\n    z' = fromInteger (floor(2^^63 * ccs))\n    y'' = (z'*y')>>63\n\nBerExp : (Float64, Float64) -> Bit\nBerExp(x, ccs) = w < 0 where\n    ln2 = 0.69314718056\n    s = x \/. ln2\n    r = floor(x - s * ln2)\n    s' = min(s, 63)\n        w = zero\n\nSamplerZ : (Float64, Float64) -> ZZ\nSamplerZ(m, sigma') = z where\n    z = zero\n\nVerify : {len} (fin len) => ([len], signature, publicKey, Integer) -> Bit\nVerify(m, sig, pk, beta) = norm^^2 <= beta where\n    norm = zero\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/FALCON\/1.2\/falcon_512.cry","filetype":"cry","content":"\/**\n * @copyright Galois, Inc\n * @author Marios Georgiou <marios@galois.com>\n *\/\nmodule falcon_512 where\n\nsubmodule falcon_inst = spec2\n    where\n    type _k = 9\n    type _n = 512\n    type pkbytelen = 897\n    type sbytelen = 666\n    type coeffs_number_of_bits = 6\n    type q = 3 * 2^^12 + 1\n    r = 3\n    sigma = 165.736617183\n    sigma_min = 1.277833697\n    sigma_max = 1.8205\n    beta = 34034726\n\n    Omega_phi = [\n        (1, 0),\n        (0.9999247018391445, 0.012271538285719925),\n        (0.9996988186962042, 0.024541228522912288),\n        (0.9993223845883495, 0.03680722294135883),\n        (0.9987954562051724, 0.049067674327418015),\n        (0.9981181129001492, 0.06132073630220858),\n        (0.9972904566786902, 0.07356456359966743),\n        (0.996312612182778, 0.0857973123444399),\n        (0.9951847266721969, 0.0980171403295606),\n        (0.9939069700023561, 0.11022220729388306),\n        (0.99247953459871, 0.1224106751992162),\n        (0.99090263542778, 0.13458070850712617),\n        (0.989176509964781, 0.14673047445536175),\n        (0.9873014181578584, 0.15885814333386145),\n        (0.9852776423889412, 0.17096188876030122),\n        (0.9831054874312163, 0.18303988795514095),\n        (0.9807852804032304, 0.19509032201612825),\n        (0.9783173707196277, 0.20711137619221856),\n        (0.9757021300385286, 0.2191012401568698),\n        (0.9729399522055602, 0.2310581082806711),\n        (0.970031253194544, 0.24298017990326387),\n        (0.9669764710448521, 0.25486565960451457),\n        (0.9637760657954398, 0.26671275747489837),\n        (0.9604305194155658, 0.27851968938505306),\n        (0.9569403357322088, 0.29028467725446233),\n        (0.9533060403541939, 0.3020059493192281),\n        (0.9495281805930367, 0.3136817403988915),\n        (0.9456073253805213, 0.3253102921622629),\n        (0.9415440651830208, 0.33688985339222005),\n        (0.937339011912575, 0.34841868024943456),\n        (0.932992798834739, 0.3598950365349881),\n        (0.9285060804732156, 0.37131719395183754),\n        (0.9238795325112867, 0.3826834323650898),\n        (0.9191138516900578, 0.3939920400610481),\n        (0.9142097557035307, 0.40524131400498986),\n        (0.9091679830905224, 0.41642956009763715),\n        (0.9039892931234433, 0.4275550934302821),\n        (0.8986744656939538, 0.43861623853852766),\n        (0.8932243011955153, 0.44961132965460654),\n        (0.8876396204028539, 0.46053871095824),\n        (0.881921264348355, 0.47139673682599764),\n        (0.8760700941954066, 0.4821837720791227),\n        (0.8700869911087115, 0.49289819222978404),\n        (0.8639728561215867, 0.5035383837257176),\n        (0.8577286100002721, 0.5141027441932217),\n        (0.8513551931052652, 0.524589682678469),\n        (0.8448535652497071, 0.5349976198870972),\n        (0.838224705554838, 0.5453249884220465),\n        (0.8314696123025452, 0.5555702330196022),\n        (0.8245893027850253, 0.5657318107836131),\n        (0.8175848131515837, 0.5758081914178453),\n        (0.8104571982525948, 0.5857978574564389),\n        (0.8032075314806449, 0.5956993044924334),\n        (0.7958369046088836, 0.6055110414043255),\n        (0.7883464276266063, 0.6152315905806268),\n        (0.7807372285720945, 0.6248594881423863),\n        (0.773010453362737, 0.6343932841636455),\n        (0.765167265622459, 0.6438315428897914),\n        (0.7572088465064846, 0.6531728429537768),\n        (0.7491363945234594, 0.6624157775901718),\n        (0.7409511253549592, 0.6715589548470183),\n        (0.7326542716724128, 0.680600997795453),\n        (0.724247082951467, 0.6895405447370668),\n        (0.7157308252838186, 0.6983762494089729),\n        (0.7071067811865476, 0.7071067811865475),\n        (0.6983762494089729, 0.7157308252838186),\n        (0.6895405447370669, 0.7242470829514669),\n        (0.6806009977954531, 0.7326542716724127),\n        (0.6715589548470184, 0.740951125354959),\n        (0.6624157775901718, 0.7491363945234593),\n        (0.6531728429537769, 0.7572088465064845),\n        (0.6438315428897915, 0.7651672656224588),\n        (0.6343932841636456, 0.7730104533627369),\n        (0.6248594881423865, 0.7807372285720944),\n        (0.6152315905806269, 0.7883464276266062),\n        (0.6055110414043255, 0.7958369046088835),\n        (0.5956993044924335, 0.8032075314806448),\n        (0.5857978574564389, 0.8104571982525948),\n        (0.5758081914178454, 0.8175848131515837),\n        (0.5657318107836132, 0.8245893027850253),\n        (0.5555702330196023, 0.8314696123025451),\n        (0.5453249884220466, 0.838224705554838),\n        (0.5349976198870974, 0.844853565249707),\n        (0.524589682678469, 0.8513551931052652),\n        (0.5141027441932218, 0.8577286100002721),\n        (0.5035383837257176, 0.8639728561215867),\n        (0.49289819222978415, 0.8700869911087113),\n        (0.4821837720791229, 0.8760700941954065),\n        (0.4713967368259978, 0.8819212643483549),\n        (0.46053871095824, 0.8876396204028539),\n        (0.4496113296546066, 0.8932243011955153),\n        (0.4386162385385277, 0.8986744656939538),\n        (0.4275550934302822, 0.9039892931234433),\n        (0.4164295600976373, 0.9091679830905224),\n        (0.4052413140049898, 0.9142097557035307),\n        (0.3939920400610481, 0.9191138516900578),\n        (0.38268343236508984, 0.9238795325112867),\n        (0.3713171939518376, 0.9285060804732155),\n        (0.3598950365349883, 0.9329927988347388),\n        (0.3484186802494345, 0.937339011912575),\n        (0.33688985339222005, 0.9415440651830208),\n        (0.325310292162263, 0.9456073253805213),\n        (0.3136817403988915, 0.9495281805930367),\n        (0.3020059493192282, 0.9533060403541938),\n        (0.2902846772544623, 0.9569403357322089),\n        (0.27851968938505306, 0.9604305194155658),\n        (0.2667127574748984, 0.9637760657954398),\n        (0.2548656596045146, 0.9669764710448521),\n        (0.24298017990326398, 0.970031253194544),\n        (0.23105810828067125, 0.9729399522055601),\n        (0.21910124015686977, 0.9757021300385286),\n        (0.20711137619221856, 0.9783173707196277),\n        (0.1950903220161283, 0.9807852804032304),\n        (0.18303988795514103, 0.9831054874312163),\n        (0.17096188876030136, 0.9852776423889412),\n        (0.1588581433338614, 0.9873014181578584),\n        (0.14673047445536175, 0.989176509964781),\n        (0.13458070850712622, 0.99090263542778),\n        (0.12241067519921628, 0.99247953459871),\n        (0.11022220729388318, 0.9939069700023561),\n        (0.09801714032956077, 0.9951847266721968),\n        (0.08579731234443988, 0.996312612182778),\n        (0.07356456359966745, 0.9972904566786902),\n        (0.061320736302208655, 0.9981181129001492),\n        (0.04906767432741813, 0.9987954562051724),\n        (0.03680722294135899, 0.9993223845883495),\n        (0.024541228522912267, 0.9996988186962042),\n        (0.012271538285719944, 0.9999247018391445),\n        (6.123233995736766e-17, 1.0),\n        (-0.012271538285719823, 0.9999247018391445),\n        (-0.024541228522912142, 0.9996988186962042),\n        (-0.036807222941358866, 0.9993223845883495),\n        (-0.04906767432741801, 0.9987954562051724),\n        (-0.06132073630220853, 0.9981181129001492),\n        (-0.07356456359966734, 0.9972904566786902),\n        (-0.08579731234443977, 0.996312612182778),\n        (-0.09801714032956066, 0.9951847266721969),\n        (-0.11022220729388307, 0.9939069700023561),\n        (-0.12241067519921617, 0.99247953459871),\n        (-0.1345807085071261, 0.99090263542778),\n        (-0.14673047445536164, 0.989176509964781),\n        (-0.15885814333386128, 0.9873014181578584),\n        (-0.17096188876030124, 0.9852776423889412),\n        (-0.18303988795514095, 0.9831054874312163),\n        (-0.1950903220161282, 0.9807852804032304),\n        (-0.20711137619221845, 0.9783173707196277),\n        (-0.21910124015686966, 0.9757021300385286),\n        (-0.23105810828067117, 0.9729399522055602),\n        (-0.24298017990326387, 0.970031253194544),\n        (-0.2548656596045145, 0.9669764710448521),\n        (-0.2667127574748983, 0.9637760657954398),\n        (-0.27851968938505295, 0.9604305194155659),\n        (-0.2902846772544622, 0.9569403357322089),\n        (-0.3020059493192281, 0.9533060403541939),\n        (-0.31368174039889146, 0.9495281805930367),\n        (-0.32531029216226287, 0.9456073253805214),\n        (-0.33688985339221994, 0.9415440651830208),\n        (-0.3484186802494344, 0.937339011912575),\n        (-0.35989503653498817, 0.9329927988347388),\n        (-0.37131719395183754, 0.9285060804732156),\n        (-0.3826834323650897, 0.9238795325112867),\n        (-0.393992040061048, 0.9191138516900578),\n        (-0.40524131400498975, 0.9142097557035307),\n        (-0.416429560097637, 0.9091679830905225),\n        (-0.42755509343028186, 0.9039892931234434),\n        (-0.4386162385385274, 0.8986744656939539),\n        (-0.4496113296546067, 0.8932243011955152),\n        (-0.4605387109582401, 0.8876396204028539),\n        (-0.4713967368259977, 0.881921264348355),\n        (-0.4821837720791227, 0.8760700941954066),\n        (-0.4928981922297839, 0.8700869911087115),\n        (-0.5035383837257175, 0.8639728561215868),\n        (-0.5141027441932216, 0.8577286100002721),\n        (-0.5245896826784687, 0.8513551931052652),\n        (-0.5349976198870969, 0.8448535652497072),\n        (-0.5453249884220461, 0.8382247055548382),\n        (-0.555570233019602, 0.8314696123025455),\n        (-0.5657318107836132, 0.8245893027850253),\n        (-0.5758081914178453, 0.8175848131515837),\n        (-0.5857978574564389, 0.8104571982525948),\n        (-0.5956993044924332, 0.8032075314806449),\n        (-0.6055110414043254, 0.7958369046088836),\n        (-0.6152315905806267, 0.7883464276266063),\n        (-0.6248594881423862, 0.7807372285720946),\n        (-0.6343932841636453, 0.7730104533627371),\n        (-0.6438315428897913, 0.7651672656224591),\n        (-0.6531728429537765, 0.7572088465064848),\n        (-0.6624157775901718, 0.7491363945234593),\n        (-0.6715589548470184, 0.740951125354959),\n        (-0.680600997795453, 0.7326542716724128),\n        (-0.6895405447370668, 0.724247082951467),\n        (-0.6983762494089728, 0.7157308252838187),\n        (-0.7071067811865475, 0.7071067811865476),\n        (-0.7157308252838186, 0.6983762494089729),\n        (-0.7242470829514669, 0.689540544737067),\n        (-0.7326542716724127, 0.6806009977954532),\n        (-0.7409511253549589, 0.6715589548470186),\n        (-0.749136394523459, 0.662415777590172),\n        (-0.7572088465064847, 0.6531728429537766),\n        (-0.765167265622459, 0.6438315428897914),\n        (-0.773010453362737, 0.6343932841636455),\n        (-0.7807372285720945, 0.6248594881423863),\n        (-0.7883464276266062, 0.6152315905806269),\n        (-0.7958369046088835, 0.6055110414043255),\n        (-0.8032075314806448, 0.5956993044924335),\n        (-0.8104571982525947, 0.585797857456439),\n        (-0.8175848131515836, 0.5758081914178454),\n        (-0.8245893027850251, 0.5657318107836135),\n        (-0.8314696123025453, 0.5555702330196022),\n        (-0.8382247055548381, 0.5453249884220464),\n        (-0.8448535652497071, 0.5349976198870972),\n        (-0.8513551931052652, 0.524589682678469),\n        (-0.8577286100002721, 0.5141027441932218),\n        (-0.8639728561215867, 0.5035383837257176),\n        (-0.8700869911087113, 0.49289819222978415),\n        (-0.8760700941954065, 0.4821837720791229),\n        (-0.8819212643483549, 0.4713967368259978),\n        (-0.8876396204028538, 0.4605387109582402),\n        (-0.8932243011955152, 0.4496113296546069),\n        (-0.8986744656939539, 0.43861623853852755),\n        (-0.9039892931234433, 0.42755509343028203),\n        (-0.9091679830905224, 0.41642956009763715),\n        (-0.9142097557035307, 0.40524131400498986),\n        (-0.9191138516900578, 0.39399204006104815),\n        (-0.9238795325112867, 0.38268343236508984),\n        (-0.9285060804732155, 0.37131719395183765),\n        (-0.9329927988347388, 0.35989503653498833),\n        (-0.9373390119125748, 0.3484186802494348),\n        (-0.9415440651830207, 0.3368898533922203),\n        (-0.9456073253805213, 0.3253102921622632),\n        (-0.9495281805930367, 0.3136817403988914),\n        (-0.9533060403541939, 0.30200594931922803),\n        (-0.9569403357322088, 0.29028467725446233),\n        (-0.9604305194155658, 0.2785196893850531),\n        (-0.9637760657954398, 0.2667127574748985),\n        (-0.9669764710448521, 0.2548656596045147),\n        (-0.970031253194544, 0.24298017990326404),\n        (-0.9729399522055601, 0.2310581082806713),\n        (-0.9757021300385285, 0.21910124015687002),\n        (-0.9783173707196275, 0.20711137619221884),\n        (-0.9807852804032304, 0.19509032201612858),\n        (-0.9831054874312164, 0.1830398879551409),\n        (-0.9852776423889412, 0.1709618887603012),\n        (-0.9873014181578584, 0.15885814333386145),\n        (-0.989176509964781, 0.1467304744553618),\n        (-0.99090263542778, 0.13458070850712628),\n        (-0.99247953459871, 0.12241067519921635),\n        (-0.9939069700023561, 0.11022220729388325),\n        (-0.9951847266721968, 0.09801714032956084),\n        (-0.996312612182778, 0.08579731234444016),\n        (-0.9972904566786902, 0.07356456359966775),\n        (-0.9981181129001492, 0.061320736302208495),\n        (-0.9987954562051724, 0.04906767432741797),\n        (-0.9993223845883495, 0.03680722294135883),\n        (-0.9996988186962042, 0.024541228522912326),\n        (-0.9999247018391445, 0.012271538285720007),\n        (-1.0, 1.2246467991473532e-16),\n        (-0.9999247018391445, -0.01227153828571976),\n        (-0.9996988186962042, -0.024541228522912083),\n        (-0.9993223845883495, -0.03680722294135858),\n        (-0.9987954562051724, -0.049067674327417724),\n        (-0.9981181129001492, -0.061320736302208245),\n        (-0.9972904566786902, -0.0735645635996675),\n        (-0.996312612182778, -0.08579731234443992),\n        (-0.9951847266721969, -0.09801714032956059),\n        (-0.9939069700023561, -0.110222207293883),\n        (-0.99247953459871, -0.1224106751992161),\n        (-0.99090263542778, -0.13458070850712606),\n        (-0.989176509964781, -0.14673047445536158),\n        (-0.9873014181578584, -0.15885814333386122),\n        (-0.9852776423889413, -0.17096188876030097),\n        (-0.9831054874312164, -0.18303988795514067),\n        (-0.9807852804032304, -0.19509032201612836),\n        (-0.9783173707196277, -0.20711137619221862),\n        (-0.9757021300385286, -0.21910124015686983),\n        (-0.9729399522055602, -0.2310581082806711),\n        (-0.970031253194544, -0.24298017990326382),\n        (-0.9669764710448522, -0.25486565960451446),\n        (-0.96377606579544, -0.26671275747489825),\n        (-0.9604305194155659, -0.2785196893850529),\n        (-0.9569403357322089, -0.29028467725446216),\n        (-0.953306040354194, -0.3020059493192278),\n        (-0.9495281805930368, -0.3136817403988912),\n        (-0.9456073253805213, -0.32531029216226304),\n        (-0.9415440651830208, -0.3368898533922201),\n        (-0.937339011912575, -0.34841868024943456),\n        (-0.932992798834739, -0.3598950365349881),\n        (-0.9285060804732156, -0.3713171939518375),\n        (-0.9238795325112867, -0.38268343236508967),\n        (-0.9191138516900578, -0.39399204006104793),\n        (-0.9142097557035307, -0.4052413140049897),\n        (-0.9091679830905225, -0.41642956009763693),\n        (-0.9039892931234434, -0.4275550934302818),\n        (-0.898674465693954, -0.4386162385385273),\n        (-0.8932243011955153, -0.44961132965460665),\n        (-0.8876396204028539, -0.46053871095824006),\n        (-0.881921264348355, -0.47139673682599764),\n        (-0.8760700941954066, -0.4821837720791227),\n        (-0.8700869911087115, -0.4928981922297839),\n        (-0.8639728561215868, -0.5035383837257175),\n        (-0.8577286100002721, -0.5141027441932216),\n        (-0.8513551931052652, -0.5245896826784687),\n        (-0.8448535652497072, -0.5349976198870969),\n        (-0.8382247055548382, -0.5453249884220461),\n        (-0.8314696123025455, -0.555570233019602),\n        (-0.8245893027850253, -0.5657318107836132),\n        (-0.8175848131515837, -0.5758081914178453),\n        (-0.8104571982525948, -0.5857978574564389),\n        (-0.8032075314806449, -0.5956993044924332),\n        (-0.7958369046088836, -0.6055110414043254),\n        (-0.7883464276266063, -0.6152315905806267),\n        (-0.7807372285720946, -0.6248594881423862),\n        (-0.7730104533627371, -0.6343932841636453),\n        (-0.7651672656224591, -0.6438315428897913),\n        (-0.7572088465064848, -0.6531728429537765),\n        (-0.7491363945234593, -0.6624157775901718),\n        (-0.740951125354959, -0.6715589548470184),\n        (-0.7326542716724128, -0.680600997795453),\n        (-0.724247082951467, -0.6895405447370668),\n        (-0.7157308252838187, -0.6983762494089728),\n        (-0.7071067811865477, -0.7071067811865475),\n        (-0.698376249408973, -0.7157308252838185),\n        (-0.6895405447370672, -0.7242470829514667),\n        (-0.6806009977954532, -0.7326542716724126),\n        (-0.6715589548470187, -0.7409511253549588),\n        (-0.6624157775901721, -0.749136394523459),\n        (-0.6531728429537771, -0.7572088465064842),\n        (-0.6438315428897915, -0.7651672656224588),\n        (-0.6343932841636459, -0.7730104533627367),\n        (-0.6248594881423865, -0.7807372285720944),\n        (-0.6152315905806274, -0.7883464276266059),\n        (-0.6055110414043257, -0.7958369046088833),\n        (-0.5956993044924332, -0.803207531480645),\n        (-0.5857978574564391, -0.8104571982525947),\n        (-0.5758081914178452, -0.8175848131515837),\n        (-0.5657318107836136, -0.8245893027850251),\n        (-0.5555702330196022, -0.8314696123025452),\n        (-0.5453249884220468, -0.8382247055548377),\n        (-0.5349976198870973, -0.8448535652497071),\n        (-0.5245896826784694, -0.8513551931052649),\n        (-0.5141027441932219, -0.857728610000272),\n        (-0.5035383837257181, -0.8639728561215865),\n        (-0.49289819222978426, -0.8700869911087113),\n        (-0.4821837720791226, -0.8760700941954067),\n        (-0.47139673682599786, -0.8819212643483549),\n        (-0.4605387109582399, -0.887639620402854),\n        (-0.44961132965460693, -0.8932243011955152),\n        (-0.4386162385385276, -0.8986744656939538),\n        (-0.4275550934302825, -0.9039892931234431),\n        (-0.4164295600976372, -0.9091679830905224),\n        (-0.40524131400499036, -0.9142097557035305),\n        (-0.3939920400610482, -0.9191138516900577),\n        (-0.38268343236509034, -0.9238795325112865),\n        (-0.3713171939518377, -0.9285060804732155),\n        (-0.35989503653498794, -0.932992798834739),\n        (-0.34841868024943484, -0.9373390119125748),\n        (-0.33688985339221994, -0.9415440651830208),\n        (-0.32531029216226326, -0.9456073253805212),\n        (-0.31368174039889146, -0.9495281805930367),\n        (-0.3020059493192285, -0.9533060403541938),\n        (-0.2902846772544624, -0.9569403357322088),\n        (-0.2785196893850536, -0.9604305194155657),\n        (-0.26671275747489853, -0.9637760657954398),\n        (-0.2548656596045143, -0.9669764710448522),\n        (-0.24298017990326412, -0.970031253194544),\n        (-0.23105810828067097, -0.9729399522055602),\n        (-0.2191012401568701, -0.9757021300385285),\n        (-0.20711137619221848, -0.9783173707196277),\n        (-0.19509032201612866, -0.9807852804032303),\n        (-0.18303988795514098, -0.9831054874312163),\n        (-0.17096188876030172, -0.9852776423889411),\n        (-0.15885814333386153, -0.9873014181578583),\n        (-0.14673047445536233, -0.9891765099647809),\n        (-0.13458070850712636, -0.99090263542778),\n        (-0.12241067519921596, -0.9924795345987101),\n        (-0.11022220729388331, -0.9939069700023561),\n        (-0.09801714032956045, -0.9951847266721969),\n        (-0.08579731234444021, -0.996312612182778),\n        (-0.07356456359966736, -0.9972904566786902),\n        (-0.06132073630220899, -0.9981181129001492),\n        (-0.04906767432741803, -0.9987954562051724),\n        (-0.03680722294135933, -0.9993223845883494),\n        (-0.02454122852291239, -0.9996988186962042),\n        (-0.012271538285720512, -0.9999247018391445),\n        (-1.8369701987210297e-16, -1.0),\n        (0.012271538285720144, -0.9999247018391445),\n        (0.02454122852291202, -0.9996988186962042),\n        (0.03680722294135897, -0.9993223845883495),\n        (0.04906767432741767, -0.9987954562051724),\n        (0.061320736302208634, -0.9981181129001492),\n        (0.073564563599667, -0.9972904566786902),\n        (0.08579731234443987, -0.996312612182778),\n        (0.09801714032956009, -0.9951847266721969),\n        (0.11022220729388295, -0.9939069700023561),\n        (0.1224106751992156, -0.9924795345987101),\n        (0.13458070850712597, -0.99090263542778),\n        (0.14673047445536194, -0.9891765099647809),\n        (0.15885814333386114, -0.9873014181578584),\n        (0.17096188876030133, -0.9852776423889412),\n        (0.1830398879551406, -0.9831054874312164),\n        (0.19509032201612828, -0.9807852804032304),\n        (0.2071113761922181, -0.9783173707196278),\n        (0.21910124015686974, -0.9757021300385286),\n        (0.23105810828067058, -0.9729399522055603),\n        (0.24298017990326376, -0.970031253194544),\n        (0.25486565960451396, -0.9669764710448523),\n        (0.2667127574748982, -0.96377606579544),\n        (0.2785196893850533, -0.9604305194155658),\n        (0.2902846772544621, -0.9569403357322089),\n        (0.3020059493192282, -0.9533060403541938),\n        (0.31368174039889113, -0.9495281805930368),\n        (0.325310292162263, -0.9456073253805213),\n        (0.3368898533922196, -0.9415440651830209),\n        (0.3484186802494345, -0.937339011912575),\n        (0.35989503653498767, -0.9329927988347391),\n        (0.37131719395183743, -0.9285060804732156),\n        (0.38268343236509, -0.9238795325112866),\n        (0.39399204006104793, -0.9191138516900579),\n        (0.40524131400499, -0.9142097557035306),\n        (0.4164295600976369, -0.9091679830905225),\n        (0.4275550934302822, -0.9039892931234433),\n        (0.43861623853852727, -0.898674465693954),\n        (0.4496113296546066, -0.8932243011955153),\n        (0.4605387109582396, -0.8876396204028542),\n        (0.4713967368259976, -0.881921264348355),\n        (0.4821837720791222, -0.8760700941954069),\n        (0.49289819222978387, -0.8700869911087115),\n        (0.5035383837257177, -0.8639728561215867),\n        (0.5141027441932214, -0.8577286100002722),\n        (0.524589682678469, -0.8513551931052651),\n        (0.5349976198870969, -0.8448535652497073),\n        (0.5453249884220465, -0.838224705554838),\n        (0.5555702330196018, -0.8314696123025456),\n        (0.5657318107836131, -0.8245893027850253),\n        (0.5758081914178449, -0.817584813151584),\n        (0.5857978574564388, -0.8104571982525949),\n        (0.5956993044924328, -0.8032075314806453),\n        (0.6055110414043253, -0.7958369046088837),\n        (0.6152315905806269, -0.7883464276266061),\n        (0.6248594881423861, -0.7807372285720947),\n        (0.6343932841636456, -0.7730104533627369),\n        (0.6438315428897912, -0.7651672656224592),\n        (0.6531728429537768, -0.7572088465064846),\n        (0.6624157775901715, -0.7491363945234597),\n        (0.6715589548470183, -0.7409511253549592),\n        (0.6806009977954527, -0.7326542716724131),\n        (0.6895405447370668, -0.7242470829514671),\n        (0.6983762494089724, -0.715730825283819),\n        (0.7071067811865475, -0.7071067811865477),\n        (0.7157308252838188, -0.6983762494089727),\n        (0.7242470829514667, -0.6895405447370672),\n        (0.7326542716724129, -0.680600997795453),\n        (0.7409511253549588, -0.6715589548470187),\n        (0.7491363945234594, -0.6624157775901718),\n        (0.7572088465064842, -0.6531728429537771),\n        (0.7651672656224588, -0.6438315428897915),\n        (0.7730104533627367, -0.6343932841636459),\n        (0.7807372285720944, -0.6248594881423865),\n        (0.7883464276266059, -0.6152315905806274),\n        (0.7958369046088833, -0.6055110414043257),\n        (0.803207531480645, -0.5956993044924332),\n        (0.8104571982525947, -0.5857978574564391),\n        (0.8175848131515837, -0.5758081914178452),\n        (0.8245893027850251, -0.5657318107836136),\n        (0.8314696123025452, -0.5555702330196022),\n        (0.8382247055548377, -0.5453249884220468),\n        (0.8448535652497071, -0.5349976198870973),\n        (0.8513551931052649, -0.5245896826784694),\n        (0.857728610000272, -0.5141027441932219),\n        (0.8639728561215865, -0.5035383837257181),\n        (0.8700869911087113, -0.49289819222978426),\n        (0.8760700941954067, -0.4821837720791226),\n        (0.8819212643483549, -0.4713967368259979),\n        (0.887639620402854, -0.46053871095823995),\n        (0.8932243011955151, -0.449611329654607),\n        (0.8986744656939538, -0.43861623853852766),\n        (0.9039892931234431, -0.42755509343028253),\n        (0.9091679830905224, -0.41642956009763726),\n        (0.9142097557035305, -0.4052413140049904),\n        (0.9191138516900577, -0.39399204006104827),\n        (0.9238795325112865, -0.3826834323650904),\n        (0.9285060804732155, -0.37131719395183777),\n        (0.932992798834739, -0.359895036534988),\n        (0.9373390119125748, -0.3484186802494349),\n        (0.9415440651830208, -0.33688985339222),\n        (0.9456073253805212, -0.3253102921622633),\n        (0.9495281805930367, -0.3136817403988915),\n        (0.9533060403541936, -0.30200594931922853),\n        (0.9569403357322088, -0.29028467725446244),\n        (0.9604305194155657, -0.27851968938505367),\n        (0.9637760657954398, -0.2667127574748986),\n        (0.9669764710448522, -0.25486565960451435),\n        (0.970031253194544, -0.24298017990326418),\n        (0.9729399522055602, -0.23105810828067103),\n        (0.9757021300385285, -0.21910124015687016),\n        (0.9783173707196277, -0.20711137619221853),\n        (0.9807852804032303, -0.19509032201612872),\n        (0.9831054874312163, -0.18303988795514103),\n        (0.9852776423889411, -0.17096188876030177),\n        (0.9873014181578583, -0.15885814333386158),\n        (0.9891765099647809, -0.1467304744553624),\n        (0.99090263542778, -0.13458070850712642),\n        (0.99247953459871, -0.12241067519921603),\n        (0.9939069700023561, -0.11022220729388338),\n        (0.9951847266721969, -0.09801714032956052),\n        (0.996312612182778, -0.08579731234444028),\n        (0.9972904566786902, -0.07356456359966743),\n        (0.9981181129001492, -0.06132073630220905),\n        (0.9987954562051724, -0.04906767432741809),\n        (0.9993223845883494, -0.036807222941359394),\n        (0.9996988186962042, -0.02454122852291245),\n        (0.9999247018391445, -0.012271538285720572)\n    ]\n\nimport submodule falcon_inst\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Specification.cry","filetype":"cry","content":"\/**\n * ML-KEM key encapsulation mechanism for establishing a shared secret key\n * between two parties, with a fast NTT implementation.\n *\n * This implements the final version of ML-KEM as standardized in [FIPS-203].\n * The executable spec differs from the spec in several important ways:\n * - In the spec, two ML-KEM functions (`KeyGen` and `Encaps`) require the\n *   generation of randomness. In the exectable spec, this\n *   randomness is passed as input, because Cryptol cannot generate randomness.\n *   Implementors must manually verify that their functions generate randomness\n *   using an approved RBG with a suitable security strength for their chosen\n *   parameter set, and that the sampling of random values is performed by the\n *   cryptographic module.\n * - The spec requires that intermediate values must be destroyed prior to the\n *   termination of each algorithm, with two exceptions (see Section 3.3\n *   \"Destruction of intermediate values.\") Cryptol cannot express this\n *   requirement. Implementors must manually verify that intermediate data is\n *   destroyed as soon as it is no longer needed.\n *\n * The spec defines other requirements that cannot be verified by Cryptol!\n * For full details, see [FIPS-203] Section 3.3.\n * - K-PKE cannot be used as a stand-alone cryptographic scheme. This\n *   executable spec makes the K-PKE module private; implementors must manually\n *   verify that their own implementations do not make the K-PKE API public.\n * - The internal functions `KeyGen_internal`, `Encaps_internal`, and\n *   `Decaps_internal` must not be made available to other applications except\n *   for testing purposes. This executable spec makes the internal functions\n *   private; implementors must manually verify that the same is true in their\n *   implementations.\n * - The shared secret key generated by `Encaps` and `Decaps` can be used\n *   directly as a key for symmetric cryptography. If further key derivation is\n *   needed, it must be done using an approved technique. Cryptol cannot verify\n *   that the shared secret key is used in an appropriate way.\n * - As mentioned, randomness must be generated using an approved RBG, and a\n *   fresh string of random bytes must be generated for each invocation.\n *   Cryptol cannot verify either of these requirements.\n * - The input to `Encaps` and `Decaps` must be checked. Cryptol cannot verify\n *   that the input has been checked.\n * - As mentioned, intermediate values must be destroyeda fter use. Cryptol\n *   cannot verify that this has been done.\n *\n * @copyright Galois, Inc\n * @author Marios Georgiou <marios@galois.com>\n * @editor Marcella Hastings <marcella@galois.com>\n *\n * @copyright Amazon.com or its affiliates.\n * @author Rod Chapman <rodchap@amazon.com>\n *\n * Sources:\n * [FIPS-203]: National Institute of Standards and Technology. Module-Lattice-\n *     Based Key-Encapsulation Mechanism Standard. (Department of Commerce,\n *     Washington, D.C.), Federal Information Processing Standards Publication\n *     (FIPS) NIST FIPS 203. August 2024.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.203\n *\/\nmodule Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256 as SHAKE256\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128 as SHAKE128\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 as SHA3_256\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 as SHA3_512\n\nprivate\n    \/*\n     * [FIPS-203] Section 2.3.\n     *\/\n    type n = 256\n    \/*\n     * [FIPS-203] Section 2.3.\n     *\/\n    type q = 3329\n    \/**\n     * A primitive n-th root of unity modulo `q`.\n     * [FIPS-203] Section 2.3.\n     *\/\n    zeta = 17 : Z q\n\n\/**\n * Defines the set {0, 1, ..., 255} of unsigned 8-bit integers.\n * [FIPS-203] Section 2.3.\n *\/\ntype Byte = [8]\n\nprivate\n    \/**\n     * An element in the ring `R_q`.\n     *\n     * An element in the ring is a polynomial of degree at most 255 (e.g. with\n     * 256 terms). The `i`th element in this array represents the coefficient\n     * of the degree-`i` term.\n     *\n     * [FIPS-203] Section 2.3 (definition of the ring).\n     * [FIPS-203] Section 2.4.4, Equation 2.5 (definition of the representation\n     *     of elements in the ring).\n     *\/\n    type Rq = [n](Z q)\n\n    \/**\n     * An element in the ring `T_q`.\n     *\n     * An element in this ring (sometimes called the \"NTT representation\") is a\n     * tuple of 128 polynomials, each of degree at most one (e.g. with two\n     * terms). The `2i` and `2i+1`th terms in this array represent the degree-0\n     * and degree-1 coefficients of the `i`th polynomial, respectively.\n     *\n     * [FIPS-203] Section 2.3 (definition of the `T_q`).\n     * [FIPS-203] Section 2.4.4 Equation 2.7 (definition of the representation\n     *     of an element in `T_q`).\n     *\/\n    type Tq = [n](Z q)\n\n    \/**\n     * Pseudorandom function (PRF).\n     * [FIPS-203] Section 4.1, Equations 4.2 and 4.3.\n     *\/\n    PRF : {eta} (2 <= eta, eta <= 3) => [32]Byte -> Byte -> [64 * eta]Byte\n    PRF s b = SHAKE256::xofBytes`{8 * 64 * eta} (s # [b])\n\n    \/**\n     * One of the hash functions used in the protocol.\n     * [FIPS-203] Section 4.1, Equation 4.4.\n     *\/\n    H : {hinl} (fin hinl) => [hinl]Byte -> [32]Byte\n    H s = SHA3_256::hashBytes s\n\n    \/**\n     * One of the hash functions used in the protocol.\n     * [FIPS-203] Section 4.1, Equation 4.4.\n     *\/\n    J : {hinl} (fin hinl) => [hinl]Byte -> [32]Byte\n    J s = SHAKE256::xofBytes`{8 * 32} s\n\n    \/**\n     * One of the hash functions used in the protocol.\n     * [FIPS-203] Section 4.1, Equation 4.5.\n     *\/\n    G : {ginl} (fin ginl) => [ginl]Byte -> ([32]Byte, [32]Byte)\n    G c = (a, b) where\n        [a, b] = split (SHA3_512::hashBytes c)\n\n    \/**\n     * eXtendable-Output Function (XOF) wrapper.\n     * [FIPS-203] Section 4.1, Equation 4.6.\n     *\/\n    XOF : ([34]Byte) -> [inf]Byte\n    XOF = SHAKE128::xofBytes\n\n    \/**\n     * Conversion from little-endian bit arrays to byte arrays.\n     * [FIPS-203] Section 4.2.1, Algorithm 3.\n     *\/\n    BitsToBytes : {ell} (fin ell) => [8 * ell]Bit -> [ell]Byte\n    BitsToBytes b\n        | ell == 0 => zero\n        | ell > 0 => B where\n            \/\/ Group the bits into the B[\u230ai \/ 8\u230b] sets; pad them to support\n            \/\/ subsequent operations, and correlate each bit with its index `i`.\n            b' = groupBy`{8} [(zext [bi], i)\n                | bi <- b\n                | i <- [0..8 * ell - 1]]\n\n            \/\/ Steps 2-4.\n            B = [sum [bi * (2 ^^ (i % 8))\n                    | (bi, i) <- bi8]\n                | bi8 <- b']\n\n    \/**\n     * Conversion from byte arrays to bit arrays.\n     * [FIPS-203] Section 4.2.1, Algorithm 4.\n     *\/\n    BytesToBits : {ell} (fin ell) => [ell]Byte -> [ell*8]Bit\n    BytesToBits C\n        | ell == 0 => []\n        | ell > 0 => join [[ b8ij where\n                \/\/ Step 4. Taking the last bit is the same as modding by 2. (See\n                \/\/ `mod2IsFinalBit`).\n                b8ij = Ci' ! 0\n                \/\/ Step 5. Shifting right is the same as the iterative\n                \/\/ division (see `div2IsShiftR`). This accounts for all the\n                \/\/ divisions \"up to this point\" (e.g. none when `j = 0`), which\n                \/\/ is why we use `Ci'` to evaluate `b8ij` above.\n                Ci' = Ci >> j\n            \/\/ Step 3.\n            | j <- [0..7]]\n            \/\/ Step 2. We iterate over `C` directly instead of indexing into it.\n            | Ci <- C ]\n\n    \/**\n     * The iterative division by 2 in `BytesToBits` is the same as shifting\n     * right.\n     * ```repl\n     * :prove div2IsShiftR\n     * ```\n     *\/\n    div2IsShiftR : Byte -> Bit\n    div2IsShiftR C = take (d2 C) == shl where\n        \/\/ Note: division here is floor'd by default.\n        d2 c = [c] # d2 (c \/ 2)\n        shl = [C >> j | j <- [0..7]]\n\n    \/**\n     * The conversions between bits and bytes are each others' inverses.\n     * [FIPS-203] Section 4.2.1 (see description on Algorithm 4).\n     * The sample `ell` values here are a subset of the possible values in the\n     * spec.\n     * ```repl\n     * :prove B2B2BInverts`{32}\n     * :prove B2B2BInverts`{192}\n     * :prove B2B2BInverts`{384}\n     * ```\n     *\/\n    B2B2BInverts : {ell} (fin ell, ell > 0) => [ell * 8] -> Bit\n    B2B2BInverts bits = bitsWorks && bytesWorks where\n        bitsWorks = BytesToBits (BitsToBytes bits) == bits\n        bytesWorks = BitsToBytes (BytesToBits (split bits)) == split bits\n\n    \/**\n     * Check the example given in the spec for converting between bits and\n     * bytes.\n     * [FIPS-203] Section 4.2.1 \"Converting between bits and bytes.\"\n     * ```repl\n     * :prove B2BExampleWorks\n     * ```\n     *\/\n    B2BExampleWorks = BitsToBytes 0b11010001 == [139]\n\n    \/**\n     * In Cryptol, rounding is computed via the built-in function `roundAway`.\n     * [FIPS-203] Section 2.3.\n     *\/\n    property roundingWorks y = y >= 0 ==> roundUpWorks && roundDownWorks where\n        y' = fromInteger y\n        roundUpWorks = roundAway (y' + 0.5) == (y + 1)\n        roundDownWorks = roundAway (y' + 0.4) == y\n\n    \/**\n     * Compress an integer mod `q` into an integer mod `2^d`.\n     * [FIPS-203] Section 4.2.1, Equation 4.7.\n     *\/\n    Compress : {d} (d < width q) => Z q -> [d]\n    Compress x = y where\n        \/\/ Convert from an integer mod `q` to a rational number.\n        x' = fromInteger (fromZ x) : Rational\n        \/\/ Compress. Note that `\/.` denotes division of rationals.\n        y' = roundAway (((2^^`d) \/. `q) * x')\n        \/\/ mod 2^^d (by converting from an integer to a d-bit vector).\n        y = (fromInteger y') : [d]\n\n    \/**\n     * Decompress an integer mod `2^d` into an integer mod `q`.\n     * [FIPS-203] Section 4.2.1, Equation 4.8.\n     *\/\n    Decompress : {d} (d < width q) => [d] -> Z q\n    Decompress y = x where\n        \/\/ Convert from a d-length bit vector to a rational number.\n        y' = fromInteger (toInteger y) : Rational\n        \/\/ Decompress! As before, `\/.` is division of rationals.\n        x' = roundAway((`q \/. (2^^`d)) * y')\n        \/\/ Convert from an integer to an integer mod `q`.\n        x = (fromInteger x') : Z q\n\n    \/**\n     * Compression inverts decompression for all inputs and bit lengths.\n     * We'll prove it for the bit lengths found in the\n     * ```repl\n     * :prove CompressInvertsDecompress`{1}\n     * :exhaust CompressInvertsDecompress`{d_u}\n     * :exhaust CompressInvertsDecompress`{d_v}\n     * ```\n     *\/\n    CompressInvertsDecompress : {d} (d < width q) => [d] -> Bit\n    property CompressInvertsDecompress y = Compress (Decompress y) == y\n\n    \/**\n     * When `d` is large, compression followed by decompression must not\n     * significantly alter the value.\n     * This sets `d = d_u`, which is the largest value for `d` used in the\n     * spec.\n     * [FIPS-203] Section 4.2.1, \"Compression and Decompression\".\n     * ```repl\n     * :exhaust DecompressMostlyInvertsCompress\n     * ```\n     *\/\n    DecompressMostlyInvertsCompress : Z q -> Bit\n    property DecompressMostlyInvertsCompress x = errIsSmallEnough where\n        x' = Decompress`{d_u} (Compress`{d_u} x)\n        err = abs (modpm (x' - x))\n        errIsSmallEnough = err <= B_q`{d_u}\n\n        \/\/ The spec doesn't describe formally what \"not significantly altered\"\n        \/\/ means; we use this equation.\n        B_q : {d} (d < lg2 q) => Integer\n        B_q = roundAway((`q\/.(2^^(`d+1))))\n\n        \/\/ Convert an integer mod `q` to a representation centered around 0\n        \/\/ (and represented as an `Integer`).\n        modpm : Z q -> Integer\n        modpm r = if r' > (`q \/ 2) then r' - `q else r'\n            where r' = fromZ r\n\n    \/**\n     * Compression applied to a vector is equivalent to applying compression to\n     * each individual element.\n     * [FIPS-203] Section 2.4.8, Equation 2.15.\n     *\/\n    Compress_Vec : {d} (d < lg2 q) => [n](Z q) -> [n][d]\n    Compress_Vec x = map Compress`{d} x\n\n    \/**\n     * Decompression applied to a vector is equivalent to applying\n     * decompression to each individual element.\n     * [FIPS-203] Section 2.4.8.\n     *\/\n    Decompress_Vec : {d} (d < lg2 q) => [n][d] -> [n](Z q)\n    Decompress_Vec x = map Decompress`{d} x\n\n    \/**\n     * Compression applied to a matrix is equivalent to applying compression\n     * to each individual element.\n     * [FIPS-203] Section 2.4.8.\n     *\/\n    Compress_Mat : {d, k1} (d < lg2 q, fin k1) => [k1][n](Z q) -> [k1][n][d]\n    Compress_Mat x = map Compress_Vec`{d} x\n\n    \/**\n     * Decompression applied to a matrix is equivalent to applying\n     * decompression to each individual element.\n     * [FIPS-203] Section 2.4.8.\n     *\/\n    Decompress_Mat : {d, k1} (d < lg2 q, fin k1) => [k1][n][d] -> [k1][n](Z q)\n    Decompress_Mat x = map Decompress_Vec`{d} x\n\n    \/**\n     * Encode an array of `d`-bit integers into a byte array, for `d < 12`.\n     * [FIPS-203] Section 4.2.1 Algorithm 5.\n     *\n     * Note: In this implementation, we treat the `d < 12` case separately from\n     * `d == 12` because it allows us to better express the different integer\n     * types. For `d < 12`, we use the bit vector type.\n     * See `ByteEncode12` for the `d = 12` case.\n     *\/\n    ByteEncode : {d} (1 <= d, d < 12) => [256][d] -> [32 * d]Byte\n    ByteEncode F = B where\n        \/\/ Step 1-3, 5.\n        \/\/ We iterate over `F` directly, instead of indexing into it with `i`.\n        \/\/ In a bit vector, iteratively subtracting the last bit and dividing\n        \/\/ by 2 is the same as bit-shifting to the right (see\n        \/\/ `subAndDivIsShift`).\n        as = [[ a >> j | j <- [0..d-1]] | a <- F]\n        \/\/ Step 4. In a bit vector, taking the value `% 2` is the same as taking\n        \/\/ the final bit. See `mod2IsFinalBit`.\n        b = join [ [ a ! 0 | a <- ajs] | ajs <- as]\n        \/\/ Step 8.\n        B = BitsToBytes b\n\n    \/**\n     * Encode `k` vectors of `d`-bit integers into a byte array.\n     * [FIPS-203] Section 2.4.8.\n     *\/\n    ByteEncode_Vec : {d} (fin d, 1 <= d, d < 12) => [k][256][d] -> [k * 32 * d]Byte\n    ByteEncode_Vec F_vec = join (map ByteEncode F_vec)\n\n    \/**\n     * Encode an array of integers mod `q` into a byte array.\n     * [FIPS-203] Section 4.2.1 Algorithm 5.\n     *\n     * Note: In this implementation, we treat the `d < 12` case separately from\n     * `d == 12` because it allows us to better express the different integer\n     * types. For `d == 12`, we use the integers-mod (`Z`) type.\n     * See `ByteEncode` for the `d < 12` case.\n     *\/\n    ByteEncode12 : [256](Z q) -> [32 * 12]Byte\n    ByteEncode12 F = B where\n        type d = 12\n\n        \/\/ We need to explicitly convert from integers mod `q` to 12-bit\n        \/\/ vectors.\n        toBitVec : Z q -> [d]\n        toBitVec f = fromInteger (fromZ f)\n        F' = map toBitVec F\n\n        \/\/ The following is the same as in `ByteEncode`. See notes above.\n        as = [[ a >> j | j <- [0..d-1]] | a <- F' ]\n        b = join [ [ a ! 0 | a <- ajs] | ajs <- as]\n        B = BitsToBytes b\n\n    \/**\n     * Encode a set of `k` vectors of integers mod `q` into a byte array.\n     * [FIPS-203] Section 2.4.8.\n     *\/\n    ByteEncode12_Vec : [k][256](Z q) -> [k * 32 * 12]Byte\n    ByteEncode12_Vec F_vec = join (map ByteEncode12 F_vec)\n\n    \/**\n     * The subtract-and-divide algorithm applied to `a` in `ByteEncode` is the\n     * same as shifting right.\n     *\n     * This is in reference to [FIPS-203] Section 4.2.1 Algorithm 5, Step 4-5.\n     * That algorithm converts an integer repesentation `a` into a bitwise\n     * representation `b`, and needs to iteratively update `a` to discard each\n     * bit that it has already retrieved for `b`.\n     *\n     * Note: The type constraint for `d` does not allow `1` because `% 2` is\n     * not a legal operation on 1-bit vectors (since 2 cannot be represented\n     * as a 1-bit vector). It remains true, though (with a result of 0).\n     *\n     * These tests use the values of `d` that are actually used in the\n     * algorithm. `d_u` and `d_v` are functor parameters for this module.\n     * ```repl\n     * :prove subAndDivIsShiftR`{d_u}\n     * :prove subAndDivIsShiftR`{d_v}\n     * :prove subAndDivIsShiftR`{12}\n     * ```\n     *\/\n    subAndDivIsShiftR : {d} (fin d, d > 1) => [d] -> Bit\n    property subAndDivIsShiftR a = take (sad a) == shift a where\n        \/\/ Recursive definition of Step 4-5 (step 4 is inline here)\n        sad x = [x] # sad ((x - (x % 2)) \/ 2)\n        shift x = [x >> i | i <- [0..d-1]]\n\n    \/**\n     * Computing a bit vector mod 2 is the same as taking its final (least\n     * significant) bit.\n     *\n     * This is in reference to [FIPS-203] Section 4.2.1 Algorithm 5, Step 4.\n     * That algorithm converts the integer representation of `a` into a bitwise\n     * representation `b` and uses `mod` to iteratively get bits out of `a`.\n     *\n     * Note: The type constraint for `d` does not allow `1` because `% 2` is\n     * not a legal operation on 1-bit vectors (since 2 cannot be represented\n     * as a 1-bit vector.) It's trivially true, though.\n     *\n     * These tests use the values of `d` that are actually used in the\n     * algorithm. `d_u` and `d_v` are functor parameters for this module.\n     * ```repl\n     * :prove mod2IsFinalBit`{d_u}\n     * :prove mod2IsFinalBit`{d_v}\n     * :prove mod2IsFinalBit`{12}\n     * ```\n     *\/\n    mod2IsFinalBit : {d} (fin d, d > 1) => [d] -> Bit\n    property mod2IsFinalBit a = a % 2 == zext [a ! 0]\n\n    \/**\n     * Decode a byte array into an array of `d`-bit integers, for `d < 12`.\n     * [FIPS-203] Section 4.2.1 Algorithm 6.\n     *\n     * Note: In this implementation, we treat the `d < 12` case separately from\n     * `d == 12` because it allows us to better express the different integer\n     * types. For `d < 12`, we use the bit vector type.\n     * See `ByteDecode12` for the `d = 12` case.\n     *\/\n    ByteDecode : {d} (1 <= d, d < 12) => [32 * d]Byte -> [256][d]\n    ByteDecode B = F where\n        \/\/ Step 1.\n        b = BytesToBits B\n        \/\/ Steps 2-4.\n        \/\/ - In FIPS 203, these operations are taken `mod m`, where `m = 2^d`.\n        \/\/   The `mod` is implicit here because computations on the `[d]` type\n        \/\/   are `mod 2^d` by definition.\n        \/\/ - In a bit vector, multiplying by `2^j` is the same as left shift\n        \/\/   (see mul2jIsShiftL`).\n        \/\/ - `bidj` is a single Bit; we use `zext` to convert to a `d`-length\n        \/\/   bit vector (with zeros in the higher-order bits) to support\n        \/\/   subsequentoperations.\n        F = [ sum [ (zext [bidj]) << j\n                | bidj <- bid\n                | j <- [0..d-1]]\n            | bid <- split`{256} b]\n\n    \/**\n     * Decode `k` arrays of `d`-bit integers into a byte array.\n     * [FIPS-203] Section 2.4.8.\n     *\/\n    ByteDecode_Vec : {d} (1 <= d, d < 12) => [k * 32 * d]Byte -> [k][256][d]\n    ByteDecode_Vec B_vec = map ByteDecode (split B_vec)\n\n    \/**\n     * Decode a byte array into an array of integers mod `q`.\n     * [FIPS-203] Section 4.2.1 Algorithm 6.\n     *\n     * Note: In this implementation, we treat the `d < 12` case separately from\n     * `d == 12` because it allows us to better express the different integer\n     * types. For `d = 12`, we use the integers-mod (`Z`) type.\n     * See `ByteDecode` for the `d < 12` case.\n     *\/\n    ByteDecode12 : [32 * 12]Byte -> [256](Z q)\n    ByteDecode12 B = F' where\n        type d = 12\n        \/\/ These steps are the same as in `ByteDecode`. See that function for\n        \/\/ notes.\n        b = BytesToBits B\n        F = [ sum [ (zext`{d} [bidj]) << j\n                | bidj <- bid\n                | j <- [0..d-1]]\n            | bid <- split`{256} b]\n\n        \/\/ In this case, since `m = q` (and not `2^12`), we need to explicitly\n        \/\/ convert each integer from a 12-bit array to an integer mod `q`.\n        toZq f = fromInteger (toInteger f)\n        F' = map toZq F\n\n    \/**\n     * Decode `k` joined byte arrays into `k` arrays of integers mod `q`.\n     *\/\n    ByteDecode12_Vec : [k * 32 * 12]Byte -> [k][256](Z q)\n    ByteDecode12_Vec B = map ByteDecode12 (split B)\n\n    \/**\n     * Multiplying a value by `2^j` is the same as bit-shifting it left by `j`\n     * bits.\n     * Note: The type constraint does not allow `d == 1` because the hard-coded\n     * `2` does not fit in a single bit, but the property is trivial:\n     * `j` can only be 0. On the left, `b * 2^0 == b * 1 == b`. On the right,\n     * `b << 0 == b`.\n     *\n     * These tests use the values of `d` that are actually used in the\n     * algorithm. `d_u` and `d_v` are functor parameters for this module.\n     * ```repl\n     * :prove mul2jIsShiftL`{d_u}\n     * :prove mul2jIsShiftL`{d_v}\n     * :prove mul2jIsShiftL`{12}\n     * ```\n     *\/\n    mul2jIsShiftL : {d} (fin d, 1 < d) => [d] -> Bit\n    property mul2jIsShiftL b = and [( b * (2^^j)) == (b << j) | j <- [0..d-1]]\n\n    \/**\n     * When `d < 12`, the byte encoding and decoding functions should be\n     * one-to-one inverses of each other.\n     * [FIPS-203] Section 4.2.1 \"Encoding and decoding\", first point.\n     *\n     * These tests use the values of `d` that are actually used in the\n     * algorithm. `d_u` and `d_v` are functor parameters for this module.\n     * ```repl\n     * :prove ByteEncodeInvertsByteDecode`{1}\n     * :prove ByteEncodeInvertsByteDecode`{d_u}\n     * :prove ByteEncodeInvertsByteDecode`{d_v}\n     * ```\n     *\/\n    ByteEncodeInvertsByteDecode : {d} (fin d, 1 <= d, d < 12) => [256][d] -> Bit\n    property ByteEncodeInvertsByteDecode bits =\n        decode_encode_works && encode_decode_works where\n        decode_encode_works = ByteDecode (ByteEncode bits) == bits\n        \/\/ Rearrange random input to be valid for the decode function\n        bytes = split (join bits)\n        encode_decode_works = ByteEncode (ByteDecode bytes) == bytes\n\n    \/**\n     * Byte decoding is the inverse of byte decoding for `d = 12`.\n     * [FIPS-203] Section 4.2.1 \"Encoding and decoding\", second point.\n     *\n     * Note that the reverse property (decoding, then encoding) is not true!\n     * ```repl\n     * :check ByteDecode12InvertsByteEncode12\n     * ```\n     *\/\n    ByteDecode12InvertsByteEncode12 : [256](Z q) -> Bit\n    ByteDecode12InvertsByteEncode12 bits =\n        ByteDecode12 (ByteEncode12 bits) == bits\n\n    \/**\n     * Uniformly sample NTT representations.\n     *\n     * This uses a seed `B` to generate a pseudorandom stream, which is parsed into\n     * a polynomial in `T_q` drawn from a distribution indistinguishable from the\n     * uniform distribution.\n     *\n     * [FIPS-203] Section 4.2.2, Algorithm 7.\n     *\/\n    SampleNTT : [34]Byte -> Tq\n    SampleNTT B = a_hat' where\n        \/\/ Steps 1-2, 5.\n        \/\/ We (lazily) take an infinite stream from the XOF and remove only as\n        \/\/ many bytes as are needed to compute the function. See [FIPS-203]\n        \/\/ Section 4.1 Equation 4.6 for a discussion of the equivalence of this\n        \/\/ form to the one in Algorithm 7.\n        ctx0 = XOF B\n\n        \/\/ Step 3. Since Cryptol is not imperative, we implement this loop using\n        \/\/ recursion. The `j` counter is not made explicit; instead we lazily\n        \/\/ generate an infinite stream of coefficients in `T_q` and `take` the\n        \/\/ correct length in the next line.\n\n        \/\/ Step 4-16. `take` fulfills the `j < 256` condition in Steps 4 and 12.\n        a_hat = take`{256} (filter ctx0)\n\n        \/\/ `filter` parses an infinite stream from the XOF, computing\n        \/\/ potential elements `d1` and `d2` from the first 3 bytes in the stream\n        \/\/ and adding them to the output if they are valid elements in `Z q`.\n        filter: [inf]Byte -> [inf][12]\n        filter XOFSqueeze = a_hat_j where\n            \/\/ Step 5.\n            (C # ctx) = XOFSqueeze\n\n            \/\/ The conversion from 8-bit to 12-bit vectors (with the same\n            \/\/ value!) is implicit in the spec -- see notes on Step 5 and 6\/7.\n            \/\/ In Cryptol, we need to convert manually to do the subsequent\n            \/\/ computations.\n            [C0, C1, C2] = map zext`{12} C\n\n            \/\/ Step 6.\n            d1 = C0 + 256 * (C1 % 16)\n\n            \/\/ Step 7. Cryptol uses integer division; it always takes the floor\n            \/\/ of the result.\n            d2 = (C1 \/ 16) + 16 * C2\n\n            \/\/ Steps 4, 8 - 15.\n            \/\/ Add `d1` and\/or `d2` to the sampled vector `a_hat` if they are\n            \/\/ valid elements in `Z q`.\n            \/\/ The `while` loop in Step 4 is equivalent to the recursive call to\n            \/\/ `filter` in each condition.\n            a_hat_j = if (d1 < `q) && (d2 < `q) then\n                    [d1, d2] # filter ctx\n                else if d1 < `q then\n                    [d1] # filter ctx\n                else if d2 < `q then\n                    [d2] # filter ctx\n                else filter ctx\n\n        \/\/ This conversion is implicit in the implementation -- see the notes on\n        \/\/ Step 6\/7 and 9.\n        toZq : [12] -> Z q\n        toZq x = fromInteger (toInteger x)\n\n        a_hat' = map toZq a_hat\n\n    \/**\n     * Sample a special, centered distribution of polynomials in `R_q` with small\n     * coefficients.\n     *\n     * The input stream `B` must be uniformly random bytes!\n     *\n     * [FIPS-203] Section 4.2.2, Algorithm 8.\n     *\/\n    SamplePolyCBD: {eta} (2 <= eta, eta <= 3) => [64 * eta]Byte -> Rq\n    SamplePolyCBD B = f where\n        \/\/ Step 1.\n        b = BytesToBits B\n        \/\/ This conversion is implicit in the implementation. Convert each bit into\n        \/\/ an element of Z q.\n        BitToZ : Bit -> Z q\n        BitToZ bit = if bit then 1 else 0\n        b' = map BitToZ b\n\n        \/\/ Step 3.\n        x i = sum [b'@(2 * i * `eta + j) | j <- [0 .. (eta-1)]]\n                y i = sum [b'@(2 * i * `eta + `eta + j) | j <- [0 .. (eta-1)]]\n\n        \/\/ Steps 2, 5. The `mod q` is not explicit here because `x` and `y`\n        \/\/ return elements of `Z q`.\n        f = [(x i) - (y i) | i <- [0 .. 255]]\n\n    \/**\n     * [FIPS-203] Section 4.3 \"The mathematical structure of the NTT.\"\n     * ```repl\n     * :prove QisCorrectlyDefined\n     * ```\n     *\/\n    QisCorrectlyDefined: Bit\n    property QisCorrectlyDefined = `q == 2^^8 * 13 + 1\n\n    \/**\n     * `zeta` is a primitive 256-th root of unity modulo `q`.\n     * [FIPS-203] Section 4.3 \"The mathematical structure of the NTT.\"\n     *\n     * ```repl\n     * :prove zetaIsPrimitiveRoot\n     * ```\n     *\/\n    property zetaIsPrimitiveRoot = zeta ^^ 128 == -1\n\n    \/**\n     * Proves that `zeta` is correctly set to be the 256th root of `q`.\n     * ```repl\n     * :exhaust Is256thRootOfq\n     * ```\n     *\/\n    Is256thRootOfq : [lg2 q] -> Bit\n    property Is256thRootOfq p = (p == 0) || (p >= 256) || (zeta^^p != 1)\n\n    \/**\n     * Reverse the unsigned 7-bit value corresponding to an input integer in\n     * `[0, ..., 127]`.\n     * [FIPS-203] Section 4.3 \"The mathematical structure of the NTT.\"\n     *\n     * This diverges from the spec by operating over an 8-bit vector;\n     * this is to ease prior and subsequent computations that would overflow a\n     * 7-bit vector, like:\n     * - `2 * (BitRev7 i) + 1`\n     * - `2 * i + 1`\n     *\n     * A \"pure\" implementation of `BitRev7` in Cryptol is the `reverse` function\n     * on 7-bit vectors. This mini-property shows equivalence:\n     * ```repl\n     * :prove \\(x:[7]) -> ([0] # reverse x) == BitRev7 ([0] # x)\n     * ```\n     *\/\n    BitRev7 : [8] -> [8]\n    BitRev7 i = if i > 255 then error \"BitRev7 called with invalid input\"\n        else (reverse i) >> 1\n\n\/**\n * This section specifies the number-theoretic transform (NTT).\n *\n * It includes the version from [FIPS-203] Section 4.3 as well\n * as a faster O(N log N) version, and a proof of their equivalence.\n *\n * This is explicitly allowed by the spec: \"For every computational procedure\n * [...] a conforming implementation may replace the given set of steps with\n * any mathematically equivalent set of steps\". The equivalence properties\n * prove mathematical equivalence.\n * [FIPS-203] Introduction, \"7. Implementations\".\n *\/\nimport submodule NTT\nsubmodule NTT where\n    private\n        \/**\n         * Number theoretic transform: compute the \"NTT representation\" in\n         * `T_q` of a polynomial in `R_q`.\n         *\n         * [FIPS-203] Section 4.3, Algorithm 9.\n         *\/\n        NaiveNTT : Rq -> Tq\n        NaiveNTT f = join [[f2i i, f2iPlus1 i] | i <- [0 .. 127]] where\n            f2i i = sum [f @(2*j) * zeta_term i j | j <- [0 .. 127]]\n            f2iPlus1 i = sum [f @(2*j+1) * zeta_term i j | j <- [0 .. 127]]\n            zeta_term i j = zeta ^^ ((2 * BitRev7 i + 1) * j)\n\n        \/**\n         * Inverse of the number theoretic transform: converts from the \"NTT\n         * representation\" in `T_q` to a polynomial in `R_q`.\n         *\n         * [FIPS-203] Section 4.3, Algorithm 10.\n         *\/\n        NaiveNTTInv : Tq -> Rq\n        NaiveNTTInv f_hat = [f_i * 3303 | f_i <- f] where\n            f = join [[f2i i, f2iPlus1 i] | i <- [0 .. 127]]\n            f2i i = sum [f_hat @(2*j) * zeta_term i j | j <- [0 .. 127]]\n            f2iPlus1 i = sum [f_hat @(2*j+1) * zeta_term i j | j <- [0 .. 127]]\n            zeta_term i j = (recip zeta) ^^ ((2 * BitRev7 j + 1) * i)\n\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/ This section specifies fast O(N log N) NTT and Inverse NTT\n        \/\/\n        \/\/ A readable explanation of the derivation of this form of\n        \/\/ the NTT is in \"A Complete Beginner Guide to the Number\n        \/\/ Theoretic Transform (NTT)\" by Ardianto Satriawan,\n        \/\/ Rella Mareta, and Hanho Lee. Available from:\n        \/\/    https:\/\/eprint.iacr.org\/2024\/585\n        \/\/\n        \/\/ This section Copyright Amazon.com, Inc. or its affiliates.\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n        \/**\n         * Lookup table for `zeta` values computed in `NTT` and `NTTInv`.\n         *\n         * [FIPS-203] Appendix A.\n         *\/\n        zeta_expc  : [128](Z q)\n        zeta_expc = [\n            1, 1729, 2580, 3289, 2642, 630, 1897, 848,\n            1062, 1919, 193, 797, 2786, 3260, 569, 1746,\n            296, 2447, 1339, 1476, 3046, 56, 2240, 1333,\n            1426, 2094, 535, 2882, 2393, 2879, 1974, 821,\n            289, 331, 3253, 1756, 1197, 2304, 2277, 2055,\n            650, 1977, 2513, 632, 2865, 33, 1320, 1915,\n            2319, 1435, 807, 452, 1438, 2868, 1534, 2402,\n            2647, 2617, 1481, 648, 2474, 3110, 1227, 910,\n            17, 2761, 583, 2649, 1637, 723, 2288, 1100,\n            1409, 2662, 3281, 233, 756, 2156, 3015, 3050,\n            1703, 1651, 2789, 1789, 1847, 952, 1461, 2687,\n            939, 2308, 2437, 2388, 733, 2337, 268, 641,\n            1584, 2298, 2037, 3220, 375, 2549, 2090, 1645,\n            1063, 319, 2773, 757, 2099, 561, 2466, 2594,\n            2804, 1092, 403, 1026, 1143, 2150, 2775, 886,\n            1722, 1212, 1874, 1029, 2110, 2935, 885, 2154\n        ]\n\n\n        \/\/ Top level entry point - start with lv=256, k=1\n        fast_ntt : Rq -> Tq\n        fast_ntt v = fast_nttl v 1\n\n        \/\/ Recursive NTT function\n        fast_nttl :\n            {lv}  \/\/ Length of v is a member of {256,128,64,32,16,8,4}\n            (lv >= 2, lv <= 8) =>\n            [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\n        fast_nttl v k\n            \/\/ Base case. lv==2 so just compute the butterfly and return\n            | lv == 2 => ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n            \/\/ Recursive case. Butterfly what we have, then recurse on each half,\n            \/\/ concatenate the results and return.\n            | lv  > 2 => (fast_nttl`{lv-1} s0 (k * 2)) #\n                    (fast_nttl`{lv-1} s1 (k * 2 + 1))\n                        where\n                        t = ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n                                                [s0, s1] = split t\n\n        \/\/ Fast recursive CT-NTT\n        ct_butterfly :\n            {m, hm}\n            (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n            [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\n        ct_butterfly v z = new_v where\n            halflen = 2^^`hm\n            lower, upper : [2^^hm](Z q)\n            lower@x = v@x + z * v@(x + halflen)\n            upper@x = v@x - z * v@(x + halflen)\n            new_v = lower # upper\n\n\n        \/\/ Recursive inverse-NTT function\n        fast_invnttl :\n            {lv}  \/\/ Length of v is a member of {256,128,64,32,16,8,4}\n            (lv >= 2, lv <= 8) =>\n            [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\n        fast_invnttl v k\n            \/\/ Base case. lv==2 so just compute the butterfly and return\n            | lv == 2 => gs_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n            \/\/ Recursive case. Recurse on each half,\n            \/\/ concatenate the results, butterfly that, and return.\n            | lv  > 2 => gs_butterfly`{lv,lv-1} t (zeta_expc@k) where\n                                [s0, s1] = split v\n                t = (fast_invnttl`{lv-1} s0 (k * 2 + 1)) #\n                    (fast_invnttl`{lv-1} s1 (k * 2))\n\n        \/\/ Fast recursive GS-Inverse-NTT\n        gs_butterfly :\n            {m, hm}\n            (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n            [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\n        gs_butterfly v z = new_v where\n            halflen = 2^^`hm\n            lower, upper : [2^^hm](Z q)\n            lower@x = v@x  + v@(x + halflen)\n            upper@x = z * (v@(x + halflen) - v@x)\n            new_v = lower # upper\n\n        \/\/ Top level entry point - start with lv=256, k=1\n        fast_invntt : Tq -> Rq\n        fast_invntt v = mul_recip128 (fast_invnttl v 1) where\n\n            \/\/ Multiplicative inverse of 128, mod `q`.\n            recip_128_modq = (recip 128) : (Z q)\n\n            \/\/ Multiply all elements of v' by the reciprocal of 128 (modulo q)\n            mul_recip128 : Tq -> Tq\n            mul_recip128 v' = [ v'@x * recip_128_modq | x <- [0 .. <n] ]\n\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/ Properties and proofs of Naive and Fast NTT\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n        \/**\n         * This property demonstrates that NaiveNTT is self-inverting.\n         * ```repl\n         * :prove NaiveNTT_Inverts\n         * ```\n         *\/\n        NaiveNTT_Inverts : Rq -> Bit\n        property NaiveNTT_Inverts f =  NaiveNTTInv (NaiveNTT f) == f\n\n        \/**\n         * This property demonstrates that NaiveNTTInv is self-inverting.\n         * ```repl\n         * :prove NaiveNTTInv_Inverts\n         * ```\n         *\/\n        NaiveNTTInv_Inverts : Tq -> Bit\n        property NaiveNTTInv_Inverts f =  NaiveNTT (NaiveNTTInv f) == f\n\n        \/**\n         * This property demonstrates that `fast_ntt` is the inverse of `fast_invntt`.\n         * ```repl\n         * :prove fast_ntt_inverts\n         * ```\n         *\/\n        fast_ntt_inverts : Rq -> Bit\n        property fast_ntt_inverts    f =  fast_invntt (fast_ntt f)    == f\n\n        \/**\n         * This property demonstrates that `fast_invntt` is the inverse of `fast_ntt`.\n         * ```repl\n         * :prove fast_invntt_inverts\n         * ```\n         *\/\n        fast_invntt_inverts : Tq -> Bit\n        property fast_invntt_inverts f =  fast_ntt    (fast_invntt f) == f\n\n        \/**\n         * This property demonstrates that `naive_ntt` is equivalent to `fast_ntt`.\n         * ```repl\n         * :prove naive_fast_ntt_equiv\n         * ```\n         *\/\n        naive_fast_ntt_equiv : Rq -> Bit\n        property naive_fast_ntt_equiv f =  NaiveNTT f == fast_ntt f\n\n        \/**\n         * This property demonstrates that `naive_invntt` is equivalent to `fast_invntt`.\n         * ```repl\n         * :prove naive_fast_invntt_equiv\n         * ```\n         *\/\n        naive_fast_invntt_equiv : Tq -> Bit\n        property naive_fast_invntt_equiv f =  NaiveNTTInv f == fast_invntt f\n\n    \/**\n     * The Number-Theoretic Transform (NTT) is used to improve the efficiency\n     * of multiplication in the ring `R_q`. We choose to use the fast version\n     * of NTT, which is equivalent to the version described in the spec.\n     *\/\n    NTT : Rq -> Tq\n    NTT = fast_ntt\n\n    \/**\n     * The inverse of the Number-Theoretic Transform (NTT) is used to improve\n     * the efficiency of multiplication in the ring `R_q`. We choose to use\n     * the fast version of inverse function, which is equivalent to the version\n     * described in the spec.\n     *\/\n    NTTInv : Tq -> Rq\n    NTTInv = fast_invntt\n\n    \/**\n     * The notation `NTT` is overloaded to mean both a single application of `NTT`\n     * to an element of `R_q` and also `k` applications of `NTT` to every element\n     * of a `k`-length vector.\n     * [FIPS-203] Section 2.4.6 Equation 2.9.\n     *\/\n    NTT_Vec v = map NTT v\n\n    \/**\n     * The notation `NTTInv` is overloaded to mean both a single application of\n     * `NTTInv` to an element of `R_q` and also `k` applications of `NTTInv` to\n     * every element of a `k`-length vector.\n     * [FIPS-203] Section 2.4.6.\n     *\/\n    NTTInv_Vec v = map NTTInv v\n\n\n    \/**\n     * Compute the product of two degree-one polynomials with respect to a\n     * quadratic modulus.\n     * [FIPS-203] Section 4.3.1 Algorithm 12.\n     *\/\n    BaseCaseMultiply : (Z q) -> (Z q) -> (Z q) -> (Z q) -> (Z q) -> [2](Z q)\n    BaseCaseMultiply a0 a1 b0 b1 \u03b3 = [c0, c1]\n      where\n        c0 = a0 * b0 + a1 * b1 * \u03b3\n        c1 = a0 * b1 + a1 * b0\n\n    \/**\n     * Compute the product (in the ring `T_q`) of two NTT representations.\n     * [FIPS-203] Section 4.3.1 Algorithm 11.\n     *\/\n    MultiplyNTTs : Tq -> Tq -> Tq\n    MultiplyNTTs f_hat g_hat = join h_hat where\n        h_hat = [ BaseCaseMultiply\n            (f_hat @(2*i))\n            (f_hat @(2*i+1))\n            (g_hat @(2*i))\n            (g_hat @(2*i+1))\n            (zeta ^^(2 * BitRev7 i + 1))\n        | i <- [0 .. 127] ]\n\n    \/**\n     * Testing that (1+x)^2 = 1+2x+x^2.\n     * ```repl\n     * :prove TestMult\n     * ```\n     *\/\n    TestMult : Bit\n    property TestMult = prod f f == fsq where\n      f = [1, 1] # [0 | i <- [3 .. 256]]\n      fsq = [1,2,1] # [0 | i <- [4 .. 256]]\n\n      prod : Rq -> Rq -> Rq\n      prod a b = NTTInv (MultiplyNTTs (NTT a) (NTT b))\n\n    \/**\n     * The cross product notation \u00d7\ud835\udc47\ud835\udc5e is defined as the `MultiplyNTTs` function\n     * (also referred to as `T_q` multiplication).\n     * [FIPS-203] Section 2.4.5 Equation 2.8.\n     *\/\n    (\u00d7) = MultiplyNTTs\n\n    \/**\n     * Overloaded `dot` function between two vectors is a standard dot-product\n     * functionality with `T_q` multiplication as the base operation.\n     * [FIPS-203] Section 2.4.7 Equation 2.14.\n     *\/\n    dotVecVec : {k1} (fin k1) => [k1]Tq -> [k1]Tq -> Tq\n    dotVecVec v1 v2 = sum (zipWith (\u00d7) v1 v2)\n\n    \/**\n     * Overloaded `dot` function between a matrix and a vector is standard\n     * matrix-vector multiplication with `T_q` multiplication as the base\n     * operation.\n     * [FIPS-203] Section 2.4.7 Equation 2.12 and 2.13.\n     *\/\n    dotMatVec : {k1,k2} (fin k1, fin k2) => [k1][k2]Tq -> [k2]Tq -> [k1]Tq\n    dotMatVec matrix vector = [dotVecVec v1 vector | v1 <- matrix]\n\n    \/**\n     * Overloaded `dot` function between two matrices is standard matrix\n     * multiplication with `T_q` multiplication as the base operation.\n     * [FIPS-203] Section 2.4.7.\n     *\/\n    dotMatMat :{k1,k2,k3} (fin k1, fin k2, fin k3) =>\n        [k1][k2]Tq -> [k2][k3]Tq -> [k1][k3]Tq\n    dotMatMat matrix1 matrix2 = transpose [dotMatVec matrix1 vector | vector <- m']\n        where m' = transpose matrix2\n\n\/**\n * The K-PKE component scheme.\n *\n * \u26a0\ufe0f This scheme is not approved for stand-alone use! \u26a0\ufe0f\n * K-PKE is an encryption scheme consisting of three algorithms `(KeyGen,\n * Encrypt, Decrypt)`, which are used to instantiate the approved ML-KEM\n * scheme. It's not secure as a standalone scheme; it doesn't do any input\n * checking.\n * [FIPS-203] Section 5.\n *\/\nprivate submodule K_PKE where\n    \/\/ Encryption key for the K_PKE component scheme.\n    \/\/ [FIPS-203] Section 5 Algorithm 13. See \"Output\".\n    type EncryptionKey = [384 * k + 32]Byte\n\n    \/\/ Decryption key for the K_PKE component scheme.\n    \/\/ [FIPS-203] Section 5 Algorithm 13. See \"Output\".\n    type DecryptionKey = [384 * k]Byte\n\n    \/\/ Ciphertext generated by the K_PKE component scheme.\n    \/\/ [FIPS-203] Section 5 Algorithm 14. See \"Output\".\n    type Ciphertext = [32 * (d_u * k + d_v)]Byte\n\n    \/**\n     * Key generation for the K-PKE component scheme.\n     *\n     * \u26a0\ufe0f Warnings \u26a0\ufe0f\n     * - This scheme is not approved for use in a stand-alone fashion! It does not\n     *   do any input validation and should only be used as a subroutine of ML-KEM.\n     * - The seed `d` passed as input and the decryption key `dkPKE` returned from\n     *   this algorithm must be kept private!\n     *\n     * [FIPS-203] Section 5.1 Algorithm 13.\n     *\/\n    KeyGen: [32]Byte -> (EncryptionKey, DecryptionKey)\n    KeyGen d = (ekPKE, dkPKE) where\n        \/\/ Step 1.\n        (\u03c1, \u03c3) = G (d # [`(k)])\n        \/\/ Steps 3-7.\n        A_hat = [[ SampleNTT (\u03c1 # [j] # [i])\n            | j <- [0 .. k-1]]\n            | i <- [0 .. k-1]]\n        \/\/ Steps 2, 8-11.\n        s = [SamplePolyCBD`{eta_1} (PRF \u03c3 N)\n            | N <- [0 .. k-1]]\n        \/\/ Steps 12 - 15.\n        e = [SamplePolyCBD`{eta_1} (PRF \u03c3 N)\n            | N <- [k .. 2 * k - 1]]\n        \/\/ Step 16.\n        s_hat = NTT_Vec s\n        \/\/ Step 17.\n        e_hat = NTT_Vec e\n        \/\/ Step 18.\n        t_hat = (dotMatVec A_hat s_hat) + e_hat\n        \/\/ Step 19.\n        ekPKE = (ByteEncode12_Vec t_hat) # \u03c1\n        \/\/ Step 20.\n        dkPKE = ByteEncode12_Vec s_hat\n\n    \/**\n     * Encryption algorithm for the K-PKE component scheme.\n     *\n     * \u26a0\ufe0f Warning \u26a0\ufe0f This scheme is not approved for use in a stand-alone fashion!\n     * It does not do any input validation and should only be used as a subroutine\n     * of ML-KEM.\n     *\n     * [FIPS-203] Section 5.2 Algorithm 14.\n     *\/\n    Encrypt : EncryptionKey -> [32]Byte -> [32]Byte -> Ciphertext\n    Encrypt ekPKE m r = c where\n        \/\/ Step 2.\n        t_hat = ByteDecode12_Vec (ekPKE @@[0 .. 384*k - 1])\n        \/\/ Step 3.\n        rho = ekPKE @@[384*k .. 384*k + 32 - 1]\n        \/\/ Steps 4-8.\n        A_hat = [[ SampleNTT (rho # [j] # [i])\n            | j <- [0 .. k-1]]\n            | i <- [0 .. k-1]]\n        \/\/ Steps 1, 9-12.\n        y = [SamplePolyCBD`{eta_1} (PRF r N)\n            | N <- [0 .. k-1]]\n        \/\/ Steps 13-16.\n        e1 = [SamplePolyCBD`{eta_2} (PRF r N)\n            | N <- [k .. 2 * k - 1]]\n        \/\/ Step 17. In the spec, the second parameter is `N = 2k`. In this\n        \/\/ implementation, `N` itself is out of scope, so we use the fixed\n        \/\/ value instead.\n        e2 = SamplePolyCBD`{eta_2} (PRF r (2 * `k))\n        \/\/ Step 18.\n        y_hat = NTT_Vec y\n        \/\/ Step 19.\n        u = NTTInv_Vec (dotMatVec (transpose A_hat) y_hat) + e1\n        \/\/ Step 20.\n        mu = Decompress_Vec`{1} (ByteDecode`{1} m)\n                v = (NTTInv (dotVecVec t_hat y_hat)) + e2 + mu\n                c1 = ByteEncode_Vec`{d_u} (Compress_Mat`{d_u} u)\n                c2 = ByteEncode`{d_v} (Compress_Vec`{d_v} v)\n                c = c1 # c2\n\n    \/**\n     * Decryption algorithm for the K-PKE component scheme.\n     *\n     * \u26a0\ufe0f Warning \u26a0\ufe0f This scheme is not approved for use in a stand-alone fashion!\n     * It does not do any input validation and should only be used as a subroutine\n     * of ML-KEM.\n     *\n     * [FIPS-203] Section 5.3 Algorithm 15.\n     *\/\n    Decrypt : DecryptionKey -> Ciphertext -> [32]Byte\n    Decrypt dkPKE c = m where\n        \/\/ Step 1.\n        c1 = c @@[0 .. 32 * d_u * k - 1]\n        \/\/ Step 2.\n        c2 = c @@[32 * d_u * k .. 32 * (d_u * k + d_v) - 1]\n        \/\/ Step 3.j\n        u' = Decompress_Mat`{d_u} (ByteDecode_Vec`{d_u} c1)\n                v' = Decompress_Vec`{d_v} (ByteDecode`{d_v} c2)\n        \/\/ Step 5.\n        s_hat = ByteDecode12_Vec dkPKE\n        \/\/ Step 6.\n        w = v' - NTTInv (dotVecVec s_hat (NTT_Vec u'))\n        \/\/ Step 7.\n        m = ByteEncode`{1} (Compress_Vec`{1} w)\n\n    \/**\n     * The K-PKE scheme must satisfy the basic properties of an encryption\n     * scheme.\n     * This must be `:check`ed because K-PKE is correct with probability\n     * 1-delta and not 1. It is not provably correct because there is a\n     * (very small!) fraction of seeds `d, r` that don't work.\n     * ```repl\n     * :set tests=3\n     * :check CorrectnessPKE\n     * ```\n     *\/\n    CorrectnessPKE : [32]Byte -> [32]Byte -> [32]Byte -> Bit\n    property CorrectnessPKE d m r = (m' == m) where\n        (pk, sk) = KeyGen d\n        c = Encrypt pk m r\n        m' = Decrypt sk c\n\n\nprivate\n    \/**\n     * Uses randomness to generate an encapsulation key and corresponding\n     * decapsulation key.\n     * [FIPS-203] Section 6.1 Algorithm 16.\n     *\n     * Warning: This function does not validate input and should not be used\n     * externally!\n     *\/\n    KeyGen_internal : [32]Byte -> [32]Byte\n        -> (EncapsulationKey, DecapsulationKey)\n    KeyGen_internal d z = (ek, dk) where\n      (ekPKE, dkPKE) = K_PKE::KeyGen d\n      ek = ekPKE\n      dk = dkPKE # ek # (H ek) # z\n\n    \/**\n     * Uses the encapsulation key and randomness to generate a key and an\n     * associated ciphertext.\n     * [FIPS-203] Section 6.2 Algorithm 17.\n     *\n     * Warning: This function does not validate input and should not be used\n     * externally!\n     *\/\n    Encaps_internal : EncapsulationKey -> [32]Byte\n        -> (SharedSecretKey, Ciphertext)\n    Encaps_internal ek m = (K, c) where\n      (K, r) = G (m # (H ek))\n      c = K_PKE::Encrypt ek m r\n\n    \/**\n     * Uses the decapsulation key to produce a shared secret key from a\n     * ciphertext.\n     * [FIPS-203] Section 6.3 Algorithm 18.\n     *\n     * Warning: This function does not validate input and should not be used\n     * externally!\n     *\/\n    Decaps_internal : DecapsulationKey -> Ciphertext -> SharedSecretKey\n    Decaps_internal dk c = K where\n        \/\/ Step 1. Extract (from KEM decaps key) the PKE decryption key.\n        dkPKE = dk @@ [0 .. 384*k - 1]\n        \/\/ Step 2. Extract PKE encryption key.\n        ekPKE = dk @@ [384*k .. 768*k + 32 - 1]\n        \/\/ Step 3. Extract hash of PKE encryption key.\n        h = dk @@ [768*k + 32 .. 768*k + 64 - 1]\n        \/\/ Step 4. Extract implicit rejection value.\n        z = dk @@ [768*k + 64 .. 768*k + 96 - 1]\n        \/\/ Step 5. Decrypt ciphertext.\n        m' = K_PKE::Decrypt dkPKE c\n        \/\/ Step 6.\n        (K', r') = G (m' # h)\n        \/\/ Step 7.\n        Kbar = J (z # c)\n        \/\/ Step 8. Re-encrypt using the derived randomness `r'`.\n        c' = K_PKE::Encrypt ekPKE m' r'\n        \/\/ Step 9 - 11. If ciphertextx do not match, \"implicitly reject\".\n        K = if (c != c') then\n                Kbar\n            else\n                K'\n\n    \/**\n     * The ML-KEM scheme is correct with probability 1-delta and not 1. As a\n     * result, running `:prove CorrectnessPKE` will not succeed since there is a\n     * fraction delta of seeds `d`, `z`, `m` that do not work.\n     * Cryptol does not currently support counting.\n     * ```repl\n     * :set tests=3\n     * :check CorrectnessKEM\n     * ```\n     *\/\n    CorrectnessKEM : [32]Byte -> [32]Byte -> [32]Byte -> Bit\n    property CorrectnessKEM z d m = (K == K') where\n        (ek, dk) = KeyGen_internal d z\n        (K, c) = Encaps_internal ek m\n        K' = Decaps_internal dk c\n\n\/*\n * Type of an encapsulation key used in the public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 19.\n * See also the paragraph \"Terminology for keys\" in Section 3.2.\n *\/\ntype EncapsulationKey = [384 * k + 32]Byte\n\n\/*\n * Type of an decapsulation key used in the public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 19.\n * See also the paragraph \"Terminology for keys\" in Section 3.2.\n *\/\ntype DecapsulationKey = [768 * k + 96]Byte\n\n\/*\n * Type of the shared secret key material generated by the public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 20.\n * See also the paragraph \"Terminology for keys\" in Section 3.2.\n *\/\ntype SharedSecretKey = [32]Byte\n\n\/*\n * Type of the ciphertext generated by teh public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 20.\n *\n * Usage: This ciphertext is only used in the context of ML-KEM, to derive a\n * shared secret key.\n *\/\ntype Ciphertext = [32 * (d_u * k + d_v)]Byte\n\n\/**\n * Generate an encapsulation key and a corresponding decapsulation key.\n * [FIPS-203] Section 7.1, Algorithm 19.\n *\n * This differs from the spec: it takes the randomness `d` and `z` as\n * parameters instead of generating them internally (because Cryptol\n * cannot generate randomness).\n *\n * The decapsulation key produced from this function MUST remain private. The\n * seed `(d, z)` produced (or in this case, passed as input) is sensitive data\n * and MUST be treated with the same safeguards as the decapsulation key.\n *\/\nKeyGen : Option ([32]Byte) -> Option ([32]Byte)\n    -> (EncapsulationKey, DecapsulationKey)\nKeyGen d z = (ek, dk) where\n    \/\/ Steps 1 and 2 are skipped because Cryptol cannot generate randomness.\n    \/\/ Step 3 - 5.\n    d' = case d of\n        None -> error \"Random bit generation failed; `d` not initialized.\"\n        Some _d -> _d\n    z' = case z of\n        None -> error \"Random bit generation failed; `z` not initialized.\"\n        Some _z -> _z\n    \/\/ Step 6.\n    (ek, dk) = KeyGen_internal d' z'\n\n\/**\n * Perform checks on a key pair.\n *\n * The security of ML-KEM depends on the use of key pairs that were correctly\n * generated using `KeyGen`!\n * This checking process _does not_ guarantee that the input pair is a properly\n * produced output of `KeyGen`. While these checks can detect certain\n * corruptions, they do not guarantee that the key pair was properly generated.\n *\/\nkeyPairCheck : EncapsulationKey\n    -> DecapsulationKey\n    -> Option ([32]Byte, [32]Byte)\n    -> [32]Byte\n    -> Bit\nkeyPairCheck ek dk maybe_seed m =\n    seedConsistency && encapsCheck && decapsCheck && pairwiseConsistency where\n    seedConsistency = case maybe_seed of\n        Some (d, z) -> KeyGen_internal d z == (ek, dk)\n        None -> True\n\n    encapsCheck = encapsulationKeyCheck ek\n    decapsCheck = decapsulationKeyCheck dk\n\n    pairwiseConsistency = K == K'\n    (K, c) = Encaps_internal ek m\n    K' = Decaps_internal dk c\n\n\/**\n * A properly produced output of the `KeyGen` function should always pass the\n * key pair checks.\n * ```repl\n * :set tests=3\n * :check KeyGenProducesValidKeys\n * ```\n *\/\nKeyGenProducesValidKeys d z m = keyPairCheck ek dk (Some (d, z)) m where\n    (ek, dk) = KeyGen (Some d) (Some z)\n\n\/**\n * Perform checks on a candidate encapsulation key.\n *\n * The type check is implicit; if this function compiles with a given `ek`,\n * then it must be of the correct type.\n *\n * This checking process _does not_ gurantee that `ek` is a properly produced\n * output of `KeyGen`.\n *\/\nencapsulationKeyCheck : EncapsulationKey -> Bool\nencapsulationKeyCheck ek = modulusCheck where\n    test = ByteEncode12_Vec (ByteDecode12_Vec (ek @@ [0..384 * k - 1]))\n    modulusCheck = test == (ek @@ [0..384 * k - 1])\n\n\/**\n * Use the encapsulation key to generate a shared secret an an associated\n * ciphertext.\n * [FIPS-203] Section 7.2, Algorithm 20.\n *\n * This differs from the spec: it takes the randomness `m` as a parameter\n * instead of generating it internally (because Cryptol cannot generate\n * randomness).\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f\n * The encapsulation key passed as a parameter MUST be checked before use with\n * `encapsulationKeyCheck`! The caller must have assurance that the\n * encapsulation key is valid.\n * This executable spec (and Cryptol in general) cannot enforce this\n * requirement! Implementors must check it manually.\n *\/\nEncaps : EncapsulationKey -> Option ([32]Byte) -> (SharedSecretKey, Ciphertext)\nEncaps ek m = (K, c) where\n    \/\/ Step 1 is skipped because Cryptol cannot generate randomness.\n    \/\/ Step 2 - 4.\n    m' = case m of\n        None -> error \"Random bit generation failed; `m` not initialized.\"\n        Some _m -> _m\n    \/\/ Step 5.\n    (K, c) = Encaps_internal ek m'\n\n\/**\n * Perform three checks on candidate inputs to decapsulation.\n * [FIPS-203] Section 7.3 \"Decapsulation input check\" #1-3.\n *\n * The type checks are implicit; if this function compiles with a given `dk`\n * and `c`, then they must be of the correct type.\n *\n * This check _does not_ guarantee that `dk` is a propertly produced output\n * of `KeyGen`, or that `c` is a properly produced output of `Encaps`!\n *\/\ndecapsulationInputCheck : DecapsulationKey -> Ciphertext -> Bool\ndecapsulationInputCheck dk c = decapsulationKeyCheck dk\n\nprivate\n    \/**\n     * Perform a type check and a hash check on a candidate decapsulation key.\n     * [FIPS-203] Section 7.3 \"Decapsulation input check\" #2-3.\n     *\n     * The type check is implicit; if this function compiles with a given `dk`,\n     * then it must be the correct type.\n     *\n     * This check _does not_ guarantee that `dk` is a propertly produced output\n     * of `KeyGen`!\n     *\/\n    decapsulationKeyCheck : DecapsulationKey -> Bool\n    decapsulationKeyCheck dk = hash_check where\n        test = H (dk @@ [384*k .. 768*k + 32 - 1])\n        hash_check = test == (dk @@ [768*k + 32 .. 768*k + 64 - 1])\n\n\n\/**\n * Use the decapsulation key to produce a shared secret from a ciphertext.\n * [FIPS-203] Section 7.3, Algorithm 21.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f\n * The decapsulation key and the ciphertext MUST be checked before use with\n * `decapsulationInputCheck`! The caller must have assurance that the\n * decapsulation key and ciphertext are valid.\n * This executable spec (and Cryptol in general) cannot enforce this\n * requirement! Implementors must check it manually.\n *\/\nDecaps : DecapsulationKey -> Ciphertext -> SharedSecretKey\nDecaps = Decaps_internal\n\nparameter\n    \/*\n     * The parameter `k` determines the dimensions of the encryption key matrix\n     * and the secret and noise vectors created and used in key generation and\n     * encryption.\n     * [FIPS-203] Section 8.\n     *\n     * The constraint on the width of `k` is drawn from `K-PKE-KeyGen`. In\n     * that function, the variable `N` varies from 0 to `2k` and is passed as\n     * the second parameter to the `PRF` function. `PRF` restricts the second\n     * parameter to be exactly 1 byte. Therefore, `2k` must fit into a byte.\n     * [FIPS-203] Section 5.1 Algorithm 13 (see lines 2 and 8-15) and Section\n     * 4.1 Equation 4.2.\n     *\/\n    type k : #\n    type constraint (width k > 0, width (2*k) <= 8)\n\n    \/*\n     * The parameter `eta_1` specifies the distribution from which the secret\n     * vectors are drawn in key generation and encryption.\n     * [FIPS-203] Section 8.\n     *\n     * eta_1 must be in the set {2, 3} for use in a PRF and to parameterize\n     * sampling from the centered binomial distribution.\n     * [FIPS-203] Section 4.1 \"Pseudorandom Function\" and Section 4.2.2\n     * \"Sampling from the centered binomial distribution\"\n     *\/\n    type eta_1 : #\n    type constraint (fin eta_1, 2 <= eta_1, eta_1 <= 3)\n\n    \/*\n     * The parameter eta_2 is required to specify the distribution from which\n     * the noise vectors are drawn in encryption.\n     * [FIPS-203] Section 8.\n     *\n     * eta_2 must be in the set {2, 3} for use in a PRF and to parameterize\n     * sampling from the centered binomial distribution.\n     * [FIPS-203] Section 4.1 \"Pseudorandom Function\" and Section 4.2.2\n     * \"Sampling from the centered binomial distribution\"\n     *\/\n    type eta_2 : #\n    type constraint (fin eta_2, 2 <= eta_2, eta_2 <= 3)\n\n    \/*\n     * The parameter `d_u` is a parameter and input for the compression and\n     * encoding functions.\n     * [FIPS-203] Section 8.\n     *\n     * For compression, `d_u` must be smaller than the bit length of `q` (fixed\n     * to 12).\n     * [FIPS-203] Section 4.2.1 \"Compression and decompression\".\n     * For encoding, the valid range of values for `d_u` is `1 \u2264 d_u \u2264 12`.\n     * [FIPS-203] Section 4.2.1 \"Encoding and decoding\".\n     *\/\n    type d_u : #\n    type constraint (fin d_u, d_u < 12, d_u > 0)\n\n    \/*\n     * The parameter `d_v` is a parameter and input for the compression and\n     * encoding functions.\n     * [FIPS-203] Section 8.\n     *\n     * For compression, `d_v` must be smaller than the bit length of `q` (fixed\n     * to 12).\n     * [FIPS-203] Section 4.2.1 \"Compression and decompression\".\n     * For encoding, the valid range of values for `d_v` is `1 \u2264 d_v \u2264 12`.\n     * [FIPS-203] Section 4.2.1 \"Encoding and decoding\".\n     *\/\n    type d_v : #\n    type constraint (fin d_v, d_v < 12, d_v > 0)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ECDH\/Specification.cry","filetype":"cry","content":"\/**\n * Specification for some of the cryptographic primitives used in pair-wise key\n * establishment as defined in [SP-800-56Ar3].\n *\n * \u26a0 Warning \u26a0\n * This file DOES NOT implement the complete specification in [SP-800-56Ar3]!\n * It omits many components, including cryptographic elements and the larger\n * key agreement schemes that combine those elements into secure protocols.\n * These missing pieces are _necessary_ for secure key establishment! Use of\n * the `ECC_CDH` primitive in this file does not constitute key agreement!\n * - It DOES NOT enforce use of valid domain parameters! The architecture of\n *   this module requires instantiation with an elliptic curve, but the EC\n *   interface does not enforce that the parameters are valid or consistently\n *   applied. Implementers must ensure that the EC instantiation they choose\n *   is suitable. See [SP-800-56Ar3] Section 5.5.\n * - It DOES NOT contain a complete model of keys! Keys are either static or\n *   ephemeral; keys should be associated with the domain parameters used to\n *   generate them, generated appropriately, protected from compromise (for\n *   private \/ signing keys), and protected with integrity. Static keys must\n *   also be associated with an identifier for the owner and must not be\n *   reused for other applications. None of these requirements are described or\n *   enforced in this file! See [SP-800-56Ar3] Section 5.6.1 (key generation),\n *   Section 5.6.2 (context on calling the validation methods implemented\n *   here), and Section 5.6.3 (key management).\n * - It DOES NOT contain any key derivation methods! A key derivation method\n *   must be used to derive a key from the shared secret; the secret cannot\n *   be used as-is for keying material, nor can it ever be used as a key stream\n *   for a stream cipher. See [SP-800-56Ar3] Section 5.8.\n * - It DOES NOT contain any key confirmation methods! Key confirmation can be\n *   used to provide assurance to one or both parties that both participants\n *   have completed the protocol with the same key. See [SP-800-56Ar3] Section\n *   5.9.\n * - It DOES NOT implement any complete key establishment schemes! A complete\n *   pair-wise key establishment protocol allows two parties to generate\n *   matching keying material. These schemes combine all of the primitives in\n *   [SP-800-56Ar3] into secure protocols. The primitive to compute a shared\n *   secret that's provided in this file is inadequate! See [SP-800-56Ar3]\n *   Section 6 (key establishment schemes) and Section 7 (selecting a key\n *   establishment scheme).\n *\n * It also omits all of the components of [SP-800-56Ar3] that have to do with\n * finite field cryptography and MQV-based schemes for key agreement.\n *\n * References:\n * [SP-800-56Ar3]: Elaine Barker, LilyChen, Allen Roginsky, Apostol Vassilev,\n *    Richard Davis. Recommendation for Pair-Wise Key-Establishment Schemes\n *    Using Discrete Logarithm Cryptography. (National Institute of Standards\n *    and Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST\n *    SP 800-56A Revision 3. April 2018.\n *    @see https:\/\/doi.org\/10.6028\/NIST.SP.800-56Ar3\n * [SP-800-186]: Lily Chen, Dustin Moody, Karen Randall, Andrew Regenscheid,\n *    Angela Robinson. Recommendations for Discrete Logarithm-based Cryptography:\n *    Elliptic Curve Domain Parameters. (National Institute of Standards and\n *    Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST SP\n *    800-186. February 2023.\n *    @see https:\/\/doi.org\/10.6028\/NIST.SP.800-186\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\n *\/\nmodule Primitive::Asymmetric::KEM::ECDH::Specification where\n\nimport Common::utils(ZtoBV)\n\n\/**\n * Secure key establishment depends on the arithmetic validity of the domain\n * parameters used by the parties.\n *\n * \u26a0 Warning \u26a0\n * Instantiation of this interface does not guarantee validity of the domain\n * parameters! Implementors must ensure that they instantiate this interface\n * with an approved curve as specified in [SP-800-186], and must also ensure\n * that the implementation of that curve is correct.\n * [SP-800-56Ar3] Section 5.5.2.\n *\n * Note: The specification [SP-800-56Ar3] uses the term \"identity\" to refer to\n * the additive identity element of the elliptic curve group. For the approved\n * curves, the identity point is always the special \"point at infinity\". These\n * terms are used interchangeably in this documentation.\n *\/\nimport interface Common::EC::ECInterface as EC\n\n\/**\n * An ECC private, or signing, key.\n *\n * A valid private key is an integer that is randomly selected in the\n * interval [1, n-1]. This type can be used to represent either static or\n * ephemeral keys (as defined in [SP-800-56Ar3]).\n *\n * \u26a0 Warning \u26a0\n * This must be generated with an approved method! This specification does\n * not enforce correct generation.\n *\n * [SP-800-56Ar3] Section 5.6.1.2.\n *\/\ntype SigningKey = Z EC::n\n\n\/**\n * An ECC public, or verifying, key.\n *\n * A valid public key is a non-identity point on the curve, in the subgroup\n * generated by the base point `G`. It must form a pair with a corresponding\n * `SigningKey`.\n *\n * \u26a0 Warning \u26a0\n * - This must be generated from a valid `SigningKey`! This specification does\n * not enforce correct generation.\n * - This type alone cannot enforce validity of the `VerifyingKey`.\n * Implementors should use `verifyingKeyFullyValid` to check ensure validity\n * before using a key for any key establishment schemes.\n *\n * [SP-800-56Ar3] Section 5.6.1.2.\n *\/\ntype VerifyingKey = EC::Point\n\n\/**\n * Get assurance of private-key validity.\n *\n * A valid private key is in the interval `[1, n-1]`, where `n` is the order\n * of the base point for the curve.\n * The upper bound is assured by the `SigningKey` type itself: the integer mod\n * group in Cryptol consists of the integers in the range `[0, n-1]`.\n *\n * [SP-800-56Ar3] Section 5.6.2.1.2.\n *\/\nsigningKeyValid : SigningKey -> Bool\nsigningKeyValid d = d != 0\n\n\/**\n * Check whether the verifying key is fully valid:\n * - It must not be the point at infinity;\n * - It must have the expected representation for an element in the underlying\n *   field;\n * - It must be a point on the correct curve; and\n * - It must have the correct order.\n *\n * [SP-800-56Ar3] Section 5.6.2.3.3.\n *\/\nverifyingKeyFullyValid : VerifyingKey -> Bool\nverifyingKeyFullyValid Q = verifyingKeyPartiallyValid Q && correctOrder where\n    correctOrder = EC::isInfinity (EC::scmul `EC::n Q)\n\n\/**\n * Partially check whether the verifying key is valid:\n * - It must not be the point at infinity;\n * - It must have the expected representation for an element in the underlying\n *   field; and\n * - It must be a point on the correct curve.\n *\n * \u26a0 Warning \u26a0\n * This routine omits the validation that the point is in the subgroup\n * generated by the base point `G`; it is usually faster than full validation.\n * This should only be used for _ephemeral_ ECC public keys!\n *\n * [SP-800-56Ar3] Section 5.6.2.3.4.\n *\/\nverifyingKeyPartiallyValid : VerifyingKey -> Bool\nverifyingKeyPartiallyValid Q = EC::isValid Q && ~(EC::isInfinity Q)\n\n\/**\n * The owner of a key pair needs to make sure it's consistent before using it\n * for key establishment.\n * [SP-800-56Ar3] Section 5.6.2.1.4.\n *\/\nkeyPairIsConsistent : SigningKey -> VerifyingKey -> Bool\nkeyPairIsConsistent d Q = EC::pointEq expectedQ Q where\n    expectedQ = EC::scmul (fromZ d) EC::G\n\n\/**\n * Compute a shared secret `Z` using the domain parameters, the other party's\n * public key (`QB`) and one's own private key (`dA`).\n *\n * \u26a0 Warning: Deviation from the spec \u26a0\n * This deviates from the spec in one important way: All intermediate values,\n * including `P` and `z`, should be destroyed (zeroized) before providing\n * output. Cryptol cannot express this; implementors must manually verify that\n * all potentially sensitive local data is destroyed.\n * [SP-800-56Ar3] Section 5.7.1.2.\n *\n * \u26a0 Warning: Usage \u26a0\n * This routine is not secure if used in isolation! It should be\n * used as a component of one of the key agreement schemes described in\n * [SP-800-56Ar3] Section 6. These schemes handle (input) key management and\n * validation, (output) key derivation, and optional key confirmation.\n * There are several obvious failure modes if this primitive is used in\n * isolation:\n * - Failure to use a valid key agreement scheme can compromise the security of\n * the `SigningKey`s used in `ECC_CDH`! This routine does not validate the\n * other party's public key. A malicious party can claim invalid curve points\n * for her public key `QB` and collect residues to derive the honest party's\n * private key!\n * - The output of this method is a _shared secret_, not a key!\n * It _must not_ be used directly as keying material. An approved key\n * derivation method must be used to derive keying material from the shared\n * secret. [SP-800-56Ar3] Section 5.8.\n *\/\nECC_CDH : SigningKey -> VerifyingKey -> Option ([(width EC::n) \/^ 8][8])\nECC_CDH dA QB = maybe_Z where\n    \/\/ Step 1. Compute P = h dA QB\n    P = EC::scmul EC::h (EC::scmul (fromZ dA) QB)\n    maybe_Z = case EC::xCoord P of\n        \/\/ Step 2.\n        \/\/ xCoord returns `None` if `P` is the point at infinity.\n        None -> None\n        \/\/ Step 3.\n        \/\/ The built-in Cryptol conversion methods produce the same output as the\n        \/\/ routine described in [SP-800-56Ar3] Appendix C.2.\n        Some z -> Some (split (ZtoBV z))\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Instantiations\/ML_KEM512.cry","filetype":"cry","content":"module Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM512 =\n    Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\ntype k = 2\ntype eta_1 = 3\ntype eta_2 = 2\ntype d_u = 10\ntype d_v = 4\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Instantiations\/ML_KEM1024.cry","filetype":"cry","content":"module Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM1024 =\n    Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\ntype k = 4\ntype eta_1 = 2\ntype eta_2 = 2\ntype d_u = 11\ntype d_v = 5\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Instantiations\/ML_KEM768.cry","filetype":"cry","content":"module Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM768 =\n    Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\ntype k = 3\ntype eta_1 = 2\ntype eta_2 = 2\ntype d_u = 10\ntype d_v = 4\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/EC\/ECInterface.cry","filetype":"cry","content":"interface module Common::EC::ECInterface where\n    \/**\n     * Representation of a point on the curve.\n     *\n     * This should be able to represent both concrete points (with an x and y\n     * coordinate) and the point at infinity.\n     *\/\n    type Point : *\n\n    \/**\n     * Order of the base point `G` for the curve.\n     *\/\n    type n : #\n    type constraint (fin n, prime n, n >= 1)\n\n    \/**\n     * Modulus of the field over which the curve is defined.\n     *\n     * The curve must be defined over a Galois fields `GF(q)` for some `q`\n     * (typically an odd prime or 2^m).\n     *\/\n    type q : #\n    type constraint (fin q, q >= 1)\n\n    \/**\n     * Cofactor for the elliptic curve.\n     *\n     * The order of the curve is defined as `h * n`, where `h` is small\n     * and `n`, the order of the base point `G`, is prime. If `h` is not\n     * 1, then the base point does not generate the entire curve.\n     *\/\n    h : Integer\n\n    \/**\n     * Base point for the curve.\n     *\/\n    G : Point\n\n    \/**\n     * Indicate whether a point is the point at infinity (also known as the\n     * identity).\n     *\/\n    isInfinity : Point -> Bool\n\n    \/**\n     * Indicate whether a point is valid: either the point at infinity or\n     * another point on the curve.\n     *\n     * This should check the following:\n     * - The coordinates of the `Point` are correctly formed\n     * - The point is either on the curve (e.g. satisfies the curve equation)\n     *   OR is the point at infinity.\n     *\/\n    isValid : Point -> Bool\n\n    \/**\n     * Indicate whether two points are the same.\n     *\/\n    pointEq : Point -> Point -> Bool\n\n    \/**\n     * Addition of two points.\n     *\/\n    add : Point -> Point -> Point\n\n    \/**\n     * Subtraction of two points.\n     *\/\n    sub : Point -> Point -> Point\n\n    \/**\n     * Doubling of a point (typically, elliptic curves offer optimized\n     * routines for doubling a point compared to adding it to itself).\n     *\/\n    double : Point -> Point\n\n    \/**\n     * Scalar multiplication of a point by an integer.\n     *\/\n    scmul : Integer -> Point -> Point\n\n    \/**\n     * Twin multiplication of two points. This is the operation\n     * [c]P + [d]Q, which sometimes has an optimized routine\n     * compared to doing the scalar multiplications separately.\n     *\/\n    twin_mul : Integer -> Point -> Integer -> Point -> Point\n\n    \/**\n     * Extract the x-coordinate of the affine representation of a `Point`,\n     * or `None` if it's the point at infinity.\n     *\/\n    xCoord: Point -> Option (Z q)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/EC\/Curve25519.cry","filetype":"cry","content":"\/**\n * Curve 25519 is an elliptic curve commonly used\n * in ECDH, originally created as an alternative\n * to NIST curves. Now, NIST standardizes these curves\n * in NIST SP 800-186.\n *\n * This implementation is based upon RFC 7748.\n *\n * The RFC notes many situations in which side-channels\n * can be exploited in EC cryptography. This executable\n * specification does NOT model all of the constant-time\n * recommendations that the RFC does.\n *\n * The RFC defines a function X448 over Curve448\n * in addition to X25519 and Curve25519. This\n * executable specification includes neither\n * X448 nor Curve448.\n *\n * References:\n *  [rfc 7748]\n *  Elliptic Curves for Security (IRTF RFC 7748)\n *  A. Langley, Google; M. Hamburg, Rambus;\n *  S. Turner, sn3rd.\n *  January 2016\n *  @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc7748\n *\n *  [SP 800-186]\n *  Recommendations for Discrete Logarithm-based Cryptography:\n *  Elliptic Curve Domain Parameters.\n *  L. Chen, D. Moody, K. Randall, A. Regenscheid, A. Robinson.\n *  February 2023\n *  @see https:\/\/doi.org\/10.6028\/NIST.SP.800-186\n *\n *\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\/\n\nmodule Common::EC::Curve25519 where\n\nimport Common::utils(ZtoBV, BVtoZ)\n\n\/*\n * Curve 25519 is a Montgomery curve of the form\n * `v^2 = u^3 + A * u^2 + u` over a prime `p`.\n *\n * Reference:\n * [rfc7748] Section 4.1\n *\/\n\n\/**\n * The prime defining the field\n *\/\ntype p = 2^^255 - 19\n\n\/**\n * The coefficient `A`.\n * The multiplication formula in the RFC\n * avoids the direct use of `A`, but it is included\n * for completion.\n *\/\ntype A = 486662\n\n\/**\n * The order of the curve.\n * The multiplication formula in the RFC does not\n * directly use the order of the curve, but it is\n * included for completion.\n *\/\ntype order = 2^^252 + 27742317777372353535851937790883648493\n\n\/**\n * The specification uses hexadecimal notation to define the curve order.\n *\n * ```repl\n * :prove orderOk\n * ```\n *\/\nproperty orderOk = `order == order'\n    where\n        i = toInteger 0x14def9dea2f79cd65812631a5cf5d3ed\n        order' = 2^^252 + i\n\n\/**\n * The `u`-coordinate of the base point `(Gu, Gv)`.\n *\/\ntype Gu = 9\n\n\/**\n * The `v`-coordinate of the base point `(Gu, Gv)`.\n * The multiplication formula in the RFC uses a \"point compressed\"\n * view of elliptic curve points that avoids directly specifying\n * the `v` coordinates. This is included for completion.\n *\/\ntype Gv = 14781619447589544791020593568409986887264606134616475288964881837755586237401\n\n\/**\n * Shorthand for the bytes array of minimum length\n * that can fit some number of bits `b`.\n *\/\ntype Bytes b = [b \/^ 8][8]\n\n\/**\n * Constraint that some number of bits `b` can\n * fit in a byte array of length `n` of finite length.\n *\/\ntype constraint Fit b n = (b \/^ 8 <= n, fin b, fin n)\n\n\/**\n * Take an array of bytes and decode as a little endian number.\n * Follow the specification. Assume that the array is \"already\"\n * little endian.\n *\n * For Curve25519, `bits` is always fixed to be `255`.\n * RFC7748 defines other curves with different bit parameters.\n * To faciliate eventual refactoring, we make this function\n * polymorphic in the parameter `bits`.\n *\n * RFC7748 specifies that the operations work internally\n * with integers, with all operations done `% p`. We use\n * a modular integer type directly, to more closely match\n * the notation in the multiplication formula later.\n *\n * Reference:\n * [rfc7748] Section 5.\n *\/\ndecodeLittleEndian : {bits, n} (Fit bits n) => [n][8] -> Z p\ndecodeLittleEndian x = fromInteger (sum iterates)\n    where\n        lshft y i = y * 256 ^^ i         iterates = [lshft (toInteger b) i | b <- x | i <- [0..bits \/^ 8]]\n\n\/**\n * Test vector for encoding derived\n * from running the Python code provided\n * in Section 5 of [rfc7748].\n *\n * ```repl\n * :prove decodeTest\n * ```\n *\/\nproperty decodeTest = decodeLittleEndian `{88} \"hello world\" == x\n    where\n        x = 121404708502361365413651816\n\n\/**\n * Decode the `u` coordinate.\n * Assume the array is already \"little endian\".\n *\n * Reference:\n * [rfc7748] Section 5.\n *\/\ndecodeUCoordinate : {bits, n} (Fit bits n, bits >= 1) => [n][8] -> Z p\ndecodeUCoordinate u_list = decodeLittleEndian `{bits} u_list''\n    where\n        mask = (1 << (`bits % 8)) - 1 : [8]\n        type m = bits \/^ 8\n        u_list' = take `{m} u_list\n        l = `m - 1\n        u_list'' = if `bits % 8 != 0\n                then update u_list' l (last u_list' && mask)\n                else u_list'\n\n\/**\n * Encode the `u` coordinate from `Z p` as a little endian byte array.\n * Since we use a modular arithmetic type directly, we do not need\n * to reduce the coordinate modulo `p`.\n *\n * We also use Cryptol intrinsics rather than following the specification.\n *\/\nencodeUCoordinate : {bits, n} (Fit bits n, bits >= 1) => Z p -> [n][8]\nencodeUCoordinate u = reverse (split (ZtoBV u))\n\n\/**\n * `encodeUCoordinate` inverts `decodeUCoordinate` if the\n * type parameters are coherent for Curve25519 and the\n * little endian value fits in `255` bits.\n *\n * The final bit affects the correctness of this property\n * because the decoding procedure masks it.\n *\n * ```repl\n * :check encodePartiallyInvertsDecode\n * ```\n *\/\nencodePartiallyInvertsDecode : [32][8] -> Bit\nproperty encodePartiallyInvertsDecode x = ~((x ! 0) @ 0) ==>\n    encodeUCoordinate `{255} (decodeUCoordinate `{255} x) == x\n\n\/**\n * `decodeUCoordinate` inverts `encodeUCoordinate`.\n * Since the `u` coordinates are represented as members of `Z p`,\n * there is no restriction on this property.\n *\n * ```repl\n * :check decodeInvertsEncode\n * ```\n *\/\ndecodeInvertsEncode : Z p -> Bit\nproperty decodeInvertsEncode x =\n    decodeUCoordinate `{255} (encodeUCoordinate `{255, 32} x) == x\n\n\/**\n * Test vector derived from running the Python code\n * in Section 5 of [rfc7748].\n *\n * ```repl\n * :prove decodeUCoordinateTest\n * ```\n *\/\nproperty decodeUCoordinateTest = decodeUCoordinate `{6} \"hello world\" == x\n    where\n        x = 40\n\n\/**\n * Scalars are assumed to be randomly generated bytes.\n * For curve 25519, we need 32 bytes, and we mask\n * the final bit (i.e., assume that it is zero).\n *\n * Assume the array is already little endian.\n *\n * Reference:\n * [rfc7748] Section 5.\n *\/\ndecodeScalar25519 : [32][8] -> Z p\ndecodeScalar25519 k0 = decodeLittleEndian `{255} k3\n    where\n        k1 = update k0 0 ((k0@0) && 248)\n        k2 = update k1 31 ((k1@31) && 127)\n        k3 = update k2 31 ((k2@31) || 64)\n\n\/**\n * Test the scalar decode using a value derived from\n * the Python code in section 5.\n *\n * ```repl\n * :prove decodeScalarOk\n * ```\n *\n * Reference:\n * [rfc7748] Section 5.\n *\/\nproperty decodeScalarOk = decodeScalar25519 (repeat 0x61) == x\n    where\n        x = 44046402572626160612103472728795008085361523578694645928734845681441465000288\n\n\/**\n * The function `X25519(k, u)`, described in Section 5.\n * Assume that the input arrays are already little endian.\n *\n * Reference:\n * [rfc7748] Section 5.\n *\/\nX25519 : [32][8] -> [32][8] -> [32][8]\nX25519 kb ub = result\n    where\n                a24 = 121665\n        \/\/ decode the byte array `ub` as a `Z p` element.\n        \/\/ decode scalar `kb` as a 255-bit bitvector.\n        k = ZtoBV (decodeScalar25519 kb)\n        u = decodeUCoordinate `{255} ub\n                loop (x1, x2, z2, x3, z3, swap) t = (x1', x2', z2', x3', z3', swap')\n            where\n                k_t = (k >> t) && 1\n                swapt = swap ^ k_t\n                (x2s, x3s) = cswap' swapt (x2, x3)\n                (z2s, z3s) = cswap' swapt (z2, z3)\n                swap' = zext [k_t ! 0]\n\n                A = x2s + z2s\n                AA = A^^2\n                B = x2s - z2s\n                BB = B^^2\n                E = AA - BB\n                C = x3s + z3s\n                D = x3s - z3s\n                DA = D * A\n                CB = C * B\n                x1' = x1\n                x3' = (DA + CB) ^^ 2\n                z3' = x1 * (DA - CB) ^^ 2\n                x2' = AA * BB\n                z2' = E * (AA + a24 * E)\n\n                (x1l, x2l, z2l, x3l, z3l, swapl) = foldl loop (u, 1 : Z p, 0 : Z p, u, 1 : Z p, 0 : [255]) (reverse [0..255-1])\n\n                (x2ls, x3ls) = cswap' swapl (x2l, x3l)\n        (z2ls, z3ls) = cswap' swapl (z2l, z3l)\n\n                rzp = x2ls * (z2ls ^^ `(p - 2))\n\n        \/\/ result as byte array\n        result = encodeUCoordinate `{255, 32} rzp\n\n\/**\n * \"Conditional swap\".\n * This function must be constant time in a production implementation.\n * Cryptol cannot enforce this.\n *\/\ncswap : [255] -> (Z p, Z p) -> (Z p, Z p)\ncswap swap (x, y) = (BVtoZ `{p} (dummy ^ x_2), BVtoZ `{p} (dummy ^ x_3))\n    where\n        mask : [255] -> [255]\n        mask z = 0 - z\n\n        (x_2, x_3) = (ZtoBV x, ZtoBV y)\n        dummy = mask swap && (x_2 ^ x_3)\n\n\/**\n * Faster conditional swap that will definitely not\n * be constant time (branches on the bits of the scalar)\n * but faciliates slightly faster test execution.\n *\n * Performance can be improved further by using `Bit` instead `[255]`,\n * but the same constant time issue remains.\n *\/\ncswap' : [255] -> (Z p, Z p) -> (Z p, Z p)\ncswap' swap (x, y) = if swap == 0 then (x, y) else (y, x)\n\n\/**\n * The swap implementations are equivalent.\n * ```\n * :check cswapEq\n * ```\n *\/\ncswapEq s x = elem s [0, 1] ==> cswap s x == cswap' s x\n\n\/**\n * `cswap False` is the identity.\n *\n * ```repl\n * :check cswapFalse\n * ```\n *\/\nproperty cswapFalse x = cswap 0 x == x\n\n\/**\n * `cswap True` is an involution.\n *\n * ```repl\n * :check cswapTrue\n * ```\n *\/\nproperty cswapTrue y x = y > 0 ==> cswap y (cswap y x) == x\n\n\/**\n * Test vector from section 5.2.\n *\n * ```repl\n * :prove testVector1\n * ```\n *\n * Reference:\n * [rfc7748] Section 5.2.\n *\/\nproperty testVector1 = X25519 k u == u'\n    where\n        k = split 0xa546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4\n        u = split 0xe6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c\n        u' = split 0xc3da55379de9c6908e94ea4df28d084f32eccf03491c71f754b4075577a28552\n\n\/**\n * Test vector from Section 5.2.\n *\n * ```repl\n * :prove testVector2\n * ```\n *\n * Reference:\n * [rfc7748] Section 5.2.\n *\/\nproperty testVector2 = X25519 k u == u'\n    where\n        k = split 0x4b66e9d4d1b4673c5ad22691957d6af5c11b6421e0ea01d42ca4169e7918ba0d\n        u = split 0xe5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a493\n        u' = split 0x95cbde9476e8907d7aade45cb4b873f88b595a68799fa152e6f8f7647aac7957\n\n\/**\n * Iterative testing.\n *\/\niterTest : {n} (fin n) => [32][8] -> [32][8] -> [32][8]\niterTest k u\n    | n == 0 => k\n    | n >= 1 => iterTest `{n-1} (X25519 k u) k\n\n\/**\n * An \"iterative\" test vector.\n *\n * ```repl\n * :prove mcTv1\n * ```\n *\/\nproperty mcTv1 = iterTest `{1} k u == r\n    where\n        k = split 0x0900000000000000000000000000000000000000000000000000000000000000\n        u = k\n        r = split 0x422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079\n\n\/**\n * An \"iterative\" test vector.\n *\n * ```repl\n * :prove mcTv2\n * ```\n *\/\nproperty mcTv2 = iterTest `{1000} k u == r\n    where\n        k = split 0x0900000000000000000000000000000000000000000000000000000000000000\n        u = k\n        r = split 0x684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51\n\n\/*\n * Cryptol is too slow to efficiently\n * execute the \"iterative\" test vector\n * for a million iterations.\n *\n * We include the test vector for\n * documentary purposes, and omit the\n * property keyword so it is not executed\n * by `check`, `prove`, etc...\n *\/\nmcTv3 = iterTest `{1000} k u == r\n    where\n        k = split 0x0900000000000000000000000000000000000000000000000000000000000000\n        u = k\n        r = split 0x7c3911e0ab2586fd864497297e575e6f3bc601c0883c30df5f4dd2d24f665424\n\/**\n * Cryptol uses a big-endian convention when\n * using intrinsics such as `toInteger`.\n * This version of X25519 assumes that the byte-arrays\n * are big-endian, and converts the arguments\n * to little endian.\n *\/\nX25519' k u = reverse (X25519 k' u')\n    where\n        k' = reverse k\n        u' = reverse u\n\n\/**\n * Check that the conversion is okay.\n *\n * ```repl\n * :check bigOk\n * ```\n *\/\nproperty bigOk k u = reverse (X25519 (reverse k) (reverse u)) == X25519' k u\n\n\/**\n * Generate the public key `X25519(a, 9)` where\n * `9` is the `u` coordinate of the base point\n * and `a` is the secret value.\n *\n * Reference:\n * [rfc7748] Section 6.1.\n *\n * ```repl\n * let a = split `{32} 0x77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a\n * let b = split `{32} 0x5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb\n * let Ga = split `{32} 0x8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a\n * let Gb = split `{32} 0xde9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f\n * let K = split `{32} 0x4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742\n * :prove DH_sender a == Ga\n * :prove DH_sender b == Gb\n * :prove X25519 a Gb == K\n * :prove X25519 b Ga == K\n * ```\n *\/\nDH_sender : [32][8] -> [32][8]\nDH_sender a = X25519 a (reverse (split Gu'))\n    where\n        \/\/ must be little-endian.\n        \/\/ Cryptol `fromInteger` semantics will\n        \/\/ make a big-endian bitvector.\n        Gu' = (fromInteger `Gu) : [32 * 8]\n\n\/**\n * Generate the shared value `K` given the received value `Gr`\n * and the secret `a`.\n *\/\nDH_receiver : [32][8] -> [32][8] -> [32][8]\nDH_receiver a Gr = X25519 a Gr\n\n\n\/**\n * Diffie-Hellman produces a shared secret.\n *\n * ```repl\n * :check DHSharedSecret\n * ```\n *\/\nproperty DHSharedSecret a b = DH_receiver a Gb == DH_receiver b Ga\n    where\n        Ga = DH_sender a\n        Gb = DH_sender b\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/PFEC.cry","filetype":"cry","content":"module Common::EC::PrimeField::PFEC where\n\nimport Common::utils(half, mul2, mul3, mul4, mul8, ZtoBV)\n\nparameter\n    \/**\n     * Field size `P`.\n     * P must be an odd prime power and is not divisible by 3.\n     * I don't think there's a way to enforce \"prime power\" in the type\n     * constraint, but for the NIST curves, every `P` itself is prime,\n     * so we use the simpler constraint `prime P`.\n     * [SP-800-186] Section 2.1.1.\n     *\/\n    type P : #\n    type constraint (fin P, prime P, P >= 5, P % 2 == 1, P % 3 != 0)\n\n    \/**\n     * Order of the base point `G = (Gx, Gy)`. This must be prime.\n     * [SP-800-186] Section 2.1.1.\n     *\/\n    type n' : #\n    type constraint (fin n', prime n', n' < P)\n\n    \/**\n     * Coefficients that define the curve.\n     * For a curve in short-Weierstrass form, the equation is\n     * `y^2 = x^3 + ax + b`.\n     * See the `curveCoefficientsAreValid` property.\n     * [SP-800-186] Section 2.1.1.\n     *\/\n    b : Z P\n\n    \/**\n     * Coordinates of the base point `G = (Gx, Gy)`.\n     *\/\n    Gx : Z P\n    Gy : Z P\n\n\/**\n * Order of the base point `G`.\n *\n * This makes the private functor parameter publicly available.\n *\/\ntype n = n'\n\n\/**\n * Modulus of the field over which the curve is defined.\n *\n * This is called `q` for the `ECInterface`, which is designed to support\n * curves that are not necessarily over prime order fields.\n *\/\ntype q = P\n\n\/**\n * Coefficient that defines the curve.\n * For a curve in short-Weierstrass form, the equation is\n * `y^2 = x^3 + ax + b`.\n * See the `curveCoefficientsAreValid` property.\n * [SP-800-186] Section 2.1.1.\n *\n * Due to restrictions on the underlying elliptic curve operations, the\n * a-coordinate must be -3. This is the case for all NIST-standardized\n * prime order fields in short-Weierstrass form.\n *\/\nprivate a = -3 : Z P\n\n\/**\n * Cofactor for the curve.\n *\n * The order of the curve is defined as `h * n`, where `h` is small\n * and `n`, the order of the base point `G`, is prime. If `h` is not\n * 1, then the base point does not generate the entire curve.\n *\n * This is fixed to 1 for all the NIST-standardized prime order fields\n * in short-Weierstrass form. It's not necessarily true for all reasonable\n * elliptic curves.\n *\/\nh = 1 : Integer\n\n\n\/**\n * A point that satisfies the curve equation `y^2 = x^3 + ax + b`.\n * Sometimes this is called an \"affine\" representation.\n * [SP-800-186] Section 2.1.1.\n *\/\nenum Point = Infinity | Affine (Z P) (Z P)\n\n\/**\n * Check equality of two affine points.\n *\n * I don't know if this is explicitly specified anywhere because it's just\n * by definition.\n *\/\naffineEq : Point -> Point -> Bool\naffineEq p1 p2 = case p1 of\n    Infinity -> case p2 of\n        Infinity -> True\n        _ -> False\n    Affine x y -> case p2 of\n        Affine x' y' -> (x == x') && (y == y')\n        _ -> False\n\n\/**\n * The EC interface uses `pointEq` to compare equality on two points, since it\n * isn't prescriptive about what its point type is, exactly.\n *\/\npointEq = affineEq\n\n\/**\n * Check that a given point is on the curve -- either it is the point at\n * infinity or it satisfies the curve equation.\n * [SP-800-186] Section 2.1.1.\n * [SEC1-v2] Section 2.2.1.\n * [MATH-2008] Routine 2.2.5.\n *\n * Note: by definition, the coordinates of an affine point will be correctly\n * formed (e.g. in the range [0, P-1]), because they are of type `Z P`.\n *\/\nisValid : Point -> Bit\nisValid point = case point of\n    Infinity -> True\n    Affine x y -> (y ^^ 2 == x ^^ 3 + a * x + b)\n\n\/**\n * Indicate whether a point is the point at infinity.\n *\/\nisInfinity : Point -> Bool\nisInfinity point = case point of\n    Infinity -> True\n    _ -> False\n\n\/**\n * Convenient `Point` representation of the base point `G`.\n *\/\nG = Affine Gx Gy : Point\n\n\/**\n * For curves in short-Weierstrass form, the following inequality must hold:\n *      4a^3 + 27b^2 != 0\n * [SP-800-186] Section 2.1.1.\n *\n * ```repl\n * :prove curveCoefficientsAreValid\n * ```\n *\/\nproperty curveCoefficientsAreValid = (4 * a^^3 + _27 * b^^2 != 0)\n    where\n        _27 : Z P\n        _27 = fromInteger 27\n\n\/**\n * G must be of order `n`.\n * ```repl\n * :prove gOrderIsN\n * ```\n *\/\nproperty gOrderIsN = affineEq G ((`n + 1) ~* G)\n\n\/**\n * `G` must be a valid point on the curve.\n * ```repl\n * :prove gIsValid\n * ```\n *\/\nproperty gIsValid = isValid G\n\n\/**\n * Add two elliptic curve points together.\n *\n * Assumption: The `Point`s passed as parameters must be valid EC points,\n * otherwise this operation makes no sense. Use `isValid` to make sure\n * the inputs are valid before calling this function.\n *\/\nadd : Point -> Point -> Point\nadd p1 p2 = to_affine (ec_full_add (to_projective p1) (to_projective p2))\n\n\/**\n * Addition is a closed operation: the sum of two valid elliptic curve\n * points is also on the curve.\n * ```repl\n * :check addIsClosed\n * ```\n *\/\nproperty addIsClosed k1 k2 = isValid (add p1 p2)\n    where\n        p1 = validPointFromK k1\n        p2 = validPointFromK k2\n\n\/**\n * Double an elliptic curve point.\n *\n * Assumption: The `Point` passed as a parameter must be a valid EC point,\n * otherwise this operation makes no sense. Use `isValid` to make sure\n * the input is valid before calling this function.\n *\/\ndouble : Point -> Point\ndouble p = to_affine (ec_double (to_projective p))\n\n\/**\n * Doubling is a closed operation: the double of a valid elliptic\n * curve point is also on the curve.\n * ```repl\n * :check doubleIsClosed\n * ```\n *\/\nproperty doubleIsClosed k = isValid (double p)\n    where\n        p = validPointFromK k\n\n\/**\n * Subtract one curve point from another.\n *\n * Assumption: The `Point`s passed as parameters must be valid EC points,\n * otherwise this operation makes no sense. Use `isValid` to make sure\n * the inputs are valid before calling this function.\n *\/\nsub : Point -> Point -> Point\nsub p1 p2 = to_affine (ec_full_sub (to_projective p1) (to_projective p2))\n\n\/**\n * Subtraction is a closed operation: the difference of two valid elliptic\n * curve points is also on the curve.\n * ```repl\n * :check subIsClosed\n * ```\n *\/\nproperty subIsClosed k1 k2 = isValid (sub p1 p2)\n    where\n        p1 = validPointFromK k1\n        p2 = validPointFromK k2\n\n\/**\n * Scalar multiplication of a curve point.\n\n * Scalar multiplication is the process of adding `P` to itself `k` times\n * for an integer `k`.\n *\n * [SEC1-v2] Section 2.2.1 doesn't explicitly specify an algorithm, but it\n * notes that it can be computed efficiently using the addition rule and a\n * variant of the double-and-add algorithm.\n * In this implementation, we use a variant from [MATH-2008] (see `ec_mult`).\n *\n * Assumption: The `Point` passed as a parameter must be a valid EC point,\n * otherwise this operation makes no sense. Use `isValid` to make sure\n * the input is valid before calling this function.\n *\/\nscmul : Integer -> Point -> Point\nscmul k p = to_affine (ec_mult (fromInteger k) (to_projective p))\n\n(~*) = scmul  \/\/ infix form of operator\n\n\/**\n * Scalar multiplication is a closed operation: the result must also be on the\n * curve.\n * ```repl\n * :check scmulIsClosed\n * ```\n *\/\nproperty scmulIsClosed m = isValid (m ~* G)\n\n\/**\n * Scalar multiplication is commutative.\n * ```repl\n * :check scmul_commutes\n * ```\n *\/\nproperty scmul_commutes m m' = affineEq (m ~* (m' ~* G)) (m' ~* (m ~* G))\n\n\/**\n * Compute twin multiplication.\n *\/\ntwin_mul : Integer -> Point -> Integer -> Point -> Point\ntwin_mul c P d Q = to_affine (ec_twin_mult c' P' d' Q')\n    where\n        [c', d'] = [fromInteger   x | x <- [c, d]]\n        [P', Q'] = [to_projective p | p <- [P, Q]]\n\n\/**\n * Extract the x-coordinate `Z P` value, if the point is not the point at\n * infinity.\n *\/\nxCoord: Point -> Option (Z P)\nxCoord p = case p of\n    Infinity -> None\n    Affine x _ -> Some x\n\n\nprivate\n    type ProjectivePoint = { x : Z P, y : Z P, z : Z P }\n    InfinityProjective = { x=1, y=1, z=0 }\n    Zero = { x=0, y=0, z=0 }\n\n    \/**\n     * Convert from an affine to a projective representation.\n     * [MATH-2008] Routine 2.2.1.\n     *\/\n    to_projective : Point -> ProjectivePoint\n    to_projective p = case p of\n        Infinity -> InfinityProjective\n        Affine x y -> { x=x, y=y, z=1 }\n\n    \/**\n     * Convert from a projective to an affine representation.\n     * [MATH-2008] Routine 2.2.2.\n     *\/\n    to_affine : ProjectivePoint -> Point\n    to_affine p =\n        \/\/ The point at infinity does not have an affine representation.\n        if p.z == 0 then Infinity\n        \/\/ Note the parentheses here.\n        \/\/ See Note [Limit scope of recip in where clauses].\n        else (Affine (lambda ^^2 * p.x) (lambda ^^3 * p.y)\n               where\n                 lambda = recip p.z)\n\n\n    \/\/ The twin affine function depends on the set of four points: two\n    \/\/ arbitrary points S and T, their sum SpT, and their difference SmT.\n    type TwinPoints = {\n        A: ProjectivePoint,\n        B: ProjectivePoint,\n        C: ProjectivePoint,\n        D: ProjectivePoint\n    }\n    \/**\n     * Optimized routine to affinify and projectify four points at once\n     * (or do nothing, if any of the points are the point at infinity).\n     *\n     * This optimization is designed for use in `ec_twin_mult` and should not\n     * be used in other settings without checking that its behavior is suitable.\n     * [MATH-2008] Section 2.2, Note 8.\n     *\/\n    twin_normalize: TwinPoints -> TwinPoints\n    twin_normalize { A=A, B=B, C=C, D=D } =\n        \/\/ We can't compute twin normalization on the point at infinity\n        \/\/ because it doesn't have an inverse. Instead, skip the normalization\n        \/\/ step (the algorithm will still work!)\n        if (A.z == 0) || (B.z == 0) || (C.z == 0) || (D.z == 0) then\n            { A=A, B=B, C=C, D=D }\n        else\n          \/\/ Note the parentheses here.\n          \/\/ See Note [Limit scope of recip in where clauses].\n          ({\n             A = normalize_from_inv A a_inv,\n             B = normalize_from_inv B b_inv,\n             C = normalize_from_inv C c_inv,\n             D = normalize_from_inv D d_inv\n           } where\n               ab = A.z * B.z\n               cd = C.z * D.z\n               abc = ab * C.z\n               abd = ab * D.z\n               acd = A.z * cd\n               bcd = B.z * cd\n               abcd = ab * cd\n               e = recip abcd\n               a_inv = e * bcd\n               b_inv = e * acd\n               c_inv = e * abd\n               d_inv = e * abc\n               normalize_from_inv p inv =\n                   to_projective (Affine (inv ^^2 * p.x) (inv ^^3 * p.y)))\n\n\n    \/**\n     * This checks that the normalization function doesn't break on normalized\n     * points. The actual, more interesting check would be to generate random\n     * projective points (in non-normal representation, e.g. where the z coord\n     * is not 1) on the curve and run those through `twin_normalize` but there\n     * is not an obvious efficient way to sample such points.\n     *\n     * ```repl\n     * :set tests=25\n     * :check normalizeWorksOnNormalPoints\n     * :prove normalizeWorksOnNormalPoints 0 0 0 0\n     * ```\n     *\/\n    property normalizeWorksOnNormalPoints k1 k2 k3 k4 = all_are_normal && all_match\n        where\n            p1 = to_projective (validPointFromK k1)\n            p2 = to_projective (validPointFromK k2)\n            p3 = to_projective (validPointFromK k3)\n            p4 = to_projective (validPointFromK k4)\n\n            input = {A=p1, B=p2, C=p3, D=p4}\n            out = twin_normalize input\n\n            \/\/ If any of the multipliers is 0, the resulting point\n            \/\/ will be the point at infinity.\n            \/\/ In this case, `twin_normalize` will do nothing...\n            any_are_infinity = any (\\k -> k == 0) [k1, k2, k3, k4]\n\n            \/\/ ...and the point at infinity always has a z-coordinate of 0.\n            \/\/ So, this check for \"normalcy\" is only relevant if we're not\n            \/\/ dealing with a point at infinity.\n            all_are_normal = any_are_infinity ||\n                all (\\p -> p.z == 1) [out.A, out.B, out.C, out.D]\n\n            \/\/ In either case, our `toProjective` function produces points in normal\n            \/\/ form, so `twin_normalize` shouldn't actually change the representation.\n            all_match = (out.A == p1) && (out.B == p2)\n                && (out.C == p3) && (out.D == p4)\n\n    \/**\n     * Double an elliptic curve point.\n     * [MATH-2008] Routine 2.2.6.\n     *\n     * Requires that curve parameter `a = -3 mod P`\n     *\/\n    ec_double : ProjectivePoint -> ProjectivePoint\n    ec_double S =\n      if S.z == 0 then InfinityProjective \/* 5: r <- (1,1,0) and return *\/\n      else {x = r18, y = r23, z = r13}\n      where\n          r7  = S.z ^^ 2                \/*  7: t4 <- (t3)^2 *\/\n          r8  = S.x - r7                \/*  8: t5 <- t1 - t4 *\/\n          r9  = S.x + r7                \/*  9: t4 <- t1 + t4 *\/\n          r10 = r9 * r8                 \/* 10: t5 <- t4 * t5 *\/\n          r11 = mul3 r10                \/* 11: t4 <- 3 * t5 *\/\n          r12 = S.z * S.y               \/* 12: t3 <- t3 * t2 *\/\n          r13 = mul2 r12                \/* 13: t3 <- 2 * t3 *\/\n          r14 = S.y ^^ 2                \/* 14: t2 <- (t2)^2 *\/\n          r15 = S.x * r14               \/* 15: t5 <- t1 * t2 *\/\n          r16 = mul4 r15                \/* 16: t5 <- 4 * t5 *\/\n          r17 = r11 ^^ 2                \/* 17: t1 <- (t4)^2 *\/\n          r18 = r17 - (mul2 r16)        \/* 18: t1 <- t1 - 2 * t5 *\/\n          r19 = r14 ^^ 2                \/* 19: t2 <- (t2)^2 *\/\n          r20 = mul8 r19                          r21 = r16 - r18                         r22 = r11 * r21                         r23 = r22 - r20                   \/**\n     * Addition of two elliptic curve points.\n     *\n     * This will fail in the case where either of the input points are the\n     * point at infinity or if the two input points are the same (if they\n     * are the same, will return a default value of (0,0,0)).\n     * [MATH-2008] Routine 2.2.7.\n     *\/\n    ec_add : ProjectivePoint -> ProjectivePoint -> ProjectivePoint\n    ec_add S T =\n        if r13 == 0 then\n            if r14 == 0 then Zero                   else InfinityProjective             else\n            {x = r32, y = r37, z = r27} \/* 38: Rx <- t1; Ry <- t2, Rz <- t3 *\/\n        where\n            (t1, t2, t3, t4, t5, t6) = if T.z == 1 then\n                \/\/ 1: set t6 = 1 to make L25 work\n                (S.x, S.y, S.z, T.x, T.y, T.z)\n                else (r5, r7, S.z, T.x, T.y, r3)\n\n            r3 = T.z                \/* 3: t6 <- T_z *\/\n            r4 = r3 ^^ 2            \/* 4: t7 <- t6^2 *\/\n            r5 = S.x * r4           \/* 5: t1 <- t1 * t7 *\/\n            r6 = r3 * r4            \/* 6: t7 <- t6 * t7 *\/\n            r7 = S.y * r6           \/* 7: t2 <- t2 * t7 *\/\n\n            r9  = t3 ^^ 2           \/*  9: t7 <- (t3)^2 *\/\n            r10 = t4 * r9           \/* 10: t4 <- t4 * t7 *\/\n            r11 = t3 * r9           \/* 11: t7 <- t3 * t7 *\/\n            r12 = t5 * r11                      r13 = t1 - r10                      r14 = t2 - r12                      r22 = mul2 t1 - r13                 r23 = mul2 t2 - r14                 r25 = t3 * t6           \/* 25: t3 <- t3 * t6 if Tz =\/= 1.\n                                       If T.z == 1, then t6 == 1 and this is a\n                                       no-op *\/\n\n            r27 = r25 * r13                      r28 = r13 ^^ 2                       r29 = r13 * r28          \/* 29: t4 <- t4 * t7 *\/\n            r30 = r22 * r28          \/* 30: t7 <- t1 * t7 *\/\n            r31 = r14 ^^ 2           \/* 31: t1 <- (t5)^2 *\/\n            r32 = r31 - r30          \/* 32: t1 <- t1 - t7 *\/\n            r33 = r30 - (mul2 r32)   \/* 33: t7 <- t7 - 2*t1 *\/\n            r34 = r14 * r33          \/* 34: t5 <- t5 * t7 *\/\n            r35 = r23 * r29          \/* 35: t4 <- t2 * t4 *\/\n            r36 = r34 - r35          \/* 36: t2 <- t5 - t4 *\/\n            r37 = half r36               \/**\n     * Checked addition of two elliptic curve points.\n     *\n     * This method handles the cases where either of the input points are the\n     * point at infinity or if the input points are the same.\n     * [MATH-2008] Routine 2.2.8.\n     *\/\n    ec_full_add : ProjectivePoint -> ProjectivePoint -> ProjectivePoint\n    ec_full_add S T =\n        if S.z == 0 then T\n        | T.z == 0 then S\n        | R == {x = 0, y = 0, z = 0} then ec_double S\n        else R\n        where R = ec_add S T\n\n    \/**\n     * Checked subtraction of two elliptic curve points.\n     *\n     * This method handles the cases where either of the input points are the\n     * point at infinity or if the input points are the same.\n     * [MATH-2008] Routine 2.2.8.\n     *\/\n    ec_full_sub : ProjectivePoint -> ProjectivePoint -> ProjectivePoint\n    ec_full_sub S T = R\n        where\n            U = {x = T.x, y = -T.y, z = T.z}\n            R = ec_full_add S U\n\n    \/**\n     * Scalar multiplication on projective points\n     * [MATH-2008] Routine 2.2.10.\n     *\n     * The routine requires that 0 <= d < P. We enforce this constraint by\n     * setting the type of `d` to be `Z P`, then converting it to an integer\n     * for all actual uses.\n     *\/\n    ec_mult : Z P -> ProjectivePoint -> ProjectivePoint\n    ec_mult d S =\n        if d == 0 then to_projective Infinity\n        | d == 1 then S\n        | S.z == 0 then to_projective Infinity\n        else Rs ! 1 \/* the iteration stops at 1, not 0 *\/\n        where\n            S' = if S.z != 1 then to_projective (to_affine S) else S\n            \/\/ Get bits of `d` and `3d`. The width of `ks` is set to be large\n            \/\/ enough to hold the full width of `hs`.\n            ks = ZtoBV d : [width P + 2]\n            hs = 3 * ks\n\n            \/\/ The specified routine initializes R = S and skips the first\n            \/\/ high-bit of `hs`, assuming that it's 1. Since we're a little\n            \/\/ floppy with our bitwise conversion, we'll start at 0 and\n            \/\/ iterate over all the bits.\n            Rs = [ InfinityProjective ] #\n                [ if hi && ~ki then ec_full_add doubleR S\n                  | ~hi && ki then ec_full_sub doubleR S\n                  else doubleR\n                  where doubleR = ec_double Ri\n                | ki <- ks | hi <- hs | Ri <- Rs ]\n\n    \/**\n     * Addition of two elliptic curve points on a prime-field curve with\n     * coefficient 'a'. Note 'b' is unused.\n     * [SP-800-186] Appendix A.1.1.\n     * [SEC1-v2] Section 2.2.1.\n     *\n     * This uses the less-efficient affine representation.\n     *\/\n    affine_add : Point -> Point -> Point\n    affine_add point1 point2 = case point1 of\n        Infinity -> point2\n        Affine x1 y1 -> case point2 of\n            Infinity -> point1\n            Affine x2 y2 -> if (x1 == x2) && (y1 == -y2) then Infinity\n                else Affine x y\n                where  \/\/ all arithmetic operations are mod p\n                    x = lambda ^^ 2 - x1 - x2\n                    y = lambda * (x1 - x) - y1\n                    lambda = if x1 == x2 then (3 * x1 ^^ 2 + a) %\/ (2 * y1)\n                        else (y2 - y1) %\/ (x2 - x1)\n\n\n    \/**\n     * Compute a valid curve point from a random `k` and the base point `G`.\n     *\n     * `k` is in the range [0, h * n), where `h * n` is the order of the\n     * elliptic curve.\n     * All the standardized NIST prime-order curves have (as the name suggests)\n     * prime order and cofactor 1.\n     *\n     * NB: If the cofactor `h` is not 1, this function will not derive points\n     * on the curve uniformly. When the cofactor is 1, that means the group is\n     * cyclic and can be generated by a single point. When it's not 1, the group\n     * has a large cyclic subgroup that is generated by `G`, but it's not the\n     * entire group.\n     *\n     * The scalar multiplication specification specifically allows\n     * multiplication by `k` in the range [0, P), hence the conversion.\n     *\/\n    validPointFromK : Z n' -> Point\n    validPointFromK k = to_affine (ec_mult _k (to_projective G))\n        where\n            _k : Z P\n            _k = fromInteger (fromZ k)\n\n    \/**\n     * Proof that the affine and projective versions of addition are equivalent.\n     * This doesn't test the point at infinity.\n     *\n     * ```repl\n     * :check addsAreEquivalent\n     * ```\n     *\/\n    addsAreEquivalent : Z n' -> Z n' -> Bool\n    property addsAreEquivalent k1 k2 =\n        affineEq (affine_add p1 p2) (to_affine full_sum)\n        where\n            p1 = validPointFromK k1\n            p2 = validPointFromK k2\n            full_sum = ec_full_add (to_projective p1) (to_projective p2)\n\n    \/**\n     * Proof that both addition properties work correctly for the point at infinity.\n     *\n     * ```repl\n     * :check addsBehaveCorrectlyAtInfinity\n     * ```\n     *\/\n    addsBehaveCorrectlyAtInfinity : Z n' -> Bool\n    property addsBehaveCorrectlyAtInfinity k =\n        oo && ok && ko && oo' && ok' && ko'\n        where\n            \/\/ Compute infinity identies in affine form.\n            point = validPointFromK k\n            oo = affineEq Infinity (affine_add Infinity Infinity)\n            ok = affineEq point (affine_add Infinity point)\n            ko = affineEq point (affine_add point Infinity)\n\n            \/\/ Compute infinity identies in projective form.\n            point' = to_projective point\n            oo' = InfinityProjective ==\n                ec_full_add InfinityProjective InfinityProjective\n            ok' = point' == ec_full_add InfinityProjective point'\n            ko' = point' == ec_full_add point' InfinityProjective\n\n\n    \/**\n     * Twin multiplication computes `[d0]S + [d1]T`.\n     * [MATH-2008] Routine 2.2.12.\n     *\n     * [MATH-2008] Section 2.2, Note 8 describes an optimization that can be\n     * made by converting the input points between affine and projective\n     * representations. That is not included here.\n     *\/\n    ec_twin_mult : Z P -> ProjectivePoint -> Z P -> ProjectivePoint -> ProjectivePoint\n    ec_twin_mult d0 S d1 T = (states!0).0\n        where\n            SpT = ec_full_add S T                                  SmT = ec_full_sub S T                                  \/\/ [MATH-2008] Section 2.2, Note 8 describes an optimization to\n            \/\/ speed up the arithmetic in L19-26 by normalizing (convert to\n            \/\/ affine and then back to projective) the points.\n            { A=S', B=T', C=SpT', D=SmT' } =\n                twin_normalize { A=S, B=T, C=SpT, D=SmT }\n            e0s = ZtoBV d0 : [max 4 (width P)]                     e1s = ZtoBV d1 : [max 4 (width P)]                     c   = [[False, False] # take e0s,                             [False, False] # take e1s] : [2][6]\n            states = [(InfinityProjective, c)] #                       [ (Rk', [c0', c1'])\n                    where\n                    \/\/ Lines 8-13.\n                    \/\/ `tail ci` uses Cryptol's built-in bit vector\n                    \/\/ representation to reconstruct `hi` as in L9.\n                    h0 = if c0@0 then 31 - tail c0 else tail c0\n                    h1 = if c1@0 then 31 - tail c1 else tail c1\n                                        u0 = if h0 < (F h1) then 0 else if c0@0 then -1 else 1 : [2]\n                    u1 = if h1 < (F h0) then 0 else if c1@0 then -1 else 1 : [2]\n                    \/\/ Line 17.\n                    \/\/ The absolute value on bits is computed as (u_i != 0).\n                    c0' = [(u0!=0) ^ c0@1] # drop c0 # [e0k]\n                    c1' = [(u1!=0) ^ c1@1] # drop c1 # [e1k]\n                                        RkDouble = ec_double Rk\n                                        Rk' = if (u0 == -1) && (u1 == -1) then\n                            ec_full_sub RkDouble SpT'\n                        | (u0 == -1) && (u1 ==  0) then ec_full_sub RkDouble S'\n                        | (u0 == -1) && (u1 ==  1) then\n                            ec_full_sub RkDouble SmT'\n                        | (u0 ==  0) && (u1 == -1) then ec_full_sub RkDouble T'\n                        | (u0 ==  0) && (u1 ==  1) then ec_full_add RkDouble T'\n                        | (u0 ==  1) && (u1 == -1) then\n                            ec_full_add RkDouble SmT'\n                        | (u0 ==  1) && (u1 ==  0) then ec_full_add RkDouble S'\n                        | (u0 ==  1) && (u1 ==  1) then\n                            ec_full_add RkDouble SpT'\n                        else RkDouble\n                | (Rk, [c0, c1]) <- states\n                \/\/ Line 7: Iterate through the eis, after dropping the four\n                \/\/ bits we already used to initialize `c` and padding with 0.\n                | e0k <- drop`{4} e0s # (zero : [5])\n                | e1k <- drop`{4} e1s # (zero : [5]) ]\n\n            \/\/ An auxiliary routine.\n            \/\/ [MATH-2008] Routine 2.2.11.\n            F : [5] -> [5]\n            F t = if (18 <= t) && (t < 22) then 9\n                | (14 <= t) && (t < 18) then 10\n                | (22 <= t) && (t < 24) then 11\n                | (4 <= t)  && (t < 12) then 14\n                else 12\n\n    \/**\n     * Checks that twin multiplication works as expected. Note that a given\n     * point can have multiple projective representations, so we have to\n     * check equality in the affine representation.\n     *\n     * These tests check the general case, the case where the two points `S`\n     * and `T` are the same, and the case where one of the points is the point\n     * at infinity.\n     * ```repl\n     * :check twin_mult_works\n     * :check (\\d0 d1 k -> twin_mult_works d0 k d1 k)\n     * :check (\\d0 d1 k -> twin_mult_works d0 k d1 0)\n     * :check (\\d0 d1 k -> twin_mult_works d0 0 d1 k)\n     * ```\n     *\/\n    property twin_mult_works d0 k0 d1 k1 = affineEq R_plain R_twin\n        where\n            S = to_projective (validPointFromK k0)\n            T = to_projective (validPointFromK k1)\n            R_plain = to_affine (ec_full_add (ec_mult d0 S) (ec_mult d1 T))\n            R_twin = to_affine (ec_twin_mult d0 S d1 T)\n\n    \/**\n    * Calulate x \/ y in a field.\n    * ```repl\n    * :prove  2 %\/ 2 == (1 : Z 3)\n    * ```\n    *\/\n    (%\/) : {a} (Field a) => a -> a -> a\n    (%\/) x y = x * recip y\n\n\/*\nNote [Limit scope of recip in where clauses]\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThere are a small number of places where we call the `recip` function in a\nlocal definition bound by a `where` clause such that the definition is only ever\nused in the `else` branch of an if-expression. For example, in `to_affine` we\nhave:\n\n  to_affine p =\n      if p.z == 0 then Infinity\n      \/\/ Note the explicit parentheses here, which ensures that `lambda` is in\n      \/\/ scope in the `else` branch but *not* the `then` branch.\n      else (Affine (lambda ^^2 * p.x) (lambda ^^3 * p.y)\n             where\n               lambda = recip p.z)\n\nDoing so is not strictly necessary in Cryptol, as Cryptol's lazy evaluation\nwill only evaluate `lambda` if the `else` branch is evaluated. This is solely\ndone for the benefit of compiling to call-by-value languages (e.g., C or Rust),\nas evaluating `lambda` before the `if`-expression would result in a panic when\n`p.z == 0`.\n*\/\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Tests\/P256.cry","filetype":"cry","content":"module Common::EC::PrimeField::Tests::P256 where\nimport Common::EC::PrimeField::Instantiations::P256 as P256\nimport Common::utils(BVtoZ)\n\n\/\/ NB: We haven't implemented the point compression functions yet, but if we\n\/\/ do we can use these test vectors\n\/\/property p256_G_compress = P256::affineEq (P256::compress P256::G)\n\/\/    0x000000036b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\n\/\/property mp_mod_sqrt_256_correct = p256::mp_mod_sqrt_correct\n\nS = P256::Affine (BVtoZ 0xde2444bebc8d36e682edd27e0f271508617519b3221a8fa0b77cab3989da97c9)\n     (BVtoZ 0xc093ae7ff36e5380fc01a5aad1e66659702de80f53cec576b6350b243042a256)\n\nT = P256::Affine (BVtoZ 0x55a8b00f8da1d44e62f6b3b25316212e39540dc861c89575bb8cf92e35e0986b)\n     (BVtoZ 0x5421c3209c2d6c704835d82ac4c3dd90f61a8a52598b9e7ab656e9d8c8b24316)\n\n\/**\n * ```repl\n * :prove sAndTAreValid\n * ```\n *\/\nproperty sAndTAreValid = P256::isValid S && P256::isValid T\n\n\/**\n * ```repl\n * :prove additionVectorPasses\n * ```\n *\/\nproperty additionVectorPasses = P256::affineEq (P256::add S T) R\n  where R = P256::Affine (BVtoZ 0x72b13dd4354b6b81745195e98cc5ba6970349191ac476bd4553cf35a545a067e)\n             (BVtoZ 0x8d585cbb2e1327d75241a8a122d7620dc33b13315aa5c9d46d013011744ac264)\n\n\/**\n * ```repl\n * :prove subtractionVectorPasses\n * ```\n *\/\nproperty subtractionVectorPasses = P256::affineEq (P256::sub S T) R\n  where R = P256::Affine (BVtoZ 0xc09ce680b251bb1d2aad1dbf6129deab837419f8f1c73ea13e7dc64ad6be6021)\n             (BVtoZ 0x1a815bf700bd88336b2f9bad4edab1723414a022fdf6c3f4ce30675fb1975ef3)\n\n\/**\n * ```repl\n * :prove doubleVectorPasses\n * ```\n *\/\nproperty doubleVectorPasses = P256::affineEq (P256::double S) R\n  where R = P256::Affine (BVtoZ 0x7669e6901606ee3ba1a8eef1e0024c33df6c22f3b17481b82a860ffcdb6127b0)\n             (BVtoZ 0xfa878162187a54f6c39f6ee0072f33de389ef3eecd03023de10ca2c1db61d0c7)\n\n\/**\n * ```repl\n * :prove scalarMultVectorPasses\n * ```\n *\/\nproperty scalarMultVectorPasses = P256::affineEq (P256::scmul d S) R\n  where d = toInteger 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        R = P256::Affine (BVtoZ 0x51d08d5f2d4278882946d88d83c97d11e62becc3cfc18bedacc89ba34eeca03f)\n             (BVtoZ 0x75ee68eb8bf626aa5b673ab51f6e744e06f8fcf8a6c0cf3035beca956a7b41d5)\n\n\/**\n * ```repl\n * :prove twinMultVectorPasses\n * ```\n *\/\nproperty twinMultVectorPasses =\n  P256::affineEq R (P256::twin_mul d S e T)\n  where d = toInteger 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        e = toInteger 0xd37f628ece72a462f0145cbefe3f0b355ee8332d37acdd83a358016aea029db7\n        R = P256::Affine (BVtoZ 0xd867b4679221009234939221b8046245efcf58413daacbeff857b8588341f6b8)\n            (BVtoZ 0xf2504055c03cede12d22720dad69c745106b6607ec7e50dd35d54bd80f615275)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Tests\/P192.cry","filetype":"cry","content":"module Common::EC::PrimeField::Tests::P192 where\nimport Common::EC::PrimeField::Instantiations::P192 as P192\nimport Common::utils(BVtoZ)\n\n\/\/ NB: We haven't implemented the point compression functions yet, but if we\n\/\/ do we can use these test vectors\n\/*\nproperty p192_G_compress = P192::affineEq (P192::compress P192::G)\n    0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\nproperty mp_mod_sqrt_192_correct = p192::mp_mod_sqrt_correct\n\nproperty p192_decompress_S = p192::affine_decompress_correct S\nproperty p192_decompress_T = p192::affine_decompress_correct T\n*\/\n\nS = P192::Affine (BVtoZ 0xd458e7d127ae671b0c330266d246769353a012073e97acf8)\n     (BVtoZ 0x325930500d851f336bddc050cf7fb11b5673a1645086df3b)\n\nT = P192::Affine (BVtoZ 0xf22c4395213e9ebe67ddecdd87fdbd01be16fb059b9753a4)\n     (BVtoZ 0x264424096af2b3597796db48f8dfb41fa9cecc97691a9c79)\n\n\/**\n * ```repl\n * :prove sAndTAreValid\n * ```\n *\/\nproperty sAndTAreValid = P192::isValid S && P192::isValid T\n\n\/**\n * ```repl\n * :prove additionVectorPasses\n * ```\n *\/\nproperty additionVectorPasses = P192::affineEq (P192::add S T) R\n  where R = P192::Affine (BVtoZ 0x48e1e4096b9b8e5ca9d0f1f077b8abf58e843894de4d0290)\n             (BVtoZ 0x408fa77c797cd7dbfb16aa48a3648d3d63c94117d7b6aa4b)\n\n\/**\n * ```repl\n * :prove subtractionVectorPasses\n * ```\n *\/\nproperty subtractionVectorPasses = P192::affineEq (P192::sub S T) R\n  where R = P192::Affine (BVtoZ 0xfc9683cc5abfb4fe0cc8cc3bc9f61eabc4688f11e9f64a2e)\n             (BVtoZ 0x093e31d00fb78269732b1bd2a73c23cdd31745d0523d816b)\n\n\/**\n * ```repl\n * :prove doubleVectorPasses\n * ```\n *\/\nproperty doubleVectorPasses = P192::affineEq (P192::double S) R\n  where R = P192::Affine (BVtoZ 0x30c5bc6b8c7da25354b373dc14dd8a0eba42d25a3f6e6962)\n             (BVtoZ 0x0dde14bc4249a721c407aedbf011e2ddbbcb2968c9d889cf)\n\n\/**\n * ```repl\n * :prove scalarMultVectorPasses\n * ```\n *\/\nproperty scalarMultVectorPasses = P192::affineEq (P192::scmul d S) R\n  where d = toInteger 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        R = P192::Affine (BVtoZ 0x1faee4205a4f669d2d0a8f25e3bcec9a62a6952965bf6d31)\n             (BVtoZ 0x5ff2cdfa508a2581892367087c696f179e7a4d7e8260fb06)\n\n\/**\n * ```repl\n * :prove scalarMultVectorPasses2\n * ```\n *\/\nproperty scalarMultVectorPasses2 = P192::affineEq (P192::scmul d S') R\n    where\n        S' = P192::Affine (BVtoZ 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012)\n            (BVtoZ 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811)\n        d = toInteger 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3\n        R = P192::Affine (BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6)\n            (BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477)\n\n\/**\n * ```repl\n * :prove twinMultVectorPasses\n * ```\n *\/\nproperty twinMultVectorPasses =\n  P192::affineEq R (P192::twin_mul d S e T)\n  where d = toInteger 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        e = toInteger 0xc4be3d53ec3089e71e4de8ceab7cce889bc393cd85b972bc\n        R = P192::Affine (BVtoZ 0x019f64eed8fa9b72b7dfea82c17c9bfa60ecb9e1778b5bde)\n            (BVtoZ 0x16590c5fcd8655fa4ced33fb800e2a7e3c61f35d83503644)\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Tests\/P224.cry","filetype":"cry","content":"module Common::EC::PrimeField::Tests::P224 where\nimport Common::EC::PrimeField::Instantiations::P224 as P224\nimport Common::utils(BVtoZ)\n\n\/\/ NB: We haven't implemented the point compression functions yet, but if we\n\/\/ do we can use these test vectors\n\/\/property p224_G_compress = P224::affineEq (P224::compress P224::G)\n\/\/    0x00000002b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\n\/\/property mp_mod_sqrt_224_correct = p224::mp_mod_sqrt_correct\n\n\nS = P224::Affine (BVtoZ 0x6eca814ba59a930843dc814edd6c97da95518df3c6fdf16e9a10bb5b)\n     (BVtoZ 0xef4b497f0963bc8b6aec0ca0f259b89cd80994147e05dc6b64d7bf22)\n\nT = P224::Affine (BVtoZ 0xb72b25aea5cb03fb88d7e842002969648e6ef23c5d39ac903826bd6d)\n     (BVtoZ 0xc42a8a4d34984f0b71b5b4091af7dceb33ea729c1a2dc8b434f10c34)\n\n\/**\n * ```repl\n * :prove sAndTAreValid\n * ```\n *\/\nproperty sAndTAreValid = P224::isValid S && P224::isValid T\n\n\/**\n * ```repl\n * :prove additionVectorPasses\n * ```\n *\/\nproperty additionVectorPasses = P224::affineEq (P224::add S T) R\n  where R = P224::Affine (BVtoZ 0x236f26d9e84c2f7d776b107bd478ee0a6d2bcfcaa2162afae8d2fd15)\n             (BVtoZ 0xe53cc0a7904ce6c3746f6a97471297a0b7d5cdf8d536ae25bb0fda70)\n\n\/**\n * ```repl\n * :prove subtractionVectorPasses\n * ```\n *\/\nproperty subtractionVectorPasses = P224::affineEq (P224::sub S T) R\n  where R = P224::Affine (BVtoZ 0xdb4112bcc8f34d4f0b36047bca1054f3615413852a7931335210b332)\n             (BVtoZ 0x90c6e8304da4813878c1540b2396f411facf787a520a0ffb55a8d961)\n\n\/**\n * ```repl\n * :prove doubleVectorPasses\n * ```\n *\/\nproperty doubleVectorPasses = P224::affineEq (P224::double S) R\n  where R = P224::Affine (BVtoZ 0xa9c96f2117dee0f27ca56850ebb46efad8ee26852f165e29cb5cdfc7)\n             (BVtoZ 0xadf18c84cf77ced4d76d4930417d9579207840bf49bfbf5837dfdd7d)\n\n\/**\n * ```repl\n * :prove scalarMultVectorPasses\n * ```\n *\/\nproperty scalarMultVectorPasses = P224::affineEq (P224::scmul d S) R\n  where d = toInteger 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        R = P224::Affine (BVtoZ 0x96a7625e92a8d72bff1113abdb95777e736a14c6fdaacc392702bca4)\n             (BVtoZ 0x0f8e5702942a3c5e13cd2fd5801915258b43dfadc70d15dbada3ed10)\n\n\/**\n * ```repl\n * :prove twinMultVectorPasses\n * ```\n *\/\nproperty twinMultVectorPasses =\n  P224::affineEq R (P224::twin_mul d S e T)\n  where d = toInteger 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        e = toInteger 0x54d549ffc08c96592519d73e71e8e0703fc8177fa88aa77a6ed35736\n        R = P224::Affine (BVtoZ 0xdbfe2958c7b2cda1302a67ea3ffd94c918c5b350ab838d52e288c83e)\n            (BVtoZ 0x2f521b83ac3b0549ff4895abcc7f0c5a861aacb87acbc5b8147bb18b)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Instantiations\/P256.cry","filetype":"cry","content":"module Common::EC::PrimeField::Instantiations::P256 =\n       Common::EC::PrimeField::PFEC where\ntype P = 115792089210356248762697446949407573530086143415290314195533631308867097853951\ntype n' = 115792089210356248762697446949407573529996955224135760342422259061068512044369\nb  = `0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\nGx = `0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\nGy = `0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Instantiations\/P192.cry","filetype":"cry","content":"\/*\n\nNIST P-192 Elliptic Curve defined in [FIPS-186-5].\n\nAlso standardized as \"secp192r1\" in [SEC2-v2] Section 2.2.2.\n\n\u26a0\ufe0f Warning \u26a0\ufe0f: This curve is deprecated and should not be used to proactively\nsecure new data! It should only be used to decrypt or verify previously\nencrypted data.\n\n@copyright Galois, Inc\n@author Max Orhai\n\n*\/\n\nmodule Common::EC::PrimeField::Instantiations::P192 =\n       Common::EC::PrimeField::PFEC where\ntype P = 6277101735386680763835789423207666416083908700390324961279\ntype n' =  6277101735386680763835789423176059013767194773182842284081\nb  = `0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\nGx = `0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\nGy = `0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Instantiations\/P224.cry","filetype":"cry","content":"module Common::EC::PrimeField::Instantiations::P224 =\n       Common::EC::PrimeField::PFEC where\ntype P = 26959946667150639794667015087019630673557916260026308143510066298881\ntype n' = 26959946667150639794667015087019625940457807714424391721682722368061\nb  = `0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\nGx = `0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\nGy = `0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1533\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet get_x2_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 8);\n  llvm_points_to (llvm_field ss \"x2\") (llvm_term z);\n  llvm_execute_func [ss];\n  llvm_return (llvm_term z);\n};\n\nm <- llvm_load_module \"test.bc\";\n\nllvm_verify     m            \"get_x2\" [] false get_x2_spec (w4_unint_z3 []);\nllvm_verify_x86 m \"test.exe\" \"get_x2\" [] false get_x2_spec (w4_unint_z3 []);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_property_as_rewrite_rule\/test.saw","filetype":"saw","content":"import \"test.cry\";\n\np1 <- prove_print z3 {{ \\(x: [8]) (y: [8]) -> (x ^ y) ^ y == x }};\nlet r1 = addsimp p1 empty_ss;\n\np2 <- prove_print z3 {{ XorInvolutes }};\nlet r2 = addsimp p2 empty_ss;\n\np3 <- prove_print z3 {{ \\x y -> XorInvolutes x y }};\nlet r3 = addsimp p3 empty_ss;","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test2148\/test.saw","filetype":"saw","content":"\/\/ A regression test that ensures that LLVM overrides will match successfully\n\/\/ when an argument is a string constant (#2148).\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet foo_spec1 = do {\n    (x, p_x) <- ptr_to_fresh \"xs\" (llvm_array 4 (llvm_int 8));\n\n    llvm_execute_func [p_x];\n\n    llvm_points_to p_x (llvm_term x);\n};\n\n\/\/ A slight variation of foo_spec1 that uses `llvm_fresh_expanded_val` instead\n\/\/ of `llvm_fresh_var`. This triggers a different code path in the LLVM override\n\/\/ matching logic.\nlet foo_spec2 = do {\n    let ty = llvm_array 4 (llvm_int 8);\n    x <- llvm_fresh_expanded_val ty;\n    p_x <- alloc_init ty x;\n\n    llvm_execute_func [p_x];\n\n    llvm_points_to p_x x;\n};\n\nlet bar_spec = do {\n    llvm_execute_func [];\n};\n\nm <- llvm_load_module \"test.bc\";\n\nfoo_ov1 <- llvm_unsafe_assume_spec m \"foo\" foo_spec1;\nllvm_verify m \"bar\" [foo_ov1] true bar_spec z3;\n\nfoo_ov2 <- llvm_unsafe_assume_spec m \"foo\" foo_spec2;\nllvm_verify m \"bar\" [foo_ov2] true bar_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_issue642\/test.saw","filetype":"saw","content":"\/\/ This test checks whether we can use an override with a pointer\n\/\/ argument that aliases a global. It is a regression test for\n\/\/ saw-script issue #642.\n\/\/ https:\/\/github.com\/GaloisInc\/saw-script\/issues\/642\n\nbc <- llvm_load_module \"test.bc\";\n\nlet i32 = llvm_int 32;\n\nfoo_ov <-\n  llvm_verify bc \"foo\" [] false\n    do {\n      llvm_alloc_global \"glob\";\n      x <- llvm_alloc i32;\n      llvm_execute_func [x];\n      llvm_return (llvm_term {{ 0 : [32] }});\n    }\n    z3;\n\nbar_ov1 <-\n  llvm_verify bc \"bar\" [] false\n    do {\n      llvm_alloc_global \"glob\";\n      llvm_execute_func [];\n      llvm_return (llvm_term {{ 1 : [32] }});\n    }\n    z3;\n\nfails (\n  llvm_verify bc \"bar\" [foo_ov] false\n    do {\n      llvm_alloc_global \"glob\";\n      llvm_execute_func [];\n      llvm_return (llvm_term {{ 0 : [32] }});\n    }\n    z3\n  );\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1132\/test.saw","filetype":"saw","content":"bc <- llvm_load_module \"test.bc\";\n\nlet f_contract = do {\n  x <- llvm_alloc (llvm_pointer (llvm_int 8));\n  llvm_execute_func [x];\n  p <- llvm_alloc (llvm_int 8);\n  llvm_points_to x p;\n  llvm_points_to p (llvm_term {{ 42 : [8] }});\n};\n\nllvm_verify bc \"f\" [] false f_contract abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0036_global\/test-appropriate-overrides.saw","filetype":"saw","content":"include \"test-common.saw\";\n\nm_O1 <- llvm_load_module \"test-O1.bc\";\nm_O2 <- llvm_load_module \"test-O2.bc\";\n\nf_O1_spec <- llvm_verify m_O1 \"f\" []                     true (f_spec 0) abc;\ng_O1_spec <- llvm_verify m_O1 \"g\" []                     true (g_spec 1) abc;\nh_O1_spec <- llvm_verify m_O1 \"h\" [f_O1_spec, g_O1_spec] true (h_spec 0) abc;\n\nf_O2_spec <- llvm_verify m_O2 \"f\" []                     true (f_spec 0) abc;\ng_O2_spec <- llvm_verify m_O2 \"g\" []                     true (g_spec 1) abc;\nh_O2_spec <- llvm_verify m_O2 \"h\" [f_O2_spec, g_O2_spec] true (h_spec 0) abc;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test0036_global\/test-signed.saw","filetype":"saw","content":"m <- llvm_load_module \"test-signed.bc\";\n\n\nlet init_global name = do {\n  llvm_alloc_global name;\n  llvm_points_to (llvm_global name)\n                 (llvm_global_initializer name);\n};\n\nf_spec <- llvm_verify m \"f\" [] true (do {\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    init_global \"x\";\n    llvm_precond {{ y < 2^^31 - 1 }};\n    llvm_execute_func [llvm_term y];\n    llvm_return (llvm_term {{ 1 + y : [32] }});\n}) abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0036_global\/test-common.saw","filetype":"saw","content":"let init_global name val = do {\n  llvm_alloc_global name;\n  llvm_points_to (llvm_global name) val;\n};\n\nlet f_spec (x_pre : Int) = do {\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    init_global \"x\" (llvm_term {{ `(x_pre) : [32] }});\n    llvm_execute_func [llvm_term y];\n    let x_post = {{ `(x_pre) + 1 : [32] }};\n    llvm_points_to (llvm_global \"x\") (llvm_term x_post);\n    llvm_return (llvm_term {{ x_post + y : [32] }});\n};\n\nlet g_spec (x_pre : Int) = do {\n    z <- llvm_fresh_var \"z\" (llvm_int 32);\n    init_global \"x\" (llvm_term {{ `(x_pre) : [32] }});\n    llvm_execute_func [llvm_term z];\n    let x_post = {{ `(x_pre) + 2 : [32] }};\n    llvm_points_to (llvm_global \"x\") (llvm_term x_post);\n    llvm_return (llvm_term {{ x_post + z : [32] }});\n};\n\nlet h_spec (x_pre : Int) = do {\n    w <- llvm_fresh_var \"w\" (llvm_int 32);\n    init_global \"x\" (llvm_term {{ `(x_pre) : [32] }});\n    llvm_execute_func [llvm_term w];\n    let x_post = {{ `(x_pre) + 3 : [32] }};\n    llvm_points_to (llvm_global \"x\") (llvm_term x_post);\n    llvm_return (llvm_term {{ x_post + `(x_pre) + 1 + w : [32] }});\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0036_global\/test-global-initializer.saw","filetype":"saw","content":"let init_global name val = do {\n  llvm_alloc_global name;\n  llvm_points_to (llvm_global name) val;\n};\n\nlet f_spec = do {\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    init_global \"x\" (llvm_global_initializer \"x\");\n    llvm_execute_func [llvm_term y];\n    llvm_points_to (llvm_global \"x\") (llvm_term {{ 1 : [32] }});\n    llvm_return (llvm_term {{ 1 + y : [32] }});\n};\n\nlet g_spec = do {\n    z <- llvm_fresh_var \"z\" (llvm_int 32);\n    init_global \"x\" (llvm_term {{ 1 : [32] }});\n    llvm_execute_func [llvm_term z];\n    llvm_points_to (llvm_global \"x\") (llvm_term {{ 3 : [32] }});\n    llvm_return (llvm_term {{ 3 + z : [32] }});\n};\n\nlet h_spec = do {\n    w <- llvm_fresh_var \"w\" (llvm_int 32);\n    init_global \"x\" (llvm_global_initializer \"x\");\n    llvm_execute_func [llvm_term w];\n    llvm_points_to (llvm_global \"x\") (llvm_term {{ 3 : [32] }});\n    llvm_return (llvm_term {{ 4 + w : [32] }});\n};\n\nm_O1 <- llvm_load_module \"test-O1.bc\";\nm_O2 <- llvm_load_module \"test-O2.bc\";\n\nf_O1_spec <- llvm_verify m_O1 \"f\" []                     true f_spec abc;\ng_O1_spec <- llvm_verify m_O1 \"g\" []                     true g_spec abc;\nh_O1_spec <- llvm_verify m_O1 \"h\" [f_O1_spec, g_O1_spec] true h_spec abc;\n\nf_O2_spec <- llvm_verify m_O2 \"f\" []                     true f_spec abc;\ng_O2_spec <- llvm_verify m_O2 \"g\" []                     true g_spec abc;\nh_O2_spec <- llvm_verify m_O2 \"h\" [f_O2_spec, g_O2_spec] true h_spec abc;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test1938\/test.saw","filetype":"saw","content":"\/\/ Test that the `abc` and `w4_abc_verilog` proof scripts will report invalid\n\/\/ goals that do not contain any variables. We test this both directly (with the\n\/\/ trivial `False` property) as well as via an LLVM verification involving a\n\/\/ proof goal that evaluates to `False`.\n\nfails (prove_print abc            {{ False }});\nfails (prove_print w4_abc_verilog {{ False }});\n\nm <- llvm_load_module \"test.bc\";\n\n\/\/ This will generate a failing proof goal about `x` being read-only.\nlet setup = do {\n  x <- llvm_alloc_readonly (llvm_int 32);\n  llvm_execute_func [x];\n};\n\nfails (llvm_verify m \"test\" [] true setup abc);\nfails (llvm_verify m \"test\" [] true setup w4_abc_verilog);\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test0030_vectors\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"vectortest.bc\";\n\nlet setup = do {\n  llvm_execute_func [ llvm_term {{ zero:[32] }}, llvm_null ];\n  llvm_return (llvm_term {{ zero:[32] }});\n};\nllvm_verify m \"main\" [] false setup z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_union\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet {{\nINC_1 = 0 : [32]\nINC_2 = 1 : [32]\n}};\n\n\n\/\/ The argument 'INC' specifies which 'alg' enum to test.\nlet inc_spec INC = do {\n\n  stp <- llvm_alloc (llvm_alias \"struct.st\");\n  llvm_points_to (llvm_field stp \"alg\") (llvm_term {{ INC }});\n\n  if eval_bool {{ INC == INC_1 }} then\n    do {\n      let p = llvm_cast_pointer (llvm_field stp \"inc_st\") (llvm_alias \"struct.inc_1_st\");\n\n      x0 <- llvm_fresh_var \"x0\" (llvm_int 32);\n      llvm_points_to (llvm_field p \"x\") (llvm_term x0);\n\n      llvm_execute_func [stp];\n\n      llvm_points_to (llvm_field p \"x\") (llvm_term {{ x0 + 1 }});\n    }\n  else if eval_bool {{ INC == INC_2 }} then\n    do {\n      let p = llvm_cast_pointer (llvm_field stp \"inc_st\") (llvm_alias \"struct.inc_2_st\");\n\n      x0 <- llvm_fresh_var \"x0\" (llvm_int 32);\n      y0 <- llvm_fresh_var \"y0\" (llvm_int 32);\n\n      llvm_points_to (llvm_field p \"x\") (llvm_term x0);\n      llvm_points_to (llvm_field p \"y\") (llvm_term y0);\n\n      llvm_execute_func [stp];\n\n      llvm_points_to (llvm_field p \"x\") (llvm_term {{ x0 + 1 }});\n      llvm_points_to (llvm_field p \"y\") (llvm_term {{ y0 + 1 }});\n    }\n  else return (); \/\/ Unknown INC value\n\n  llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nprint \"Verifying 'inc_1' using 'llvm_verify':\";\nllvm_verify m \"inc\" [] true (inc_spec {{ INC_1 }}) abc;\nprint \"\";\n\nprint \"Verifying 'inc_2' using 'llvm_verify':\";\nllvm_verify m \"inc\" [] true (inc_spec {{ INC_2 }}) abc;\nprint \"\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_rewrite_int\/test.saw","filetype":"saw","content":"\/\/ This test ensures that rewrite rules using `intEq` and `intModEq` will work.\n\nlet ss0 = add_cryptol_defs [\"ecEq\"] (cryptol_ss ());\n\nlet {{\n  squareInt : Integer -> Integer\n  squareInt x = x * x\n\n  squareZ5 : Z 5 -> Z 5\n  squareZ5 x = x * x\n}};\n\nlet prove_rule t =\n  do {\n    thm <- prove_print z3 (rewrite ss0 t);\n    print thm;\n    return thm;\n  };\n\nsquareInt_plus <-\n  prove_rule {{ \\x y -> squareInt (x + y) == squareInt x + squareInt y + 2 * x * y }};\n\nsquareInt_times <-\n  prove_rule {{ \\x y -> squareInt (x * y) == squareInt x * squareInt y }};\n\nsquareZ5_plus <-\n  prove_rule {{ \\x y -> squareZ5 (x + y) == squareZ5 x + squareZ5 y + 2 * x * y }};\n\nsquareZ5_times <-\n  prove_rule {{ \\x y -> squareZ5 (x * y) == squareZ5 x * squareZ5 y }};\n\nlet ss1 = addsimps [squareInt_plus, squareInt_times, squareZ5_plus, squareZ5_times] ss0;\nlet tac = do { simplify ss1; print_goal; w4_unint_z3 [\"squareInt\", \"squareZ5\"]; };\n\nprove_print tac\n  {{ \\x y z -> squareInt (x * y + z) == squareInt x * squareInt y + squareInt z + 2 * x * y * z }};\n\nprove_print tac\n  {{ \\x y z -> squareZ5 (x * y + z) == squareZ5 x * squareZ5 y + squareZ5 z + 2 * x * y * z }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_unfold_fix_once\/test.saw","filetype":"saw","content":"let {{\n  f : [64] -> [64]\n  f x = if x <$ 0 then 0 else 2 * (f (x + 1))\n}};\n\nprove_print\n  (do {\n    unfolding_fix_once [\"f\"];\n    w4_unint_z3 [\"f\"];\n  })\n  {{ \\x -> (f x) % 2 == 0 }};\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1999\/post-test-override.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"post-test.linked-mir.json\";\n\n\/\/ Override for x using mir_ref_of in postcondition\nlet x_override_spec = do {\n  mir_execute_func [];\n\n  ref_42 <- mir_ref_of (mir_term {{ 42 : [32] }});\n  mir_return ref_42;\n};\n\nx_ov <- mir_unsafe_assume_spec m \"post_test::x\" x_override_spec;\n\n\/\/ Now verify is42 returns true\nlet is42_spec = do {\n  mir_execute_func [];\n  mir_return (mir_term {{ True }});\n};\n\nmir_verify m \"post_test::is42\" [x_ov] false is42_spec z3;\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/intTests\/test1999\/post-test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"post-test.linked-mir.json\";\n\n\/\/ Override for x using mir_ref_of in postcondition\nlet x_spec = do {\n  mir_execute_func [];\n\n  ref_42 <- mir_ref_of (mir_term {{ 42 : [32] }});\n  mir_return ref_42;\n};\n\nmir_verify m \"post_test::x\" [] false x_spec z3;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test1999\/pre-test-override.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"pre-test.linked-mir.json\";\nlet ty = mir_u32;\n\nlet x_override_spec = do {\n  val <- mir_fresh_var \"val\" ty;\n  ref <- mir_ref_of (mir_term val);\n\n  mir_precond {{ val == 42 }};\n  mir_execute_func [ref];\n  mir_return ref;\n};\n\nx_ov <- mir_unsafe_assume_spec m \"pre_test::x\" x_override_spec;\n\nlet is42_spec = do {\n  mir_execute_func [];\n  mir_return (mir_term {{ True }});\n};\n\nmir_verify m \"pre_test::is42\" [x_ov] false is42_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1999\/pre-test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"pre-test.linked-mir.json\";\nlet ty = mir_u32;\n\nlet x_spec = do {\n  val <- mir_fresh_var \"val\" ty;\n  ref <- mir_ref_of (mir_term val);\n\n  mir_precond {{ val == 42 }};\n  mir_execute_func [ref];\n  mir_return ref;\n};\n\nmir_verify m \"pre_test::x\" [] false x_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1999\/pre-test-mut-override.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"pre-test-mut.linked-mir.json\";\nlet ty = mir_u32;\n\nlet x_override_spec = do {\n  val <- mir_fresh_var \"val\" ty;\n  ref <- mir_ref_of_mut (mir_term val);\n\n  mir_precond {{ val == 42 }};\n  mir_execute_func [ref];\n  mir_points_to ref (mir_term val);\n  mir_return ref;\n};\n\nx_ov <- mir_unsafe_assume_spec m \"pre_test_mut::x\" x_override_spec;\n\nlet is42_spec = do {\n  mir_execute_func [];\n  mir_return (mir_term {{ True }});\n};\n\nmir_verify m \"pre_test_mut::is42\" [x_ov] false is42_spec z3;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test1999\/pre-test-mut.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"pre-test-mut.linked-mir.json\";\nlet ty = mir_u32;\n\nlet x_spec = do {\n  val <- mir_fresh_var \"val\" ty;\n  ref <- mir_ref_of_mut (mir_term val);\n\n  mir_precond {{ val == 42 }};\n  mir_execute_func [ref];\n  mir_points_to ref (mir_term val);\n  mir_return ref;\n};\n\nmir_verify m \"pre_test_mut::x\" [] false x_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1999\/post-test-mut-override.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"post-test-mut.linked-mir.json\";\n\nlet get41_override_spec = do {\n  mir_execute_func [];\n\n  ref_41 <- mir_ref_of_mut (mir_term {{ 41 : [32] }});\n  mir_return ref_41;\n};\n\nget41_ov <- mir_unsafe_assume_spec m \"post_test_mut::get41\" get41_override_spec;\n\nlet is42_spec = do {\n  mir_execute_func [];\n  mir_return (mir_term {{ True }});\n};\n\nmir_verify m \"post_test_mut::is42\" [get41_ov] false is42_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1999\/post-test-mut.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"post-test-mut.linked-mir.json\";\n\nlet get41_spec = do {\n  mir_execute_func [];\n\n  ref_41 <- mir_ref_of_mut (mir_term {{ 41 : [32] }});\n  mir_return ref_41;\n};\n\nmir_verify m \"post_test_mut::get41\" [] false get41_spec z3;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_mir_verify_tuples\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet f_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  y <- mir_fresh_var \"y\" mir_u32;\n  let s = mir_tuple_value [mir_term x, mir_term y];\n\n  mir_execute_func [s];\n\n  let s' = mir_tuple_value [mir_term {{ y + 1 }}, mir_term {{ x + 2 }}];\n  mir_return s';\n};\n\nlet g_spec = do {\n  s_ptr <- mir_alloc (mir_tuple [mir_u32, mir_u32]);\n  x <- mir_fresh_var \"x\" mir_u32;\n  y <- mir_fresh_var \"y\" mir_u32;\n  let s = mir_tuple_value [mir_term x, mir_term y];\n  mir_points_to s_ptr s;\n\n  mir_execute_func [s_ptr];\n\n  let s' = mir_tuple_value [mir_term {{ y + 1 }}, mir_term {{ x + 2 }}];\n  mir_return s';\n};\n\nlet h_spec = do {\n  s_ptr <- mir_alloc_mut (mir_tuple [mir_u32, mir_u32]);\n  x <- mir_fresh_var \"x\" mir_u32;\n  y <- mir_fresh_var \"y\" mir_u32;\n  let s = mir_tuple_value [mir_term x, mir_term y];\n  mir_points_to s_ptr s;\n\n  mir_execute_func [s_ptr];\n\n  let s' = mir_tuple_value [mir_term {{ y + 1 }}, mir_term {{ x + 2 }}];\n  mir_points_to s_ptr s';\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::f\" [] false f_spec z3;\nmir_verify m \"test::g\" [] false g_spec z3;\nmir_verify m \"test::h\" [] false h_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_refine\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet {{\n popcount : [32] -> [32]\n popcount x = sum [ zext [b] | b <- x ]\n}};\n\n\/\/ A parameterized spec where the input value is\n\/\/ given as a parameter.\nlet f_concrete_spec (x:Term) : LLVMSetup () =\n  do {\n    llvm_execute_func [ llvm_term x ];\n\n    r <- llvm_fresh_var \"r\" (llvm_int 32);\n    llvm_return (llvm_term r);\n    llvm_postcond {{ 2^^r == x }};\n  };\n\n\/\/ A \"unified\" spec, where the input is taken from the\n\/\/ call site argument.\nlet f_total_spec : LLVMSetup () =\n  do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_precond {{ x <= 16 }};\n    llvm_precond {{ popcount x == 1 }};\n\n    llvm_execute_func [ llvm_term x ];\n\n    r <- llvm_fresh_var \"r\" (llvm_int 32);\n    llvm_return (llvm_term r);\n    llvm_postcond {{ 2^^r == x }};\n  };\n\n\/\/ This spec is incorrect, and should be rejected\nlet f_bogus_spec : LLVMSetup () =\n  do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_precond {{ x <= 32 }};\n    llvm_precond {{ popcount x == 1 }};\n\n    llvm_execute_func [ llvm_term x ];\n\n    r <- llvm_fresh_var \"r\" (llvm_int 32);\n    llvm_return (llvm_term r);\n    llvm_postcond {{ 2^^r == x }};\n  };\n\nm <- llvm_load_module \"test.bc\";\n\nf_concrete_ovrs <-\n  for (eval_list {{ [1,2,4,8,16:[32]] }}) (\\i ->\n    do {\n      print (str_concat \"f lemma: \" (show (eval_int i)));\n      llvm_verify m \"f\" [] false (f_concrete_spec i) yices;\n    });\n\nllvm_refine_spec m \"f\" f_concrete_ovrs f_total_spec yices;\n\nfails (llvm_refine_spec m \"f\" f_concrete_ovrs f_bogus_spec yices);\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_llvm_alignment\/test.saw","filetype":"saw","content":"\/\/ This is a regression test for saw-script issue #635.\n\/\/ https:\/\/github.com\/GaloisInc\/saw-script\/issues\/635\n\nbc <- llvm_load_module \"test.bc\";\n\nlet i8 = llvm_int 8;\nlet i64 = llvm_int 64;\n\nwrite_ov <-\n  llvm_verify bc \"write\" [] false\n    do {\n      p <- llvm_alloc i64;\n      x <- llvm_fresh_var \"x\" i64;\n      llvm_execute_func [p, llvm_term x];\n      llvm_points_to p (llvm_term x);\n    }\n    z3;\n\nlet write_unaligned_spec =\n  do {\n    p <- llvm_alloc (llvm_array 16 i8);\n    b <- llvm_fresh_var \"b\" (llvm_array 16 i8);\n    x <- llvm_fresh_var \"x\" i64;\n    llvm_points_to p (llvm_term b);\n    llvm_execute_func [p, llvm_term x];\n    llvm_points_to p (llvm_term {{ take`{1} b # reverse (split x) # drop`{9} b }});\n  };\n\nfails (\n  llvm_verify bc \"write_unaligned\" [] false\n    write_unaligned_spec\n    z3\n  );\n\nfails (\n  llvm_verify bc \"write_unaligned\" [write_ov] false\n    write_unaligned_spec\n    z3\n  );\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test1308\/test.saw","filetype":"saw","content":"enable_lax_pointer_ordering;\n\nlet alloc_init_readonly ty v = do {\n  p <- llvm_alloc_readonly ty;\n  llvm_points_to p v;\n  return p;\n};\n\nlet ptr_to_fresh_readonly n ty = do {\n  x <- llvm_fresh_var n ty;\n  p <- alloc_init_readonly ty (llvm_term x);\n  return (x, p);\n};\n\nlet LEN = 42;\n\nlet zip_with_add_spec = do {\n  let array_ty = llvm_array LEN (llvm_int 64);\n  c_ptr <- llvm_alloc array_ty;\n  (a, a_ptr) <- ptr_to_fresh_readonly \"a\" array_ty;\n  (b, b_ptr) <- ptr_to_fresh_readonly \"b\" array_ty;\n\n  llvm_execute_func [c_ptr, a_ptr, b_ptr];\n\n  llvm_points_to c_ptr (llvm_term {{ zipWith`{LEN} (+) a b }});\n};\n\nmod <- llvm_load_module \"test.bc\";\nllvm_verify mod \"zip_with_add\" [] false zip_with_add_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_yosys_compositional\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet {{\n  cryfull :  {a : [1], b : [1], cin : [1]} -> {cout : [1], s : [1]}\n  cryfull inp = { cout = [cout], s = [s] }\n    where [cout, s] = zext inp.a + zext inp.b + zext inp.cin\n  \n  cryadd4 : {a : [4], b : [4]} -> {res : [4]}\n  cryadd4 inp = { res = inp.a + inp.b }\n  \n  cryfullnocarry :  {a : [1], b : [1], cin : [1]} -> {cout : [1], s : [1]}\n  cryfullnocarry inp = { cout = [cout], s = [s] }\n    where [cout, s] = zext inp.a + zext inp.b\n}};\n\nm <- yosys_import \"test.json\";\n\nfull_spec <- yosys_verify {{ m.full }} [] {{ cryfull }} [] w4;\nyosys_verify {{ m.add4 }} [] {{ cryadd4 }} [full_spec] w4;\nfull_nocarry_spec <- yosys_verify {{ m.full }} [{{\\(inp : {a : [1], b : [1], cin : [1]}) -> inp.cin == 0}}] {{ cryfullnocarry }} [] w4;\nyosys_verify {{ m.add4 }} [] {{ cryadd4 }} [full_nocarry_spec] w4;","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_ghost_branch_00\/test.saw","filetype":"saw","content":"let f_lt_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{ i < 42 }};\n  llvm_execute_func [llvm_term i];\n  llvm_ghost_value x i;\n  llvm_return (llvm_term i);\n};\n\nlet f_ge_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{ (i >= 42) && (i < 512) }};\n  llvm_execute_func [llvm_term i];\n  let ret = {{ 2 * i }};\n  llvm_ghost_value x ret;\n  llvm_return (llvm_term ret);\n};\n\nlet g_spec : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{i < 512}};\n  llvm_execute_func [llvm_term i];\n  ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n  llvm_return (llvm_term ret);\n  llvm_postcond {{ ret >= i }};\n};\n\nlet main : TopLevel () = do {\n  x <- declare_ghost_state \"x\";\n  m <- llvm_load_module \"test.bc\";\n  f_lt_ov <- llvm_unsafe_assume_spec m \"f\" (f_lt_spec x);\n  f_ge_ov <- llvm_unsafe_assume_spec m \"f\" (f_ge_spec x);\n  llvm_verify m \"g\" [f_lt_ov, f_ge_ov] false g_spec z3;\n  print \"done\";\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0220\/test.saw","filetype":"saw","content":"\/\/ Test an inexact postcondition.\n\nmod <- llvm_load_module \"test.bc\";\n\nlet spec = do {\n   llvm_alloc_global \"y\";\n   y <- llvm_fresh_var \"y\" (llvm_int 8); \n   llvm_points_to (llvm_global \"y\") (llvm_term y); \n   llvm_execute_func [];\n   y_new <- llvm_fresh_var \"y_new\" (llvm_int 8);\n   llvm_points_to (llvm_global \"y\") (llvm_term y_new);\n   llvm_postcond {{ y_new > 0 }};\n};\n\nllvm_verify mod \"f\" [] false spec abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0038_rust\/test.saw","filetype":"saw","content":"let f_spec : CrucibleSetup() = do {\n    \/\/ For unclear reasons, this struct:\n    \/\/\n    \/\/     struct BI { i: [[i32; 4]; 2] }\n    \/\/\n    \/\/ maps to the LLVM type:\n    \/\/\n    \/\/     %BI = type { [0 x i32], [2 x [4 x i32]], [0 x i32] }\n    \/\/\n    i <- llvm_fresh_var \"w.i\" (llvm_array 2 (llvm_array 4 (llvm_int 32)));\n    pw <- llvm_alloc (llvm_alias \"BI\");\n    llvm_points_to pw\n      (llvm_struct_value [ llvm_term {{ zero:[0][32] }}\n                         , llvm_term i\n                         , llvm_term {{ zero:[0][32] }}\n                         ]);\n\n    llvm_execute_func [pw];\n    llvm_points_to (llvm_elem pw 1) (llvm_term {{ zero:[2][4][32] }});\n\n    };\n\nlet main : TopLevel () = do {\n    structTest <- llvm_load_module \"test.bc\";\n\n    f_result <- llvm_verify structTest \"f\" [] false f_spec z3;\n\n    print \"Done!\";\n};\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/intTests\/test_profiling\/dotprod_struct.saw","filetype":"saw","content":"import \"dotprod.cry\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet dotprod_spec n = do {\n    let nt = llvm_term {{ `n : [32] }};\n    (xs, xsp) <- ptr_to_fresh \"xs\" (llvm_array n (llvm_int 32));\n    (ys, ysp) <- ptr_to_fresh \"ys\" (llvm_array n (llvm_int 32));\n    let xval = llvm_struct_value [ xsp, nt ];\n    let yval = llvm_struct_value [ ysp, nt ];\n    xp <- alloc_init (llvm_alias \"struct.vec_t\") xval;\n    yp <- alloc_init (llvm_alias \"struct.vec_t\") yval;\n    llvm_execute_func [xp, yp];\n    llvm_return (llvm_term {{ dotprod xs ys }});\n};\n\nm <- llvm_load_module \"dotprod_struct.bc\";\n\nenable_crucible_profiling \"prof\";\ndotprod_ov <- llvm_verify m \"dotprod_struct\" [] true (dotprod_spec 2) z3;\nllvm_verify m \"dotprod_wrap\" [dotprod_ov] true (dotprod_spec 2) z3;\ndisable_crucible_profiling;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_bitfield_basic\/test.saw","filetype":"saw","content":"enable_experimental;\nenable_lax_loads_and_stores;\n\nlet get_x2_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 2);\n  llvm_points_to_bitfield ss \"x2\" (llvm_term z);\n  llvm_execute_func [ss];\n  llvm_return (llvm_term {{ zext z : [8] }});\n};\n\nlet get_y_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 1);\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n  llvm_execute_func [ss];\n  llvm_return (llvm_term z);\n};\n\nlet set_x2_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 8);\n  llvm_execute_func [ss, llvm_term z];\n  llvm_points_to_bitfield ss \"x2\" (llvm_term {{ drop z : [2] }});\n};\n\nlet set_x2_alt_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 2);\n  llvm_execute_func [ss, llvm_term {{ zext z : [8] }}];\n  llvm_points_to_bitfield ss \"x2\" (llvm_term z);\n};\n\nlet set_y_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 1);\n  llvm_execute_func [ss, llvm_term z];\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n};\n\nlet set_y_alt_spec = set_y_spec;\n\nm <- llvm_load_module \"test.bc\";\n\nllvm_verify m \"get_x2\" [] false get_x2_spec (w4_unint_z3 []);\nllvm_verify m \"get_y\" [] false get_y_spec (w4_unint_z3 []);\nllvm_verify m \"set_x2\" [] false set_x2_spec (w4_unint_z3 []);\nllvm_verify m \"set_x2_alt\" [] false set_x2_alt_spec (w4_unint_z3 []);\nllvm_verify m \"set_y\" [] false set_y_spec (w4_unint_z3 []);\nllvm_verify m \"set_y_alt\" [] false set_y_alt_spec (w4_unint_z3 []);\n\nset_x2_ov <- llvm_unsafe_assume_spec m \"set_x2\" set_x2_spec;\nllvm_verify m \"set_x2_alt\" [set_x2_ov] false set_x2_alt_spec (w4_unint_z3 []);\nset_y_ov <- llvm_unsafe_assume_spec m \"set_y\" set_y_spec;\nllvm_verify m \"set_y_alt\" [set_y_ov] false set_y_alt_spec (w4_unint_z3 []);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_verify_structs\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet s1_adt = mir_find_adt m \"test::S1\" [];\nlet s2_adt = mir_find_adt m \"test::S2\" [mir_u32, mir_u32];\nlet s3_adt = mir_find_adt m \"test::S3\" [];\nlet s4_adt = mir_find_adt m \"test::S4\" [];\n\nlet foo_adt_1 = mir_find_adt m \"test::Foo\" [mir_array 4 mir_u8];\nlet foo_adt_2 = mir_find_adt m \"test::Foo\" [mir_adt s2_adt];\n\nlet option_adt = mir_find_adt m \"core::option::Option\" [mir_adt s2_adt];\n\nlet f_spec adt = do {\n    x1 <- mir_fresh_var \"x1\" mir_u32;\n    y1 <- mir_fresh_var \"y1\" mir_u32;\n    let s = mir_struct_value\n              adt\n              [ mir_term x1\n              , mir_term y1\n              ];\n\n    mir_execute_func [s];\n\n    let s' = mir_struct_value\n              adt\n              [ mir_term {{ y1 + 1 }}\n              , mir_term {{ x1 + 2 }}\n              ];\n    mir_return s';\n};\n\n\nlet f1_spec = f_spec s1_adt;\nlet f2_spec = f_spec s2_adt;\nlet f3_spec = f_spec s3_adt;\n\nlet f4_spec = do {\n    x4 <- mir_fresh_var \"x4\" mir_u32;\n    let s = mir_struct_value s4_adt [mir_term x4];\n\n    mir_execute_func [s];\n\n    let s' = mir_struct_value s4_adt [mir_term {{ x4 + 2 }}];\n    mir_return s';\n};\n\nlet g_spec = do {\n    s_ptr <- mir_alloc (mir_adt s1_adt);\n    x1 <- mir_fresh_var \"x1\" mir_u32;\n    y1 <- mir_fresh_var \"y1\" mir_u32;\n    let s = mir_struct_value\n              s1_adt\n              [ mir_term x1\n              , mir_term y1\n              ];\n    mir_points_to s_ptr s;\n\n    mir_execute_func [s_ptr];\n\n    let s' = mir_struct_value\n              s1_adt\n              [ mir_term {{ y1 + 1 }}\n              , mir_term {{ x1 + 2 }}\n              ];\n    mir_return s';\n};\n\nlet h_spec = do {\n    s_ptr <- mir_alloc_mut (mir_adt s1_adt);\n    x1 <- mir_fresh_var \"x1\" mir_u32;\n    y1 <- mir_fresh_var \"y1\" mir_u32;\n    let s = mir_struct_value\n              s1_adt\n              [ mir_term x1\n              , mir_term y1\n              ];\n    mir_points_to s_ptr s;\n\n    mir_execute_func [s_ptr];\n\n    let s' = mir_struct_value\n              s1_adt\n              [ mir_term {{ y1 + 1 }}\n              , mir_term {{ x1 + 2 }}\n              ];\n    mir_points_to s_ptr s';\n};\n\nlet bar_spec = do {\n    f1_ptr <- mir_alloc_mut (mir_adt foo_adt_1);\n    f1_arr_val0 <- mir_fresh_var \"f1_arr_val0\" mir_u8;\n    f1_arr_val1 <- mir_fresh_var \"f1_arr_val1\" mir_u8;\n    f1_arr_val2 <- mir_fresh_var \"f1_arr_val2\" mir_u8;\n    f1_arr_val3 <- mir_fresh_var \"f1_arr_val3\" mir_u8;\n    let f1_arr_val = mir_array_value\n                       mir_u8\n                       [ mir_term f1_arr_val0\n                       , mir_term f1_arr_val1\n                       , mir_term f1_arr_val2\n                       , mir_term f1_arr_val3\n                       ];\n    let f1_foo_val = mir_struct_value foo_adt_1 [f1_arr_val];\n    mir_points_to f1_ptr f1_foo_val;\n\n    f2_ptr <- mir_alloc_mut (mir_adt foo_adt_2);\n    f2_s2_val0 <- mir_fresh_var \"f2_s2_val0\" mir_u32;\n    f2_s2_val1 <- mir_fresh_var \"f2_s2_val1\" mir_u32;\n    let f2_s2_val = mir_struct_value\n                      s2_adt\n                      [ mir_term f2_s2_val0\n                      , mir_term f2_s2_val1\n                      ];\n    let f2_foo_val = mir_struct_value foo_adt_2 [f2_s2_val];\n    mir_points_to f2_ptr f2_foo_val;\n\n    mir_execute_func [f1_ptr, f2_ptr];\n\n    let f1_arr_val' = mir_array_value\n                        mir_u8\n                        [ mir_term f1_arr_val0\n                        , mir_term {{ 42 : [8] }}\n                        , mir_term f1_arr_val2\n                        , mir_term f1_arr_val3\n                        ];\n    let f1_foo_val' = mir_struct_value foo_adt_1 [f1_arr_val'];\n    mir_points_to f1_ptr f1_foo_val';\n\n    let f2_s2_val' = mir_struct_value\n                       s2_adt\n                       [ mir_term f2_s2_val1\n                       , mir_term f2_s2_val1\n                       ];\n    let f2_foo_val' = mir_struct_value foo_adt_2 [f2_s2_val'];\n    mir_points_to f2_ptr f2_foo_val';\n\n    mir_return f2_ptr;\n};\n\nmir_verify m \"test::f1\" [] false f1_spec z3;\nmir_verify m \"test::f2\" [] false f2_spec z3;\nmir_verify m \"test::f3\" [] false f3_spec z3;\nmir_verify m \"test::f4\" [] false f4_spec z3;\nmir_verify m \"test::g\" [] false g_spec z3;\nmir_verify m \"test::h\" [] false h_spec z3;\n\nfails (\n  mir_verify m \"test::f1\" [] false f2_spec z3\n);\nfails (\n  mir_verify m \"test::f2\" [] false f1_spec z3\n);\n\nmir_verify m \"test::bar\" [] false bar_spec z3;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test0046_memcpy\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet f_setup = do {\n  xp <- llvm_alloc_readonly (llvm_array 4 (llvm_int 8));\n  llvm_execute_func [xp];\n  };\n\n\/\/ should fail because destination is not mutable,\n\/\/ even though the memcpy is 0 length\nfails (llvm_verify m \"f\" [] false f_setup z3);\n\nlet g_setup = do {\n  xp <- llvm_alloc (llvm_array 4 (llvm_int 8));\n  llvm_execute_func [xp];\n  };\n\n\/\/ should succeed because memcpy is allowed to copy uninitilized bytes\nllvm_verify m \"g\" [] false g_setup z3;\n\n\/\/ fails because direct reading of uninitialized bytes is not allowed\nfails (llvm_verify m \"h\" [] false g_setup z3); ","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1998_jvm\/test.saw","filetype":"saw","content":"let f_spec = do {\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_equal (jvm_term x) (jvm_term y);\n\n    jvm_execute_func [jvm_term x, jvm_term y];\n\n    jvm_return (jvm_term {{ True }});\n};\n\nc <- java_load_class \"Test\";\njvm_verify c \"f\" [] false f_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_x86_01\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"bar.bc\";\n\nlet foo_setup = do {\n  ptr <- llvm_alloc (llvm_int 64);\n  val <- llvm_fresh_var \"val\" (llvm_int 64);\n  llvm_points_to ptr (llvm_term val);\n  j <- llvm_fresh_var \"j\" (llvm_int 64);\n  llvm_execute_func [ptr, llvm_term j];\n  val <- llvm_fresh_var \"val'\" (llvm_int 64);\n  llvm_points_to ptr (llvm_term val);\n};\nfoo_method_spec <- llvm_verify_x86 m \".\/foo\" \"foo\" [] false foo_setup w4;\n\nlet bar_setup = do {\n  llvm_execute_func [];\n};\nllvm_verify m \"bar\" [foo_method_spec] false bar_setup z3;","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_x86_06\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet discoverytest_setup = do {\n  llvm_execute_func [];\n};\n\nfails (llvm_verify_x86 m \".\/discoverytest\" \"discoverytest\" [] false discoverytest_setup w4);\n\nadd_x86_preserved_reg \"rax\";\nllvm_verify_x86 m \".\/discoverytest\" \"discoverytest\" [] false discoverytest_setup w4;\ndefault_x86_preserved_reg;","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_llvm_sizeof\/test.saw","filetype":"saw","content":"\/\/ This test checks that the `llvm_sizeof` function works as expected.\n\nbc1 <- llvm_load_module \"test1.bc\";\nbc2 <- llvm_load_module \"test2.bc\";\n\nlet s1 = llvm_sizeof bc1 (llvm_int 8);\nlet s2 = llvm_sizeof bc1 (llvm_int 16);\nlet s3 = llvm_sizeof bc1 (llvm_int 32);\nlet s4 = llvm_sizeof bc1 (llvm_int 64);\nlet s5 = llvm_sizeof bc1 (llvm_alias \"struct.foo\");\nlet s6 = llvm_sizeof bc1 (llvm_alias \"struct.bar\");\nlet s7 = llvm_sizeof bc1 (llvm_array 2 (llvm_alias \"struct.foo\"));\nlet s8 = llvm_sizeof bc2 (llvm_alias \"struct.baz\");\nlet s9 = llvm_sizeof bc2 (llvm_array 8 (llvm_alias \"struct.baz\"));\nlet s0 = llvm_sizeof bc2 (llvm_type \"void*\");\n\n\/\/ This is a workaround to delay evaluation of a pure function\n\/\/ so that `fails` can catch any errors raised.\nlet apply f x = do { () <- return (); return (f x); };\n\nfails (apply (llvm_sizeof bc1) (llvm_type \"void\"));\nfails (apply (llvm_sizeof bc1) (llvm_alias \"baz\"));\nfails (apply (llvm_sizeof bc2) (llvm_alias \"foo\"));\n\nprove_print z3 {{\n  `s1 == (1 : Integer) \/\\\n  `s2 == (2 : Integer) \/\\\n  `s3 == (4 : Integer) \/\\\n  `s4 == (8 : Integer) \/\\\n  `s5 == (8 : Integer) \/\\\n  `s6 == (84 : Integer) \/\\\n  `s7 == (16 : Integer) \/\\\n  `s8 == (8  : Integer) \/\\\n  `s9 == (64 : Integer) \/\\\n  `s0 == (8  : Integer)\n  }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test2032\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\n\/\/ We now have the mir_vec_of command for creating Vec values, which is tested\n\/\/ below, but we first test that we are able to construct a Vec using the\n\/\/ mir_alloc_raw_ptr_const_multi and mir_points_to_multi primitives in the same\n\/\/ way that mir_vec_of does internally. If this works but mir_vec_of fails then\n\/\/ we can isolate where the problem is coming from.\n\nlet GlobalAlloc = mir_find_adt m \"alloc::alloc::Global\" [];\nlet Vec_i32 = mir_find_adt m \"alloc::vec::Vec\" [mir_i32, mir_adt GlobalAlloc];\nlet RawVec_i32 = mir_find_adt m \"alloc::raw_vec::RawVec\" [mir_i32, mir_adt GlobalAlloc];\nlet TypedAllocator_i32 = mir_find_adt m \"crucible::alloc::TypedAllocator\" [mir_i32];\nlet RawVecInner_i32 = mir_find_adt m \"alloc::raw_vec::RawVecInner\" [mir_adt TypedAllocator_i32];\nlet Unique_u8 = mir_find_adt m \"core::ptr::unique::Unique\" [mir_u8];\nlet NonNull_u8 = mir_find_adt m \"core::ptr::non_null::NonNull\" [mir_u8];\nlet PhantomData = mir_find_adt m \"core::marker::PhantomData\";\nlet PhantomData_u8 = PhantomData [mir_u8];\nlet PhantomData_i32 = PhantomData [mir_i32]; \nlet UsizeNoHighBit = mir_find_adt m \"core::num::niche_types::UsizeNoHighBit\" [];\n\nlet mk_vec_i32 len contents = do {\n    ptr <- mir_alloc_raw_ptr_const_multi len mir_i32;\n    cap <- mir_fresh_var \"cap\" mir_usize;\n    mir_assert {{ cap <= 0x7fff_ffff_ffff_ffff \/ (32 \/ 8) }};\n    mir_assert {{ cap >= `len }};\n    mir_points_to_multi ptr contents;\n    return (mir_struct_value Vec_i32 [\n        mir_struct_value RawVec_i32 [\n            mir_struct_value RawVecInner_i32 [\n                mir_struct_value Unique_u8 [\n                    mir_struct_value NonNull_u8 [\n                        mir_cast_raw_ptr ptr mir_u8\n                    ],\n                    mir_struct_value PhantomData_u8 []\n                ],\n                mir_struct_value UsizeNoHighBit [\n                    mir_term cap\n                ],\n                mir_struct_value TypedAllocator_i32 [\n                    mir_struct_value PhantomData_i32 []\n                ]\n            ],\n            mir_struct_value GlobalAlloc [],\n            mir_struct_value PhantomData_i32 []\n        ],\n        mir_term {{ `len : [64] }}\n    ]);\n};\n\nlet rev_i32_spec_manual len = do {\n    contents <- mir_fresh_var \"contents\" (mir_array len mir_i32);\n    in_vec <- mk_vec_i32 len (mir_term contents);\n    mir_execute_func [in_vec];\n    out_vec <- mk_vec_i32 len (mir_term {{ reverse contents }});\n    mir_return out_vec;\n};\n\nrev_i32_ov_manual <- mir_verify m \"test::rev_i32\" [] false (rev_i32_spec_manual 10) z3;\n\nlet rev_rev_i32_spec_manual len = do {\n    contents <- mir_fresh_var \"contents\" (mir_array len mir_i32);\n    in_vec <- mk_vec_i32 len (mir_term contents);\n    mir_execute_func [in_vec];\n    out_vec <- mk_vec_i32 len (mir_term contents);\n    mir_return out_vec;\n};\n\nmir_verify m \"test::rev_rev_i32\" [rev_i32_ov_manual] false (rev_rev_i32_spec_manual 10) z3;\n\n\/\/ Test mir_vec_of.\n\nlet rev_spec_auto ty len = do {\n    contents <- mir_fresh_var \"contents\" (mir_array len ty);\n    in_vec <- mir_vec_of \"in_vec\" ty (mir_term contents);\n    mir_execute_func [in_vec];\n    out_vec <- mir_vec_of \"out_vec\" ty (mir_term {{ reverse contents }});\n    mir_return out_vec;\n};\n\nlet rev_rev_spec_auto ty len = do {\n    contents <- mir_fresh_var \"contents\" (mir_array len ty);\n    in_vec <- mir_vec_of \"in_vec\" ty (mir_term contents);\n    mir_execute_func [in_vec];\n    out_vec <- mir_vec_of \"out_vec\" ty (mir_term contents);\n    mir_return out_vec;\n};\n\nrev_i32_ov_auto <- mir_verify m \"test::rev_i32\" [] false (rev_spec_auto mir_i32 10) z3;\nmir_verify m \"test::rev_rev_i32\" [rev_i32_ov_auto] false (rev_rev_spec_auto mir_i32 10) z3;\n\nrev_tuple_ov_auto <- mir_verify m \"test::rev_tuple\" [] false (rev_spec_auto (mir_tuple [mir_u8, mir_i64, mir_u128]) 10) z3;\nmir_verify m \"test::rev_rev_tuple\" [rev_tuple_ov_auto] false (rev_rev_spec_auto (mir_tuple [mir_u8, mir_i64, mir_u128]) 10) z3;\n\n\/\/ Uncomment this when Vec of ZST is supported in crucible (blocked by at least\n\/\/ crucible#1497 and #1504).\n\n\/\/ Test that empty Vecs work.\n\n\/*\nThis test is disabled for now while we work on improving the Vec API in #2666.\n\nlet empty_spec = do {\n    mir_execute_func [];\n    out_vec <- mir_vec_of \"out_vec\" mir_i32 (mir_array_value mir_i32 []);\n    mir_return out_vec;\n};\n\nempty_ov <- mir_verify m \"test::empty\" [] false empty_spec z3;\n\nlet empty_len_spec = do {\n    mir_execute_func [];\n    mir_return (mir_term {{ 0 : [64] }});\n};\n\nmir_verify m \"test::empty_len\" [empty_ov] false empty_len_spec z3;\n*\/\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0044_invariant_4\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh n ty = do {\n  p <- llvm_alloc ty;\n  x <- llvm_fresh_var n ty;\n  llvm_points_to p (llvm_term x);\n  return (p, x);\n};\n\nlet len = 100;\n\nlet array_inc_spec = do {\n  (pa, a) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 8));\n  let n = llvm_term {{ `len : [64] }};\n  llvm_execute_func [pa, n];\n};\n\nlet inv_spec = do {\n  (pa, a) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 8));\n  ppa <- llvm_alloc (llvm_int 64);\n  llvm_points_to ppa pa;\n  let n = llvm_term {{ `len : [64] }};\n  pn <- llvm_alloc (llvm_int 64);\n  llvm_points_to pn n;\n  (pi, i) <- ptr_to_fresh \"i\" (llvm_int 64);\n  llvm_precond {{ 0 <= i \/\\ i <= `len }};\n  llvm_execute_func [ppa, pn, pi];\n};\n\ninv <- llvm_unsafe_assume_spec m \"__breakpoint__inv#array_inc\" inv_spec;\nllvm_verify m \"__breakpoint__inv#array_inc\" [inv] false inv_spec abc;\nllvm_verify m \"array_inc\" [inv] false array_inc_spec abc;\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_x86_08\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\n\/\/ Test a function with more than 6 arguments to ensure that the remaining\n\/\/ arguments are spilled to the stack on x86-64.\nlet test_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_execute_func\n    [ llvm_term {{ 0 : [64] }}\n    , llvm_term {{ 1 : [64] }}\n    , llvm_term {{ 2 : [64] }}\n    , llvm_term {{ 3 : [64] }}\n    , llvm_term {{ 4 : [64] }}\n    , llvm_term {{ 5 : [64] }}\n    , llvm_term x\n    , llvm_term {{ 1 : [64] }}\n    ];\n  llvm_return (llvm_term {{ x - 1 }});\n};\n\nllvm_verify_x86 m \".\/test\" \"test\" [] true test_spec w4;\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_points_to_overrides\/test.saw","filetype":"saw","content":"enable_experimental;\n\nimpl_mir <- mir_load_module \"test.linked-mir.json\";\n\nlet inner_spec = do {\n    x <- mir_fresh_var \"x\" mir_u32;\n    r <- mir_alloc_mut mir_u32;\n    mir_points_to r (mir_term x);\n\n    mir_execute_func [r];\n\n    mir_points_to r (mir_term x);\n};\n\nlet outer_spec = do {\n    x <- mir_fresh_var \"x\" mir_u32;\n    r <- mir_alloc_mut mir_u32;\n    mir_points_to r (mir_term x);\n\n    mir_execute_func [r];\n\n    mir_points_to r (mir_term x);\n};\n\ninner_ov <- mir_verify impl_mir \"test::inner\" []         false inner_spec z3;\nouter_ov <- mir_verify impl_mir \"test::outer\" [inner_ov] false outer_spec z3;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test0061_path_sat\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"termination.bc\";\n\nlet g_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_execute_func [llvm_term x];\n  };\n\nllvm_verify m \"g1\" [] false g_spec z3;\n\n\/\/ NB: path sat checking is required for this\n\/\/ to terminate in a reasonable time\nllvm_verify m \"g2\" [] true g_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_external_abc\/test.saw","filetype":"saw","content":"enable_experimental;\n\n\/\/ A formula that is universally true.\nlet t = {{ \\(x:[8]) (y:[8]) -> x == y ==> x+y == x+x }};\n\nprove_print sbv_abc t;\nprove_print w4_abc_smtlib2 t;\nprove_print w4_abc_verilog t;\nprove_print (offline_verilog \"offline_verilog\") t;\nprove_print (w4_offline_smtlib2 \"w4_offline_smtlib2\") t;\nprove_print (offline_aig_external \"offline_aig\") t;\nprove_print (offline_cnf_external \"offline_cnf\") t;\n\n\/\/ A formula that is unsatisfiable.\nlet q_unsat = {{ \\(x:[8]) -> x != 0 \/\\ x+x == x }};\n\nwrite_verilog \"write_verilog_unsat.v\" q_unsat;\nwrite_smtlib2_w4 \"write_smtlib2_w4_unsat.smt2\" q_unsat;\nwrite_aig_external \".\/write_aig_external_unsat.aig\" q_unsat;\nwrite_cnf_external \".\/write_aig_external_unsat.cnf\" q_unsat;\n\n\/\/ A formula that is satisfiable.\nlet q_sat = {{ \\(x:[8]) -> x+x == x }};\n\nwrite_verilog \"write_verilog_sat.v\" q_sat;\nwrite_smtlib2_w4 \"write_smtlib2_w4_sat.smt2\" q_sat;\nwrite_aig_external \".\/write_aig_external_sat.aig\" q_sat;\nwrite_cnf_external \".\/write_aig_external_sat.cnf\" q_sat;\n\nfails (prove_print sbv_abc q_sat);\nfails (prove_print w4_abc_smtlib2 q_sat);\nfails (prove_print w4_abc_verilog q_sat);\n\n\/\/ A function that returns a sequence\nlet seqt = {{ \\(x:[8]) (y:[8]) -> [x + y, x - y] }};\nwrite_verilog \"write_verilog_seqt.v\" seqt;\n\n\/\/ A function that returns a tuple\nlet tupt = {{ \\(x:[8]) (y:[8]) -> (x + y, x - y) }};\nwrite_verilog \"write_verilog_tupt.v\" tupt;\n\nlet order_term = {{ \\(x:[2][2][8]) -> \\(y:[32]) -> y == 0x81050fff \/\\ x == [[2,3],[4,5]] }};\nlet order_res = {{ ([[0x02,0x03],[0x04,0x05]], 0x81050fff) }};\n\n\/\/ Check that Verilog counterexamples are in the right order\nsr1 <- sat w4_abc_verilog order_term;\ncaseSatResult sr1 (fail \"ABC verilog sat fail\") (\\t -> prove_print yices {{ t == order_res }});\n\n\/\/ Check that AIGER counterexamples are in the right order\nsr2 <- sat w4_abc_aiger order_term;\ncaseSatResult sr2 (fail \"ABC aiger sat fail\") (\\t -> prove_print yices {{ t == order_res }});\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_global_field\/test.saw","filetype":"saw","content":"\/\/ This test ensures that `llvm_field` can be used in conjunction\n\/\/ with `llvm_global`. It is a regression test for saw-script\n\/\/ issue 742 (https:\/\/github.com\/GaloisInc\/saw-script\/issues\/742).\n\nbc <- llvm_load_module \"test.bc\";\n\nllvm_verify bc \"set\" [] false\n  do {\n    llvm_alloc_global \"the_pair\";\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    llvm_execute_func [llvm_term x, llvm_term y];\n    llvm_points_to (llvm_field (llvm_global \"the_pair\") \"first\") (llvm_term x);\n    llvm_points_to (llvm_field (llvm_global \"the_pair\") \"second\") (llvm_term y);\n  }\n  z3;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_FNV_a1_rev\/FNV_a1.cry","filetype":"cry","content":"fnv1a : {n} (fin n) => [n] -> [64]\nfnv1a ws = fnv1a' (pad ws)\n\npad : {msgLen,chunks,padding}\n     ( fin chunks\n     , fin msgLen\n     , chunks     == (msgLen+7) \/ 8\n     , padding    == (8 - msgLen % 8) % 8\n     )\n     => [msgLen] -> [chunks][8]\npad msg = split (msg # (zero:[padding]))\n\nfnv1a' : {chunks} (fin chunks) => [chunks][8] -> [64]\nfnv1a' msg = Ss ! 0\n  where\n   Ss = [fnv1a_offset_basis] #\n           [ block s m\n           | s <- Ss\n           | m <- msg\n           ]\n\nblock : {padding} ( fin padding, padding == 64 - 8) => [64] -> [8] -> [64]\nblock state val = (state ^ ((zero : [padding]) # val)) * fnv1a_prime\n\nfnv1a_offset_basis : [64]\nfnv1a_offset_basis = 14695981039346656037\n\nfnv1a_prime : [64]\nfnv1a_prime = 1099511628211\n\nt1 = fnv1a [] == 0xcbf29ce484222325\nt2 = fnv1a (join \"a\") == 0xaf63dc4c8601ec8c\nt3 = fnv1a (join \"foobar\") == 0x85944171f73967e8\n\nproperty testsPass = [t1, t2, t3] == ~zero\n\nbreak : {n} (fin n) => [4]([64],[64]) -> [n][8] -> Bit\nbreak pairs secret = ~zero == [saltHashCorrect p secret | p <- pairs]\n\nsecret1 : [4]([64],[64])\nsecret1 = [ (`0    , saltHash `0x0   msg)\n          , (`0xF  , saltHash `0xF   msg)\n          , (`0xFF , saltHash `0xFF  msg)\n          , (`0xFFF, saltHash `0xFFF msg)\n          ]\n  where msg = \"Secret Message\"\n\nsaltHashCorrect : {n} (fin n) => ([64],[64]) -> [n][8] -> Bit\nsaltHashCorrect (salt,result) secret = saltHash salt secret == result\n\nsaltHash : {n} (fin n) => [64] -> [n][8] -> [64]\nsaltHash s msg = fnv1a (s # join msg)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0040_statics\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"static.bc\";\n\nf_ov <- llvm_verify m \"f\" [] false do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    let xtm = llvm_term x;\n    llvm_execute_func [xtm];\n    llvm_return xtm;\n} abc;\n\nllvm_verify m \"f1\" [f_ov] false do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_execute_func [llvm_term x];\n    llvm_return (llvm_term {{ x + 1}});\n} abc;\n\nllvm_verify m \"f2\" [f_ov] false do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_execute_func [llvm_term x];\n    llvm_return (llvm_term {{ x - 1}});\n} abc;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test0056_instantiate_match_term\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet foo_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [(llvm_term x), (llvm_term {{ x + 1 }})];\n  llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nlet bar_spec = do {\n  llvm_execute_func [];\n};\n\nfoo_ov <- llvm_verify m \"foo\" [] false foo_spec abc;\nllvm_verify m \"bar\" [foo_ov] false bar_spec abc;\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_verify_conds\/test.saw","filetype":"saw","content":"enable_experimental;\n\n\/\/ A spec using mir_precond\n\nlet add1_precond_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_precond {{ x < 0xffffffff }};\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term {{ x + 1 }});\n};\n\n\/\/ A spec using mir_assert in a precondition\n\nlet add1_precond_assert_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_assert {{ x < 0xffffffff }};\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term {{ x + 1 }});\n};\n\n\/\/ A spec using mir_postcond\n\nlet add1_postcond_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_precond {{ x < 0xffffffff }};\n\n  mir_execute_func [mir_term x];\n\n  x' <- mir_fresh_var \"x'\" mir_u32;\n  mir_return (mir_term x');\n  mir_postcond {{ x < x' }};\n};\n\n\/\/ A spec using mir_assert in a postcondition\n\nlet add1_postcond_assert_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_precond {{ x < 0xffffffff }};\n\n  mir_execute_func [mir_term x];\n\n  x' <- mir_fresh_var \"x'\" mir_u32;\n  mir_return (mir_term x');\n  mir_assert {{ x < x' }};\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::add1\" [] false add1_precond_spec z3;\nmir_verify m \"test::add1\" [] false add1_precond_assert_spec z3;\nmir_verify m \"test::add1\" [] false add1_postcond_spec z3;\nmir_verify m \"test::add1\" [] false add1_postcond_assert_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_x86_07\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet precondtest_setup = do {\n  x <- crucible_fresh_var \"x\" (llvm_int 64);\n  crucible_precond {{ x < 10 }};\n  llvm_execute_func [crucible_term x];\n  x' <- crucible_fresh_var \"x'\" (llvm_int 64);\n  crucible_return (crucible_term x');\n  crucible_postcond {{ x' < 10 }};\n};\n\nllvm_verify_x86 m \".\/precondtest\" \"precondtest\" [] false precondtest_setup w4;","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_non_fresh\/test.saw","filetype":"saw","content":"\/\/ This test checks whether we can verify a spec that says a function\n\/\/ returns a fresh pointer, when in actuality the function returns\n\/\/ a pointer from the input. It is a regression test for saw-script\n\/\/ issue #641.\n\/\/ https:\/\/github.com\/GaloisInc\/saw-script\/issues\/641\n\nbc <- llvm_load_module \"test.bc\";\n\nlet i64 = llvm_int 64;\n\nfoo_ov <-\n  llvm_verify bc \"foo\" [] false\n    do {\n      x <- llvm_alloc i64;\n      llvm_execute_func [x];\n      llvm_return x;\n    }\n    z3;\n\nfails (\n  llvm_verify bc \"foo\" [] false\n    do {\n      x <- llvm_alloc i64;\n      llvm_execute_func [x];\n      y <- llvm_alloc i64;\n      llvm_return y;\n    }\n    z3\n  );\n\nfails (\n  llvm_verify bc \"bar\" [foo_ov] false\n    do {\n      x <- llvm_alloc i64;\n      llvm_execute_func [x];\n      llvm_return (llvm_term {{ 0 : [32] }});\n    }\n    z3\n  );\n\nbar_ov1 <-\n  llvm_verify bc \"bar\" [] false\n    do {\n      x <- llvm_alloc i64;\n      llvm_execute_func [x];\n      llvm_return (llvm_term {{ 1 : [32] }});\n    }\n    z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0027_crucible_llvm\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nllvm_verify m \"add_nums32\" [] false\n  do { x <- llvm_fresh_var \"x\" (llvm_int 32);\n       y <- llvm_fresh_var \"y\" (llvm_int 32);\n       llvm_execute_func [ llvm_term x, llvm_term y ];\n       llvm_return (llvm_term {{ x + y }});\n     }\n  z3;\n\n\nllvm_verify m \"add_nums64\" [] false\n  do { x <- llvm_fresh_var \"x\" (llvm_int 64);\n       y <- llvm_fresh_var \"y\" (llvm_int 64);\n       llvm_execute_func [ llvm_term x, llvm_term y ];\n       llvm_return (llvm_term {{ x + y }});\n     }\n  z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_goal_tags_01\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet f_spec : CrucibleSetup () = llvm_setup_with_tag \"f spec\" do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{i < 512}};\n  llvm_execute_func [llvm_term i];\n\n  j <- llvm_fresh_var \"j\" (llvm_int 32);\n  llvm_return (llvm_term j);\n  llvm_setup_with_tag \"post bound\"\n    (llvm_postcond {{ j <= 512 }});\n  llvm_setup_with_tag \"post eq\"\n    (llvm_postcond {{ j == i+1 }});\n};\n\nlet tac : ProofScript () = do {\n  isBound <- goal_has_tags [\"post bound\", \"f spec\"];\n  isEq    <- goal_has_tags [\"post eq\", \"f spec\"];\n\n  if isBound then do {\n    print_goal_summary;\n    yices;\n  } else if isEq then do {\n    print_goal_summary;\n    z3;\n  } else do {\n    \/\/ empty tactic should fail here if there are any goals\n    \/\/ not handled by the above\n    return ();\n  };\n};\n\nlet main : TopLevel () = do {\n  m <- llvm_load_module \"test.bc\";\n  llvm_verify m \"f\" [] false f_spec tac;\n  print \"done\";\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_fresh_cryptol_var\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet id_spec cty = do {\n  x <- mir_fresh_cryptol_var \"x\" cty;\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term x);\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::id_array\" [] false (id_spec {| [5][32] |}) z3;\nmir_verify m \"test::id_tuple\" [] false (id_spec {| ([32], [32]) |}) z3;\nmir_verify m \"test::id_u32\" [] false (id_spec {| [32] |}) z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_jvm_static_fields\/test.saw","filetype":"saw","content":"a <- java_load_class \"A\";\nprint a;\nb <- java_load_class \"B\";\nc <- java_load_class \"C\";\n\nprint \"Verifying class A\";\n\na_setX <-\n  jvm_verify a \"setX\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      v <- jvm_fresh_var \"v\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      jvm_execute_func [jvm_term v];\n      jvm_static_field_is \"x\" (jvm_term v);\n    }\n    z3;\n\na_setY <-\n  jvm_verify a \"setY\" [] false\n    do {\n      y <- jvm_fresh_var \"y\" java_long;\n      v <- jvm_fresh_var \"v\" java_long;\n      jvm_static_field_is \"y\" (jvm_term y);\n      jvm_execute_func [jvm_term v];\n      jvm_static_field_is \"y\" (jvm_term v);\n    }\n    z3;\n\na_getSum <-\n  jvm_verify a \"getSum\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      y <- jvm_fresh_var \"y\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      jvm_static_field_is \"y\" (jvm_term y);\n      jvm_execute_func [];\n      jvm_return (jvm_term {{ x + y }});\n    }\n    z3;\n\nprint \"Verifying class B\";\n\nb_setX <-\n  jvm_verify b \"setX\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      v <- jvm_fresh_var \"v\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      jvm_execute_func [jvm_term v];\n      jvm_static_field_is \"x\" (jvm_term v);\n    }\n    z3;\n\nb_setY <-\n  jvm_verify b \"setY\" [] false\n    do {\n      y <- jvm_fresh_var \"y\" java_long;\n      v <- jvm_fresh_var \"v\" java_long;\n      jvm_static_field_is \"y\" (jvm_term y);\n      jvm_execute_func [jvm_term v];\n      jvm_static_field_is \"y\" (jvm_term v);\n    }\n    z3;\n\nfails (\n  jvm_verify b \"getSum\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      y <- jvm_fresh_var \"y\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      \/\/ This fails because \"getSum\" is inherited from class A,\n      \/\/ which has its own static field called \"y\", which in turn\n      \/\/ is shadowed by field \"y\" from class B.\n      jvm_static_field_is \"y\" (jvm_term y);\n      jvm_execute_func [];\n      jvm_return (jvm_term {{ x + y }});\n    }\n    z3);\n\nb_getSum <-\n  jvm_verify b \"getSum\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      y <- jvm_fresh_var \"y\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      \/\/ Because field \"A.y\" is shadowed by another field named \"y\"\n      \/\/ in class \"B\", we must use the qualified field name.\n      jvm_static_field_is \"A.y\" (jvm_term y);\n      jvm_execute_func [];\n      jvm_return (jvm_term {{ x + y }});\n    }\n    z3;\n\nprint \"Verifying class C\";\n\nc_setX <-\n  jvm_verify c \"setX\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      v <- jvm_fresh_var \"v\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      jvm_execute_func [jvm_term v];\n      jvm_static_field_is \"x\" (jvm_term v);\n    }\n    z3;\n\nc_setY <-\n  jvm_verify c \"setY\" [] false\n    do {\n      y <- jvm_fresh_var \"y\" java_long;\n      v <- jvm_fresh_var \"v\" java_long;\n      jvm_static_field_is \"y\" (jvm_term y);\n      jvm_execute_func [jvm_term v];\n      jvm_static_field_is \"y\" (jvm_term v);\n    }\n    z3;\n\nc_getSum <-\n  jvm_verify c \"getSum\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      y <- jvm_fresh_var \"y\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      jvm_static_field_is \"y\" (jvm_term y);\n      jvm_execute_func [];\n      jvm_return (jvm_term {{ x + y }});\n    }\n    z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_bitfield_duplicate_points_to\/test.saw","filetype":"saw","content":"enable_experimental;\nenable_lax_loads_and_stores;\n\nlet get_y_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 1);\n  \/\/ Duplicate llvm_points_to_bitfield statements involving `y`\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n  llvm_execute_func [ss];\n  llvm_return (llvm_term z);\n};\n\nm <- llvm_load_module \"test.bc\";\nfails (llvm_verify m \"get_y\" [] false get_y_spec (w4_unint_z3 []));\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_one_past_end\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet t = llvm_array 16 (llvm_int 32);\n\nlet spec_increment = do {\n    a <- llvm_fresh_var \"a\" t;\n    p <- llvm_alloc t;\n    llvm_points_to p (llvm_term a);\n    let ptr_end = llvm_elem p 16;\n    llvm_execute_func [ptr_end];\n};\n\nlet spec_increment_span = do {\n    a <- llvm_fresh_var \"a\" t;\n    p <- llvm_alloc t;\n    llvm_points_to p (llvm_term a);\n    let ptr_start = llvm_elem p 0;\n    let ptr_end = llvm_elem p 16;\n    llvm_execute_func [ptr_start, ptr_end];\n    llvm_points_to p (llvm_term {{ map (\\x -> x+1) a }} );\n};\n\nllvm_verify m \"increment_span\" [] false spec_increment_span rme;\nfails (llvm_verify m \"increment\" [] false spec_increment rme);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test2045\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet oneThroughFive = mir_term {{ [1, 2, 3, 4, 5] : [5][8] }};\n\nlet f_spec_1 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_value a];\n\n  mir_return (mir_term {{ 3 : [8] }});\n};\n\nlet f_spec_2 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_range_value a 1 3];\n\n  mir_return (mir_term {{ 5 : [8] }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nf_ov_1 <- mir_verify m \"test::f\" [] false f_spec_1 z3;\nmir_verify m \"test::g\" [f_ov_1] false f_spec_1 z3;\n\nf_ov_2 <- mir_verify m \"test::f\" [] false f_spec_2 z3;\nmir_verify m \"test::g\" [f_ov_2] false f_spec_2 z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_newtype\/complex.cry","filetype":"cry","content":"\/\/ This is a development of rational complex numbers\n\ntype Int = Integer\n\n\/\/ Complex rational numbers in rectangular coordinates\nnewtype CplxInt =\n  { real : Int, imag : Int }\n\nembedQ : Int -> CplxInt\nembedQ x = CplxInt{ real = x, imag = 0 }\n\ncplxAdd : CplxInt -> CplxInt -> CplxInt\ncplxAdd x y = CplxInt { real = r, imag = i }\n  where\n  r = x.real + y.real\n  i = x.imag + y.imag\n\ncplxMul : CplxInt -> CplxInt -> CplxInt\ncplxMul x y = CplxInt { real = r, imag = i }\n  where\n  r = x.real * y.real - x.imag * y.imag\n  i = x.real * y.imag + x.imag * y.real\n\ncplxEq : CplxInt -> CplxInt -> Bit\ncplxEq x y = (x.real == y.real) && (x.imag == y.imag)\n\ncplxAddAssoc : CplxInt -> CplxInt -> CplxInt -> Bit\ncplxAddAssoc x y z =\n  cplxEq (cplxAdd (cplxAdd x y) z)\n         (cplxAdd x (cplxAdd y z))\n\ncplxMulAssoc : CplxInt -> CplxInt -> CplxInt -> Bit\ncplxMulAssoc x y z =\n  cplxEq (cplxMul (cplxMul x y) z)\n         (cplxMul x (cplxMul y z))\n\ncplxMulDistrib : CplxInt -> CplxInt -> CplxInt -> Bit\ncplxMulDistrib x y z =\n  cplxEq (cplxMul x (cplxAdd y z))\n         (cplxAdd (cplxMul x y) (cplxMul x z))","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_newtype\/complex_newtype.saw","filetype":"saw","content":"import \"complex.cry\";\n\nprove_print cvc4 {{ \\ x y z -> cplxAddAssoc x y z}};\n\nprove_print cvc4 {{ \\ x y z -> cplxMulAssoc x y z}};\n\nprove_print cvc4 {{ \\ x y z -> cplxMulDistrib x y z}};\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0053_crucible_symbolic_alloc\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet foo_spec check = do {\n  n <- llvm_fresh_var \"n\" (llvm_int 64);\n  x_ptr <- llvm_symbolic_alloc false 4 {{ n * 4 }};\n  i <- llvm_fresh_var \"i\" (llvm_int 64);\n  llvm_precond {{ n < 2 ^^ 61 }};\n  if check then do {\n    llvm_precond {{ i < n }};\n  } else do {\n    return ();\n  };\n  llvm_execute_func [x_ptr, (llvm_term n), (llvm_term i)];\n};\n\nlet bar_spec = do {\n  n <- llvm_fresh_var \"n\" (llvm_int 64);\n  x_ptr <- llvm_symbolic_alloc false 4 n;\n  i <- llvm_fresh_var \"i\" (llvm_int 64);\n  llvm_precond {{ n < 2 ^^ 63 }};\n  llvm_precond {{ n && 3 == 0 }};\n  llvm_execute_func [x_ptr, (llvm_term n), (llvm_term i)];\n};\n\nfails (llvm_verify m \"foo\" [] false (foo_spec false) yices);\nfoo_ov <- llvm_verify m \"foo\" [] false (foo_spec true) yices;\nllvm_verify m \"bar\" [foo_ov] false bar_spec yices;\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_statics\/test.saw","filetype":"saw","content":"enable_experimental;\n\n\/\/ A basic spec that uses the initial value of S1.\nlet f1_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_static_initializer \"test::S1\");\n};\n\n\/\/ An alternative spec that uses a different initial value for S1.\nlet f1_alt_spec = do {\n  let s1_static = mir_static \"test::S1\";\n  let init = mir_term {{ 42 : [32] }};\n  mir_points_to s1_static init;\n\n  mir_execute_func [];\n\n  mir_points_to s1_static init;\n  mir_return init;\n};\n\n\/\/ A buggy spec that refers to a non-existent static initializer value.\nlet f1_fail_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_static_initializer \"test::S1_fake\");\n};\n\n\/\/ A buggy spec that refers to a non-existent static value.\nlet f1_fail_alt_spec = do {\n  let s1_static = mir_static \"test::S1_fake\";\n  let init = mir_term {{ 42 : [32] }};\n  mir_points_to s1_static init;\n\n  mir_execute_func [];\n\n  mir_points_to s1_static init;\n  mir_return init;\n};\n\n\/\/ A spec that matches against a static in the return value.\nlet f2_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_static \"test::S2\");\n};\n\n\/\/ A basic spec that uses the initial value of S3.\nlet f3_spec = do {\n  let s3_static = mir_static \"test::S3\";\n  mir_points_to s3_static (mir_static_initializer \"test::S3\");\n\n  mir_execute_func [];\n\n  let ret = mir_term {{ 4 : [32] }};\n  mir_points_to s3_static ret;\n  mir_return ret;\n};\n\n\/\/ An alternative spec that uses a different initial value for S3.\nlet f3_alt_spec = do {\n  let s3_static = mir_static \"test::S3\";\n  let init = {{ 42 : [32] }};\n  mir_points_to s3_static (mir_term init);\n\n  mir_execute_func [];\n\n  let ret = mir_term {{ init + 1 }};\n  mir_points_to s3_static ret;\n  mir_return ret;\n};\n\n\/\/ A buggy spec that does not initialize S3 (a mutable static value).\nlet f3_fail_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_term {{ 4 : [32] }});\n};\n\n\/\/ A spec that ensures that fresh allocations do not alias with static\n\/\/ references.\nlet g_spec = do {\n  r_ref <- mir_alloc mir_u32;\n\n  mir_execute_func [r_ref];\n\n  mir_return (mir_term {{ False }});\n};\n\n\/\/ g(&S1) should return True.\nlet g_alt_spec = do {\n  mir_execute_func [mir_static \"test::S1\"];\n\n  mir_return (mir_term {{ True }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::f1\" [] false f1_spec z3;\nmir_verify m \"test::f1\" [] false f1_alt_spec z3;\nmir_verify m \"test::f2\" [] false f2_spec z3;\nmir_verify m \"test::f3\" [] false f3_spec z3;\nmir_verify m \"test::f3\" [] false f3_alt_spec z3;\nmir_verify m \"test::g\" [] false g_spec z3;\nmir_verify m \"test::g\" [] false g_alt_spec z3;\n\nfails (\n  mir_verify m \"test::f1\" [] false f1_fail_spec z3\n);\nfails (\n  mir_verify m \"test::f1\" [] false f1_fail_alt_spec z3\n);\nfails (\n  mir_verify m \"test::f3\" [] false f3_fail_spec z3\n);\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_llvm_global_fresh_pointer\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\n\/\/ test the fact that glb and x_ptr are allowed to alias each other.\nlet foo_spec = do {\n  llvm_alloc_global \"glb\";\n  x_ptr <- llvm_fresh_pointer (llvm_int 32);\n\n  llvm_execute_func [x_ptr];\n};\n  \nfoo_ov <- llvm_verify m \"foo\"\n  []\n  false\n  foo_spec\n  (do {\n    print_goal;\n    w4_unint_z3 [];\n  });\n\nllvm_verify m \"bar\"\n  [foo_ov]\n  false\n  foo_spec\n  (do {\n    print_goal;\n    w4_unint_z3 [];\n  });\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0047_alloc_sized\/test.saw","filetype":"saw","content":"\/\/ Ultimately, this spec is unsound when used as an override due to issue #30,\n\/\/ but it demonstrates the llvm_alloc_with_size feature.\nm <- llvm_load_module \"test.bc\";\nenable_experimental;\nlet set_spec = do {\n  \/\/ sizeof(A_t) + sizeof(B_t) = 8\n  both_ptr <- llvm_alloc_with_size 8 (llvm_type \"%struct.A\");\n  llvm_points_to (llvm_field both_ptr \"x\") (llvm_term {{ 0 : [32] }});\n  llvm_execute_func [both_ptr];\n  llvm_points_to (llvm_field both_ptr \"x\") (llvm_term {{ 10 : [32] }});\n};\nllvm_verify m \"set\" [] false set_spec z3;","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_verify_enums\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet option_u32_adt = mir_find_adt m \"core::option::Option\" [mir_u32];\nlet i_adt = mir_find_adt m \"test::I\" [];\n\nlet f_none_spec = do {\n  let x = mir_enum_value option_u32_adt \"None\" [];\n\n  mir_execute_func [x];\n\n  mir_return (mir_term {{ 27 : [32] }});\n};\n\nlet f_some_spec = do {\n  let ret = mir_term {{ 42 : [32] }};\n  let x = mir_enum_value option_u32_adt \"Some\" [ret];\n\n  mir_execute_func [x];\n\n  mir_return ret;\n};\n\nlet g_spec = do {\n  b <- mir_fresh_var \"b\" mir_bool;\n\n  mir_execute_func [mir_term b];\n\n  mir_return (mir_term {{ if b then 27 else 42 : [32] }});\n};\n\nlet h_none_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_enum_value option_u32_adt \"None\" []);\n};\n\nlet h_some_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_enum_value option_u32_adt \"Some\" [mir_term x]);\n};\n\nlet i42_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_enum_value i_adt \"I42\" []);\n};\n\nlet i43_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_enum_value i_adt \"I43\" []);\n};\n\n\/\/ `mir_enum_value` should error if it cannot find a variant name.\nlet i43_bad_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_enum_value i_adt \"I44\" []);\n};\n\nf_none_ov <- mir_verify m \"test::f\" [] false f_none_spec z3;\nf_some_ov <- mir_verify m \"test::f\" [] false f_some_spec z3;\n\nmir_verify m \"test::g\" [f_none_ov, f_some_ov] false g_spec z3;\n\nmir_verify m \"test::h_none\" [] false h_none_spec z3;\nmir_verify m \"test::h_some\" [] false h_some_spec z3;\n\nmir_verify m \"test::i42\" [] false i42_spec z3;\nmir_verify m \"test::i43\" [] false i43_spec z3;\nfails (\n  mir_verify m \"test::i43\" [] false i43_bad_spec z3\n);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test2028_vacuity_detect\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet fun_rs_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_precond {{ x != x }};\n  mir_execute_func [];\n};\nmir_mod <- mir_load_module \"test.linked-mir.json\";\nmir_verify mir_mod \"test::fun_rs\" [] false fun_rs_spec z3;\n\nlet fun_jvm_spec = do {\n  x <- jvm_fresh_var \"x\" java_int;\n  jvm_precond {{ x != x }};  \/\/ Always false\n  jvm_execute_func [];\n};\n\ncls <- java_load_class \"Test\";\njvm_verify cls \"fun_jvm\" [] false fun_jvm_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_unsafe_assume_spec\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet f_generic_spec (x : Term) = do {\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term x);\n};\n\nlet f_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  f_generic_spec x;\n};\n\nlet f2_spec = do {\n  let x = {{ 2 : [32] }};\n  f_generic_spec x;\n};\n\nlet f3_spec = do {\n  let x = {{ 3 : [32] }};\n  f_generic_spec x;\n};\n\nlet g_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term {{ x + 1 }});\n};\n\nlet g2_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_term {{ 3 : [32] }});\n};\n\nlet h_spec = g_spec;\n\nlet p_spec_1 = do {\n  x_ptr <- mir_alloc mir_u32;\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_points_to x_ptr (mir_term x);\n\n  y_ptr <- mir_alloc mir_u32;\n  y <- mir_fresh_var \"y\" mir_u32;\n  mir_points_to y_ptr (mir_term y);\n\n  mir_execute_func [x_ptr, y_ptr];\n\n  mir_return (mir_term {{ x + y }});\n};\n\nlet p_spec_2 = do {\n  x_ptr <- mir_alloc mir_u32;\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_points_to x_ptr (mir_term x);\n\n  mir_execute_func [x_ptr, x_ptr];\n\n  mir_return (mir_term {{ 2 * x }});\n};\n\nlet q_spec = p_spec_1;\n\nlet side_spec_1 = do {\n  a_ptr <- mir_alloc_mut mir_u32;\n  a <- mir_fresh_var \"a\" mir_u32;\n  mir_points_to a_ptr (mir_term a);\n\n  mir_execute_func [a_ptr];\n\n  mir_points_to a_ptr (mir_term {{ 0 : [32] }});\n  mir_return (mir_term a);\n};\n\nlet side_spec_2 = do {\n  a_ptr <- mir_alloc_mut mir_u32;\n  a <- mir_fresh_var \"a\" mir_u32;\n  mir_points_to a_ptr (mir_term a);\n\n  mir_execute_func [a_ptr];\n\n  mir_return (mir_term a);\n};\n\n\/\/ This spec is erroneous. See the comments below in the \"Avoid unsoundness\"\n\/\/ part of the test.\nlet foo_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term {{ x }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nf_ov  <- mir_unsafe_assume_spec m \"test::f\" f_spec;\nf2_ov <- mir_unsafe_assume_spec m \"test::f\" f2_spec;\nf3_ov <- mir_unsafe_assume_spec m \"test::f\" f3_spec;\n\n\/\/ `g` should fail without an override for `f`...\nfails (\n  mir_verify m \"test::g\" [] false g_spec z3\n);\n\/\/ ...but should succeed with an `f` override.\nmir_verify m \"test::g\" [f_ov] false g_spec z3;\n\/\/ `h` never calls `f`, but it's still fine to redundantly pass an `f` override\nmir_verify m \"test::h\" [f_ov] false h_spec z3;\n\n\/\/ `g2` will succeed with both a generic `f` override as well as a specialized\n\/\/ one where the argument and result values are concrete.\nmir_verify m \"test::g2\" [f_ov] false g2_spec z3;\nmir_verify m \"test::g2\" [f2_ov] false g2_spec z3;\nmir_verify m \"test::g2\" [f_ov, f2_ov] false g2_spec z3;\n\n\/\/ Overrides that fail to match.\nfails (\n  mir_verify m \"test::g\" [f3_ov] false g_spec z3\n);\nfails (\n  mir_verify m \"test::g2\" [f3_ov] false g2_spec z3\n);\n\np_ov_1 <- mir_unsafe_assume_spec m \"test::p\" p_spec_1;\np_ov_2 <- mir_unsafe_assume_spec m \"test::p\" p_spec_2;\n\nmir_verify m \"test::q\" [p_ov_1] false q_spec z3;\nfails (\n  mir_verify m \"test::q\" [p_ov_2] false q_spec z3\n);\n\nside_ov_1 <- mir_verify m \"test::side_effect\" [] false side_spec_1 z3;\nside_ov_2 <- mir_verify m \"test::side_effect\" [] false side_spec_2 z3;\n\n\/\/ This should not verify, as invoking `side_effect` should cause `foo` to\n\/\/ always return `0` rather than the argument value.\nfails (\n  mir_verify m \"test::foo\" [side_ov_1] false foo_spec z3\n);\n\/\/ This should not verify, as side_spec_2 underspecifies the mutable\n\/\/ allocation `a_ptr` in its postconditions. SAW will catch this when attempting\n\/\/ to use side_ov_2 as an override.\nfails (\n  mir_verify m \"test::foo\" [side_ov_2] false foo_spec z3\n);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_ghost_types_00\/test.saw","filetype":"saw","content":"let f_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_execute_func [llvm_term i];\n  llvm_ghost_value x i;\n  llvm_return (llvm_term i);\n};\n\nlet g_spec (y : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_execute_func [llvm_term i];\n  let v = {{ drop (i \/ 8) : [8] }};\n  llvm_ghost_value y v;\n  llvm_return (llvm_term v);\n};\n\nlet h_spec : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{i < 512}};\n  llvm_execute_func [llvm_term i];\n  ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n  llvm_return (llvm_term ret);\n  llvm_postcond {{ ret <= i }};\n};\n\nlet main : TopLevel () = do {\n  x <- declare_ghost_state \"x\";\n  m <- llvm_load_module \"test.bc\";\n  f_ov <- llvm_unsafe_assume_spec m \"f\" (f_spec x);\n  \/\/ This spec should probably use a different variable, but doesn't:\n  g_ov <- llvm_unsafe_assume_spec m \"g\" (g_spec x);\n  fails (llvm_verify m \"h\" [f_ov, g_ov] false h_spec z3);\n  print \"done\";\n};\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_dangling_hoist\/test.saw","filetype":"saw","content":"enable_experimental;\n\nprove_extcore do {\n    print_goal;\n    check_goal;\n    hoist_ifs_in_goal;\n    print_goal;\n    check_goal;\n    admit \"sure\";\n  }\n  (parse_core \"(x : Integer) -> (y:Integer) -> (z:Integer) -> (b:Bool) -> EqTrue (intEq z (ite Integer b x y)) -> EqTrue (ite Bool b (intEq z x) (intEq z y))\");\n\n\nprove_extcore do {\n    print_goal;\n    check_goal;\n    goal_eval;\n    print_goal;\n    check_goal;\n    admit \"sure\";\n  }\n  (parse_core \"(x : Integer) -> (y:Integer) -> (z:Integer) -> (b:Bool) -> EqTrue (intEq z (ite Integer b x y)) -> EqTrue (ite Bool b (intEq z x) (intEq z y))\");\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_bisimulation\/Comp.cry","filetype":"cry","content":"module Comp where\n\n\/\/ Specification for a functional AND gate. First output bit is the ready bit,\n\/\/ second bit is the result\nandSpec : ((), (Bit, Bit)) -> ((), (Bit, Bit))\nandSpec (_, (x, y)) = ((), (True, x && y))\n\n\/\/ Specification for a functional NAND gate. First output bit is the ready bit,\n\/\/ second bit is the result\nnandSpec : ((), (Bit, Bit)) -> ((), (Bit, Bit))\nnandSpec (_, (x, y)) = ((), (True, ~ (andSpec ((), (x, y))).1.1))\n\n\/\/ State for a stateful AND gate that first loads its inputs into memory, then\n\/\/ computes logical AND over them. `loaded` indicates whether the inputs have\n\/\/ been loaded into `origX` and `origY`.\ntype andState = { loaded : Bit, origX : Bit, origY : Bit }\n\n\/\/ A stateful AND gate.  First output bit is the ready bit, second bit is the\n\/\/ result.  This gate takes 2 cycles to compute.  It restarts when the input\n\/\/ changes.\nandImp : (andState, (Bit, Bit)) -> (andState, (Bit, Bit))\nandImp (s, (x, y)) =\n  if s.loaded \/\\ x == s.origX \/\\ y == s.origY\n  then (s, (True, s.origX && s.origY))\n  else ({ loaded = True, origX = x, origY = y }, (False, 0))\n\n\/\/ Output relation between `andImp` and `andSpec`.  Checks that outputs are\n\/\/ equivalent, given that `andImp` is ready to be read.\nandOutputRel : (andState, (Bit, Bit)) -> ((), (Bit, Bit)) -> Bit\nandOutputRel (s, (impReady, impO)) ((), (_, specO)) =\n  if impReady then impO == specO else True\n\n\/\/ State relation between `andImp` and `andSpec`.  Trivial in this case because\n\/\/ `andSpec` is stateless.\nandStateRel : andState -> () -> Bit\nandStateRel _ () = True\n\n\/\/ Stateful NAND gate holds `andState` as well as an unused bit.\ntype nandState = { as : andState, unused : Bit }\n\n\/\/ A stateful NAND gate.  First output bit is the ready bit, second bit is the\n\/\/ result.  This gate takes 2 cycles to compute.  It restarts when the input\n\/\/ changes.\nnandImp : (nandState, (Bit, Bit)) -> (nandState, (Bit, Bit))\nnandImp (s, in) = ({ as = as' , unused = False }, (andReady, ~andRes))\n  where\n    (as', (andReady, andRes)) = andImp (s.as, in)\n\n\/\/ Relation between `nandImp` and `nandSpec`.  Checks that outputs are\n\/\/ equivalent, given that `nandImp` is ready to be read.\nnandOutputRel : (nandState, (Bit, Bit)) -> ((), (Bit, Bit)) -> Bit\nnandOutputRel (s, (impReady, impO)) ((), (_, specO)) =\n  if impReady then impO == specO else True\n\n\/\/ State relation between `nandImp` and `nandSpec`.  Trivial in this case\n\/\/ because `nandSpec` is stateless.\nnandStateRel : nandState -> () -> Bit\nnandStateRel _ () = True\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_bisimulation\/Test.cry","filetype":"cry","content":"module Test where\n\n\/\/ State types\ntype S1 = [8]\ntype S2 = [16]\n\n\/\/ f1 and f2 both take a counter as state, as well as an input. They return a\n\/\/ pair containing the incremented counter and the sum of the input and counter.\n\/\/ f1 and f2 differ only their state types.\nf1 : (S1, [8]) -> (S1, [8])\nf1 (ctr, inp) = (ctr+1, inp+ctr)\nf2 : (S2, [8]) -> (S2, [8])\nf2 (ctr, inp) = (ctr+1, inp+(drop ctr))\n\n\/\/ A version of f2 with an input type that differs from f1\nf2_bad_input_type : (S2, [9]) -> (S2, [8])\nf2_bad_input_type (ctr, inp) = (ctr+1, (drop inp)+(drop ctr))\n\n\/\/ A version of f2 with an output type that differs from f1\nf2_bad_output_type : (S2, [8]) -> (S2, [9])\nf2_bad_output_type (ctr, inp) = (ctr+1, zext (inp+(drop ctr)))\n\n\/\/ Output bisimulation relation for f1 and f2\norel : (S1, [8]) -> (S2, [8]) -> Bit\norel (s1, o1) (s2, o2) = s1 == drop s2 \/\\ o1 == o2\n\n\/\/ State bisimulation relation for f1 and f2\nsrel : S1 -> S2 -> Bit\nsrel s1 s2 = s1 == drop s2\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_bisimulation\/test.saw","filetype":"saw","content":"\/* Test the prove_bisim command with some simple examples *\/\n\nimport \"Test.cry\";\n\nenable_experimental;\n\nres <- prove_bisim z3 [] {{ srel }} {{ orel }} {{ f1 }} {{ f2 }};\n\n\/\/ Test non-named constant in bisimulation term\nfails (prove_bisim z3 [] {{ srel }} {{ orel }} {{ f1 }} {{ \\x -> f2 x }});\n\n\/\/ Test incompatable input types\nfails (prove_bisim z3 [] {{ srel }} {{ orel }} {{ f1 }} {{ f2_bad_input_type }});\n\n\/\/ Test incompatable output types\nfails (prove_bisim z3 [] {{ srel }} {{ orel }} {{ f1 }} {{ f2_bad_output_type }});\n\n\/\/ Test bad output relation type\nfails (prove_bisim z3 [] {{ srel }} {{ True }} {{ f1 }} {{ f2 }});\n\n\/\/ Test bad state relation type\nfails (prove_bisim z3 [] {{ True }} {{ orel }} {{ f1 }} {{ f2 }});\n\n\/\/ Test wrong state type\nfails (prove_bisim z3 [] {{ srel }} {{ orel }} {{ f2 }} {{ f2 }});\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_bisimulation\/comp.saw","filetype":"saw","content":"\/* Test the prove_bisim command with a compositional circuit *\/\n\nimport \"Comp.cry\";\n\nenable_experimental;\n\n\/\/ Prove 'andImp' and 'andSpec' simulate each other\nand_res <- prove_bisim z3\n                       []\n                       {{ andStateRel }}\n                       {{ andOutputRel }}\n                       {{ andImp }}\n                       {{ andSpec }};\n\n\/\/ Prove 'nandImp' and 'nandSpec' simulate each other, using 'and_res' in the\n\/\/ process.\nnand_res <- prove_bisim (do {\n    unfolding [\"nandImp\", \"nandSpec\"];\n    w4_unint_z3 [\"andImp\", \"andSpec\" ];\n  })\n  [and_res] {{ \\x -> nandStateRel x }} {{ \\x -> nandOutputRel x }} {{ nandImp }} {{ nandSpec }};\n\n\/\/ Test using theorem that doesn't apply\nprove_bisim z3\n            [nand_res]\n            {{ andStateRel }}\n            {{ andOutputRel }}\n            {{ andImp }}\n            {{ andSpec }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test2043\/A.cry","filetype":"cry","content":"module A where\n\nparameter\n  type N : #\n  foo : [N]\n\nbar : {n, a} (Zero a) => [n]a\nbar | n == 1 => zero\n    | n != 1 => zero\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_hoist_ifs_in_goal\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet {{\n  f : Integer -> Integer\n  f x = undefined\n  g : Integer -> Integer\n  g x = undefined\n}};\n\nlet prop = {{ \\c x y -> f (if c then g x else g y) == if c then x else y }};\n\nl1 <- prove_print assume_unsat {{ \\x -> f (g x) == x }};\n\nprove_print\n  (do {\n    hoist_ifs_in_goal;\n    simplify (addsimps [l1] empty_ss);\n    w4;\n  })\n  prop;\n\nprint \"Done\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0026_bad_pointers\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet bad_pointer_no_biscuit nm =\n  do { print \"=======================================\";\n       print (str_concat \"Testing failure case: \" nm);\n       print \"\";\n       fails (llvm_verify m nm [] false\n         do { llvm_execute_func [];\n              llvm_return (llvm_term {{ 1:[32] }});\n            }\n         trivial);\n  };\n\nbad_pointer_no_biscuit \"read_after_free\";\nbad_pointer_no_biscuit \"write_after_free\";\nbad_pointer_no_biscuit \"double_free\";\nbad_pointer_no_biscuit \"equals_after_free\";\nbad_pointer_no_biscuit \"equals_null_after_free\";\nbad_pointer_no_biscuit \"le_after_free\";\nbad_pointer_no_biscuit \"le_different_allocs\";\n\nbad_pointer_no_biscuit \"read_after_stack_free\";\nbad_pointer_no_biscuit \"write_after_stack_free\";\nbad_pointer_no_biscuit \"free_after_stack_free\";\nbad_pointer_no_biscuit \"equals_after_stack_free\";\nbad_pointer_no_biscuit \"lt_after_stack_free\";\n\nbad_pointer_no_biscuit \"free_local\";\nbad_pointer_no_biscuit \"free_global\";\n\nprint \"\";\nprint \"============================================\";\nprint \"Success!\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0006\/test.saw","filetype":"saw","content":"import \"..\/..\/deps\/cryptol-specs\/Primitive\/Keyless\/Hash\/MD5.md\";\n\nlet main = do {\n   print \"ref type\";\n   print_type {{ md5_ref }};\n   print \"\";\n\n   print \"ref type, checked\";\n   check_term {{ md5_ref }};\n   print \"\";\n\n   let thm1 = {{ md5_ref zero == [82, 231, 200, 108, 39, 210, 159, 253, 158, 75, 174, 116, 196, 18, 24, 165] }};\n   prove_print abc thm1;\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1983\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet get_3_spec = do {\n    xs <- mir_fresh_var \"xs\" (mir_array 10 mir_i32);\n    mir_execute_func [mir_term xs];\n    mir_return (mir_elem_value (mir_term xs) 3);\n};\n\nget_3_ov <- mir_verify m \"test::get_3\" [] false get_3_spec z3;\n\nlet get_3_ref_spec = do {\n    xs <- mir_fresh_var \"xs\" (mir_array 10 mir_i32);\n    r <- mir_ref_of (mir_term xs);\n    mir_execute_func [r];\n    mir_return (mir_elem_ref r 3);\n};\n\nget_3_ref_ov <- mir_verify m \"test::get_3_ref\" [] false get_3_ref_spec z3;\n\nlet get_19_3_spec = do {\n    xss <- mir_fresh_var \"xss\" (mir_array 20 (mir_array 10 mir_i32));\n    mir_execute_func [mir_term xss];\n    mir_return (mir_elem_value (mir_elem_value (mir_term xss) 19) 3);\n};\n\nget_19_3_ov <- mir_verify m \"test::get_19_3\" [get_3_ov] false get_19_3_spec z3;\n\nlet get_19_3_ref_spec = do {\n    xss <- mir_fresh_var \"xss\" (mir_array 20 (mir_array 10 mir_i32));\n    r <- mir_ref_of (mir_term xss);\n    mir_execute_func [r];\n    mir_return (mir_elem_ref (mir_elem_ref r 19) 3);\n};\n\nget_19_3_ref_ov <- mir_verify m \"test::get_19_3_ref\" [get_3_ref_ov] false get_19_3_ref_spec z3;\n\nlet get_25_19_3_spec = do {\n    xsss <- mir_fresh_var \"xsss\" (mir_array 30 (mir_array 20 (mir_array 10 mir_i32)));\n    mir_execute_func [mir_term xsss];\n    mir_return (mir_elem_value (mir_elem_value (mir_elem_value (mir_term xsss) 25) 19) 3);\n};\n\nmir_verify m \"test::get_25_19_3\" [get_19_3_ov] false get_25_19_3_spec z3;\n\nlet get_25_19_3_ref_spec = do {\n    xsss <- mir_fresh_var \"xsss\" (mir_array 30 (mir_array 20 (mir_array 10 mir_i32)));\n    r <- mir_ref_of (mir_term xsss);\n    mir_execute_func [r];\n    mir_return (mir_elem_ref (mir_elem_ref (mir_elem_ref r 25) 19) 3);\n};\n\nmir_verify m \"test::get_25_19_3_ref\" [get_19_3_ref_ov] false get_25_19_3_ref_spec z3;\n\nlet get_static_2_spec = do {\n    mir_execute_func [];\n    mir_return (mir_elem_value (mir_static_initializer \"test::ARRAY\") 2);\n};\n\nmir_verify m \"test::get_static_2\" [] false get_static_2_spec z3;\n\nlet get_static_2_ref_spec = do {\n    mir_execute_func [];\n    mir_return (mir_elem_ref (mir_static \"test::ARRAY\") 2);\n};\n\nmir_verify m \"test::get_static_2_ref\" [] false get_static_2_ref_spec z3;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test0019_jvm_switch_statement\/test.saw","filetype":"saw","content":"import \"..\/..\/doc\/llvm-java-verification-with-saw\/code\/ffs.cry\";\nFFS <- java_load_class \"FFS\";\njava_ffs_imp <- jvm_extract FFS \"ffs_imp\";\nprove_print abc {{ \\x -> java_ffs_imp x == ffs_ref x }};\n\nId <- java_load_class \"Id\";\njava_id_imp <- jvm_extract Id \"id_imp\";\nprove_print abc {{ \\x -> java_id_imp x == x }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1977\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet raw_assign_spec = do {\n    src <- mir_alloc_raw_ptr_const mir_i32;\n    val <- mir_fresh_var \"val\" mir_i32;\n    mir_points_to src (mir_term val);\n    dest <- mir_alloc_raw_ptr_mut mir_i32;\n    mir_execute_func [src, dest];\n    mir_points_to dest (mir_term val);\n};\n\nraw_assign_ov <- mir_verify m \"test::raw_assign\" [] false raw_assign_spec z3;\n\nlet raw_swap_spec = do {\n    x <- mir_alloc_raw_ptr_mut mir_i32;\n    x_val <- mir_fresh_var \"x_val\" mir_i32;\n    mir_points_to x (mir_term x_val);\n    y <- mir_alloc_raw_ptr_mut mir_i32;\n    y_val <- mir_fresh_var \"y_val\" mir_i32;\n    mir_points_to y (mir_term y_val);\n    mir_execute_func [x, y];\n    mir_points_to x (mir_term y_val);\n    mir_points_to y (mir_term x_val);\n};\n\nmir_verify m \"test::raw_swap\" [raw_assign_ov] false raw_swap_spec z3;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_cvc5\/test.saw","filetype":"saw","content":"let\n{{\nadd_mul_lemma : Integer -> Integer -> Integer -> Integer -> Bit\nadd_mul_lemma m n p q =\n  (0 <= m \/\\ 0 <= n \/\\ 0 <= p \/\\ 0 <= q \/\\ n < q \/\\ p < m) ==>\n  (m * n + p < m * q)\n}};\n\nprove_print (w4_unint_cvc5 []) {{ add_mul_lemma }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0055\/test.saw","filetype":"saw","content":"\/\/ read an empty file into byte list\nempty <- read_bytes \"empty\";\nlet actually_empty = {{ empty == [] }};\nprove_print z3 actually_empty;\n\n\/\/ non-empty file; should be ASCII rep. of \"Hello, world!\" (13 bytes)\nnonempty <- read_bytes \"nonempty\";\nlet correct_seq = {{ nonempty == \"Hello, world!\" }};\nprove_print z3 correct_seq;\n\n\/\/ non-empty, but full of 255 bytes of random noise\n\/\/ random data generated at https:\/\/random.org\/bytes\/\nnoise <- read_bytes \"noise\";\nlet length_correct = {{ length noise == 255 }};\nprove_print z3 length_correct;\n\n\/\/ pathological case: empty file name\nfails (read_bytes \"\");\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_smt_array_load_concrete_size\/Mix.cry","filetype":"cry","content":"module Mix where\n\nimport Array\n\ntype ByteArray = Array[64][8]\n\nmix : {l} (width l <= 64) => ByteArray -> [64] -> [l][8] -> ByteArray\nmix block n data = arrayCopy block n (arrayRangeUpdate (arrayConstant 0) 0 data) 0 `(l)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_smt_array_load_concrete_size\/test.saw","filetype":"saw","content":"enable_experimental;\n\nimport \"Mix.cry\";\nlet arrayRangeEq = parse_core \"arrayRangeEq 64 (Vec 8 Bool)\";\n\nm <- llvm_load_module \"test.bc\";\n\nlet i8 = llvm_int 8;\nlet i32 = llvm_int 32;\n\nlet alloc_init_readonly ty v = do {\n  p <- llvm_alloc_readonly ty;\n  llvm_points_to p v;\n  return p;\n};\n\nlet ptr_to_fresh_readonly n ty = do {\n  x <- llvm_fresh_var n ty;\n  p <- alloc_init_readonly ty (llvm_term x);\n  return (x, p);\n};\n\nlet mix_spec len res_block_len range_eq_len = do {\n  block <- llvm_fresh_cryptol_var \"block\" {| ByteArray |};\n  block_ptr <- llvm_symbolic_alloc false 1 {{ 128:[64] }};\n  llvm_points_to_array_prefix block_ptr block {{ 128:[64] }};\n\n  (data, data_ptr) <- ptr_to_fresh_readonly \"data\" (llvm_array len i8);\n\n  n <- llvm_fresh_var \"n\" i32;\n  llvm_precond({{ n < 128 }});\n\n  llvm_execute_func [block_ptr, (llvm_term n), data_ptr, (llvm_term {{ `len : [64] }})];\n\n  let res = {{ mix block (0 # n) data }};\n  res_block <- llvm_fresh_cryptol_var \"res_block\" {| ByteArray |};\n  llvm_points_to_array_prefix block_ptr res_block {{ `res_block_len:[64] }};\n  llvm_postcond {{ arrayRangeEq res_block 0 res 0 `range_eq_len }};\n\n  llvm_return (llvm_term {{ 1 : [32]}});\n};\n\nllvm_verify m \"mix\"\n  []\n  true\n  (mix_spec 1 128 128)\n  (do {\n    w4_unint_z3 [];\n  });\n\nllvm_verify m \"mix\"\n  []\n  true\n  (mix_spec 1 0 0)\n  (do {\n    w4_unint_z3 [];\n  });\n\nfails (llvm_verify m \"mix\"\n  []\n  true\n  (mix_spec 1 129 0)\n  (do {\n    w4_unint_z3 [];\n  }));\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_verify_basic\/test.saw","filetype":"saw","content":"enable_experimental;\n\n\/\/ Specifications using `mir_fresh_var`\n\nlet id_spec mty = do {\n  x <- mir_fresh_var \"x\" mty;\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term x);\n};\n\nlet id_u32_wrong = do {\n  x <- mir_fresh_var \"x\" (mir_u32);\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term {{ x + 1 : [32] }});\n};\n\nlet id_unit = do {\n  x <- mir_fresh_var \"x\" (mir_tuple []);\n\n  mir_execute_func [mir_term x];\n};\n\n\/\/ Specifications using specific Cryptol terms\n\nlet id_array_cryptol_spec = do {\n  let t = mir_term {{ [42, 27, 100, 27, 42] : [5][32] }};\n\n  mir_execute_func [t];\n\n  mir_return t;\n};\n\nlet id_tuple_cryptol_spec = do {\n  let t = mir_term {{ (42, 27) : ([32], [32]) }};\n\n  mir_execute_func [t];\n\n  mir_return t;\n};\n\nlet id_u32_cryptol_spec = do {\n  let t = mir_term {{ 42 : [32] }};\n\n  mir_execute_func [t];\n\n  mir_return t;\n};\n\nlet id_unit_cryptol_spec = do {\n  mir_execute_func [mir_term {{ () }}];\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::id_array\" [] false (id_spec (mir_array 5 mir_u32)) z3;\nmir_verify m \"test::id_i8\" [] false (id_spec mir_i8) z3;\nmir_verify m \"test::id_i16\" [] false (id_spec mir_i16) z3;\nmir_verify m \"test::id_i32\" [] false (id_spec mir_i32) z3;\nmir_verify m \"test::id_i64\" [] false (id_spec mir_i64) z3;\nmir_verify m \"test::id_isize\" [] false (id_spec mir_isize) z3;\nmir_verify m \"test::id_tuple\" [] false (id_spec (mir_tuple [mir_u32, mir_u32])) z3;\nmir_verify m \"test::id_u8\" [] false (id_spec mir_u8) z3;\nmir_verify m \"test::id_u16\" [] false (id_spec mir_u16) z3;\nmir_verify m \"test::id_u32\" [] false (id_spec mir_u32) z3;\nmir_verify m \"test::id_u64\" [] false (id_spec mir_u64) z3;\nmir_verify m \"test::id_usize\" [] false (id_spec mir_usize) z3;\nmir_verify m \"test::id_unit\" [] false id_unit z3;\n\n\/\/ Test using fully disambiguated names\nmir_verify m \"test\/233c8eaf::id_u8\" [] false (id_spec mir_u8) z3;\nmir_verify m \"test\/233c8eaf::id_u8[0]\" [] false (id_spec mir_u8) z3;\n\nmir_verify m \"test::id_array\" [] false id_array_cryptol_spec z3;\nmir_verify m \"test::id_tuple\" [] false id_tuple_cryptol_spec z3;\nmir_verify m \"test::id_u32\" [] false id_u32_cryptol_spec z3;\nmir_verify m \"test::id_unit\" [] false id_unit_cryptol_spec z3;\n\n\/\/ A specification that is expected to fail\nfails (\n  mir_verify m \"test::id_u32\" [] false id_u32_wrong z3\n);\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/intTests\/test2162\/test1.saw","filetype":"saw","content":"\/\/ Create three monadic functions, one polymorphic in its monad and\n\/\/ the other two bound to TopLevel and LLVMSetup respectively.\nlet f x = return x;\nlet g x = do { disable_crucible_profiling; return x; };\nlet h x = do { llvm_assert {{ True }}; return x; };\n\n\/\/ We should be able to run f and g at the top level, but not h.\na0 <- f 3;\na1 <- g 3;\n\/\/ We should be able to use b0 and b1 together in the same function.\nlet foo () = do {\n   b0 <- f 3;\n   b1 <- g 3;\n   return 0;\n};\n\n\/\/ We should also be able to use b0 and b2 together in the same function.\nlet bar () = do {\n   b0 <- f 3;\n   b2 <- h 3;\n   return 0;\n};\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_yosys_sequential_known_cycles\/test.saw","filetype":"saw","content":"enable_experimental;\nm <- yosys_import_sequential \"seqgen\" \"test.json\";\nt <- yosys_extract_sequential m 10;\n\nsat_print w4 {{ \\(c : Bit) (g : Bit) (x : Bit) ->\n  (t {\n    clk = repeat 1,\n    reset = [1] # zero,\n    C = [0, 1, 1, 1, [c]] # zero,\n    G = [0, 0, 0, 0, [g]] # repeat 1,\n    P = [0, 1, 1, 1, [x]] # zero\n  }).S ! 0 == 1\n}};","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0042_invariant_2\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh n ty = do {\n  p <- llvm_alloc ty;\n  x <- llvm_fresh_var n ty;\n  llvm_points_to p (llvm_term x);\n  return (p, x);\n};\n\nlet zero_inc_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_execute_func [llvm_term x];\n  r <- llvm_fresh_var \"r\" (llvm_int 64);\n  llvm_postcond {{ r > 0 }};\n  llvm_return (llvm_term {{ r }});\n};\n\nlet inv_spec = do {\n  (px, x) <- ptr_to_fresh \"x\" (llvm_int 64);\n  llvm_execute_func [px];\n  llvm_return (llvm_term {{ x + 1 }});\n};\n\ninv <- llvm_verify m \"__breakpoint__inv#zero_inc\" [] false inv_spec abc;\nllvm_verify m \"zero_inc\" [inv] false zero_inc_spec abc;\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0007\/test.saw","filetype":"saw","content":"let main = do {\n   java_md5 <- read_aig \"..\/support\/JavaMD5.aig\";\n\n   print \"AIG type\";\n   print_type java_md5;\n   print \"\";\n   print \"AIG type, checked\";\n   check_term java_md5;\n\n   let thm1 = {{ java_md5 0 == 0x52e7c86c27d29ffd9e4bae74c41218a5 }};\n   prove_print abc thm1;\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0669\/test2.saw","filetype":"saw","content":"let {{\n   type t = { x : Integer, y : Integer }\n\n   f (a : t) = { x = a.x + 1, y = a.y + 1 }\n   g (a : t) (b : t) = (a.x < b.x) && (a.y < b.y)\n}};\n\nprove_print (quickcheck 100) {{ \\x -> g x (f x) }};\n\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/intTests\/test0669\/test1.saw","filetype":"saw","content":"let {{ f (x : Integer, y : Integer) = (x + 1, y + 1) }};\nlet {{ g (a : Integer, b : Integer) (c, d) = (a < c) && (b < d) }};\n\nprove_print (quickcheck 100) {{ \\x -> g x (f x) }};\nprove_print (quickcheck 100) {{ \\(a, b) -> g (a, b) (a + 2, b + 2) }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0000\/mutRecTest.cry","filetype":"cry","content":"\/\/ Test cases for mutually-recursive cryptol definitions\n\n\/\/ Classic stream-equation version of the Fibonocci numbers\n\/\/ broken out into two mutually recursive streams to test\n\/\/ mutual recursion translation into SAWCore\nstreamFibs : [8] -> [32]\nstreamFibs x = fibs0@x\n   where fibs0 = [0]#fibs1\n         fibs1 = [1]#[ a + b | a <- fibs0\n                             | b <- fibs1\n                     ]\n\n\/\/ Single-stream Fibonocci numbers\nstreamFibsAlt : [8] -> [32]\nstreamFibsAlt x = fibs@x\n   where fibs = [0,1]#[ a + b | a <- fibs\n                              | b <- drop`{1} fibs\n                      ]\n\n\/\/ recursive reference implementation of the Fibonocci numbers\nrecFibs : [8] -> [32]\nrecFibs n = if n > 1  then recFibs (n-1) + recFibs (n-2) else zx n\n\n\/\/ zero extend\nzx : {a, b} (fin a, fin b) => [b] -> [a+b]\nzx m = zero#m\n\nrecFibs2 : [8] -> [32]\nrecFibs2 n =\n  if n == 0 then 0\n   | n == 1 then 1\n   else recFibs2 (n-1) + recFibs2 (n-2)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0070_llvm_alloc_sym_init\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet f_spec = do {\n  x_ptr <- llvm_alloc_sym_init (llvm_int 32);\n  llvm_execute_func [x_ptr];\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_return (llvm_term x);\n};\n\nlet test_spec = do {\n  llvm_execute_func [];\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_return (llvm_term x);\n};\n\nf_ov <- llvm_verify m \"f\" [] false f_spec trivial;\nllvm_verify m \"test_f_calloc\" [f_ov] false test_spec trivial;\nfails (llvm_verify m \"test_f_malloc\" [f_ov] false test_spec trivial);\ndisable_alloc_sym_init_check;\nllvm_verify m \"test_f_malloc\" [f_ov] false test_spec trivial;\nenable_alloc_sym_init_check;\nfails (llvm_verify m \"test_f_malloc\" [f_ov] false test_spec trivial);\n\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_mir_verify_slices\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet oneThroughFive = mir_term {{ [1, 2, 3, 4, 5] : [5][32] }};\n\nlet f_spec_1 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_value a];\n\n  mir_return (mir_term {{ 3 : [32] }});\n};\n\nlet f_spec_2 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_range_value a 1 3];\n\n  mir_return (mir_term {{ 5 : [32] }});\n};\n\n\/\/ mir_slice_value must take an array reference as an argument.\n\/\/ Passing a bare array constitutes a type error.\nlet f_fail_spec_1 = do {\n  let arr = mir_array_value mir_u32 [mir_term {{ 1 : [32] }}];\n  mir_execute_func [mir_slice_value arr];\n\n  mir_return (mir_term {{ 0 : [32] }});\n};\n\n\/\/ The end value of the range given to mir_slice_range_value must not\n\/\/ exceed the length of the slice.\nlet f_fail_spec_2 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_range_value a 0 6];\n\n  mir_return (mir_term {{ 3 : [32] }});\n};\n\n\/\/ The start value of the range given to mir_slice_range_value must not\n\/\/ exceed the end value.\nlet f_fail_spec_3 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_range_value a 6 5];\n\n  mir_return (mir_term {{ 0 : [32] }});\n};\n\n\/\/ Indexing into a length-0 slice is disallowed.\nlet f_fail_spec_4 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_range_value a 0 0];\n\n  mir_return (mir_term {{ 0 : [32] }});\n};\n\n\/\/ f requires a slice of length at least two.\nlet f_fail_spec_5 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_range_value a 0 1];\n\n  mir_return (mir_term {{ 0 : [32] }});\n};\n\n\/\/ mir_alloc cannot be used to allocate slice references.\nlet f_fail_spec_6 = do {\n  s <- mir_alloc (mir_slice mir_u32);\n\n  mir_execute_func [s];\n\n  mir_return (mir_term {{ 0 : [32] }});\n};\n\n\/\/ mir_alloc cannot be used to allocate str references.\nlet g_fail_spec = do {\n  s <- mir_alloc mir_str;\n\n  mir_execute_func [s];\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::f\" [] false f_spec_1 z3;\nmir_verify m \"test::f\" [] false f_spec_2 z3;\n\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_1 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_2 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_3 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_4 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_5 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_6 z3\n);\nfails (\n  mir_verify m \"test::g\" [] false g_fail_spec z3\n);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_fold_rewrite_proof\/tupletest.cry","filetype":"cry","content":"module tupletest where\n\nfoldFunction : [8] -> [16] -> [16] -> [8]\nfoldFunction x y z = output.0\n  where\n    output = foldl fnc (x, y, z) [0 .. 15]\n\nfnc : ([8], [16], [16]) -> [4] -> ([8], [16], [16])\nfnc (x, y, z) i = returnTup\n  where\n    returnTup = (x ^ take y' ^ take z', y', z')\n    y' = y <<< i\n    z' = z >>> i\n\nfoldFunction' : [8] -> [16] -> [16] -> [8]\nfoldFunction' x y z = output.0\n  where\n    output = foldl fnc' (x, y, z) [15, 14 .. 0]\n\nfnc' : ([8], [16], [16]) -> [4] -> ([8], [16], [16])\nfnc' (x, y, z) i = returnTup\n  where\n    returnTup = (x ^ take y ^ take z, y', z')\n    y' = y >>> i\n    z' = z <<< i\n\nproperty foldFunctionInverse x y z =\n    foldFunction' (foldFunction x y z) y z == x\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_fold_rewrite_proof\/tupletest.saw","filetype":"saw","content":"enable_experimental;\n\nlet use_lemmas lemmas =\n    simplify (addsimps lemmas\n              (add_prelude_eqs [\"foldl_cons\",\"foldl_nil\",\"head_gen\",\"tail_gen\"] (cryptol_ss())));\n\nlet proveit p script =\n  do {\n    print (str_concat \"Proving \" (show_term p));\n    time (prove_print script p);\n  };\n\nimport \"tupletest.cry\";\n\nfnc_lemma <- proveit {{ \\x y z i -> (fnc' (fnc (x, y, z) i) i).0 == x }} z3;\n\nproveit {{ foldFunctionInverse }} do {\n    unfolding [ \"foldFunctionInverse\"\n              , \"foldFunction\"\n              , \"foldFunction'\"\n              ];\n    goal_normalize [\"fnc\", \"fnc'\"];\n    simplify (add_prelude_eqs [\"foldl_cons\",\"foldl_nil\",\n                               \"head_gen\",\"tail_gen\"] (cryptol_ss()));\n    z3;\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_ffi_verify_salsa\/salsa.saw","filetype":"saw","content":"enable_experimental;\n\nimport \"salsa.cry\";\n\nlet cipher_setup (a : Int) (w : Int) = llvm_ffi_setup {{ cipher`{a, w} }};\n\nm <- llvm_load_module \"salsa.bc\";\nfor [1, 2] (\\a ->\n  for [1, 2, 63, 64, 65] (\\w ->\n    llvm_verify m \"cipher\" [] false (cipher_setup a w) z3));\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_ffi_verify_salsa\/salsa.cry","filetype":"cry","content":"import Primitive::Symmetric::Cipher::Stream::Salsa20 (Salsa20_encrypt)\n\nforeign cipher : {a, w} (a >= 1, 2 >= a, w <= 2^^70) => [16*a][8] -> [8][8] -> [w][8] -> [w][8]\ncipher = Salsa20_encrypt\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0054\/test.saw","filetype":"saw","content":"\/\/ construct some fresh symbolic variables to play with\nx <- fresh_symbolic \"x\" {| [32] |};\ny <- fresh_symbolic \"y\" {| [32] |};\n\nlet t = {{ x + y }};\n\n\/\/ various abstractions over `t` that should be operationally equivalent\nlet f1 = abstract_symbolic t;\nlet f2 = lambda y (lambda x t);\nlet f3 = lambdas [y, x] t;\n\n\/\/ degenerate case of `lambdas`\nlet f4 = lambdas [] t;\n\nlet thm1 = {{ \\z w -> f1 z w == f2 z w}};\nlet thm2 = {{ \\z w -> f2 z w == f3 z w}};\nlet thm3 = {{ t == f4 }};\n\nprove_print z3 thm1;\nprove_print z3 thm2;\nprove_print z3 thm3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1985\/test.saw","filetype":"saw","content":"typedef Foo = Int;\ntypedef Bar = Foo;\nlet thing : Bar = 2;\n\nlet local = do {\n  typedef LocalFoo = Bar;\n  typedef LocalBar = LocalFoo;\n  let local_thing : LocalBar = 3;\n  return ();\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_points_to_at_type\/test.saw","filetype":"saw","content":"\/\/ This is a test to demonstrate the use of the saw-script LLVM setup\n\/\/ declaration `llvm_points_to_at_type`.\n\nbc <- llvm_load_module \"test.bc\";\n\nlet i32 = llvm_int 32;\n\n\/\/ The function `f` copies the first half of an array into the second\n\/\/ half. So the full array needs to be allocated, but only the first\n\/\/ half needs to be initialized.\n\n\/\/ This first example fails because the types don't match in the first\n\/\/ `llvm_points_to` declaration.\nfails (\n  llvm_verify bc \"f\" [] false\n    do {\n      x <- llvm_fresh_var \"x\" (llvm_array 2 i32);\n      p <- llvm_alloc (llvm_array 4 i32);\n      llvm_points_to p (llvm_term x);\n      llvm_execute_func [p];\n      llvm_points_to p (llvm_term {{ x # x }});\n    }\n    z3);\n\n\/\/ Changing `llvm_points_to` to `llvm_points_to_at_type` will work, as\n\/\/ long as the specified type matches the type of the rhs.\nf_ov <-\n  llvm_verify bc \"f\" [] false\n    do {\n      x <- llvm_fresh_var \"x\" (llvm_array 2 i32);\n      p <- llvm_alloc (llvm_array 4 i32);\n      llvm_points_to_at_type p (llvm_array 2 i32) (llvm_term x);\n      llvm_execute_func [p];\n      llvm_points_to p (llvm_term {{ x # x }});\n    }\n    z3;\n\n\/\/ But if the specified type does not match the rhs, the declaration\n\/\/ will fail with another type mismatch error.\nfails (\n  llvm_verify bc \"f\" [] false\n    do {\n      x <- llvm_fresh_var \"x\" (llvm_array 2 i32);\n      p <- llvm_alloc (llvm_array 4 i32);\n      llvm_points_to_at_type p (llvm_array 3 i32) (llvm_term x);\n      llvm_execute_func [p];\n      llvm_points_to p (llvm_term {{ x # x }});\n    }\n    z3);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_import_foreign\/test.saw","filetype":"saw","content":"import \"test.cry\";\n\n\/\/ requires definition of add\nprove_print z3 {{ \\x y -> add x y == x + y }};\n\n\/\/ does not require definition of f\nprove_print (unint_z3 [\"f\"]) {{ \\x -> f x + 1 == 1 + f x }};\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test0028\/test.saw","filetype":"saw","content":"\/** f clears the 2x4 array of 32-bit unsigned ints in the referenced struct *\/\n    let f_spec : CrucibleSetup() = do {\n        i <- llvm_fresh_var \"w.i\" (llvm_array 2 (llvm_array 4 (llvm_int 32)));\n        pw <- llvm_alloc (llvm_alias \"struct.BI\");\n        llvm_points_to pw (llvm_struct_value [llvm_term i]);\n\n        llvm_execute_func [pw];\n        llvm_points_to pw (llvm_struct_value [llvm_term {{ zero:[2][4][32] }} ]);\n    };\n\n    \/\/ A variant of f_spec that uses llvm_struct_type instead of llvm_alias.\n    let f_spec2 : CrucibleSetup() = do {\n        i <- llvm_fresh_var \"w.i\" (llvm_array 2 (llvm_array 4 (llvm_int 32)));\n        pw <- llvm_alloc (llvm_struct_type [llvm_array 2 (llvm_array 4 (llvm_int 32))]);\n        llvm_points_to pw (llvm_struct_value [llvm_term i]);\n\n        llvm_execute_func [pw];\n        llvm_points_to pw (llvm_struct_value [llvm_term {{ zero:[2][4][32] }} ]);\n    };\n\n    let main : TopLevel () = do {\n        structTest <- llvm_load_module \"test.bc\";\n\n        f_result <- llvm_verify structTest \"f\" [] false f_spec z3;\n        f_result2 <- llvm_verify structTest \"f\" [] false f_spec2 z3;\n\n        print \"Done!\";\n    };\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_ghost_branch_02\/test.saw","filetype":"saw","content":"let f_lt_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{ i < 42 }};\n  llvm_execute_func [llvm_term i];\n  llvm_return (llvm_term i);\n};\n\nlet f_ge_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{ (i >= 42) && (i < 512) }};\n  llvm_execute_func [llvm_term i];\n  llvm_ghost_value x i;\n  llvm_return (llvm_term i);\n};\n\nlet g_spec : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{i < 512}};\n  llvm_execute_func [llvm_term i];\n  llvm_return (llvm_term i);\n};\n\nlet main : TopLevel () = do {\n  x <- declare_ghost_state \"x\";\n  m <- llvm_load_module \"test.bc\";\n  f_lt_ov <- llvm_unsafe_assume_spec m \"f\" (f_lt_spec x);\n  f_ge_ov <- llvm_unsafe_assume_spec m \"f\" (f_ge_spec x);\n  fails (llvm_verify m \"g\" [f_lt_ov, f_ge_ov] false g_spec z3);\n  print \"done\";\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_jvm_unsound\/test.saw","filetype":"saw","content":"\/\/ This is a regression test for saw-script issue #900; it tests whether\n\/\/ `jvm_verify` will successfully verify a spec that does not specify a\n\/\/ new value for a field, when the method actually does modify that\n\/\/ field. For soundness of compositional verification, it is required\n\/\/ that such a verification will fail.\n\/\/ https:\/\/github.com\/GaloisInc\/saw-script\/issues\/900\n\nc <- java_load_class \"Test\";\n\nlet set_spec_1 =\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"b\" (jvm_term x);\n  };\n\nlet set_spec_2 =\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_execute_func [this, jvm_term x];\n    jvm_static_field_is \"a\" (jvm_term x);\n  };\n\nset_ov_1 <- jvm_unsafe_assume_spec c \"set\" set_spec_1;\nset_ov_2 <- jvm_unsafe_assume_spec c \"set\" set_spec_2;\n\nlet one = jvm_term {{ 1:[32] }};\nlet two = jvm_term {{ 2:[32] }};\n\n\/\/ A correct spec for test_a.\njvm_verify c \"test_a\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    jvm_static_field_is \"a\" one;\n    jvm_execute_func [this, two];\n    jvm_static_field_is \"a\" two;\n    jvm_field_is this \"b\" two;\n    jvm_return two;\n  }\n  z3;\n\n\/\/ An incorrect spec for test_a, which can be proven using the bogus\n\/\/ spec set_ov_1.\njvm_verify c \"test_a\" [set_ov_1] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    jvm_static_field_is \"a\" one;\n    jvm_execute_func [this, two];\n    jvm_static_field_is \"a\" one;\n    jvm_field_is this \"b\" two;\n    jvm_return one;\n  }\n  z3;\n\n\/\/ A correct spec for test_b.\njvm_verify c \"test_b\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    jvm_static_field_is \"a\" one;\n    jvm_field_is this \"b\" one;\n    jvm_execute_func [this, two];\n    jvm_static_field_is \"a\" two;\n    jvm_field_is this \"b\" two;\n    jvm_return two;\n  }\n  z3;\n\n\/\/ An incorrect spec for test_b, which can be proven using the bogus\n\/\/ spec set_ov_2.\njvm_verify c \"test_b\" [set_ov_2] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    jvm_static_field_is \"a\" one;\n    jvm_field_is this \"b\" one;\n    jvm_execute_func [this, two];\n    jvm_static_field_is \"a\" two;\n    jvm_field_is this \"b\" one;\n    jvm_return one;\n  }\n  z3;\n\n\/\/ It should be impossible to verify the bogus set_spec_1.\nfails (jvm_verify c \"set\" [] false set_spec_1 z3);\n\n\/\/ It should be impossible to verify the bogus set_spec_2.\nfails (jvm_verify c \"set\" [] false set_spec_2 z3);\n\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0045_invariant_5\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh n ty = do {\n  p <- llvm_alloc ty;\n  x <- llvm_fresh_var n ty;\n  llvm_points_to p (llvm_term x);\n  return (p, x);\n};\n\nlet len = 100;\n\nlet multiple_array_inc_spec = do {\n  (pa, a) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 8));\n  let n = llvm_term {{ `len : [64] }};\n  m <- llvm_fresh_var \"m\" (llvm_int 64);\n  llvm_execute_func [pa, n, llvm_term m];\n};\n\nlet outer_inv_spec = do {\n  (pa, a) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 8));\n  ppa <- llvm_alloc (llvm_int 64);\n  llvm_points_to ppa pa;\n  let n = llvm_term {{ `len : [64] }};\n  pn <- llvm_alloc (llvm_int 64);\n  llvm_points_to pn n;\n  (pm, m) <- ptr_to_fresh \"m\" (llvm_int 64);\n  pi <- llvm_alloc (llvm_int 64);\n  (pj, j) <- ptr_to_fresh \"j\" (llvm_int 64);\n  llvm_precond {{ 0 <= j \/\\ j <= m }};\n  llvm_execute_func [ppa, pn, pm, pi, pj];\n};\n\nlet inner_inv_spec = do {\n  (pa, a) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 8));\n  ppa <- llvm_alloc (llvm_int 64);\n  llvm_points_to ppa pa;\n  let n = llvm_term {{ `len : [64] }};\n  pn <- llvm_alloc (llvm_int 64);\n  llvm_points_to pn n;\n  (pm, m) <- ptr_to_fresh \"m\" (llvm_int 64);\n  (pi, i) <- ptr_to_fresh \"i\" (llvm_int 64);\n  (pj, j) <- ptr_to_fresh \"j\" (llvm_int 64);\n  llvm_precond {{ 0 <= j \/\\ j < m }};\n  llvm_precond {{ 0 <= i \/\\ i <= `len }};\n  llvm_execute_func [ppa, pn, pm, pi, pj];\n};\n\ninner_inv <- llvm_unsafe_assume_spec m \"__breakpoint__inner_inv#multiple_array_inc\" inner_inv_spec;\nouter_inv <- llvm_unsafe_assume_spec m \"__breakpoint__outer_inv#multiple_array_inc\" outer_inv_spec;\n\nllvm_verify m \"__breakpoint__inner_inv#multiple_array_inc\" [inner_inv, outer_inv] false inner_inv_spec abc;\nllvm_verify m \"__breakpoint__outer_inv#multiple_array_inc\" [inner_inv, outer_inv] false outer_inv_spec abc;\nllvm_verify m \"multiple_array_inc\" [inner_inv, outer_inv] false multiple_array_inc_spec abc;\n\nllvm_verify m \"__breakpoint__inner_inv#multiple_array_inc\" [inner_inv] false inner_inv_spec abc;\nllvm_verify m \"multiple_array_inc\" [inner_inv] false multiple_array_inc_spec abc;\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_jvm_small_types\/test.saw","filetype":"saw","content":"c <- java_load_class \"Test\";\n\njvm_verify c \"addBoolean\" [] false\n  do {\n    x <- jvm_fresh_var \"x\" java_bool;\n    y <- jvm_fresh_var \"y\" java_bool;\n    jvm_execute_func [jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x ^ y }});\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"addByte\" [] false\n  do {\n    x <- jvm_fresh_var \"x\" java_byte;\n    y <- jvm_fresh_var \"y\" java_byte;\n    jvm_execute_func [jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x + y }});\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"addChar\" [] false\n  do {\n    x <- jvm_fresh_var \"x\" java_char;\n    y <- jvm_fresh_var \"y\" java_char;\n    jvm_execute_func [jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x + y }});\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"addShort\" [] false\n  do {\n    x <- jvm_fresh_var \"x\" java_short;\n    y <- jvm_fresh_var \"y\" java_short;\n    jvm_execute_func [jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x + y }});\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"updBoolean\" [] false\n  do {\n    a <- jvm_fresh_var \"x\" (java_array 4 java_bool);\n    x <- jvm_fresh_var \"x\" java_bool;\n    aref <- jvm_alloc_array 4 java_bool;\n    jvm_array_is aref a;\n    jvm_execute_func [aref, jvm_term x];\n    jvm_array_is aref {{ update a 0x0 x }};\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"updByte\" [] false\n  do {\n    a <- jvm_fresh_var \"x\" (java_array 4 java_byte);\n    x <- jvm_fresh_var \"x\" java_byte;\n    aref <- jvm_alloc_array 4 java_byte;\n    jvm_array_is aref a;\n    jvm_execute_func [aref, jvm_term x];\n    jvm_array_is aref {{ update a 0x0 x }};\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"updChar\" [] false\n  do {\n    a <- jvm_fresh_var \"x\" (java_array 4 java_char);\n    x <- jvm_fresh_var \"x\" java_char;\n    aref <- jvm_alloc_array 4 java_char;\n    jvm_array_is aref a;\n    jvm_execute_func [aref, jvm_term x];\n    jvm_array_is aref {{ update a 0x0 x }};\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"updShort\" [] false\n  do {\n    a <- jvm_fresh_var \"x\" (java_array 4 java_short);\n    x <- jvm_fresh_var \"x\" java_short;\n    aref <- jvm_alloc_array 4 java_short;\n    jvm_array_is aref a;\n    jvm_execute_func [aref, jvm_term x];\n    jvm_array_is aref {{ update a 0x0 x }};\n  }\n  do {\n    check_goal;\n    z3;\n  };\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_goal_eval\/test.saw","filetype":"saw","content":"\/\/ This is a regression test for GaloisInc\/saw-script#985.\n\/\/ It uses `goal_eval` and then calls `goal_intro` to enforce\n\/\/ that `goal_eval` has preserved the explicit quantifiers in\n\/\/ the goal.\n\nenable_experimental;\n\nlet prop = {{ \\(xs:[4][8]) (ys:([8],[8])) -> sum xs == ys.0 * ys.1 }};\n\nprove_print\n  do {\n    goal_intro \"z\";\n    assume_unsat;\n  }\n  prop;\n\nprove_print\n  do {\n    goal_eval;\n    goal_intro \"z\";\n    assume_unsat;\n  }\n  prop;\n\nprint \"Done\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0041_invariant_1\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh n ty = do {\n  p <- llvm_alloc ty;\n  x <- llvm_fresh_var n ty;\n  llvm_points_to p (llvm_term x);\n  return (p, x);\n};\n\nlet add2_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_execute_func [llvm_term x];\n  llvm_return (llvm_term {{ x + 2 }});\n};\n\nlet inv_spec = do {\n  (px, x) <- ptr_to_fresh \"x\" (llvm_int 64);\n  llvm_execute_func [px];\n  llvm_return (llvm_term {{ x + 1 }});\n};\n\ninv <- llvm_verify m \"__breakpoint__inv#add2\" [] false inv_spec abc;\nllvm_verify m \"add2\" [inv] false add2_spec abc;\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_verify_str_slices\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet hello = mir_term {{ \"hello\" : [5][8] }};\n\n\/\/ Alternatively we could define it like this:\n\/\/\n\/\/ let hello = mir_term {{ [104, 101, 108, 108, 111] : [5][8] }};\n\nlet f_spec_1 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_str_slice_value a];\n\n  mir_return (mir_term {{ 205 : [8] }});\n};\n\nlet f_spec_2 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_str_slice_range_value a 1 3];\n\n  mir_return (mir_term {{ 209 : [8] }});\n};\n\n\/\/ mir_str_slice_value must take an array reference as an argument.\n\/\/ Passing a bare array constitutes a type error.\nlet f_fail_spec_1 = do {\n  let arr = mir_array_value mir_u8 [mir_term {{ 1 : [8] }}];\n  mir_execute_func [mir_str_slice_value arr];\n\n  mir_return (mir_term {{ 0 : [8] }});\n};\n\n\/\/ The end value of the range given to mir_slice_range_value must not\n\/\/ exceed the length of the slice.\nlet f_fail_spec_2 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_str_slice_range_value a 0 6];\n\n  mir_return (mir_term {{ 205 : [8] }});\n};\n\n\/\/ The start value of the range given to mir_slice_range_value must not\n\/\/ exceed the end value.\nlet f_fail_spec_3 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_str_slice_range_value a 6 5];\n\n  mir_return (mir_term {{ 0 : [8] }});\n};\n\n\/\/ Indexing into a length-0 slice is disallowed.\nlet f_fail_spec_4 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_str_slice_range_value a 0 0];\n\n  mir_return (mir_term {{ 0 : [8] }});\n};\n\n\/\/ f requires a slice of length at least two.\nlet f_fail_spec_5 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_str_slice_range_value a 0 1];\n\n  mir_return (mir_term {{ 0 : [8] }});\n};\n\n\/\/ f specifically requires a value of type &str as an argument. Passing a value\n\/\/ of type &[u8] instead should yield a type error.\nlet f_fail_spec_6 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_slice_value a];\n\n  mir_return (mir_term {{ 205 : [8] }});\n};\n\n\/\/ mir_str_slice_value must take a &[u8; N] value as an argument. Passing a\n\/\/ value of another type (e.g., &[u32; N]) constitutes a type error.\nlet f_fail_spec_7 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a (mir_term {{ map zext`{32,8} \"hello\" }});\n\n  mir_execute_func [mir_str_slice_value a];\n\n  mir_return (mir_term {{ 205 : [8] }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nf_ov_1 <- mir_verify m \"test::f\" [] false f_spec_1 z3;\nf_ov_2 <- mir_verify m \"test::f\" [] false f_spec_2 z3;\n\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_1 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_2 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_3 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_4 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_5 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_6 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_7 z3\n);\n\nmir_verify m \"test::g\" [f_ov_1] false f_spec_1 z3;\nmir_verify m \"test::g\" [f_ov_2] false f_spec_2 z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0067_term_eqs\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet f_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [(crucible_term {{ x - 1 }}), (crucible_term x), (crucible_term {{ x + 1 }})];\n  crucible_return (crucible_term {{ 3 * x }});\n};\n\nlet f_false_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [(crucible_term {{ x - 1 }}), (crucible_term {{ x + 0 }}), (crucible_term {{ x + 1 }})];\n  crucible_return (crucible_term {{ 3 * x }});\n};\n\nlet test_spec = do {\n  llvm_execute_func [];\n};\n\nf_ov <- llvm_unsafe_assume_spec m \"f\" f_spec;\nf_false_ov <- llvm_unsafe_assume_spec m \"f\" f_false_spec;\nllvm_verify m \"test_f\" [f_ov] false test_spec trivial;\nfails (llvm_verify m \"test_f\" [f_false_ov] false test_spec trivial);\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0032_clear_void\/test.saw","filetype":"saw","content":"\/\/ saw -d 4 voidTest.saw\n\n\/** \n * spec for mockup of subroutine that clears the given number of bytes from the \n * arbitrary array pointed to by a given void * \n *\/\nlet clear_void_spec : CrucibleSetup() = do {\n    let voidArrayType = (llvm_array 12 (llvm_int 8));\n    \n    arr <- (llvm_fresh_var \"arr\" voidArrayType);\n    p_arr <- (llvm_alloc voidArrayType);\n    let v_arr = (llvm_term arr);\n    \n    size <- (llvm_fresh_var \"size\" (llvm_int 32));\n    let v_size = (llvm_term size);\n    \n    llvm_equal v_size (llvm_term {{ 12:[32] }});\n    llvm_points_to p_arr v_arr;\n    \n    llvm_execute_func [p_arr, v_size];\n    \n    llvm_points_to p_arr (llvm_term {{ zero:[12][8] }});\n};\n\n\/** \n * spec for function that calls the subroutine to clear the given number of \n * unsigned ints from the array pointed to by a specified unsigned int * \n *\/ \nlet clear_uints_spec : CrucibleSetup() = do {\n    let uintsType = (llvm_array 3 (llvm_int 32));\n    \n    uints <- (llvm_fresh_var \"uints\" uintsType);\n    p_uints <- (llvm_alloc uintsType);\n    let v_uints = (llvm_term uints);\n    \n    numUInts <- (llvm_fresh_var \"numUInts\" (llvm_int 32));\n    let v_numUInts = (llvm_term numUInts);\n    \n    llvm_equal v_numUInts (llvm_term {{ 3:[32] }});\n    llvm_points_to p_uints v_uints;\n    \n    llvm_execute_func [p_uints, v_numUInts];\n    \n    llvm_points_to p_uints (llvm_term {{ zero:[3][32] }});\n};\n\nlet main : TopLevel () = do {\n    voidTest <- llvm_load_module \"voidTest.bc\";\n    \n    \/\/ The actual subroutine result would be \"llvm_unsafe_assume_spec ...\"\n    enable_crucible_assert_then_assume;\n    clear_void_12_result <- llvm_verify voidTest \"clear_void\" [] true clear_void_spec z3;\n    disable_crucible_assert_then_assume;\n    clear_uints_3_result <- llvm_verify voidTest \"clear_uints\" [clear_void_12_result] true clear_uints_spec z3;\n    \n    print \"Done!\";\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_cryptol_enums\/test2.saw","filetype":"saw","content":"import \"Test2.cry\";\n\nprint \"cc3:\";\ncheck_term {{ cc3 }};\n\nprint \"results1:\";\nprint  {{results1}};\nprove_print abc {{ results1 == ~zero}};\n\nprint \"results2:\";\nprint  {{results2}};\nprove_print abc {{ results2 == ~zero}};\n\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_cryptol_enums\/Test2.cry","filetype":"cry","content":"module Test2 where\n\n\/\/ Our data type, constructors of arity 0, 1, and 2+.\n\/\/ ETT = Enum Type Test\nenum ETT a b = C1\n             | C2 a\n             | C3 Bool b\n\n\n\/*******************************************************\/\n\n\nf1 : {c, d} ETT c d -> [8]\nf1 e1 = case e1 of\n          C1 -> 101\n          _  -> 102\n\nf1' e1 = case e1 of\n           C1 -> 101\n           _  -> 102\n\n\nf2 : ETT Bool () -> [8]\nf2 e = case e of\n         C1     -> 101\n         C3 _ _ -> 103\n         C2 _   -> 102\n\nf3 : ETT Bool () -> [8]\nf3 e = case e of\n         C1      -> 101\n         _       -> 105\n           \/\/ ^ compiles to two default functions but they have different\n           \/\/   types.\n\nt11 = f1 C1\nt12 = f1 (C2 ())\nt13 = f1 (C3 True False)\n\nt31 = f3 C1\nt32 = f3 (C2 False)\nt33 = f3 (C3 True ())\n\nresults1 = [ t11 == 101\n           , t12 == 102\n           , t13 == 102\n           , t31 == 101\n           , t32 == 105\n           , t33 == 105\n           ]\n\n\/* sawcript idioms:\n\nreturn (type {{ f1  }})\nreturn (type {{ f1' }})\n\nreturn (normalize_term {{ t11 }})\nreturn (normalize_term {{ t12 }})\nreturn (normalize_term {{ t13 }})\n\nreturn (eval_int {{ t31 }})\nreturn (eval_int {{ t32 }})\nreturn (eval_int {{ t33 }})\n*\/\n\n\n\/***********************************************************\n * Sanity check on currying constructors.\n *\/\n\ncc3 : {a, b} b -> ETT a b\ncc3 = C3 True\n\n\/***********************************************************\n * tests that we're referencing proper variables when generating code for case expressions\n *\/\n\nx : [16]\nx = 2\n\ny : [16]\ny = 1\n\nf4 : [16] -> ETT [16] [16] -> [16]\nf4 z e = 4 + z + case e of\n                   C3 _ b   ->     b + z + y + 32\n                   C2 a     -> a +     z + y + 16\n                   _        ->         z + x + 8\n\nt43a = f4 64 (C3 False 512) \/\/ 4+64   + 512   + 64+1+32   -- 677\nt42a = f4 64 (C2 128)       \/\/ 4+64 + 128     + 64+ 1+16  -- 277\nt41a = f4 64 C1             \/\/ 4+64          + 64+2+8    -- 142\n\nresults2 = [ t43a == 677\n           , t42a == 277\n           , t41a == 142\n           ]\n\n\/* sawcript idioms:\n\nreturn (eval_int {{ t41a }})\nreturn (eval_int {{ t42a }})\nreturn (eval_int {{ t43a }})\n*\/\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_constraint_guards\/Parameterized.cry","filetype":"cry","content":"module Parameterized where\n\nparameter\n    type gamma : #\n    type constraint (fin gamma, gamma >= 2, 32 >= width gamma)\n\n\/\/ Constraint guard with type dependent on module parameter value\nv : [gamma]\nv | (gamma == 3) => 0\n  \/\/ Cryptol replaces this next constraint with `TError 3 == 2` when\n  \/\/ instantiating `Instantiated.cry`\n  | (gamma == 2) => 1\n  | () => 2\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_constraint_guards\/Test.cry","filetype":"cry","content":"module Test where\n\n\/\/ Exhaustive constraint guards with some overlapping branches\nguard : {w} [w] -> Integer\nguard x\n  | (w == 32) => 0\n  | (w >= 32) => 1\n  | (w < 8) => 2\n  | (w != 8, w != 9) => 3\n  | () => 4\n\n\/\/ Non-exhaustive constraint guard\nincomplete : {w} [w] -> Bool\nincomplete x\n  | (w == 32) => True\n\n\/\/ More dependently typed case\ndependent : {n} [n]\ndependent\n  | n == 1 => [True]\n  | ()     => repeat False","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_constraint_guards\/test.saw","filetype":"saw","content":"import \"Test.cry\";\n\n\/\/ Test exhaustive constraint guards\nprove_print z3 {{ \\(x : [32])  -> guard x == 0 }};\nprove_print z3 {{ \\(x : [34])  -> guard x == 1 }};\nprove_print z3 {{ \\(x : [4])   -> guard x == 2 }};\nprove_print z3 {{ \\(x : [16])  -> guard x == 3 }};\nprove_print z3 {{ \\(x : [8])   -> guard x == 4}};\nprove_print z3 {{ \\(x : [9])   -> guard x == 4}};\n\n\/\/ Test non-exhaustive constraint guards\nprove_print z3 {{ \\(x : [32]) -> incomplete x }};\nfails (prove_print z3 {{ \\(x : [64]) -> incomplete x }});\n\n\/\/ Test more dependently typed constraint guards\nprove_print z3 {{ dependent`{1} == [True] }};\nprove_print z3 {{ dependent`{3} == [False, False, False] }};\nprove_print z3 {{ dependent`{0} == [] }};\n\n\/\/ Test constraint guards dependently typed on module parameters\nimport \"Instantiated.cry\";\nprove_print z3 {{ v == 0 }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_smtlib\/test.saw","filetype":"saw","content":"\/\/ `offline_smtlib2` takes a formula to prove universally\nprove (offline_smtlib2 \"prove\") {{ \\(x:[8]) (y:[8]) -> x == y ==> x+y == x+x }};\n\n\/\/ `write_smtlib2` takes a formula to prove existentially\nwrite_smtlib2 \"sat.smt2\" {{ \\(x:[8]) -> x != 0 \/\\ x+x == x }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_tuple\/test.saw","filetype":"saw","content":"\/\/ This is a test demonstrating the use of `llvm_points_to` with a\n\/\/ struct pointer and a single Cryptol term of tuple type.\n\/\/ https:\/\/github.com\/GaloisInc\/saw-script\/issues\/159\n\nbc <- llvm_load_module \"test.bc\";\n\nlet i8 = llvm_int 8;\nlet i16 = llvm_int 16;\n\nlet {{\n  swap_spec : ([4][8], [16], [16]) -> ([4][8], [16], [16])\n  swap_spec (xs, y, z) = (reverse xs, z, y)\n}};\n\nswap_ov <-\n  llvm_verify bc \"swap\" [] false\n    do {\n      let t = llvm_alias \"struct.triple\";\n      p <- llvm_alloc t;\n      x <- llvm_fresh_var \"x\" t;\n      llvm_points_to p (llvm_term x);\n      llvm_execute_func [p];\n      llvm_points_to p (llvm_term {{ swap_spec x }});\n    }\n    z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1768\/test.saw","filetype":"saw","content":"import \"test.cry\";\nprint {{ f 0b11 }};\nprint {{ f 0b10 }};\nprint {{ f 0b00 }};\nsat z3 {{ \\x -> f x == zero }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_unsafe_assume_spec_statics\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet side_spec_1 = do {\n  let a_static = mir_static \"test::A\";\n  a_init <- mir_fresh_var \"A\" mir_u32;\n  mir_points_to a_static (mir_term a_init);\n\n  mir_execute_func [];\n\n  mir_points_to a_static (mir_term {{ 0 : [32] }});\n  mir_return (mir_term a_init);\n};\n\nlet side_spec_2 = do {\n  let a_static = mir_static \"test::A\";\n  a_init <- mir_fresh_var \"A\" mir_u32;\n  mir_points_to a_static (mir_term a_init);\n\n  mir_execute_func [];\n\n  mir_return (mir_term a_init);\n};\n\n\/\/ This spec is erroneous. See the comments below in the \"Avoid unsoundness\"\n\/\/ part of the test.\nlet foo_spec = do {\n  let a_static = mir_static \"test::A\";\n  a_init <- mir_fresh_var \"A\" mir_u32;\n  mir_points_to a_static (mir_term a_init);\n\n  mir_execute_func [];\n\n  mir_return (mir_term a_init);\n};\n\nside_ov_1 <- mir_verify m \"test::side_effect\" [] false side_spec_1 z3;\nside_ov_2 <- mir_verify m \"test::side_effect\" [] false side_spec_2 z3;\n\n\/\/ This should not verify, as invoking `side_effect` should cause `foo` to\n\/\/ always return `0` rather than the original value of A.\nfails (\n  mir_verify m \"test::foo\" [side_ov_1] false foo_spec z3\n);\n\/\/ This should not verify, as side_spec_2 underspecifies the mutable\n\/\/ static `a_ptr` in its postconditions. SAW will catch this when attempting\n\/\/ to use side_ov_2 as an override.\nfails (\n  mir_verify m \"test::foo\" [side_ov_2] false foo_spec z3\n);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_ghost_branch_03\/test.saw","filetype":"saw","content":"let get_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_ghost_value x i;\n  llvm_execute_func [];\n  llvm_ghost_value x i;\n  llvm_return (llvm_term i);\n};\n\nlet f_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_execute_func [llvm_term i];\n  llvm_ghost_value x i;\n};\n\nlet g_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_execute_func [llvm_term i];\n  llvm_ghost_value x {{ True : Bit }}; \/\/ should be [32]\n};\n\nlet h_spec : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{i < 512}};\n  llvm_execute_func [llvm_term i];\n  ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n  llvm_return (llvm_term ret);\n  llvm_postcond {{ ret == i }};\n};\n\nlet main : TopLevel () = do {\n  x <- declare_ghost_state \"x\";\n  m <- llvm_load_module \"test.bc\";\n  get_ov <- llvm_unsafe_assume_spec m \"get\" (get_spec x);\n  f_ov <- llvm_unsafe_assume_spec m \"f\" (f_spec x);\n  g_ov <- llvm_unsafe_assume_spec m \"g\" (g_spec x);\n  fails (llvm_verify m \"h\" [get_ov, f_ov, g_ov] false h_spec z3);\n  print \"done\";\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_yosys_sequential_sally\/test.saw","filetype":"saw","content":"enable_experimental;\nm <- yosys_import_sequential \"seqgen\" \"test.json\";\n\nyosys_verify_sequential_offline_sally m \"test.mcmt\" {{\n  \\(cycles : [8]) (i : {reset : [1], C : [1], G : [1], P : [1]}) (s : {S : [1]}) ->\n    ( (cycles > 1)\n    && (i.G == 0)\n    && (i.C == 1)\n    && (i.P == 1)\n    ) ==>\n      (s.S == 1)\n  }}\n  [\"C\", \"G\", \"P\", \"reset\"];","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/support\/prove_or_die.saw","filetype":"saw","content":"\/\/ Prove theorem or exit SAWScript.\nlet prove_or_die name thm = do {\n  print name;\n  r <- prove abc thm;\n  caseProofResult r\n    (\\thm -> print \"True\")\n    (\\c -> do {\n      print \"False\";\n      exit 1;\n    });\n};\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/intTests\/test1703\/test.saw","filetype":"saw","content":"import \"test.cry\";\n\nlet weird_spec = do {\n  cv <- llvm_fresh_var \"cv\" (llvm_array 8 (llvm_int 32));\n  cv_p <- llvm_alloc (llvm_array 8 (llvm_int 32));\n  llvm_points_to cv_p (llvm_term {{ cv }});\n  i <- llvm_fresh_var \"i\" (llvm_int 8);\n\n  llvm_execute_func [cv_p, llvm_term i];\n\n  llvm_return (llvm_term {{ weird cv i }});\n};\n\nm <- llvm_load_module \"test.bc\";\nllvm_verify m \"weird\" [] false weird_spec (w4_unint_z3 []);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_jvm_setup_errors\/test.saw","filetype":"saw","content":"\/*\n\nThis file is intended to test the error checking for ill-formed\n`JVMSetup` blocks. All setup blocks will be tested with\n`jvm_unsafe_assume_spec`, in order to make sure that the errors are\ncaught at the early phase when the setup block is processed, and that\nwe do not rely on run-time errors during symbolic simulation to catch\nproblems.\n\nThis file is necessarily incomplete, and should be extended with new\nadditional tests as we add new checks to the SAW\/JVM code.\n\nAny tests listed as \"KNOWN FALSE POSITIVE\" represent known bugs in\nsaw-script.\n\n*\/\n\ntest <- java_load_class \"Test\";\n\nprint test;\n\nlet check_fails cls name spec =\n  fails (jvm_unsafe_assume_spec cls name spec);\n\nlet KNOWN_FALSE_POSITIVE cls name spec =\n  do {\n    print \"KNOWN FALSE POSITIVE:\";\n    fails (check_fails cls name spec);\n  };\n\nprint \"Working spec for method 'get'\";\njvm_verify test \"get\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  } z3;\n\nprint \"jvm_field_is with non-monomorphic type\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    let val = {{ 0 }};\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with non-jvm type\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    let val = {{ 0 : Integer }};\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with wrong type\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    let val = {{ 0 : [32] }};\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with array reference\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_array 12 java_int;\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with null reference\";\ncheck_fails test \"get\"\n  do {\n    let this = jvm_null;\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with non-reference\";\ncheck_fails test \"get\"\n  do {\n    let this = jvm_term {{ 0:[32] }};\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with non-existent field name\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"var\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with previous jvm_field_is on same field\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_field_is this \"val\" (jvm_term {{ 0 : [64] }});\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_modifies_field in pre-state section\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_modifies_field this \"val\";\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"Working spec for method 'next'\";\njvm_verify test \"next\" [] false\n  do {\n    ctr <- jvm_fresh_var \"ctr\" java_long;\n    jvm_static_field_is \"counter\" (jvm_term ctr);\n    jvm_execute_func [];\n    let ctr' = {{ ctr + 1 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  } z3;\n\nprint \"jvm_static_field_is with non-monomorphic type\";\ncheck_fails test \"next\"\n  do {\n    let ctr = {{ 0 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr);\n    jvm_execute_func [];\n    let ctr' = {{ 1 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  };\n\nprint \"jvm_static_field_is with non-jvm type\";\ncheck_fails test \"next\"\n  do {\n    let ctr = {{ 0 : Integer }};\n    jvm_static_field_is \"counter\" (jvm_term ctr);\n    jvm_execute_func [];\n    let ctr' = {{ ctr + 1 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  };\n\nprint \"jvm_static_field_is with wrong type\";\ncheck_fails test \"next\"\n  do {\n    let ctr = {{ 0 : [32] }};\n    jvm_static_field_is \"counter\" (jvm_term ctr);\n    jvm_execute_func [];\n    let ctr' = {{ ctr + 1 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  };\n\nprint \"jvm_static_field_is with non-existent field name\";\ncheck_fails test \"next\"\n  do {\n    ctr <- jvm_fresh_var \"ctr\" java_long;\n    jvm_static_field_is \"count\" (jvm_term ctr);\n    jvm_execute_func [];\n    let ctr' = {{ ctr + 1 }};\n    jvm_static_field_is \"count\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  };\n\nprint \"jvm_static_field_is with previous jvm_static_field_is on same field\";\ncheck_fails test \"next\"\n  do {\n    ctr <- jvm_fresh_var \"ctr\" java_long;\n    jvm_static_field_is \"counter\" (jvm_term ctr);\n    jvm_static_field_is \"counter\" (jvm_term ctr);\n    jvm_execute_func [];\n    let ctr' = {{ ctr + 1 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  };\n\nprint \"jvm_modifies_static_field in pre-state section\";\ncheck_fails test \"next\"\n  do {\n    ctr <- jvm_fresh_var \"ctr\" java_long;\n    jvm_modifies_static_field \"counter\";\n    jvm_execute_func [];\n    let ctr' = {{ ctr + 1 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  };\n\nprint \"Working spec for method 'lookup'\";\njvm_verify test \"lookup\" [] false\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  } z3;\n\nprint \"jvm_elem_is with non-monomorphic type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    let x = {{ 0 }};\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with non-jvm type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    let x = {{ zero : ([8], [8]) }};\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with wrong type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with object reference\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_object \"Test\";\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with null reference\";\ncheck_fails test \"lookup\"\n  do {\n    let arr = jvm_null;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with non-reference\";\ncheck_fails test \"lookup\"\n  do {\n    let arr = jvm_term {{ 5 : [32] }};\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with index out of bounds\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 12 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 12 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with previous jvm_array_is\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    xs <- jvm_fresh_var \"xs\" (java_array 32 java_long);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with previous jvm_elem_is on same index\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_elem_is arr 2 (jvm_term {{ 0 : [64] }});\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_modifies_elem in pre-state section\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_modifies_elem arr 2;\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"Working spec for method 'lookup' (jvm_array_is)\";\njvm_verify test \"lookup\" [] false\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_long);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  } z3;\n\nprint \"jvm_array_is with non-monomorphic type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let xs = {{ zero }};\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with non-array type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let xs = {{ (True, False) }};\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ 0 : [64] }});\n  };\n\nprint \"jvm_array_is with wrong array length\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    xs <- jvm_fresh_var \"xs\" (java_array 4 java_long);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with non-jvm element type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let xs = {{ zero : [8]Integer }};\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with wrong array element type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_int);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with object reference\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_object \"Test\";\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_long);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with null reference\";\ncheck_fails test \"lookup\"\n  do {\n    let arr = jvm_null;\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_long);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with non-reference\";\ncheck_fails test \"lookup\"\n  do {\n    let arr = jvm_term {{ True }};\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_long);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with previous jvm_array_is\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_long);\n    jvm_array_is arr xs;\n    jvm_array_is arr {{ zero : [8][64] }};\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with previous jvm_elem_is\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_long);\n    jvm_elem_is arr 2 (jvm_term {{ 0 : [64] }});\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_modifies_array in pre-state section\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_modifies_array arr;\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"Working spec for method 'set'\";\njvm_verify test \"set\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"val\" (jvm_term x);\n  } z3;\n\nprint \"jvm_execute_func with non-monomorphic types\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term {{ 0 }}];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\nprint \"jvm_execute_func with non-jvm types\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term {{ 0 : Integer }}];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\nprint \"jvm_execute_func with wrong types\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term {{ drop`{32} x }} ];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\nprint \"jvm_execute_func with reference type when base type was expected\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, this];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\nprint \"jvm_execute_func with base type when reference type was expected\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [jvm_term x, jvm_term x];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\nprint \"jvm_execute_func with too few arguments\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\nprint \"jvm_execute_func with too many arguments\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term x, jvm_null];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\n\/\/ (this is issue #946)\nprint \"multiple use of jvm_execute_func\";\nKNOWN_FALSE_POSITIVE test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_return with non-monomorphic type\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term {{ 0 }});\n  };\n\nprint \"jvm_return with non-jvm type\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term {{ 0 : Integer }});\n  };\n\nprint \"jvm_return with wrong base type\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term {{ 0 : [32] }});\n  };\n\nprint \"jvm_return with reference type when base type was expected\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return this;\n  };\n\nprint \"jvm_return missing when one was expected\";\nKNOWN_FALSE_POSITIVE test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n  };\n\nprint \"jvm_return when none was expected\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"val\" (jvm_term x);\n    jvm_return (jvm_term x);\n  };\n\nprint \"multiple use of jvm_return\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term {{ val }});\n    jvm_return (jvm_term {{ val }});\n  };\n\n\nprint \"DONE!\";\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_llvm_x86_05\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet returntest_setup = do {\n  llvm_execute_func [];\n\n  llvm_return (llvm_term {{ 42 : [32] }});\n};\nllvm_verify_x86 m \".\/returntest\" \"returntest\" [] false returntest_setup w4;","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test0048_alloc_post\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\nlet make_A_spec = do {\n  b <- llvm_fresh_var \"b\" (llvm_type \"%struct.B\");\n  llvm_execute_func [llvm_term b];\n  a_ptr <- llvm_alloc (llvm_type \"%struct.A\");\n  llvm_points_to (llvm_field a_ptr \"b\") (llvm_term b);\n  llvm_return a_ptr;\n};\nllvm_verify m \"make_A\" [] false make_A_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_x86_02\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet increment_setup = do {\n  ptr <- llvm_alloc (llvm_int 64);\n  val <- llvm_fresh_var \"val\" (llvm_int 64);\n  llvm_points_to ptr (llvm_term val);\n  llvm_execute_func [ptr];\n  valprime <- llvm_fresh_var \"val'\" (llvm_int 64);\n  llvm_points_to ptr (llvm_term valprime);\n  llvm_postcond {{ valprime == val }};\n};\nfails (llvm_verify_x86 m \".\/increment\" \"increment\" [] false increment_setup w4);\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/intTests\/test2000\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet error_adt = mir_find_adt m \"test::Error\" [];\nlet result_adt = mir_find_adt m \"core::result::Result\" [mir_u32, mir_adt error_adt];\n\nlet increment_spec = do {\n  count <- mir_fresh_var \"count\" mir_u32;\n\n  mir_execute_func [mir_term count];\n\n  let ok  = mir_enum_value result_adt \"Ok\" [mir_term {{ count + 1 }}];\n  let err = mir_enum_value result_adt \"Err\" [mir_enum_value error_adt \"Overflow\" []];\n  let res = mir_mux_values {{ count < (2^^32 - 1) }} ok err;\n  mir_return res;\n};\n\nincrement_ov <- mir_verify m \"test::increment\" [] false increment_spec z3;\n\nlet f_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_enum_value result_adt \"Ok\" [mir_term {{ 1 : [32] }}]);\n};\n\nlet g_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_enum_value result_adt \"Err\" [mir_enum_value error_adt \"Overflow\" []]);\n};\n\nmir_verify m \"test::f\" [increment_ov] false f_spec z3;\nmir_verify m \"test::g\" [increment_ov] false g_spec z3;\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/intTests\/test1998_mir\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet f_spec = do {\n    x <- mir_fresh_expanded_value \"x\" (mir_array 32 mir_u16);\n    y <- mir_fresh_expanded_value \"y\" (mir_array 32 mir_u16);\n    mir_equal x y;\n\n    mir_execute_func [x, y];\n\n    mir_return (mir_term {{ True }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\nmir_verify m \"test::f\" [] false f_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0052_smt_array_1\/Test.cry","filetype":"cry","content":"module ArrayTest where\n\nimport Array\n\nlookup_update_axiom_1 : Array [64] [64] -> [64] -> [64] -> Bit\nlookup_update_axiom_1 a i e = arrayLookup (arrayUpdate a i e) i == e\n\nlookup_update_axiom_2 : Array [64] [64] -> [64] -> [64] -> [64] -> Bit\nlookup_update_axiom_2 a i j e = i != j ==> arrayLookup (arrayUpdate a j e) i == arrayLookup a i\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_hash_table\/ht_simplified.saw","filetype":"saw","content":"enable_experimental;\n\nimport \"ht_simplified.cry\";\n\nlet uint32_t = llvm_int 32;\nlet uint64_t = llvm_int 64;\n\nlet setup_tuple (type : LLVMType) (name : String) = do {\n  cfvTerm <- llvm_fresh_var name type;\n  let setupVal = llvm_term cfvTerm;\n  return (setupVal, cfvTerm);\n};\n\nlet global_setup name = do {\n    llvm_alloc_global name;\n    let p = (llvm_global name);\n    return p;\n};\n\nlet check_ptable ptable table = do {\n    llvm_points_to ptable (llvm_term {{pooledHashTableToTuple table}});\n};\n\nlet check_entry_pool entry_pool_p ep = do\n{\n    llvm_points_to entry_pool_p (llvm_term {{map entryToTuple ep}});\n};\n\nlet check_state ptable_p entry_pool_p state = do\n{\n    check_entry_pool entry_pool_p ({{state.ep}});\n    check_ptable ptable_p ({{state.pht}});\n};\n\nm  <- llvm_load_module \"ht_simplified.bc\";\n\nlet hash_ok = do {\n    (ve,vc) <- (setup_tuple uint64_t \"v\");\n    llvm_execute_func[ve];\n    llvm_return (llvm_term {{ hash (vc) }});\n};\n\nlet get_bucket_ok = do {   \n    (ke,kv) <- (setup_tuple uint64_t \"key\");\n    llvm_precond {{`NUMBUCKETS >= 1}};\n    llvm_execute_func[ke];\n    let return_spec = {{ getBucket (kv) }};\n    llvm_return (llvm_term return_spec);\n    llvm_postcond {{return_spec < `NUMBUCKETS }};\n};\n\n\n\n\/\/ Initialize function holds invariant.\nlet init_table_spec = do {\n    llvm_alloc_global \"entry_pool\";\n    entry_pool <- llvm_fresh_var \"entry_pool\" (llvm_array (eval_size {| POOLSIZE |}) (llvm_alias \"struct.Entry\"));\n    llvm_points_to (llvm_global \"entry_pool\") (llvm_term entry_pool);\n    llvm_alloc_global \"ptable\";\n\n    llvm_execute_func [];\n\n    let res = {{ pooledHashTableToTuple initTable }};\n    llvm_points_to (llvm_global \"ptable\") (llvm_term res);\n    let initState = {{ {ep = (tupleToEntryPool entry_pool), pht = initTable} }};\n    llvm_postcond {{ is_valid_state initState }};\n};\n\nlet increment_value_spec = do {\n    llvm_alloc_global \"entry_pool\";\n    entry_pool <- llvm_fresh_var \"entry_pool\" (llvm_array (eval_size {| POOLSIZE |}) (llvm_alias \"struct.Entry\"));\n    llvm_points_to (llvm_global \"entry_pool\") (llvm_term entry_pool);\n    llvm_alloc_global \"ptable\";\n    ptable <- llvm_fresh_var \"ptable\" (llvm_alias \"struct.PooledHashTable\");\n    llvm_points_to (llvm_global \"ptable\") (llvm_term ptable);\n\n    key <- llvm_fresh_var \"key\" uint64_t;\n\n    \/\/ Assume invariant holds on initial state.\n    let initialState = {{tupleToState (entry_pool, ptable)}};\n    llvm_precond (normalize_term {{ is_valid_state initialState }});\n\n    let initialCurrentEntry = {{initialState.pht.cur_entry}};\n\n    llvm_execute_func [llvm_term key];\n    let return_spec = {{ incrementValueFull key initialState}};\n\n    entry_pool' <- llvm_fresh_var \"entry_pool'\" (llvm_array (eval_size {| POOLSIZE |}) (llvm_alias \"struct.Entry\"));\n    llvm_points_to (llvm_global \"entry_pool\") (llvm_term entry_pool');\n    ptable' <- llvm_fresh_var \"ptable\" (llvm_alias \"struct.PooledHashTable\");\n    llvm_points_to (llvm_global \"ptable\") (llvm_term ptable');\n    let finalState = {{tupleToState (entry_pool', ptable')}};\n\n    \/\/ Invariant holds on end state\n    llvm_postcond {{ is_valid_state finalState }};\n\n    \/\/ Check if function is equivalent to cryptol spec\n    llvm_return (llvm_term {{ return_spec.value }});\n    check_state (llvm_global \"ptable\") (llvm_global \"entry_pool\") {{return_spec.state}};\n\n    \/\/Check if cryptol spec holds post conditions.\n\n    \/\/If modified slot is null then we weren't able to find a spot in entry pool value should be zero.\n    llvm_postcond {{(return_spec.slot == NULL) ==> return_spec.value == 0}};\n\n    \/\/Entry that was modified\n    let modifiedEntry = {{return_spec.state.ep@(return_spec.slot)}};\n\n    \/\/Otherwise key should be == key given\n    llvm_postcond {{(return_spec.slot != NULL) ==> modifiedEntry.key == key }};\n\n    \/\/Value should be equivalent of what is was returned\n    llvm_postcond {{(return_spec.slot != NULL) ==> ((modifiedEntry.value == return_spec.value) \/\\ (modifiedEntry.value > 0) \/\\ (modifiedEntry.value <= CAP)) }};\n\n    \/\/If we grabed from the entry pool.\n    llvm_postcond {{(return_spec.slot == initialCurrentEntry) ==> ((modifiedEntry.next == NULL) \/\\ (modifiedEntry.value == 1))}};\n    llvm_postcond {{(return_spec.slot == initialCurrentEntry) ==> return_spec.state.pht.cur_entry == initialCurrentEntry + 1}};\n\n    \n};\n\n\nlet main : TopLevel () = do {\n    hash <- llvm_verify m \"hash\" [] true hash_ok (w4_unint_z3 []);\n    get_bucket <- llvm_verify m \"get_bucket\" [hash] true get_bucket_ok (w4_unint_z3 []);\n    init <- llvm_verify m \"init_table\" [] true init_table_spec (w4_unint_z3 []);\n\n    enable_what4_eval;\n    llvm_verify m \"increment_value\" [] true increment_value_spec (w4_unint_z3 []);\n    print \"Done!\";\n};\n\n\n\n\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_hash_table\/ht_simplified.cry","filetype":"cry","content":"module HT where\n\ntype Entry =   \n    { key    : [64]\n    , value  : [32]\n    , next   : [32]\n    }\n\ntype EntryTuple = ([64],[32],[32])\n\nentryToTuple : Entry -> EntryTuple\nentryToTuple e = (e.key, e.value, e.next)\n\ntupleToEntry : EntryTuple -> Entry\ntupleToEntry (key_t, value_t, next_t) = {key = key_t, value = value_t, next = next_t}\n\ntype NUMBUCKETS = 2\n\ntype POOLSIZE = 5\n\nNULL : [32]\nNULL = 0xffffffff\n\nCAP : [32]\nCAP = 5\n\ntype PooledHashTable =   \n    { buckets    : [NUMBUCKETS][32]\n    , cur_entry  : [32]\n    }\n\ntype PooledHashTableTuple = ([NUMBUCKETS][32],[32])\n\npooledHashTableToTuple : PooledHashTable -> PooledHashTableTuple\npooledHashTableToTuple pt = (pt.buckets, pt.cur_entry)\n\ntupleToPooledHashTable : PooledHashTableTuple -> PooledHashTable\ntupleToPooledHashTable (bucket_tuple,cur_entry_tuple) = {buckets = bucket_tuple, cur_entry = cur_entry_tuple}\n\ntype EntryPool = [POOLSIZE] Entry\n\ntype EntryPoolTuple = [POOLSIZE]([64], [32], [32])\n\nentryPoolToTuple : EntryPool -> EntryPoolTuple\nentryPoolToTuple ep = map entryToTuple ep\n\ntupleToEntryPool : EntryPoolTuple -> EntryPool\ntupleToEntryPool ep = map tupleToEntry ep\n\ninitTable : PooledHashTable\ninitTable = {cur_entry = 0, buckets = repeat NULL}\n\ninitEntry : Entry\ninitEntry = {key = 0, value = 0, next = NULL}\n\ninitEntryPool : EntryPool\ninitEntryPool = zero\n\nhash : [64] -> [32]\nhash v = foldr (\\c h -> 33 * h + (0 # c)) 5381 ((split v):[8][8])\n\ngetBucket : [64] -> [32]\ngetBucket key = hash(key) % `NUMBUCKETS\n\ntype State = { ep : EntryPool\n             , pht : PooledHashTable\n             }\n\nerrorState : State\nerrorState = zero:State\n\nstateToTuple : State -> ([POOLSIZE]([64], [32], [32]), ([NUMBUCKETS][32], [32]))\nstateToTuple state = (entryPoolToTuple state.ep, pooledHashTableToTuple state.pht)\n\ntupleToState : ([POOLSIZE]([64], [32], [32]), ([NUMBUCKETS][32], [32])) -> State\ntupleToState (entryPoolTuple, phtTuple) = {ep = tupleToEntryPool entryPoolTuple, pht = tupleToPooledHashTable phtTuple}\n\ninitState : State\ninitState = {ep = initEntryPool, pht = initTable}\n\ntype IncrementValueRet = { value : [32]\n                         , slot : [32]\n                         , state : State\n                         }\n\nis_valid_index : [32] -> [32] -> Bool\nis_valid_index n i = i < n \\\/ i == NULL\n\n\/\/ Entry Pool and Pooled Hash Table\nis_valid_state : State -> Bool\nis_valid_state state =\n  state.pht.cur_entry <= `POOLSIZE\n  \/\/ All of the buckets are <= cur_entry or NULL\n  \/\\ all (is_valid_index state.pht.cur_entry) state.pht.buckets\n  \/\/ for all entries at index i, next <= cur_entry or NULL, i < next, value <= cap.\n  \/\\ all (\\(i, e) -> i < state.pht.cur_entry ==> ((is_valid_index state.pht.cur_entry e.next) \/\\ i < e.next \/\\ e.value <= CAP)) (zip (take [0 ...]) state.ep)\n\nupdatePrev : EntryPool -> [32] -> [32] -> EntryPool\nupdatePrev epIn cur_index prev_index = ret where\n    prevEntry = epIn@prev_index\n    ret = update epIn prev_index {key = prevEntry.key, value = prevEntry.value, next = cur_index }\n\nincrementNextValue1 : [64] -> [32] -> [32] -> State -> IncrementValueRet\nincrementNextValue1 key prev_index bucket state = ret where\n    cur_index = state.pht.cur_entry\n    newEp = update state.ep cur_index {key = key, value = 1, next = NULL}\n    ret = if(prev_index != NULL) \n        then \n            { value = 1\n            , slot = cur_index \n            , state = \n              { ep = updatePrev newEp cur_index prev_index \n              , pht = {cur_entry = cur_index + 1, buckets = state.pht.buckets}\n              }\n            }\n        else \n            { value = 1\n            , slot = cur_index\n            , state = \n              { ep = newEp\n              , pht = {cur_entry = cur_index + 1, buckets = update state.pht.buckets bucket cur_index}\n              }\n            }\n\nincrementNextValue : [64] -> [32] -> [32] -> State -> IncrementValueRet\nincrementNextValue key prev_index bucket state = \n    if (state.pht.cur_entry < `POOLSIZE) \n        then incrementNextValue1 key prev_index bucket state\n        else {value = 0, slot = NULL, state = state}\n\n\nincrementValueLoop : [64] -> [64] -> [32] -> [32] -> State -> (Bool, [32], [32], ([32], State))\nincrementValueLoop count key cur_index prev_index state = \n    \/\/ Need something obviously terminating errorState is never reached as it is not a valid_state. \n    if (count <= 0) then (False, NULL, NULL, (0, errorState))\n    else \n        if (cur_index == NULL)\n            then (True, cur_index, prev_index, (0, state))\n            else checkCurEntry count key cur_index prev_index state\n\ncheckCurEntry : [64] -> [64] -> [32] -> [32] -> State -> (Bool, [32], [32], ([32], State))\ncheckCurEntry count key cur_index prev_index state = ret where\n    cur_entry = state.ep@cur_index\n    ret = if(cur_entry.key == key)\n        then keyHit key cur_index prev_index cur_entry state\n        else incrementValueLoop (count - 1) key cur_entry.next cur_index state\n\nkeyHit : [64] -> [32] -> [32] -> Entry -> State -> (Bool, [32], [32], ([32], State))\nkeyHit key cur_index prev_index cur_entry state = ret where\n    curValue = cur_entry.value\n    ret = if (curValue < CAP) \n        then (False, cur_index, prev_index, (curValue + 1, {ep = (update state.ep cur_index {key = cur_entry.key, value = curValue + 1, next = cur_entry.next}), pht = state.pht}))\n        else (False, cur_index, prev_index, (curValue, state))\n     \nincrementValueFull : [64] -> State -> IncrementValueRet\nincrementValueFull key state = ret where\n    bucket = getBucket(key)\n    cur_index = state.pht.buckets@bucket\n    prev_index = NULL\n    (continue, n_cur_index, n_prev_index, (value, nstate)) = incrementValueLoop (`POOLSIZE + 1) key cur_index prev_index state\n    ret = if continue then incrementNextValue key n_prev_index bucket nstate else {value = value, slot = n_cur_index, state = nstate}\n    \n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test2204\/test1.saw","filetype":"saw","content":"let f (x : a) : a = x;\nlet g (x : a) (y : b) : (a, b) = (x, y);\n\nlet h (x : a) : m a = do {\n   return x;\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test2009\/test.saw","filetype":"saw","content":"let pairEq = parse_core \"pairEq (Vec 32 Bool) (Vec 32 Bool) (bvEq 32) (bvEq 32)\";\nt <- prove_print w4 {{ \\x -> pairEq (x, x + 1) (x, 1 + x) }};\nprint_term (rewrite (addsimp t empty_ss) {{ (0 : [32], 0 + 1 : [32]) }});\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_univ_assert\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet {{\n  type vec_t = [384]\n  mul : vec_t -> vec_t -> vec_t\n  mul x y = undefined \/\/ this would be e.g. multiplication modulo p\n  add : vec_t -> vec_t -> vec_t\n  add x y = undefined\n\n  term1 x y z1 z2 z3 = add (mul (add (mul (add (mul x y) z1) x) z2) x) z3\n  term2 x y z1 z2 z3 = add (mul y (mul x (mul x x))) (add (mul z1 (mul x x)) (add (mul z2 x) z3))\n}};\n\n\/\/ Assume some of the ring axioms\nlemmas <- for\n  [ {{ \\x y -> mul x y == mul y x }}\n  , {{ \\x y -> add x y == add y x }}\n  , {{ \\x y z -> mul (mul x y) z == mul x (mul y z) }}\n  , {{ \\x y z -> add (add x y) z == add x (add y z) }}\n  , {{ \\x y z -> mul (add x y) z == add (mul x z) (mul y z) }}\n  ]\n  (prove_print assume_unsat);\n\n\/\/ Use those axioms to prove a nontrivial equality\nthm <- prove_print\n  (do {\n    unfolding [\"term1\",\"term2\"];\n    for lemmas goal_insert;\n    w4_unint_z3 [\"mul\",\"add\"];\n  })\n  {{ \\x y z1 z2 z3 -> term1 x y z1 z2 z3 == term2 x y z1 z2 z3 }};\n\nprint thm;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0037_popcount\/spec.cry","filetype":"cry","content":"popcount : {n} (n >= 1, fin n) => [n] -> [n]\npopcount x = foldr (+) zero [ if b then 1 else 0 | b <- x ]\n\nclz : {n} fin n => [n] -> [n]\nclz x = foldr f `n [ (b,i) | i <- [0 ...] | b <- x ]\n where\n f (b,i) r = if b then i else r\n\nctz : {n} fin n => [n] -> [n]\nctz x = clz (reverse x)\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test0037_popcount\/test.saw","filetype":"saw","content":"m <- llvm_load_module \".\/test.bc\";\nimport \".\/spec.cry\";\n\nlet solver = z3;\nlet sz = 32;\n\nllvm_verify m \"popcount\" [] true (do {\n  x <- llvm_fresh_var \"x\" (llvm_int sz);\n  llvm_execute_func [llvm_term {{ (zero # x):[32] }}];\n  llvm_return (llvm_term {{ popcount ((zero # x):[32]) }});\n}) solver;\n\nllvm_verify m \"clz\" [] true (do {\n  x <- llvm_fresh_var \"x\" (llvm_int sz);\n  llvm_execute_func [llvm_term {{ (zero # x):[32] }}];\n  llvm_return (llvm_term {{ clz ((zero # x):[32]) }});\n}) solver;\n\nllvm_verify m \"ctz\" [] true (do {\n  x <- llvm_fresh_var \"x\" (llvm_int sz);\n  llvm_execute_func [llvm_term {{ (zero # x):[32] }}];\n  llvm_return (llvm_term {{ ctz ((zero # x):[32]) }});\n}) solver;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_issue108\/refarray.saw","filetype":"saw","content":"Test_class <- java_load_class \"RefArray\";\nlet test1_spec : JVMSetup() = do {\n  x <- jvm_fresh_var \"x\" java_int;\n  jvm_execute_func [jvm_term x];\n  jvm_return (jvm_term x);\n};\nlet test2_spec : JVMSetup() = do {\n  x <- jvm_fresh_var \"x\" java_int;\n  r <- jvm_alloc_object \"RefArray\";\n  jvm_execute_func [r, jvm_term x];\n  jvm_return (jvm_term x);\n};\njvm_verify Test_class \"test1\" [] false test1_spec abc;\njvm_verify Test_class \"test2\" [] false test2_spec abc;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test2257\/test.saw","filetype":"saw","content":"enable_experimental;\n\nmod <- mir_load_module \"test.linked-mir.json\";\n\nlet f_spec = do {\n  arg <- mir_fresh_var \"arg\" mir_u32;\n\n  mir_execute_func [mir_term arg];\n\n  mir_return (mir_term {{ reverse arg }});\n};\n\nmir_verify mod \"test::f\" [] true f_spec w4;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_solver_cache\/test_ops.saw","filetype":"saw","content":"prove_print z3 {{ \\(x:[64]) -> x == x }};\nprove_print z3 {{ \\(new_name:[64]) -> new_name == new_name }};\nprove_print (w4_unint_z3 []) {{ \\(x:[64]) -> x == x }};\nprove_print (w4_unint_z3_using \"qfnia\" []) {{ \\(x:[64]) -> x == x }};\nfails (prove_print z3 {{ \\(x:[64])(y:[64]) -> x == y }});\nfails (prove_print z3 {{ \\(new_name_1:[64])(new_name_2:[64]) -> new_name_1 == new_name_2 }});\nfails (prove_print w4 {{ \\(x:[64])(y:[64]) -> x == y }});\nfails (prove_print (w4_unint_z3_using \"qfnia\" []) {{ \\(x:[64])(y:[64]) -> x == y }});","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_ghost\/test.saw","filetype":"saw","content":"let pre_counter (counter : Ghost) = do {\n  n <- llvm_fresh_var \"n\" (llvm_int 32);\n  llvm_precond {{n < 128}};\n  llvm_ghost_value counter n;\n  return n;\n};\n\nlet post_counter (counter : Ghost) n = do {\n  llvm_ghost_value counter {{n+1}};\n};\n\nlet get_and_increment_spec (counter : Ghost) : CrucibleSetup () = do {\n  n <- pre_counter counter;\n  llvm_execute_func [];\n  post_counter counter n;\n  llvm_return (llvm_term {{n}});\n};\n\nlet f_spec (counter : Ghost) : CrucibleSetup () = do {\n  n <- pre_counter counter;\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{i < 512}};\n  llvm_execute_func [llvm_term i];\n  post_counter counter n;\n  llvm_return (llvm_term {{i*n}});\n};\n\nlet main : TopLevel () = do {\n  counter <- declare_ghost_state \"counter\";\n  m <- llvm_load_module \"test.bc\";\n  get_and_increment_ov <-\n    llvm_unsafe_assume_spec m \"get_and_increment\" (get_and_increment_spec counter);\n  llvm_verify m \"f\" [get_and_increment_ov] false (f_spec counter) z3;\n  print \"done\";\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_w4_unint_rme\/Code.cry","filetype":"cry","content":"module Code where\n\ntype constraint ValidRnd rnd = rnd <= 16\n\nAscon_p : {rnd} (ValidRnd rnd) => State -> State\nAscon_p S = foldl round S (drop`{back=rnd} Const)\n\nround : State -> [64] -> State\nround S ci = pL (pS (pC S ci))\n\ntype State = [5][64]\n\npC : State -> [64] -> State\npC [S0, S1, S2, S3, S4] ci = [S0, S1, S2 ^ ci, S3, S4]\n\nConst : [16][64]\nConst =\n    [ 0x000000000000003c\n    , 0x000000000000002d\n    , 0x000000000000001e\n    , 0x000000000000000f\n    , 0x00000000000000f0\n    , 0x00000000000000e1\n    , 0x00000000000000d2\n    , 0x00000000000000c3\n    , 0x00000000000000b4\n    , 0x00000000000000a5\n    , 0x0000000000000096\n    , 0x0000000000000087\n    , 0x0000000000000078\n    , 0x0000000000000069\n    , 0x000000000000005a\n    , 0x000000000000004b\n    ]\n\npS : State -> State\npS S = transpose (map SBox (transpose S))\n\nSBox : [5] -> [5]\nSBox i = SBoxTable@i\n\nSBoxTable : [32][5]\nSBoxTable =\n    map drop\n    [ 0x04, 0x0b, 0x1f, 0x14, 0x1a, 0x15, 0x09, 0x02\n    , 0x1b, 0x05, 0x08, 0x12, 0x1d, 0x03, 0x06, 0x1c\n    , 0x1e, 0x13, 0x07, 0x0e, 0x00, 0x0d, 0x11, 0x18\n    , 0x10, 0x0c, 0x01, 0x19, 0x16, 0x0a, 0x0f, 0x17\n    ]\n\npL : State -> State\npL [S0, S1, S2, S3, S4] =\n    [ sigma S0 19 28\n    , sigma S1 61 39\n    , sigma S2  1  6\n    , sigma S3 10 17\n    , sigma S4  7 41\n    ]\n    where\n        sigma : [64] -> [6] -> [6] -> [64]\n        sigma x i j = x ^ x>>>i ^ x>>>j\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test2005_mir_lifetime\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet s_adt = mir_find_adt m \"test::S\" [mir_lifetime];\n\nlet f_spec = do {\n  y_ref <- mir_alloc mir_u32;\n  y_val <- mir_fresh_var \"y\" mir_u32;\n  mir_points_to y_ref (mir_term y_val);\n\n  mir_execute_func [y_ref];\n\n  let s = mir_struct_value s_adt [y_ref];\n  mir_return s;\n};\n\nmir_verify m \"test::f\" [] false f_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0062_resolve_pred\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet f_spec y = do {\n  x_p <- llvm_alloc (llvm_int 32);\n  llvm_execute_func [x_p, (llvm_term {{ `y : [32] }})];\n  llvm_points_to x_p (llvm_term {{ `y : [32] }});\n};\n\nlet g_spec y = do {\n  x_p <- llvm_alloc (llvm_int 32);\n  llvm_execute_func [x_p, (llvm_term {{ `y : [32] }})];\n  llvm_points_to x_p (llvm_term {{ `y : [32] }});\n};\n\nf_0_ov <- llvm_verify m \"f\" [] false (f_spec 0) (w4_unint_z3 []);\nf_1_ov <- llvm_verify m \"f\" [] false (f_spec 1) (w4_unint_z3 []);\nlet f_ovs =\n  [ f_0_ov\n  , f_1_ov\n  ];\ng_ov <- llvm_verify m \"g\" f_ovs false (g_spec 0) trivial;\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1646\/test4.saw","filetype":"saw","content":"\/\/ The second f call will print x=a.\n\nlet g () = do {\n   let x = \"a\";\n\n   let f () = print (str_concat \"x=\" x);\n   f ();\n\n   let x = \"b\";\n   f ();\n};\n\ng ();\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_congruence\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet {{\n  f : [32] -> [100][12] -> Integer\n  f x ys = foldl (\\i y -> i + toInteger y) (toInteger x) ys\n\n}};\n\nf_cong_term <- congruence_for {{ f }};\nf_cong_thm  <- prove_extcore (w4_unint_z3 [\"f\"]) f_cong_term;\n\nthm <- prove_print\n       do {\n         goal_intro \"x\";\n\t goal_intro \"y\";\n\t unfolding [\"ecEq\"];\n\t simplify (cryptol_ss ());\n\t goal_apply f_cong_thm;\n\t z3;\n\t z3;\n       }\n       {{ \\x y -> f (x+y) zero == f (y+x) zero }};\n\nprint thm;","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_llvm_x86_03\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"bar.bc\";\n\nlet foo_setup = do {\n  llvm_execute_func [];\n  llvm_return (llvm_term {{ 1 : [64] }});\n};\nfails (llvm_verify_x86 m \".\/foo\" \"foo\" [] false foo_setup w4);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_w4\/prims.saw","filetype":"saw","content":"print \"Bitwise operations &&\";\nprove_print w4 {{ (0x0F && 131) == 3 }};\nprint \".\";\nprove_print w4 {{ (0x0F || 131) == 143 }};\nprint \".\";\nprove_print w4 {{ (0x0F ^ 0xFF) == 240 }};\nprint \"this is a bug\";\nprove_print w4 {{ ~0x0F == 240 }};\n\n\nprint \"Arithmetic +\";\nprove_print w4 {{ (12:[8]) + 32 == 44 }};\nprint \".\";\nprove_print w4 {{ (252:[8]) + 32 == 28 }};\n\nprint \"Arithmetic -\";\nprove_print w4 {{ (12:[8]) - 3 == 9 }};\nprint \".\";\nprove_print w4 {{ (12:[8]) - 32 == 236 }};\n\nprint \"Arithmetic *\";\nprove_print w4 {{ (12:[8]) * 3 == 36 }};\nprint \".\";\nprove_print w4 {{ (12:[8]) * 200 == 96 }};\n\nprint \"Arithmetic \/\";\nprove_print w4 {{ (12:[4]) \/ 3 == 4 }};\nprint \".\";\nprove_print w4 {{ (12:[4]) \/ -3 == 0 }};\n\nprint \"Arithmetic %\";\nprove_print w4 {{ (19:[8]) % 3 == 1 }};\nprint \".\";\nprove_print w4 {{ (-19:[8]) % 3 == 0 }};\n\nprint \"Arithmetic lg2\";\nprove_print w4 {{ lg2 (8:[8]) == 3 }};\nprint \".\";\nprove_print w4 {{ lg2 (-8:[8]) == 8 }};\n\nprint \"Sequences\";\n\nprove_print w4 {{ (4:[4]) # (4:[4]) == (68:[8]) }};\nprint \".\";\nprove_print w4 {{ \\(x:[2]) (y:[3]) -> take (x # y) == x }};\nprint \".\";\nprove_print w4 {{ \\(x:[2]) (y:[3]) -> drop (x # y) == y }};\nprint \".\";\nprove_print w4 {{ \\(x:[4]) (y:[1]) -> tail (y # x) == x }};\nprint \".\";\nprove_print w4 {{ join [2:[2],3:[2]] == 11 }};\nprint \".\";\nprove_print w4 {{ split 0xFFFF == [15, 15, 15, 15] }};\nprint \".\";\nprove_print w4 {{ \\(x:[7]) -> reverse (reverse x) == x }};\n\nprint \"Sequences @\";\n\nprove_print w4 {{ [1,2,3:[8]]@ 0 == 1 }};\nprint \".\";\nprove_print w4 {{ [1,2,3:[8]]@ 1 == 2 }};\nprint \".\";\nprove_print w4 {{ [1,2,3:[8]]@ (2:[2]) == 3 }};\nprint \".\";\nprove_print w4 {{ [1,2,3:[8]]@ (2:[8]) == 3 }};\nprint \".\";\nfails (prove_print w4 {{ [1,2,3:[8]]@ 5 == 3 }});\n\nprint \"Sequences !\";\n\nprove_print w4 {{ [1,2,3:[8]]! 0 == 3 }};\nprint \".\";\nprove_print w4 {{ [1,2,3:[8]]! 1 == 2 }};\nprint \".\";\nprove_print w4 {{ [1,2,3:[8]]! (2:[2]) == 1 }};\nprint \".\";\nprove_print w4 {{ [1,2,3:[8]]! (2:[8]) == 1 }};\nprint \".\";\nfails (prove_print w4 {{ [1,2,3:[8]]! 5 == 1 }});\n\nprint \"Shifting, rotating\";\n\nprove_print w4 {{ (16:[8]) >> 3 == 2 }};\nprint \".\";\nprove_print w4 {{ (15:[8]) >> 3 == 1 }};\nprint \".\";\nprove_print w4 {{ 0xF0 >> 4 == 15 }};\nprint \".\";\nprove_print w4 {{ 0xF0 >> 8 == 0 }};\n\nprove_print w4 {{ (15:[8]) << 3 == 120 }};\nprint \".\";\nprove_print w4 {{ (15:[8]) << 7 == 128 }};\nprint \".\";\nprove_print w4 {{ (1:[8]) << 8 == 0 }};\nprint \".\";\nprove_print w4 {{ (128:[8]) <<< 2 == 2 }};\nprint \".\";\nprove_print w4 {{ (2:[8]) >>> 2 == 128 }};\nprint \".\";\nprove_print w4 {{ (4:[8]) >>> 3 == 128 }};\n\n\nprint \"Misc\";\nprove_print w4 {{ min (4:[8]) 5 == 4 }};\nprint \".\";\nprove_print w4 {{ max (4:[8]) 5 == 5 }};\n\n\nprint \"Done\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1684\/test.saw","filetype":"saw","content":"enable_experimental;\nenable_lax_loads_and_stores;\n\nlet f_spec = do {\n  aa <- llvm_fresh_var \"aa\" (llvm_alias \"struct.a\");\n  bb <- llvm_alloc (llvm_alias \"struct.b\");\n  llvm_points_to (llvm_field bb \"aa\") (llvm_term aa);\n\n  llvm_execute_func [bb];\n};\n\nm <- llvm_load_module \"test.bc\";\nllvm_verify m \"f\" [] false f_spec (w4_unint_yices []);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_ghost\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet next_spec counter = do {\n  n <- mir_fresh_var \"n\" mir_u32;\n  mir_ghost_value counter n;\n\n  mir_execute_func [];\n\n  mir_ghost_value counter {{n+1}};\n  mir_return (mir_term {{n}});\n};\n\nlet example_spec counter = do {\n  n <- mir_fresh_var \"nm\" mir_u32;\n  mir_precond {{n < 2}};\n  mir_ghost_value counter n;\n\n  mir_execute_func [];\n\n  mir_ghost_value counter {{n+3}};\n  mir_return (mir_term {{n+2}});\n};\n\ncounter <- declare_ghost_state \"ctr\";\nm <- mir_load_module \"test.linked-mir.json\";\n\nnext <- mir_unsafe_assume_spec m \"test::next\" (next_spec counter);\nmir_verify m \"test::example\" [next] false (example_spec counter) z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_points_to\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet read_from_ref_spec = do {\n  ptr <- mir_alloc mir_u32;\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_points_to ptr (mir_term x);\n\n  mir_execute_func [ptr];\n\n  mir_return (mir_term x);\n};\n\n\/\/ This spec will cause SAW to read from uninitialized memory.\n\nlet read_from_ref_spec_bad = do {\n  ptr <- mir_alloc mir_u32;\n\n  mir_execute_func [ptr];\n\n  mir_return (mir_term {{ 42 : [32] }});\n};\n\nlet write_to_ref_spec = do {\n  ptr <- mir_alloc_mut mir_u32;\n  y <- mir_fresh_var \"y\" mir_u32;\n\n  mir_execute_func [ptr, mir_term y];\n\n  mir_points_to ptr (mir_term y);\n};\n\n\/\/ This spec contains a type error, as `write_to_ref` expects a mutable\n\/\/ reference, but the spec allocates an immutable reference.\n\nlet write_to_ref_spec_bad = do {\n  ptr <- mir_alloc mir_u32;\n  y <- mir_fresh_var \"y\" mir_u32;\n\n  mir_execute_func [ptr, mir_term y];\n\n  mir_points_to ptr (mir_term y);\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::read_from_ref\" [] false read_from_ref_spec z3;\nmir_verify m \"test::write_to_ref\" [] false write_to_ref_spec z3;\n\nfails (\n  mir_verify m \"test::read_from_ref\" [] false read_from_ref_spec_bad z3\n);\nfails (\n  mir_verify m \"test::write_to_ref\" [] false write_to_ref_spec_bad z3\n);\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_llvm_x86_04\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet addvar_setup = do {\n  llvm_alloc_global \"var\";\n  var <- llvm_fresh_var \"var\" (llvm_int 64);\n  llvm_points_to (llvm_global \"var\") (llvm_term {{ 2 : [64] }});\n\n  ptr <- llvm_alloc (llvm_int 64);\n  val <- llvm_fresh_var \"val\" (llvm_int 64);\n  llvm_points_to ptr (llvm_term val);\n\n  llvm_execute_func [ptr];\n\n  valprime <- llvm_fresh_var \"_val\" (llvm_int 64);\n  llvm_points_to ptr (llvm_term valprime);\n};\nllvm_verify_x86 m \".\/addvar\" \"addvar\" [] false addvar_setup w4;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_bitfield_wrong_type\/test.saw","filetype":"saw","content":"enable_experimental;\nenable_lax_loads_and_stores;\n\nlet set_y_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  \/\/ Note that the type is 8 bits, which is a different number of bits than\n  \/\/ what is specified in the bitfield.\n  z <- llvm_fresh_var \"z\" (llvm_int 8);\n  llvm_execute_func [ss, llvm_term z];\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n};\n\nm <- llvm_load_module \"test.bc\";\nfails (llvm_verify m \"set_y\" [] false set_y_spec (w4_unint_z3 []));\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_ghost_symbolic_branch\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\ng <- declare_ghost_state \"g\";\n\nlet f_spec = do {\n    x <- mir_fresh_var \"x\" mir_u32;\n\n    mir_execute_func [mir_term x];\n\n    mir_ghost_value g x;\n};\n\nlet g_spec = do {\n    b <- mir_fresh_var \"b\" mir_bool;\n\n    mir_execute_func [mir_term b];\n\n    mir_ghost_value g ({{ if b then 27 else 42 : [32] }});\n};\n\nf_ov <- mir_unsafe_assume_spec m \"test::f\" f_spec;\nmir_verify m \"test::g\" [f_ov] false g_spec z3;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_yosys_verilog\/test.saw","filetype":"saw","content":"enable_experimental;\nm <- yosys_import \"test.json\";\n\nlet {{\n  cryfull :  {a : [4], b : [4], c_in : [1]} -> {c_out : [1], sum : [4]}\n  cryfull inp = { c_out = cout, sum = s }\n    where (cout, s) = splitAt (zext inp.a + zext inp.b + zext inp.c_in)\n}};\n\nprove_print w4 {{ m.fulladd === cryfull }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test2064\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet f_spec = do {\n  x_ref <- mir_alloc (mir_array 4 mir_u32);\n  x_val <- mir_fresh_var \"x\" (mir_array 4 mir_u32);\n  mir_points_to x_ref (mir_term x_val);\n\n  y_ref <- mir_alloc (mir_array 4 mir_u32);\n  y_val <- mir_fresh_var \"y\" (mir_array 4 mir_u32);\n  mir_points_to y_ref (mir_term y_val);\n\n  mir_execute_func [mir_slice_value x_ref, mir_slice_value y_ref];\n\n  mir_return (mir_term {{ x_val@0 == y_val@0 }});\n};\n\nlet g_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_term {{ False }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nf_ov <- mir_verify m \"test::f\" [] false f_spec z3;\nmir_verify m \"test::g\" [f_ov] false g_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_bitwuzla\/test.saw","filetype":"saw","content":"let\n{{\nadd_mul_lemma : [64] -> [64] -> [64] -> Bit\nadd_mul_lemma m n p =\n  m * (n + p) == (m * n) + (m * p)\n}};\n\nprove_print bitwuzla               {{ add_mul_lemma }};\nprove_print sbv_bitwuzla           {{ add_mul_lemma }};\nprove_print (w4_unint_bitwuzla []) {{ add_mul_lemma }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_saw_submodule_access1\/F.cry","filetype":"cry","content":"module F where\nimport B\nimport C\n\ntop0  = 2000 + b + c\ntopd2 = 5  + D3::d2\ntopd3 = 10 + D3::D4::d3\n\nd00 : [32]\nd00 = 1 submodule D3 where\n  d2   = 10000 + top0\n  d3D2 =     1 + D4::d3\n  d2'  =     1 + d3P\n\n  private\n    d3P = 1 + d2\n\n  submodule D4 where\n    d3 = 20000 + top0 + d2\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_saw_submodule_access1\/D.cry","filetype":"cry","content":"module D where\nimport B\nimport C\n\nd00 = 2000 + b + c\nd01 = 5 + D2::d2\n\ntype DTySy = [32]\n\nsubmodule D2 where\n  d2 = d00 + 10000\n\n  type D2TySy = [32]\n\n  submodule D3 where\n  d3 = d00 + d2 + 1\n\n  type D3TySy = [32]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_saw_submodule_access1\/UseFunctors.cry","filetype":"cry","content":"module UseFunctors where\n\nsubmodule M where\n    x = 0x02\n\n    submodule M1 where\n      x = 0x03\n\nex1 = M::x + M::M1::x  \/\/ This is OK because of implicit imports of M and M1\n\n\/\/ This is a functor\nsubmodule F where\n  parameter\n    p: [8]\n\n  submodule FM where\n    z = 0x03 + p\n\n  f = 2 * p\n\nsubmodule I = submodule F where\n  p = 11\n\nex2 = I::f + 2  \/\/ This is OK because of implicit import of I\n\n\/\/ ex3 = I::FM::z  This is not OK, becase FM is not syntactically visible in I, so we can't add an implicit import","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0023_java_assert_false\/test.saw","filetype":"saw","content":"c <- java_load_class \"Test0023\";\nfails (\n  jvm_verify c \"id\" [] false\n    do {\n      this <- jvm_alloc_object \"Test0023\";\n      x <- jvm_fresh_var \"x\" java_int;\n      jvm_precond {{ x > 5 }};\n      jvm_execute_func [this, jvm_term x];\n      jvm_return (jvm_term {{ 6 : [32] }});\n    }\n    abc\n  );\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0050_compositional_extract_1\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh nm ty = do {\n    x <- llvm_fresh_var nm ty;\n    p <- llvm_alloc ty;\n    llvm_points_to p (llvm_term x);\n    return (x, p);\n};\n\nlet foo_spec = do {\n  (_, p_p) <- ptr_to_fresh \"p\" (llvm_int 32);\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [p_p, llvm_term x];\n  p <- llvm_fresh_var \"p\" (llvm_int 32);\n  llvm_points_to p_p (llvm_term p);\n  r <- llvm_fresh_var \"r\" (llvm_int 32);\n  llvm_return (llvm_term r);\n};\n\nlet bar_spec = do {\n  (_, p_p) <- ptr_to_fresh \"p\" (llvm_int 32);\n  llvm_execute_func [p_p];\n  p <- llvm_fresh_var \"p\" (llvm_int 32);\n  llvm_points_to p_p (llvm_term p);\n};\n\nfoo_ov <- llvm_compositional_extract m \"foo\" \"f\" [] false foo_spec abc;\n_ <- llvm_compositional_extract m \"bar\" \"g\" [foo_ov] false bar_spec abc;\n\nf_thm <- prove_print abc {{ \\x p -> f x p == (p + x, p + x) }};\nfails (prove_print (do { unfolding [\"g\"]; w4_unint_yices [\"f\"]; }) {{ \\p -> g p == 2 * (p + 1) }});\nprove_print (do { unfolding [\"g\"]; simplify (addsimp f_thm empty_ss); w4_unint_yices [\"f\"]; })\n  {{ \\p -> g p == 2 * (p + 1) }};\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0071_w4_unint_z3_using\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet {{\nbvToInteger : [1024] -> Integer\nbvToInteger = toInteger\nbvFromInteger : Integer  -> [1024]\nbvFromInteger = fromInteger\n}};\n\nprove_print\n  (w4_unint_z3_using \"qfnia\" [\"bvToInteger\", \"bvFromInteger\"])\n  {{ \\(x : [1024]) -> bvFromInteger ((if (bvToInteger x) <= (bvToInteger (x * x)) then 1 else (bvToInteger x)) * (bvToInteger x)) == bvFromInteger ((if (bvToInteger x) <= (bvToInteger (x * x)) then (bvToInteger x) else (bvToInteger x) * (bvToInteger x))) }};\n\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_intro_examples\/rewrite.saw","filetype":"saw","content":"let {{\n    f x y = (x : [8]) + y\n    g x y = (y : [8]) + x\n    h x y = (f x y) + (g x y)\n}};\nf_eq_g <- prove_print abc {{ \\x y -> f x y == g x y }};\nprint f_eq_g;\nlet t1 = unfold_term [\"h\"] {{ \\x y -> h x y == 2*(f x y) }};\nprint_term t1;\nlet t2 = rewrite (addsimp f_eq_g empty_ss) t1;\nprint_term t2;\nprove_print (unint_yices [\"g\"]) t2;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_intro_examples\/ffs_eq.saw","filetype":"saw","content":"m <- llvm_load_module \"ffs.bc\";\nprint \"Extracting functional models...\";\nref <- llvm_extract m \"ffs_ref\";\nimp <- llvm_extract m \"ffs_imp\";\nprint \"Comparing reference and implementation...\";\nr <- time (prove abc {{ ref === imp }});\nprint r;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_intro_examples\/swap-simpler.saw","filetype":"saw","content":"m <- llvm_load_module \"xor-swap.bc\";\nlet ptr_to_fresh nm ty = do {\n    x <- llvm_fresh_var nm ty;\n    p <- llvm_alloc ty;\n    llvm_points_to p (llvm_term x);\n    return (x, p);\n};\nlet swap_spec = do {\n    (x, xp) <- ptr_to_fresh \"x\" (llvm_int 32);\n    (y, yp) <- ptr_to_fresh \"y\" (llvm_int 32);\n    llvm_execute_func [xp, yp];\n    llvm_points_to xp (llvm_term y);\n    llvm_points_to yp (llvm_term x);\n};\nllvm_verify m \"swap_xor\" [] true swap_spec abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_intro_examples\/write_cnf.saw","filetype":"saw","content":"let {{ mulcomm (x:[8]) y = x * y == y * x }};\nwrite_cnf \"mulcomm1.cnf\" {{ \\x y -> ~(mulcomm x y) }};\nprove (offline_cnf \"mulcomm2\") {{ mulcomm }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_intro_examples\/ffs_bug.saw","filetype":"saw","content":"set_base 16;\nm <- llvm_load_module \"ffs.bc\";\nprint \"Extracting functional models...\";\nref <- llvm_extract m \"ffs_ref\";\nbug <- llvm_extract m \"ffs_bug\";\nprint \"Trying to prove equivalence...\";\nr <- time (prove abc {{ ref === bug }});\nprint r;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_intro_examples\/ffs_sat.saw","filetype":"saw","content":"set_base 2;\nm <- llvm_load_module \"ffs.bc\";\nprint \"Extracting functional model...\";\nimp <- llvm_extract m \"ffs_imp\";\nprint \"Finding input for implementation that yields result of 4...\";\nr <- time (sat abc {{ \\x -> imp x == 4 }});\nprint r;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_intro_examples\/unfold.saw","filetype":"saw","content":"let {{ f x y = (x : [8]) + y }};\nlet {{ g x y = 2 * (f x y) }};\nlet {{ h x y = (f x y) + (f x y) }};\nlet {{ prop x y = g x y == h x y }};\nprint \"Original f:\";\nprint_term {{ f }};\nprint \"Unfolded f:\";\nlet t = unfold_term [\"f\"] {{ f }};\nprint_term t;\nprint \"Simplified f:\";\nprint_term (rewrite (cryptol_ss ()) t);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_intro_examples\/ffs_bug_fail.saw","filetype":"saw","content":"set_base 16;\nm <- llvm_load_module \"ffs.bc\";\nprint \"Extracting functional models...\";\nref <- llvm_extract m \"ffs_ref\";\nbug <- llvm_extract m \"ffs_bug\";\nprint \"Checking for bug via random testing...\";\nr <- time (prove (quickcheck 1000) {{ ref === bug }});\nprint r;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_fresh_expanded_value\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\nlet s1_adt = mir_find_adt m \"test::S1\" [];\nlet s2_adt = mir_find_adt m \"test::S2\" [];\n\nlet f_spec = do {\n  s <- mir_fresh_expanded_value \"s\" (mir_adt s1_adt);\n\n  mir_execute_func [s];\n};\n\nlet g_spec = do {\n  a <- mir_fresh_expanded_value \"a\" (mir_array 2 mir_u32);\n\n  mir_execute_func [a];\n};\n\nlet h_spec = do {\n  t <- mir_fresh_expanded_value \"t\" (mir_tuple [mir_u32, mir_u32]);\n\n  mir_execute_func [t];\n};\n\nlet i_spec = do {\n  s <- mir_fresh_expanded_value \"s\" (mir_adt s2_adt);\n\n  mir_execute_func [s];\n};\n\nmir_verify m \"test::f\" [] false f_spec z3;\nmir_verify m \"test::g\" [] false g_spec z3;\nmir_verify m \"test::h\" [] false h_spec z3;\nfails (\n  mir_verify m \"test::i\" [] false i_spec z3\n);\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_sanitize\/test.saw","filetype":"saw","content":"m_norm <- llvm_load_module \"add-normal.bc\";\nm_san <- llvm_load_module \"add-sanitized.bc\";\n\nlet f_spec = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    llvm_execute_func [llvm_term x, llvm_term y];\n};\n\nllvm_verify m_norm \"f\" [] false f_spec z3;\nfails (llvm_verify m_san \"f\" [] false f_spec z3);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_goal_num_ite\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet f_spec = do {\n  xp <- llvm_alloc (llvm_int 64);\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_points_to xp (crucible_term x);\n  llvm_execute_func [xp];\n  llvm_points_to xp (crucible_term {{ 6*x }});\n};\n\nlet g_spec = do {\n  xp <- llvm_alloc (llvm_int 64);\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_points_to xp (crucible_term x);\n  llvm_execute_func [xp];\n  llvm_points_to xp (crucible_term {{(2*x):[64]}});\n};\n\nlet h_spec = do {\n  xp <- llvm_alloc (llvm_int 64);\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_points_to xp (crucible_term {{x}});\n  llvm_precond {{ x > 1 }};\n  llvm_execute_func [xp];\n  llvm_points_to xp (crucible_term {{(3*x):[64]}});\n};\n\ng_ov <- llvm_verify m \"g\" [] false g_spec z3;\nh_ov <- llvm_verify m \"h\" [] false h_spec z3;\n\nenable_experimental;\n\n\/\/ we get two verification conditions: on for the precondition of h, and one for the postcondition of f\n\/\/ the override precondition of h is violated, but if we assume it's unsat then verification succeeds:\nllvm_verify m \"f\" [g_ov, h_ov] false f_spec\n  (goal_num_ite 0\n    assume_unsat\n    w4);\n\n\/\/ on the other hand, if we provide the wrong goal number, then it fails.\nfails (\n  llvm_verify m \"f\" [g_ov, h_ov] false f_spec\n    (goal_num_ite 1\n      assume_unsat\n      w4)\n);\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test2415\/test2.saw","filetype":"saw","content":"let prove_print_sbv = prove_print z3;\nlet prove_print_w4 = prove_print w4;\n\nlet props =\n      [ {{ (  5  \/   4)  ==  1 }}\n      , {{ ((-5) \/   4)  == -2 }}\n      , {{ (  5  \/ (-4)) == -2 }}\n      , {{ ((-5) \/ (-4)) ==  1 }}\n\n      , {{ (  5  %   4)  ==  1 }}\n      , {{ ((-5) %   4)  ==  3 }}\n      , {{ (  5  % (-4)) == -3 }}\n      , {{ ((-5) % (-4)) == -1 }}\n      ];\nfor props prove_print_sbv;\nfor props prove_print_w4;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace009.saw","filetype":"saw","content":"enable_experimental;\n\n\/\/ Arguments to SAWScript functions that are monadic callbacks should\n\/\/ behave the same way as arguments to builtins. Alas, not for now...\nprint \"------------------------------------------------------------\";\nprint \"monadic callback argument\";\nlet f1 m = do { m; return (); };\nf1 print_stack;\n\n\/\/ A bind\/return pair should produce the same trace behavior as a let.\nprint \"------------------------------------------------------------\";\nprint \"bind\/return\";\nf2 <- return print_stack;\nf2;\n\n\/\/ If you cons a tuple of actions and push it around, ideally that\n\/\/ should also result in trace frames. Currently, though, it does\n\/\/ not.\nprint \"------------------------------------------------------------\";\nprint \"tuple with let\";\nlet pair1 = (print_stack, print_stack);\nlet pair2 = pair1;\nlet (f3, _) = pair2;\nf3;\n\nprint \"------------------------------------------------------------\";\nprint \"tuple with bind\";\nlet pair3 = (print_stack, print_stack);\nlet pair4 = pair3;\n(f4, _) <- return pair4;\nf4;\n\n\/\/ Things are simpler for tuples that don't get pushed around.\nprint \"------------------------------------------------------------\";\nprint \"one-step tuple with let\";\nlet (f5, _) = (print_stack, print_stack);\nf5;\n\nprint \"------------------------------------------------------------\";\nprint \"one-step tuple with bind\";\n(f6, _) <- return (print_stack, print_stack);\nf6;\n\n\/\/ Repeat the tuple cases inside a do-block.\ndo {\n   print \"------------------------------------------------------------\";\n   print \"tuple with let, in do-block\";\n   let pair5 = (print_stack, print_stack);\n   let pair6 = pair5;\n   let (f7, _) = pair6;\n   f7;\n\n   print \"------------------------------------------------------------\";\n   print \"tuple with bind, in do-block\";\n   let pair7 = (print_stack, print_stack);\n   let pair8 = pair7;\n   (f8, _) <- return pair8;\n   f8;\n\n   print \"------------------------------------------------------------\";\n   print \"one-step tuple with let, in do-block\";\n   let (f9, _) = (print_stack, print_stack);\n   f9;\n\n   print \"------------------------------------------------------------\";\n   print \"one-step tuple with bind\";\n   (f10, _) <- return (print_stack, print_stack);\n   f10;\n\n   return ();\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace003.saw","filetype":"saw","content":"enable_experimental;\nprint \"\";\n\n\/\/ calls in ProofScript\n\/\/\n\/\/ This could just replicate all the cases in trace002, but does not;\n\/\/ the expectation is that most of the logic (especially for SAWScript\n\/\/ execution) is shared and doesn't need to be tested twice. Instead\n\/\/ we just make sure that (a) it works at all from inside the\n\/\/ ProofScript monad and (b) the transition calling back into the\n\/\/ interpreter for the proof script comes out in a reasonable way.\n\n\n\/\/ Test just proof_stack by itself.\n\/\/ This does not actually solve the goal so wrap in \"fails\".\nprint \"------------------------------------------------------------\";\nprint \"just proof_stack\";\nfails (prove_print proof_stack {{ True }});\nprint \"\";\n\n\/\/ Test proof_stack via a let-binding.\n\/\/ This does not actually solve the goal so wrap in \"fails\".\nprint \"------------------------------------------------------------\";\nprint \"proof_stack via let\";\nlet pf = proof_stack;\nfails (prove_print pf {{ True }});\nprint \"\";\n\n\/\/ Test with an inline do-block.\nprint \"------------------------------------------------------------\";\nprint \"do-block\";\nprove_print (do { proof_stack; z3; }) {{ True }};\nprove_print (do { z3; proof_stack; }) {{ True }};\nprint \"\";\n\n\/\/ Test with an action that doesn't take arguments.\nprint \"------------------------------------------------------------\";\nprint \"action\";\nlet prove1 = do { proof_stack; z3; };\nlet prove2 = do { z3; proof_stack; };\nprove_print prove1 {{ True }};\nprove_print prove2 {{ True }};\nprint \"\";\n\n\/\/ Test with an action that does take arguments.\nprint \"------------------------------------------------------------\";\nprint \"function\";\nlet prove3 () = do { proof_stack; z3; };\nlet prove4 () = do { z3; proof_stack; };\nprove_print (prove3 ()) {{ True }};\nprove_print (prove4 ()) {{ True }};\nprint \"\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace002.saw","filetype":"saw","content":"enable_experimental;\n\n\/\/ call chains within SAWScript\n\n\/\/ pure functions\nlet p1 () = run (print_stack);\nlet p2 () = p1 ();\nlet p3 () = p2 ();\nlet p22 () = let () = p1 () in p1 ();\n\n\/\/ monadic actions (in TopLevel)\n\/\/\n\/\/ Note that the last position of a do-block is different, so be sure\n\/\/ to check that explicitly.\n\nlet m1a = print_stack;\nlet m1b = do { print_stack; };\nlet m1c = do { print_stack; return (); };\nlet m1d = do { let x = 5; print_stack; };\n\nlet m2a = m1a;\nlet m2b = do { m1a; };\nlet m2c = do { m1a; return (); };\nlet m2d = do { let x = 5; m1a; };\nlet m2e = m1b;\nlet m2f = do { m1b; };\nlet m2g = do { m1b; return (); };\nlet m2h = do { let x = 5; m1b; };\nlet m2i = m1c;\nlet m2j = do { m1c; };\nlet m2k = do { m1c; return (); };\nlet m2l = do { let x = 5; m1c; };\n\nlet m22a = do { m1a; m1a; };\nlet m22b = do { m1a; m1a; return (); };\nlet m22c = do { m1b; m1b; };\nlet m22d = do { m1c; m1c; return (); };\n\nlet m1p1a = do { m1a; return (p1 ()); };\nlet m1p1b = do { let _ = p1 (); m1a; };\nlet m1p1c = do { m1a; let _ = p1 (); return (); };\nlet m1p1d = do { let _ = p1 (); m1a; return (); };\n\n\/\/ monadic actions that take arguments\n\nlet ma1a () = print_stack;\nlet ma1b () = do { print_stack; };\nlet ma1c () = do { print_stack; return (); };\nlet ma1d () = do { let x = 5; print_stack; };\n\nlet ma2a () = ma1a ();\nlet ma2b () = do { ma1a (); };\nlet ma2c () = do { ma1a (); return (); };\nlet ma2d () = do { let x = 5; ma1a (); };\nlet ma2e () = ma1b ();\nlet ma2f () = do { ma1b (); };\nlet ma2g () = do { ma1b (); return (); };\nlet ma2h () = do { let x = 5; ma1b (); };\n\n\/\/ now run them\n\nprint \"p1\"; let _ = p1 ();\nprint \"p2\"; let _ = p2 ();\nprint \"p3\"; let _ = p3 ();\nprint \"p22\"; let _ = p22 ();\n\nprint \"m1a\"; m1a;\nprint \"m1b\"; m1b;\nprint \"m1c\"; m1c;\nprint \"m1d\"; m1d;\n\nprint \"m2a\"; m2a;\nprint \"m2b\"; m2b;\nprint \"m2c\"; m2c;\nprint \"m2d\"; m2d;\nprint \"m2e\"; m2e;\nprint \"m2f\"; m2f;\nprint \"m2g\"; m2g;\nprint \"m2h\"; m2h;\nprint \"m2i\"; m2i;\nprint \"m2j\"; m2j;\nprint \"m2k\"; m2k;\nprint \"m2l\"; m2l;\n\nprint \"m22a\"; m22a;\nprint \"m22b\"; m22b;\nprint \"m22c\"; m22c;\nprint \"m22d\"; m22d;\n\nprint \"m1p1a\"; m1p1a;\nprint \"m1p1b\"; m1p1b;\nprint \"m1p1c\"; m1p1c;\nprint \"m1p1d\"; m1p1d;\n\nprint \"ma1a\"; ma1a ();\nprint \"ma1b\"; ma1b ();\nprint \"ma1c\"; ma1c ();\nprint \"ma1d\"; ma1d ();\n\nprint \"ma2a\"; ma2a ();\nprint \"ma2b\"; ma2b ();\nprint \"ma2c\"; ma2c ();\nprint \"ma2d\"; ma2d ();\nprint \"ma2e\"; ma2e ();\nprint \"ma2f\"; ma2f ();\nprint \"ma2g\"; ma2g ();\nprint \"ma2h\"; ma2h ();\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace004.saw","filetype":"saw","content":"enable_experimental;\nmod <- llvm_load_module \"test.bc\";\nprint \"\";\n\n\/\/ calls in LLVMSetup\n\/\/\n\/\/ This is basically like trace003, for the same reasons, except in\n\/\/ LLVMSetup.\n\n\n\/\/ Test just llvm_stack by itself.\n\/\/ This probably should not actually verify, but it does...\nprint \"------------------------------------------------------------\";\nprint \"just llvm_stack\";\nllvm_verify mod \"foo\" [] false llvm_stack z3;\nprint \"\";\n\n\/\/ Test just llvm_stack via a let-binding.\n\/\/ This probably should not actually verify, but it does...\nprint \"------------------------------------------------------------\";\nprint \"llvm_stack via let\";\nlet spec0 = llvm_stack;\nllvm_verify mod \"foo\" [] false spec0 z3;\nprint \"\";\n\n\/\/ Test with an inline do-block.\nprint \"------------------------------------------------------------\";\nprint \"do-block\";\nllvm_verify mod \"foo\" [] false (do { llvm_stack; llvm_execute_func []; }) z3;\nllvm_verify mod \"foo\" [] false (do { llvm_execute_func []; llvm_stack; }) z3;\nprint \"\";\n\n\/\/ Test with an action that doesn't take arguments.\nprint \"------------------------------------------------------------\";\nprint \"action\";\nlet spec1 = do { llvm_stack; llvm_execute_func []; };\nlet spec2 = do { llvm_execute_func []; llvm_stack; };\nllvm_verify mod \"foo\" [] false spec1 z3;\nllvm_verify mod \"foo\" [] false spec2 z3;\nprint \"\";\n\n\/\/ Test with an action that does take arguments.\nprint \"------------------------------------------------------------\";\nprint \"function\";\nlet spec3 () = do { llvm_stack; llvm_execute_func []; };\nlet spec4 () = do { llvm_execute_func []; llvm_stack; };\nllvm_verify mod \"foo\" [] false (spec3 ()) z3;\nllvm_verify mod \"foo\" [] false (spec4 ()) z3;\nprint \"\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace010.saw","filetype":"saw","content":"enable_experimental;\n\n\/\/ See what happens if we return a monadic value out of the tail of a\n\/\/ do-block and then execute it.\n\/\/\n\/\/ Currently this does not trace the flow of the monadic value;\n\/\/ arguably it shouldn't. What's flowing is not print_stack but\n\/\/ a separate monadic value that contains print_stack.\nlet get_print_stack = do { return print_stack; };\nlet foo = do { let x = 3; get_print_stack; };\nbar <- foo;\nbar;\n\n\/\/ Similarly if you pass around a pure function that returns a monadic\n\/\/ value, that doesn't get tracked.\nlet get_print_stack' () = print_stack;\nlet baz = get_print_stack';\nbaz ();\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace006.saw","filetype":"saw","content":"enable_experimental;\n\n\/\/ see what happens with for, because it has its own private\n\/\/ implementation of a number of things\n\nlet p1 _ = print_stack;\nlet p2 _ = do { print_stack; return (); };\n\nfor [1,2,3] p1;\nfor [1,2,3] p2;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace007.saw","filetype":"saw","content":"enable_experimental;\n\n\/\/ Try with lots of arguments, just in case there's anything funny\n\/\/ in the argument handling.\n\nlet foo a b c d = (a, b, c, d, run print_stack);\nreturn (foo 1 2 3 4);\n\nlet bar a b c d = do { print_stack; return (a, b, c, d); };\nbar 1 2 3 4;\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0065_match_llvm_elem\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet f_spec = do {\n  x_p <- llvm_alloc (llvm_array 2 (llvm_int 32));\n  llvm_execute_func [(llvm_elem x_p 1), x_p];\n};\n\nlet f_false_spec = do {\n  x_p <- llvm_alloc (llvm_array 2 (llvm_int 32));\n  llvm_execute_func [(llvm_elem x_p 1), (llvm_elem x_p 1)];\n};\n\nlet g_spec = do {\n  x_p <- llvm_alloc (llvm_array 2 (llvm_int 32));\n  llvm_execute_func [(llvm_elem x_p 1)];\n};\n\nlet g_false_spec = do {\n  x_p <- llvm_alloc (llvm_array 3 (llvm_int 32));\n  llvm_execute_func [(llvm_elem x_p 1)];\n};\n\nlet h_spec = do {\n  s_p <- llvm_alloc (llvm_alias \"struct.s\");\n  llvm_execute_func [(llvm_field s_p \"y\"), s_p];\n};\n\nlet test_spec = do {\n  llvm_execute_func [];\n};\n\nf_ov <- llvm_unsafe_assume_spec m \"f\" f_spec;\nf_false_ov <- llvm_unsafe_assume_spec m \"f\" f_false_spec;\ng_ov <- llvm_unsafe_assume_spec m \"g\" g_spec;\ng_false_ov <- llvm_unsafe_assume_spec m \"g\" g_false_spec;\nh_ov <- llvm_unsafe_assume_spec m \"h\" h_spec;\nllvm_verify m \"test_f\" [f_ov] false test_spec trivial;\nfails (llvm_verify m \"test_f\" [f_false_ov] false test_spec trivial);\nllvm_verify m \"test_g\" [g_ov] false test_spec trivial;\nfails (llvm_verify m \"test_g\" [g_false_ov] false test_spec trivial);\nllvm_verify m \"test_h\" [h_ov] false test_spec trivial;\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_bitfield_x86\/test.saw","filetype":"saw","content":"enable_experimental;\nenable_lax_loads_and_stores;\n\nlet get_x2_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 2);\n  llvm_points_to_bitfield ss \"x2\" (llvm_term z);\n  llvm_execute_func [ss];\n  llvm_return (llvm_term {{ zext z : [8] }});\n};\n\nlet get_y_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 1);\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n  llvm_execute_func [ss];\n  llvm_return (llvm_term z);\n};\n\nlet set_x2_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 8);\n  llvm_execute_func [ss, llvm_term z];\n  llvm_points_to_bitfield ss \"x2\" (llvm_term {{ drop z : [2] }});\n};\n\nlet set_x2_alt_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 2);\n  llvm_execute_func [ss, llvm_term {{ zext z : [8] }}];\n  llvm_points_to_bitfield ss \"x2\" (llvm_term z);\n};\n\nlet set_y_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 1);\n  llvm_execute_func [ss, llvm_term z];\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n};\n\nlet set_y_alt_spec = set_y_spec;\n\nm <- llvm_load_module \"test.bc\";\n\nllvm_verify_x86 m \"test.exe\" \"get_x2\" [] false get_x2_spec (w4_unint_z3 []);\nllvm_verify_x86 m \"test.exe\" \"get_y\" [] false get_y_spec (w4_unint_z3 []);\nllvm_verify_x86 m \"test.exe\" \"set_x2\" [] false set_x2_spec (w4_unint_z3 []);\nllvm_verify_x86 m \"test.exe\" \"set_x2_alt\" [] false set_x2_alt_spec (w4_unint_z3 []);\nllvm_verify_x86 m \"test.exe\" \"set_y\" [] false set_y_spec (w4_unint_z3 []);\nllvm_verify_x86 m \"test.exe\" \"set_y_alt\" [] false set_y_alt_spec (w4_unint_z3 []);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_jvm_modifies\/test.saw","filetype":"saw","content":"c <- java_load_class \"Test\";\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Specs with missing side effects\n\nprint \"Verification fails for add1 spec with missing side effect.\";\nfails (\n  jvm_verify c \"add1\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x + y }});\n  } z3\n  );\n\nprint \"Verification fails for add2 spec with missing side effect.\";\nfails (\n  jvm_verify c \"add2\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x + y }});\n  } z3\n  );\n\nprint \"Verification fails for add3 spec with missing side effect.\";\nfails (\n  jvm_verify c \"add3\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    arr <- jvm_alloc_array 2 java_int;\n    jvm_field_is this \"c\" arr;\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x + y }});\n  } z3\n  );\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Full specifications with side effects\n\nlet spec1 =\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_field_is this \"a\" (jvm_term x);\n    jvm_return (jvm_term {{ x + y }});\n  };\n\nlet spec2 =\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_static_field_is \"b\" (jvm_term x);\n    jvm_return (jvm_term {{ x + y }});\n  };\n\nlet spec3 =\n  do {\n    this <- jvm_alloc_object \"Test\";\n    arr <- jvm_alloc_array 2 java_int;\n    jvm_field_is this \"c\" arr;\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_elem_is arr 1 (jvm_term x);\n    jvm_return (jvm_term {{ x + y }});\n  };\n\nprint \"Verification succeeds for complete add1 spec.\";\nadd1_full <- jvm_verify c \"add1\" [] false spec1 z3;\n\nprint \"Verification succeeds for complete add2 spec.\";\nadd2_full <- jvm_verify c \"add2\" [] false spec2 z3;\n\nprint \"Verification succeeds for complete add3 spec.\";\nadd3_full <- jvm_verify c \"add3\" [] false spec3 z3;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Partial specifications with jvm_modifies\n\nprint \"Verification succeeds for partial add1 spec (jvm_modifies_field).\";\nadd1_part <-\n  jvm_verify c \"add1\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_modifies_field this \"a\";\n    jvm_return (jvm_term {{ x + y }});\n  } z3;\n\nprint \"Verification succeeds for partial add2 spec (jvm_modifies_static_field).\";\nadd2_part <-\n  jvm_verify c \"add2\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_modifies_static_field \"b\";\n    jvm_return (jvm_term {{ x + y }});\n  } z3;\n\nprint \"Verification succeeds for partial add3 spec (jvm_modifies_elem).\";\nadd3_part <-\n  jvm_verify c \"add3\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    arr <- jvm_alloc_array 2 java_int;\n    jvm_field_is this \"c\" arr;\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_modifies_elem arr 1;\n    jvm_return (jvm_term {{ x + y }});\n  } z3;\n\nprint \"Verification succeeds for partial add3 spec (jvm_modifies_array).\";\nadd3_part_a <-\n  jvm_verify c \"add3\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    arr <- jvm_alloc_array 2 java_int;\n    jvm_field_is this \"c\" arr;\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_modifies_array arr;\n    jvm_return (jvm_term {{ x + y }});\n  } z3;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Compositional verification with full specs\n\nprint \"Compositional verification succeeds with full add1 spec.\";\nwrap1_full <- jvm_verify c \"wrap1\" [add1_full] false spec1 z3;\n\nprint \"Compositional verification succeeds with full add1 spec.\";\nwrap2_full <- jvm_verify c \"wrap2\" [add2_full] false spec2 z3;\n\nprint \"Compositional verification succeeds with full add1 spec.\";\nwrap3_full <- jvm_verify c \"wrap3\" [add3_full] false spec3 z3;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Compositional verification with partial specs\n\nprint \"Compositional verification fails with partial add1 spec.\";\nfails (jvm_verify c \"wrap1\" [add1_part] false spec1 z3);\n\nprint \"Compositional verification fails with partial add2 spec.\";\nfails (jvm_verify c \"wrap2\" [add2_part] false spec2 z3);\n\nprint \"Compositional verification fails with partial add3 spec.\";\nfails (jvm_verify c \"wrap3\" [add3_part] false spec3 z3);\n\nprint \"DONE!\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0031_unit_test\/test.saw","filetype":"saw","content":"let setup = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n\n  p_a <- llvm_alloc (llvm_alias \"struct.a_t\");\n  llvm_points_to p_a ( llvm_term {{ x }} );\n\n  llvm_execute_func [ p_a ];\n  llvm_return (llvm_term {{ 3:[32] }});\n\n  llvm_points_to p_a ( llvm_term {{ 3:[32] }} );\n};\n\nm <- llvm_load_module \"test.bc\";\nllvm_verify m \"foo\" [] false setup z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_verify_pop_count\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet\n{{\npopCount : [32] -> [32]\npopCount bs = zext`{32,6} (ic ! 0) where\n    ic = [0] # [ if elt then prev + 1 else prev | elt <- bs | prev <- ic]\n}};\n\nlet pop_count_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term {{ popCount x }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\nmir_verify m \"test::pop_count\" [] false pop_count_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1691\/test.saw","filetype":"saw","content":"enable_experimental;\nenable_lax_loads_and_stores;\n\nlet f_spec = do {\n  ss <- llvm_alloc_readonly (llvm_alias \"struct.s\");\n  x <- llvm_fresh_var \"x\" (llvm_int 1);\n  y <- llvm_fresh_var \"y\" (llvm_int 1);\n  llvm_points_to_bitfield ss \"x\" (llvm_term x);\n  llvm_points_to_bitfield ss \"y\" (llvm_term y);\n\n  llvm_execute_func [ss];\n\n  llvm_return (llvm_term {{ if x == y then 1 else 0 : [32] }});\n};\n\nm <- llvm_load_module \"test.bc\";\nov <- llvm_verify m \"f\" [] false f_spec (w4_unint_yices []);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_llvm_return_global\/test.saw","filetype":"saw","content":"\/\/ This test checks whether we can verify a spec that says a function\n\/\/ returns a fresh pointer, when in actuality the function returns\n\/\/ a global. It is a regression test for saw-script issue #641.\n\/\/ https:\/\/github.com\/GaloisInc\/saw-script\/issues\/641\n\nbc <- llvm_load_module \"test.bc\";\n\nlet i64 = llvm_int 64;\n\nfails (\n  llvm_verify bc \"foo\" [] false\n    do {\n      llvm_alloc_global \"glob\";\n      llvm_execute_func [];\n      x <- llvm_alloc i64;\n      llvm_return x;\n    }\n    z3\n  );\n\nbar_ov1 <-\n  llvm_verify bc \"bar\" [] false\n    do {\n      llvm_alloc_global \"glob\";\n      llvm_execute_func [];\n      llvm_return (llvm_term {{ 1 : [32] }});\n    }\n    z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0043_invariant_3\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh n ty = do {\n  p <- llvm_alloc ty;\n  x <- llvm_fresh_var n ty;\n  llvm_points_to p (llvm_term x);\n  return (p, x);\n};\n\nlet count_n_spec = do {\n  n <- llvm_fresh_var \"n\" (llvm_int 64);\n  llvm_execute_func [llvm_term n];\n  llvm_return (llvm_term n);\n};\n\nlet inv_spec = do {\n  (pn, n) <- ptr_to_fresh \"n\" (llvm_int 64);\n  (pc, c) <- ptr_to_fresh \"c\" (llvm_int 64);\n  (pi, i) <- ptr_to_fresh \"i\" (llvm_int 64);\n  llvm_precond {{ 0 <= i \/\\ i <= n }};\n  llvm_execute_func [pn, pc, pi];\n  llvm_return (llvm_term {{ c + (n - i) }});\n};\n\ninv <- llvm_unsafe_assume_spec m \"__breakpoint__inv#count_n\" inv_spec;\nllvm_verify m \"__breakpoint__inv#count_n\" [inv] false inv_spec abc;\nllvm_verify m \"count_n\" [inv] false count_n_spec abc;\n\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/intTests\/test_sawscript_builtins\/eval.saw","filetype":"saw","content":"print true;\nprint (eval_bool {{ True }});\n\nprint 33;\nprint (eval_int {{ 33 : [8] }});\n\nprint 10;\nprint (eval_size {| 10 |});\n\nprint \"[True, False]\";\nprint (eval_list {{ [True, False] }});\n\nprint \"[34, 35]\";\nprint (list_term [ {{ 34 : [8] }}, {{ 35 : [8] }} ]);\n\n\/\/ Note that because a list of bools is a bitvector this should\n\/\/ (and does) print a number:\nlet t = {{ True }};\nlet f = {{ False }};\nprint 42;\nprint (list_term [ t, f, t, f, t, f ]);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_sawscript_builtins\/undefined6.saw","filetype":"saw","content":"\/\/ As of 20250707, we no longer execute partway into do-blocks at the\n\/\/ time they're let-bound. So these cases should not crash.\n\nlet m1 = do { undefined; return (); };\nprint \"not dead yet\";\nlet m2 = do { _ <- return 3; let x = undefined; return (); };\nprint \"still not dead\";\nlet m3 = do { let x = undefined; return (); };\nprint \"still still not dead\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_sawscript_builtins\/run.saw","filetype":"saw","content":"\/\/ Test that run works.\n\nenable_experimental;\n\n\/\/ first give summarize_verification something to say\n\/\/ (otherwise it just prints a bunch of blank lines)\nprove_print z3 {{ True == True }};\n\n\/\/ this should not do anything\nprint \"nothing should happen:\";\nlet x = summarize_verification;\nprint \"hopefully nothing happened\";\n\n\/\/ this should print (see #2343)\nprint \"this should print:\";\nlet () = run x;\nprint \"that should have printed\";\n\n\/\/ this should also print (see #2343)\nprint \"this should also print:\";\nreturn (run x);\nprint \"that should also have printed\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_sawscript_builtins\/match.saw","filetype":"saw","content":"\/\/ Tests for the workarounds for there being no match in SAWScript\n\n\/\/ caseSatResult\n\/\/\n\/\/ There is no way to directly generate values of type SatResult,\n\/\/ so we have to run some sat queries to get them.\n\/\/\n\/\/ There are three possible results -- sat, unsat, and unknown. I\n\/\/ don't know offhand how to get a solver to reliably and quickly\n\/\/ produce an unknown, and I suspect there isn't a good way, so we'll\n\/\/ leave that case off for now.\n\nprint \"caseSatResult:\";\n\nresultSat <- sat z3 {{ \\x -> x == True }};\nresultUnsat <- sat z3 {{ \\x -> (x == True) && (x == False) }};\n\ndo {\n   let no = print \"unsat\";\n   let yes t = print (\"sat\", t);\n   caseSatResult resultSat no yes;\n   caseSatResult resultUnsat no yes;\n};\n\n\/\/ caseProofResult\n\/\/\n\/\/ There is likewise no way to directly generate values of type\n\/\/ ProofResult, so we need to run some proofs.\n\nprint \"caseProofResult:\";\n\nresultValid <- prove z3 {{ \\(x : [8]) -> x == x }};\nresultInvalid <- prove z3 {{ \\(x : [8]) -> x < x }};\n\ndo {\n   let yes thm = print (\"Theorem\", thm);\n   let no cex = print (\"Counterexample\", cex);\n   caseProofResult resultValid yes no;\n   caseProofResult resultInvalid yes no;\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_sawscript_builtins\/lists.saw","filetype":"saw","content":"\/\/ Some tests for SAWScript lists.\n\nprint \"null:\";\nprint (true, null []);\nprint (false, null [1]);\n\nprint \"nth:\";\nprint (1, nth [1] 0);\nprint (4, nth [1, 2, 3, 4, 5] 3);\n\/\/ Note: need to wrap in a do-block to trap the failure (see #2424)\nfails (do { return (nth [1, 2, 3] 4); });\nfails (do { return (nth [] 0); });\n\nprint \"head:\";\nprint (1, head [1]);\nprint (3, head [3, 4, 5]);\n\/\/ Note: need to wrap in a do-block to trap the failure (see #2424)\nfails (do { return (head []); });\n\nprint \"tail:\";\nprint ([], tail [1]);\nprint ([4, 5], tail [3, 4, 5]);\n\/\/ Note: need to wrap in a do-block to trap the failure (see #2424)\nfails (do { return (tail []); });\n\nprint \"length\";\nprint (0, length []);\nprint (1, length [1]);\nprint (5, length [1, 2, 3, 4, 5]);\n\n\/\/ note that concat is what's usually called append\nprint \"concat:\";\nprint ([], concat [] []);\nprint ([1], concat [] [1]);\nprint ([1], concat [1] []);\nprint ([2, 1], concat [2] [1]);\nprint ([2, 4, 6, 8, 1, 2, 3], concat [2, 4, 6, 8] [1, 2, 3]);\n\nprint \"str_concat:\";\nprint (\"\", str_concat \"\" \"\");\nprint (\"a\", str_concat \"\" \"a\");\nprint (\"a\", str_concat \"a\" \"\");\nprint (\"ba\", str_concat \"b\" \"a\");\nprint (\"defgabc\", str_concat \"defg\" \"abc\");\n\n\/\/ str_concats is what's usually called concat\nprint (\"\", str_concats [\"\", \"\", \"\"]);\nprint (\"abc\", str_concats [\"a\", \"b\", \"c\"]);\n\n\/\/ for\nprint \"***\";\nfor [] print;\nprint \"***\";\nfor [1] print;\nprint \"***\";\nfor [1, 2] print;\nprint \"***\";\n\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/intTests\/test_ffi_verify\/test.cry","filetype":"cry","content":"\/\/ Basic integral types\n\nforeign add8 : [8] -> [8] -> [8]\nadd8 = (+)\n\nforeign sub16 : [16] -> [16] -> [16]\nsub16 = (-)\n\nforeign mul32 : [32] -> [32] -> [32]\nmul32 = (*)\n\nforeign div64 : [64] -> [64] -> [64]\ndiv64 x y = if y == 0 then 0 else x \/ y\n\n\/\/ Non-machine integer sizes\n\nforeign extendInput : [3] -> [8]\nextendInput = zext\n\nforeign maskOutput : [8] -> [3]\nmaskOutput = drop\n\nforeign noBits : [0] -> [0]\nnoBits x = x\n\n\/\/ Bit\n\nforeign not : Bit -> Bit\nnot x = ~ x\n\n\/\/ Type synonyms\n\ntype Word32 = [32]\ntype Word64 = [64]\ntype MyFunc = Word32 -> [64] -> Bit\n\nforeign usesTypeSynonym : MyFunc\nusesTypeSynonym x y = zext x == y\n\n\/\/ Sequences\n\nforeign sum10 : [10]Word32 -> Word32\nsum10 = sum\n\nforeign reverse5 : [5]Word64 -> [5]Word64\nreverse5 = reverse\n\n\/\/ Tuples and records\n\nforeign compoundTypes : ([32], { x : [10], y : [3][20] }) -> { z : [5][20] }\n  -> { a : ([16], [16]), b : { c : [8][20], d : [5], e : [5] } }\ncompoundTypes (n, { x = x, y = y }) { z = z } =\n  { a = splitAt `{16} n\n  , b = { c = y # z, d = take `{5} x, e = drop `{5} x }\n  }\n\n\/\/ Polymorphic sizes\n\nforeign typeToValue : {n} (fin n, width n <= 64) => () -> [64]\ntypeToValue () = `n\n\nforeign sumPoly : {n} (fin n) => [n]Word32 -> Word32\nsumPoly = sum\n\nforeign inits : {n} (fin n) => [n][8] -> [n * (n + 1) \/ 2][8]\n\/\/ Cryptol implementation copied from constraint guards inits test case\ninits xs\n  | n == 0 => []\n  | n >  0 => initsLoop xs' x []\n    where\n      (x : [1]_) # xs' = xs\n\ninitsLoop : {n, l, m, a} (fin l, fin m, l + m == n, m >= 1) =>\n        [l]a -> [m]a ->\n        [((m - 1) * ((m - 1) + 1)) \/ 2]a ->\n        [(n * (n + 1)) \/ 2]a\ninitsLoop ys zs acc\n  | l == 0 => acc # zs\n  | l >  0 => initsLoop ys' (zs # y) (acc # zs)\n   where (y : [1]_) # ys' = ys\n\nforeign zipMul3 : {n, m, p} (fin n, fin m, fin p) =>\n  [n][27] -> [m][27] -> [p][27] -> [min n (min m p)][27]\nzipMul3 xs ys zs = [x * y * z | x <- xs | y <- ys | z <- zs]\n\n\/\/ Nested sequences\n\nforeign reshape : {a, b, c, d} (fin a, fin b, fin c, fin d) =>\n  [a][b][c][d][32] -> { dcba : [d][c][b][a][32], acbd : [a][c][b][d][32] }\nreshape x =\n  { dcba = split (split (split (join (join (join x)))))\n  , acbd = split (split (split (join (join (join x)))))\n  }\n\n\/\/ Test overrides\n\nforeign same : ([32], [10], [8][20]) -> ([32], [10], [8][20])\nsame x = x\n\nforeign notnot : Bit -> Bit\nnotnot x = not (not x)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_ffi_verify\/test.saw","filetype":"saw","content":"enable_experimental;\n\nimport \"test.cry\";\nmod <- llvm_load_module \"test.bc\";\n\nllvm_verify mod \"add8\" [] true (llvm_ffi_setup {{ add8 }}) z3;\nllvm_verify mod \"sub16\" [] true (llvm_ffi_setup {{ sub16 }}) z3;\nllvm_verify mod \"mul32\" [] true (llvm_ffi_setup {{ mul32 }}) z3;\nllvm_verify mod \"div64\" [] true (llvm_ffi_setup {{ div64 }}) z3;\n\nllvm_verify mod \"extendInput\" [] true (llvm_ffi_setup {{ extendInput }}) z3;\nllvm_verify mod \"maskOutput\" [] true (llvm_ffi_setup {{ maskOutput }}) z3;\nllvm_verify mod \"noBits\" [] true (llvm_ffi_setup {{ noBits }}) z3;\n\nnot_ov <- llvm_verify mod \"not\" [] true (llvm_ffi_setup {{ not }}) z3;\n\nllvm_verify mod \"usesTypeSynonym\" [] true (llvm_ffi_setup {{ usesTypeSynonym }}) z3;\n\nllvm_verify mod \"sum10\" [] true (llvm_ffi_setup {{ sum10 }}) z3;\nllvm_verify mod \"reverse5\" [] true (llvm_ffi_setup {{ reverse5 }}) z3;\n\ncompoundTypes_ov <- llvm_verify mod \"compoundTypes\" [] true (llvm_ffi_setup {{ compoundTypes }}) z3;\n\nfor [0, 12345, 4294967297] (\\n ->\n  llvm_verify mod \"typeToValue\" [] true (llvm_ffi_setup {{ typeToValue`{n} }}) z3);\nfor [0, 1, 5, 42, 100] (\\n ->\n  llvm_verify mod \"sumPoly\" [] true (llvm_ffi_setup {{ sumPoly`{n} }}) z3);\nfor [1, 3, 72] (\\n ->\n  llvm_verify mod \"inits\" [] true (llvm_ffi_setup {{ inits`{n} }}) z3);\nlet dims = [1, 2, 3];\nfor dims (\\n ->\n  for dims (\\m ->\n    for dims (\\p ->\n      llvm_verify mod \"zipMul3\" [] true (llvm_ffi_setup {{ zipMul3`{n, m, p} }}) z3)));\n\nfor dims (\\a ->\n  for dims (\\b ->\n    for dims (\\c ->\n      for dims (\\d ->\n        llvm_verify mod \"reshape\" [] true (llvm_ffi_setup {{ reshape`{a, b, c, d} }}) z3))));\n\nlet same_setup = llvm_ffi_setup {{ same }};\nllvm_verify mod \"same\" [] true same_setup z3;\nllvm_verify mod \"same\" [compoundTypes_ov] true same_setup z3;\nlet notnot_setup = llvm_ffi_setup {{ notnot }};\nllvm_verify mod \"notnot\" [] true notnot_setup z3;\nllvm_verify mod \"notnot\" [not_ov] true notnot_setup z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1973\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet s_adt = mir_find_adt m \"test::S\" [];\n\nlet f_spec = do {\n  s_ref <- mir_alloc (mir_adt s_adt);\n  s <- mir_fresh_expanded_value \"s\" (mir_adt s_adt);\n  mir_points_to s_ref s;\n\n  mir_execute_func [s_ref];\n\n  mir_return s_ref;\n};\n\nmir_verify m \"test::f\" [] false f_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_crucible_jvm\/ffs_crucible.saw","filetype":"saw","content":"print \"Extracting reference term\";\nj <- java_load_class \"FFS\";\nffs_ref <- jvm_extract j \"ffs_ref\";\n\nprint \"Extracting implementation term\";\nffs_imp <- jvm_extract j \"ffs_imp\";\n\nprint \"Proving equivalence\";\nlet thm1 = {{ \\x -> ffs_ref x == ffs_imp x }};\nprove_print abc thm1;\nprint \"Done.\";\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_crucible_jvm\/statdyn_crucible.saw","filetype":"saw","content":"jdyn <- java_load_class \"Dyn\";\njstat <- java_load_class \"Stat\";\n\nprint \"**Extracting f_ref\";\nf_ref <- jvm_extract jdyn \"f_ref\";\n\nprint \"**Extracting f_imp\";\nf_imp <- jvm_extract jdyn \"f_imp\";\n\nprint \"**Extracting f_virt\";\nf_virt <- jvm_extract jdyn \"f_virt\";\n\nprint \"**Extracting h_ref\";\nh_ref <- jvm_extract jdyn \"h_ref\";\n\nprint \"**Extracting h_imp\";\nh_imp <- jvm_extract jdyn \"h_imp\";\n\nprint \"**Extracting g_imp\";\ng_imp <- jvm_extract jstat \"g_imp\";\n\n\n\nprint \"**Proving equivalence: instance variable\";\nprove_print abc {{ \\x -> f_ref x == f_imp x }};\n\nprint \"**Proving equivalence: dynamic method\";\nprove_print abc {{ \\x -> f_ref x == f_virt x }};\n\n\/* print \"**Proving equivalence: dynamic method\";\nprove_print abc {{ \\x -> h_ref x == h_imp x }}; *\/\n\nprint \"**Proving equivalence: methods two different classes\";\nprove_print abc {{ \\x -> h_ref x == g_imp x }};\n\n\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_crucible_jvm\/sub_crucible.saw","filetype":"saw","content":"obj <- java_load_class \"java.lang.Object\";\ndyn <- java_load_class \"Dyn\";\nifc <- java_load_class \"Iface\";\nsub <- java_load_class \"Sub\";\n\nprint \"**Extracting Dyn.f_virt\";\nf_virt <- jvm_extract dyn \"f_virt\";\nprint \"**Extracting Dyn.i_imp\";\ni_imp <- jvm_extract dyn \"i_imp\";\nprint \"**Extracting Sub.dyn\";\ndyn_g <- jvm_extract sub \"dyn\";\nprint \"**Extracting Sub.sub\";\nsub_g <- jvm_extract sub \"sub\";\n\nprint \"**Evaluating: dyn (12) \";\nsat_print abc {{ \\(x:[32]) -> dyn_g 12 == x }};\n\nprint \"**Evaluating: sub (12) \";\nsat_print abc {{ \\(x:[32]) -> sub_g 12 == x }};\n\nprint \"**Evaluating: f_virt (12) \";\nsat_print abc {{ \\(x:[32]) -> f_virt 12 == x }};\n\nprint \"**Evaluating: i_imp (12) \";\nsat_print abc {{ \\(x:[32]) -> i_imp 12 == x }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_crucible_jvm\/arr_crucible.saw","filetype":"saw","content":"j <- java_load_class \"Dyn\";\na <- java_load_class \"Arr\";\n\nprint \"**Extracting f_ref\";\nf_ref <- jvm_extract j \"f_ref\";\n\nprint \"**Extracting single\";\nsingle <- jvm_extract a \"single\";\n\nprint \"**Extracting doub\";\ndoub <- jvm_extract a \"doub\";\n\nprint \"**Extracting obj\";\nh_ref <- jvm_extract j \"h_ref\";\n\nprint \"**Evaluating: single array ref\";\nsat_print abc {{ \\(x:[32]) -> single 0 == x }};\n\nprint \"**Evaluating: double array ref\";\nsat_print abc {{ \\(x:[32]) -> doub 0 == x }};\n\nprint \"**Evaluating: obj array ref\";\nsat_print abc {{ \\(x:[32]) -> h_ref 0 == x }};\n\n\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_crucible_jvm\/stat_crucible.saw","filetype":"saw","content":"print \"**Extracting reference term\";\nj <- java_load_class \"Stat\";\nf_ref <- jvm_extract j \"f_ref\";\n\nprint \"**Extracting implementation term\";\nf_imp <- jvm_extract j \"f_imp\";\n\nprint \"**Proving equivalence\";\nlet thm1 = {{ \\x -> f_ref x == f_imp x }};\nprove_print abc thm1;\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_crucible_jvm\/dyn_crucible.saw","filetype":"saw","content":"obj   <- java_load_class \"java.lang.Object\";\niface <- java_load_class \"Iface\";\n\nj <- java_load_class \"Dyn\";\n\nprint \"**Extracting f_ref\";\nf_ref <- jvm_extract j \"f_ref\";\n\nprint \"**Extracting f_imp\";\nf_imp <- jvm_extract j \"f_imp\";\n\nprint \"**Extracting f_virt\";\nf_virt <- jvm_extract j \"f_virt\";\n\nprint \"**Extracting h_ref\";\nh_ref <- jvm_extract j \"h_ref\";\n\nprint \"**Extracting h_imp\";\nh_imp <- jvm_extract j \"h_imp\";\n\nprint \"**Extracting i_imp\";\ni_imp <- jvm_extract j \"i_imp\";\n\nprint \"**Extracting b\";\nb <- jvm_extract j \"b\";\n\n\nprint \"**Evaluating: instance variable\";\nsat_print abc {{ \\(x:[32]) -> f_imp 3 == x }};\n\n\nprint \"**Proving equivalence: instance variable\";\nprove_print abc {{ \\x -> f_ref x == f_imp x }};\n\nprint \"**Evaluating: dynamic method (f_virt 3)\";\nsat_print abc {{ \\(x:[32]) -> f_virt 3 == x }};\n\nprint \"**Proving equivalence: dynamic method \";\nprove_print abc {{ \\x -> f_ref x == f_virt x }};\n\nprint \"**Evaluating: alternative constructor (h_imp 3)\";\nsat_print abc {{ \\(x:[32]) -> h_imp 3 == x }};\n\nprint \"**Proving equivalence: dynamic method\";\nprove_print abc {{ \\x -> h_ref x == h_imp x }};\n\nprint \"**Evaluating: invoke interface (i_imp 3)\";\nsat_print abc {{ \\(x:[32]) -> i_imp 3 == x }};\n\nprint \"**Evaluating: two-argument dynamic method (b 3)\";\nsat_print abc {{ \\(x:[32]) -> b 3 == x }};\n\n\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_sawcore_prelude\/testDrop.saw","filetype":"saw","content":"print \"starting\";\n\nenable_experimental;\n\nload_sawcore_from_file \"testDrop.sawcore\";\nlet mod = \"testDrop\"; \/\/ SAWCore module name\n\nlet printNorm e =\n  print (show_term (normalize_term (parse_core_mod mod e)));\n\nlet runTest e c = do {\n  print e;\n  printNorm e;\n  prove_print abc (parse_core_mod mod c);\n  print \"Success\";\n  print \"\";\n};\n\nrunTest \"test1a\" \"check1a\";\nrunTest \"test1b\" \"check1b\";\nrunTest \"test1c\" \"check1c\";\nrunTest \"test1d\" \"check1d\";\nrunTest \"test1e\" \"check1e\";\n\nprint \"done\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0069_unfinished\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet andI = core_axiom \"(a b : Bool) -> EqTrue a -> EqTrue b -> EqTrue (and a b)\";\nlet script = do { simplify (cryptol_ss()); goal_apply andI; trivial; };\n\nb <- fresh_symbolic \"b\" {| Bit |};\n\nprint \"The following proof should fail because the proof is incomplete.\";\nfails (prove_print script {{ True && b }});\n\nprint \"Now we check that the 'prove' command also does the correct thing.\";\nr <- prove script {{ True && b }};\ncaseProofResult r (\\_ -> fails (print \"We should not get a theorem!\"))\n                  (\\x -> do { prove_print z3 {{ x == () }}; return ();} );\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0058\/test.saw","filetype":"saw","content":"\/\/ `Bit`s\nlet tru = {{ True }};\nlet fls = {{ False }};\n\nprint (eval_bool tru); print (eval_bool fls); \/\/ Bit vectors\n\/\/ Note: To prevent inference of the infinite numeric type `Integer`, type\n\/\/ annotations are necessary on decimal literals\nlet zero  = {{ 0 : [0] }};\nlet zero' = {{ 0 : [1] }};\nlet x     = {{ 17 : [5] }};\nlet neg_x = {{ -x }};\n\nprint (eval_int zero);  print (eval_int zero'); print (eval_int x);     print (eval_int neg_x); \/\/ [..] 15 (which has the same base-2 representation as\n                        \/\/          the two's complement negation of 17)\n\n\/\/ Sequences more generally\n\n\/\/ empty sequence\nlet l0 = {{ [] : [0]Bit }};\nprint (eval_list l0);\n\n\/\/ nonempty sequences\nlet l1   = {{ [0x01, 0x02, 0x03 ]}};\nlet l1'  = eval_list l1;\nprint l1'; \/\/ [..] ... List of Cryptol terms representing 1, 2, and 3 ...\n\nlet l2   = {{ [\"the\", \"and\", \"for\", \"not\"] }};\nlet l2'  = eval_list l2;\nprint l2'; \/\/ [..] ... List of Cryptol terms representing \"the\", \"and\", \"for\", \"not\" ...\n\n\/\/ eval_list and list_term should be inverses\nlet l1'' = list_term l1';\nlet thm1 = {{ l1 == l1'' }};\nprove_print z3 thm1;\n\nlet l2'' = list_term l2';\nlet thm2 = {{ l2 == l2'' }};\nprove_print z3 thm2;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0060\/test.saw","filetype":"saw","content":"m <- llvm_load_module \".\/test.bc\";\n\nlet id_spec = do {\n    p <- llvm_fresh_pointer (llvm_int 32);\n    llvm_execute_func [p];\n    llvm_return p;\n};\n\nllvm_verify m \"id_p\" [] false id_spec z3;\n\nlet add_two_spec = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    xp <- llvm_alloc (llvm_int 64);\n    llvm_points_to_untyped xp (llvm_term x);\n\n    llvm_execute_func [xp];\n\n    llvm_points_to_untyped xp (llvm_term {{ x + 2 }});\n};\n\nllvm_verify m \"add_two\" [] false add_two_spec z3;\n\nlet array_swap_spec = do {\n    a0 <- llvm_fresh_var \"a0\" (llvm_int 32);\n    a1 <- llvm_fresh_var \"a1\" (llvm_int 32);\n    a  <- llvm_alloc (llvm_array 2 (llvm_int 32));\n    llvm_points_to a (llvm_array_value [llvm_term a0, llvm_term a1]);\n\n    llvm_execute_func [a];\n\n    llvm_points_to (llvm_elem a 0) (llvm_term a1);\n    llvm_points_to (llvm_elem a 1) (llvm_term a0);\n};\n\nllvm_verify m \"array_swap\" [] false array_swap_spec z3;\n\nlet struct_swap_spec = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    s <- llvm_alloc (llvm_alias \"struct.foo\");\n    llvm_points_to s (llvm_packed_struct_value [llvm_term x, llvm_term y]);\n\n    llvm_execute_func [s];\n\n    llvm_points_to (llvm_field s \"x\") (llvm_term y);\n    llvm_points_to (llvm_field s \"y\") (llvm_term x);\n};\n\n\/\/ A variant of struct_swap_spec that uses llvm_struct_type instead of llvm_alias.\nlet struct_swap_spec2 = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    s <- llvm_alloc (llvm_packed_struct_type [llvm_int 32, llvm_int 32]);\n    llvm_points_to s (llvm_packed_struct_value [llvm_term x, llvm_term y]);\n\n    llvm_execute_func [s];\n\n    llvm_points_to (llvm_elem s 0) (llvm_term y);\n    llvm_points_to (llvm_elem s 1) (llvm_term x);\n};\n\nllvm_verify m \"struct_swap\" [] false struct_swap_spec z3;\nllvm_verify m \"struct_swap\" [] false struct_swap_spec2 z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1945\/test.saw","filetype":"saw","content":"\/\/ Test a use of `llvm_conditional_points_to` where the value that the pointer\n\/\/ points to will fail to match against the right-hand side value unless the\n\/\/ condition is properly incorporated into the path condition. This serves as\n\/\/ a regression test for https:\/\/github.com\/GaloisInc\/saw-script\/issues\/1945.\n\nlet test_spec = do {\n  p <- llvm_alloc (llvm_int 8);\n  x <- llvm_fresh_var \"x\" (llvm_int 8);\n  llvm_points_to p (llvm_term x);\n\n  llvm_execute_func [p];\n\n  llvm_conditional_points_to {{ x == 1 }} p (llvm_term {{ 1 : [8] }});\n};\n\nm <- llvm_load_module \"test.bc\";\nllvm_verify m \"test\" [] false test_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test2398\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet thing = mir_find_adt m \"test::Thing\" [];\n\nlet get_thing_spec = do {\n    mir_execute_func [];\n    mir_return (mir_struct_value thing [\n        mir_tuple_value [],\n        mir_term {{ 1 : [32] }},\n        mir_term {{ [] : [0][8] }}\n    ]);\n};\n\nget_thing_ov <- mir_verify m \"test::get_thing\" [] false get_thing_spec z3;\n\nlet get_thing_b_spec = do {\n    mir_execute_func [];\n    mir_return (mir_term {{ 1 : [32] }});\n};\n\nmir_verify m \"test::get_thing_b\" [get_thing_ov] false get_thing_b_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_unint_extcore\/test_unint.saw","filetype":"saw","content":"import \"unint.cry\";\n\nfails (prove_print (w4_unint_yices [\"g\"]) {{ \\x -> f x > 0 }});\n\nwrite_core \"unint.core\" {{ \\x -> f x > 0 }};\n\nprop <- read_core \"unint.core\";\n\nfails (prove_print (w4_unint_yices [\"g\"]) {{ \\x -> prop x }});","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test1788\/test.saw","filetype":"saw","content":"\/\/ This test case ensures that ABC can prove that a C implementation of the\n\/\/ `mult` function is equivalent to a direct Cryptol implementation of the\n\/\/ same function.\n\nlet\n{{\ncryptol_mult : [32] -> [32]\ncryptol_mult x = x * 0x85EBCA77\n}};\n\nm <- llvm_load_module \"test.bc\";\nllvm_mult <- llvm_extract m \"mult\";\nprove_print abc {{ \\x -> llvm_mult x == cryptol_mult x }};\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test0005\/test2.saw","filetype":"saw","content":"let main = do {\n   java_md5 <- read_aig \"..\/support\/JavaMD5.aig\";\n\n   print \"AIG type\";\n   print_type java_md5;\n\n   print \"AIG type, checked\";\n   ty2 <- check_term java_md5;\n\n   let thm1 = {{ java_md5 0 == 0x52e7c86c27d29ffd9e4bae74c41218a5 }};\n   prove_print abc thm1;\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0005\/test.saw","filetype":"saw","content":"let main = do {\n   java_md5 <- read_aig \"..\/support\/JavaMD5.aig\";\n\n   print \"AIG type\";\n   print_type java_md5;\n\n   print \"AIG type, checked\";\n   check_term java_md5;\n\n   let thm1 = {{ java_md5 zero ==\n                 join [82, 231, 200, 108, 39, 210, 159, 253, 158, 75, 174, 116, 196, 18, 24, 165] }};\n   prove_print abc thm1;\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0063_polyarith\/test.saw","filetype":"saw","content":"let {{\n\nthm : {n,m} (fin n, fin m, n > m, m >= 1) => [n] -> [m] -> Bit\nthm x y = y != 0 ==> \n    pmult y (pdiv x y) ^ (zero # pmod x y) == zero`{[m-1]}#x\n\n}};\n\nprint_term (rewrite (cryptol_ss ())\n  (unfold_term [\"thm\"] {{ thm`{16,4} }}));\n\nprove_print rme {{ thm`{16,8} }};\nprove_print rme {{ thm`{20,10} }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test_mir_fresh_expanded_value_enum\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet option_u32_adt = mir_find_adt m \"core::option::Option\" [mir_u32];\n\nlet f_none_spec = do {\n  let x = mir_enum_value option_u32_adt \"None\" [];\n\n  mir_execute_func [x];\n\n  mir_return (mir_term {{ 27 : [32] }});\n};\n\nlet f_some_spec = do {\n  ret <- mir_fresh_var \"ret\" mir_u32;\n  let x = mir_enum_value option_u32_adt \"Some\" [mir_term ret];\n\n  mir_execute_func [x];\n\n  mir_return (mir_term ret);\n};\n\nlet g_spec = do {\n  x <- mir_fresh_expanded_value \"x\" (mir_adt option_u32_adt);\n\n  mir_execute_func [x];\n};\n\nlet gg_spec = do {\n  xx <- mir_fresh_expanded_value \"xx\" (mir_adt option_u32_adt);\n\n  mir_execute_func [xx];\n};\n\nf_none_ov <- mir_verify m \"test::f\" [] false f_none_spec z3;\nf_some_ov <- mir_verify m \"test::f\" [] false f_some_spec z3;\n\nmir_verify m \"test::g\" [] false g_spec z3;\ng_ov <- mir_verify m \"test::g\" [f_none_ov, f_some_ov] false g_spec z3;\n\nmir_verify m \"test::gg\" [] false gg_spec z3;\nmir_verify m \"test::gg\" [g_ov] false gg_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0002\/test.saw","filetype":"saw","content":"import \"..\/..\/deps\/cryptol-specs\/Primitive\/Keyless\/Hash\/MD5.md\";\n\nlet main = do {\n   java_md5 <- read_aig \"..\/support\/JavaMD5.aig\";\n\n   print \"ref type\";\n   print_type {{ md5_ref }};\n   print \"\";\n\n   check_term {{ md5_ref }};\n   print \"\";\n\n   print \"AIG type\";\n   print_type java_md5;\n   print \"\";\n\n   print \"AIG type, checked\";\n   check_term java_md5;\n   print \"\";\n\n   let thm = {{ \\x -> join (md5_ref x) == java_md5 (join x) }};\n   write_aig \"md5_ref.aig\" {{ \\(x:[16][8]) -> join (md5_ref x) }};\n   write_aig \"java_md5.aig\" {{ \\(x:[16][8]) -> java_md5 (join x) }};\n};\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_jvm_method_names\/test.saw","filetype":"saw","content":"c <- java_load_class \"Test\";\nprint c;\n\njvm_verify c \"get\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"Test.val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  }\n  z3;\n\n\nprint \"********************************************************************************\";\nprint \"<init>\";\nfails (\njvm_verify c \"<init>\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    jvm_execute_func [this];\n    jvm_field_is this \"Test.val\" (jvm_term {{ 0 : [64] }});\n  }\n  z3);\n\nprint \"********************************************************************************\";\nprint \"<init>:(J)V\";\njvm_verify c \"<init>:(J)V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"Test.val\" (jvm_term x);\n  }\n  z3;\n\nprint \"********************************************************************************\";\nprint \"<init>:(I)V\";\njvm_verify c \"<init>:(I)V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"Test.val\" (jvm_term {{ sext x : [64] }});\n  }\n  z3;\n\nprint \"********************************************************************************\";\nprint \"<init>:()V\";\njvm_verify c \"<init>:()V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    jvm_execute_func [this];\n    jvm_field_is this \"Test.val\" (jvm_term {{ 0 : [64] }});\n  }\n  z3;\n\nprint \"********************************************************************************\";\nprint \"increment\";\nfails (\njvm_verify c \"increment\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"Test.val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_field_is this \"Test.val\" (jvm_term {{ val + 1 }});\n  }\n  z3);\n\nprint \"********************************************************************************\";\nprint \"increment:()V\";\njvm_verify c \"increment:()V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"Test.val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_field_is this \"Test.val\" (jvm_term {{ val + 1 }});\n  }\n  z3;\n\nprint \"********************************************************************************\";\nprint \"increment:(J)V\";\njvm_verify c \"increment:(J)V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"Test.val\" (jvm_term val);\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"Test.val\" (jvm_term {{ val + x }});\n  }\n  z3;\n\nprint \"********************************************************************************\";\nprint \"increment:(I)V\";\njvm_verify c \"increment:(I)V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"Test.val\" (jvm_term val);\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"Test.val\" (jvm_term {{ val + sext x }});\n  }\n  z3;\n\nprint \"********************************************************************************\";\nprint \"increment:(LTest;)V\";\njvm_verify c \"increment:(LTest;)V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"Test.val\" (jvm_term val);\n\n    x <- jvm_alloc_object \"Test\";\n    x_val <- jvm_fresh_var \"x_val\" java_long;\n    jvm_field_is x \"Test.val\" (jvm_term x_val);\n\n    jvm_execute_func [this, x];\n    jvm_field_is this \"Test.val\" (jvm_term {{ val + x_val }});\n  }\n  z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0051_compositional_extract_2\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh nm ty = do {\n    x <- llvm_fresh_var nm ty;\n    p <- llvm_alloc ty;\n    llvm_points_to p (llvm_term x);\n    return (x, p);\n};\n\nlet add_spec = do {\n  r_p <- llvm_alloc (llvm_alias \"struct.uint128_t\");\n  (_, a_p) <- ptr_to_fresh \"a\" (llvm_alias \"struct.uint128_t\");\n  (_, b_p) <- ptr_to_fresh \"b\" (llvm_alias \"struct.uint128_t\");\n  llvm_execute_func [r_p, a_p, b_p];\n  r <- llvm_fresh_var \"r\" (llvm_alias \"struct.uint128_t\");\n  llvm_points_to r_p (llvm_term r);\n};\n\nlet sum_spec n = do {\n  s_p <- llvm_alloc (llvm_alias \"struct.uint128_t\");\n  (_, a_p) <- ptr_to_fresh \"a\" (llvm_array n (llvm_alias \"struct.uint128_t\"));\n  llvm_execute_func [s_p, a_p, (llvm_term {{ `n:[64] }})];\n  s <- llvm_fresh_var \"s\" (llvm_alias \"struct.uint128_t\");\n  llvm_points_to s_p (llvm_term s);\n};\n\nadd_ov <- llvm_compositional_extract m \"add\" \"add\" [] false add_spec yices;\n_ <- llvm_compositional_extract m \"sum\" \"sum\" [add_ov] false (sum_spec 10) yices;\n\nadd_thm <- prove_print yices\n  {{ \\a b -> add a b == reverse (split ((join (reverse a)) + (join (reverse b)))) }};\nprove_print (do { simplify (addsimps [add_thm] empty_ss); simplify (cryptol_ss ()); yices; })\n  {{ \\a -> sum a == reverse (split (foldl (+) (0:[128]) (map join (map reverse a)))) }};\n\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test0068_zerobv\/test.saw","filetype":"saw","content":"\/\/ test case for github issue https:\/\/github.com\/GaloisInc\/saw-script\/issues\/872\n\nprove_print z3 {{ \\(x:[0]) y z -> x * (y + z) == x*y + x*z }};\nprint \"z3 OK\";\n\nprove_print w4 {{ \\(x:[0]) y z -> x * (y + z) == x*y + x*z }};\nprint \"w4 OK\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test2363\/test.saw","filetype":"saw","content":"enable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet Stuff = mir_find_adt m \"test::Stuff\" [];\n\nlet mk_stuff_spec = do {\n    p <- mir_alloc_raw_ptr_const mir_u8;\n    mir_execute_func [p];\n    mir_return (mir_struct_value Stuff [mir_cast_raw_ptr p mir_i32]);\n};\n\nmk_stuff_ov <- mir_verify m \"test::mk_stuff\" [] false mk_stuff_spec z3;\n\nlet do_stuff_spec = do {\n    x <- mir_fresh_var \"x\" mir_u8;\n    p <- mir_alloc_raw_ptr_const mir_u8;\n    mir_points_to p (mir_term x);\n    mir_execute_func [mir_struct_value Stuff [mir_cast_raw_ptr p mir_i32]];\n    mir_return (mir_term {{ x + 1 }});\n};\n\ndo_stuff_ov <- mir_verify m \"test::do_stuff\" [] false do_stuff_spec z3;\n\nlet weird_add_spec = do {\n    x <- mir_fresh_var \"x\" mir_u8;\n    mir_execute_func [mir_term x];\n    mir_return (mir_term {{ x + 1 }});\n};\n\nmir_verify m \"test::weird_add\" [mk_stuff_ov, do_stuff_ov] false weird_add_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0057\/test.saw","filetype":"saw","content":"\/\/ a variety of Cryptol terms\nlet c = {{ 17 : [8] }};\nx <- fresh_symbolic \"x\" {| [64] |};\ny <- fresh_symbolic \"y\" {| [64] |};\nlet t1 = {{ x + y }};\nlet t2 = {{ \\z -> z }};\nlet t3 = {{ \\(z : [32]) -> z }};\nlet t4 = {{ [1 .. 10] }};\nlet t5 = {{ [1 .. 10] : [10][32] }};\n\n\/\/ reading\/writing is consistent, i.e. writing a term to file and immediately\n\/\/ reading it back into memory does not change the term\nwrite_core \"c.out\" c;\nc_in <- read_core \"c.out\";\nlet thm_c = {{ c_in == c }};\nprove_print z3 thm_c;\n\n\/\/ NB. reading\/writing open terms will generate new fresh variables\nwrite_core \"x.out\" x;\nx_in <- read_core \"x.out\";\nlet thm_x = {{ x_in == x }};\nfails (prove_print z3 thm_x);\n\n\/\/ NB. reading\/writing open terms will generate new fresh variables\nwrite_core \"t1.out\" t1;\nt1_in<- read_core \"t1.out\";\nlet thm_t1 = {{ t1_in == t1 }};\nfails (prove_print z3 thm_t1);\n\n\/\/ N.B. This test currently crashes SAW due to bug #780\n\/\/ write_core \"t2.out\" t2;\n\/\/ t2_in <- read_core \"t2.out\";\n\/\/ let thm_t2 = {{ \\x -> t2_in x == t2 x }};\n\/\/ prove z3 thm_t2;\n\nwrite_core \"t3.out\" t3;\nt3_in <- read_core \"t3.out\";\nlet thm_t3 = {{ \\x -> t3_in x == t3 x }};\nprove_print z3 thm_t3;\n\n\/\/ N.B. This test currently crashes SAW due to bug #780\n\/\/ write_core \"t4.out\" t4;\n\/\/ t4_in <- read_core \"t4.out\";\n\/\/ let thm_t4 = {{ t4_in == t4 }};\n\/\/ prove_print z3 thm_t4;\n\nwrite_core \"t5.out\" t5;\nt5_in <- read_core \"t5.out\";\nlet thm_t5 = {{ t5_in == t5 }};\nprove_print z3 thm_t5;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test_mir_verify_arrays\/test.saw","filetype":"saw","content":"enable_experimental;\n\nlet f_spec = do {\n  x0_ref <- mir_alloc mir_u32;\n  x0 <- mir_fresh_var \"x0\" mir_u32;\n  mir_points_to x0_ref (mir_term x0);\n\n  x1_ref <- mir_alloc mir_u32;\n  x1 <- mir_fresh_var \"x1\" mir_u32;\n  mir_points_to x1_ref (mir_term x1);\n\n  let x = mir_array_value (mir_ref mir_u32) [x0_ref, x1_ref];\n\n  mir_execute_func [x];\n\n  mir_return (mir_term {{ x0 + x1 }});\n};\n\nlet g_spec = do {\n  x0_ref <- mir_alloc_mut mir_u32;\n\n  x1_ref <- mir_alloc_mut mir_u32;\n  x1 <- mir_fresh_var \"x1\" mir_u32;\n  mir_points_to x1_ref (mir_term x1);\n\n  let x = mir_array_value (mir_ref_mut mir_u32) [x0_ref, x1_ref];\n\n  mir_execute_func [x];\n\n  mir_points_to x0_ref (mir_term {{ 42 : [32] }});\n  mir_points_to x1_ref (mir_term {{ x1 + 1 }});\n};\n\nlet h_spec = do {\n  mir_execute_func [];\n\n  x0_ref <- mir_alloc mir_u32;\n  mir_points_to x0_ref (mir_term {{ 27 : [32] }});\n\n  x1_ref <- mir_alloc mir_u32;\n  mir_points_to x1_ref (mir_term {{ 42 : [32] }});\n\n  let x = mir_array_value (mir_ref mir_u32) [x0_ref, x1_ref];\n  mir_return x;\n};\n\nlet i_spec = do {\n  let x = mir_term {{ [] : [0][32] }};\n  mir_execute_func [x];\n\n  mir_return (mir_array_value mir_u64 []);\n};\n\nlet i_spec_bad1 = do {\n  let x = mir_term {{ [42] : [1][32] }};\n  mir_execute_func [x];\n\n  mir_return (mir_array_value mir_u64 []);\n};\n\nlet i_spec_bad2 = do {\n  let x = mir_term {{ [] : [0][32] }};\n  mir_execute_func [x];\n\n  mir_return (mir_array_value mir_u64 [mir_term {{ 42 : [64] }}]);\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::f\" [] false f_spec z3;\nmir_verify m \"test::g\" [] false g_spec z3;\nmir_verify m \"test::h\" [] false h_spec z3;\nmir_verify m \"test::i\" [] false i_spec z3;\n\nfails (\n  mir_verify m \"test::i\" [] false i_spec_bad1 z3\n);\nfails (\n  mir_verify m \"test::i\" [] false i_spec_bad2 z3\n);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0049_conditional_points_to\/test.saw","filetype":"saw","content":"m <- llvm_load_module \"test.bc\";\n\nlet get_val_impl_spec = do {\n  p <- llvm_alloc (llvm_int 32);\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [p, llvm_term x];\n  llvm_conditional_points_to {{ x >$ 0 }} p (llvm_term x);\n  llvm_return (llvm_term {{ (if x >$ 0 then 0 else 1) : [32] }});\n};\n\nlet get_val_impl_failure_spec = do {\n  p <- llvm_alloc (llvm_int 32);\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [p, llvm_term x];\n  \/\/ incorrect spec: {{ x > 0 }} instead of {{ x >$ 0 }}\n  llvm_conditional_points_to {{ x > 0 }} p (llvm_term x);\n};\n\nlet get_val_spec = do {\n  p <- llvm_alloc (llvm_int 32);\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [p, llvm_term x];\n  ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n  y <- llvm_fresh_var \"y\" (llvm_int 32);\n  llvm_conditional_points_to {{ ret == 0 }} p (llvm_term y);\n  llvm_postcond {{ ret == 0 ==> y >$ 0 }};\n  llvm_return (llvm_term ret);\n};\n\nlet get_val_failure0_spec = do {\n  p <- llvm_alloc (llvm_int 32);\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [p, llvm_term x];\n  ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n  y <- llvm_fresh_var \"y\" (llvm_int 32);\n  llvm_conditional_points_to {{ ret == 0 }} p (llvm_term y);\n  \/\/ incorrect spec: {{ y >$ 0 }} instead of {{ ret == 0 ==> y >$ 0 }}\n  llvm_postcond {{ y >$ 0 }};\n  llvm_return (llvm_term ret);\n};\n\nlet get_val_failure1_spec = do {\n  p <- llvm_alloc (llvm_int 32);\n  v <- llvm_fresh_var \"v\" (llvm_int 32);\n  llvm_points_to p (llvm_term v);\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [p, llvm_term x];\n  y <- llvm_fresh_var \"y\" (llvm_int 32);\n  \/\/ incorrect spec: p is invalidated by get_val_impl_spec\n  llvm_points_to p (llvm_term y);\n};\n\nlet get_val_default_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [llvm_term x];\n  ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n  llvm_postcond {{ ret >= 0 }};\n  llvm_return (llvm_term ret);\n};\n\nget_val_imp_ov <- llvm_verify m \"get_val_impl\" [] false get_val_impl_spec (w4_unint_yices []);\nfails (llvm_verify m \"get_val_impl\" [] false get_val_impl_failure_spec (w4_unint_yices []));\nget_val_ov <- llvm_verify m \"get_val\" [get_val_imp_ov] false get_val_spec (w4_unint_yices []);\nfails (llvm_verify m \"get_val\" [get_val_imp_ov] false get_val_failure0_spec (w4_unint_yices []));\nfails (llvm_verify m \"get_val\" [get_val_imp_ov] false get_val_failure1_spec (w4_unint_yices []));\nllvm_verify m \"get_val_default\" [get_val_ov] false get_val_default_spec (w4_unint_yices []);\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0064_detect_vacuity\/test.saw","filetype":"saw","content":"\/\/ NOTE: in the current design, contradictions are indicated as a warning\n\/\/ message, so the following script should succeed, but contain a message about\n\/\/ the detected contradiction in its output.\n\nlet bad_spec = do {\n    a <- llvm_fresh_var \"a\" (llvm_int 32);\n    llvm_precond {{ a == 0 }};\n    llvm_precond {{ a == 1 }};\n    llvm_execute_func [llvm_term a];\n    llvm_postcond {{ a == 2 }};\n};\n\nm <- llvm_load_module \"test.bc\";\n\nllvm_verify m \"double_imp\" [] true bad_spec z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test2337\/test.cry","filetype":"cry","content":"enum Letter = A | B\n\neqLetter : Letter -> Letter -> Bit\neqLetter l1 l2 =\n  case l1 of\n    A ->\n      case l2 of\n        A -> True\n        B -> False\n    B ->\n      case l2 of\n        A -> False\n        B -> True\n\nletterA : Bool -> Letter\nletterA x =\n  if x then A else B\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/intTests\/test0059_smt_array_2\/test.saw","filetype":"saw","content":"import \"Test.cry\";\n\nenable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet foo_spec = do {\n  size <- llvm_fresh_var \"size\" (llvm_int 64);\n  dest_ptr <- llvm_symbolic_alloc false 1 size;\n  src_ptr <- llvm_symbolic_alloc false 1 size;\n  src <- llvm_fresh_cryptol_var \"src\" {| ByteArray |};\n  llvm_points_to_array_prefix src_ptr src size;\n  llvm_execute_func [dest_ptr, src_ptr, (llvm_term size)];\n  llvm_points_to_array_prefix dest_ptr {{ f size src }} size;\n};\n\nlet foo_failure_spec = do {\n  size <- llvm_fresh_var \"size\" (llvm_int 64);\n  dest_ptr <- llvm_symbolic_alloc false 1 size;\n  src_ptr <- llvm_symbolic_alloc false 1 size;\n  src <- llvm_fresh_cryptol_var \"src\" {| ByteArray |};\n  llvm_points_to_array_prefix src_ptr src {{ drop`{32} size }};\n  llvm_execute_func [dest_ptr, src_ptr, (llvm_term size)];\n};\n\nlet bar_spec = do {\n  len <- llvm_fresh_var \"len\" (llvm_int 64);\n  let byte_len = rewrite (cryptol_ss ()) {{ 8 * len }};\n  a_ptr <- llvm_symbolic_alloc false 8 byte_len;\n  b_ptr <- llvm_symbolic_alloc false 8 byte_len;\n  b <- llvm_fresh_cryptol_var \"b\" {| ByteArray |};\n  llvm_points_to_array_prefix b_ptr b byte_len;\n  llvm_execute_func [a_ptr, b_ptr, (llvm_term len)];\n  llvm_points_to_array_prefix a_ptr {{ f byte_len b }} byte_len;\n};\n\nfoo_ov <- llvm_unsafe_assume_spec m \"foo\" foo_spec;\nfails (llvm_unsafe_assume_spec m \"foo\" foo_failure_spec);\nllvm_verify m \"bar\" [foo_ov] false bar_spec (w4_unint_z3 [\"f\"]);\n\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/intTests\/test1094_2464\/test.saw","filetype":"saw","content":"\/\/ A regression test for #1094 and #2464. This ensures that we can successfully\n\/\/ use sat-related commands to produce models for Vec values in SAWCore, in both\n\/\/ the SBV and What4 backends.\n\nlet test_prop (prover : ProofScript ()) (prop : Term) = do {\n    \/\/ Test both sat_print...\n    sat_print prover prop;\n\n    \/\/ ...and sat\/caseSatResult, as these commands exercise slightly different\n    \/\/ code paths.\n    r_sbv <- sat prover prop;\n    caseSatResult r_sbv (print \"Unsat\") print;\n};\n\nlet prop1 = {{ \\(x : [2][8]) -> x == reverse x }};\ntest_prop (sbv_unint_z3 []) prop1;\ntest_prop (w4_unint_z3 []) prop1;\n\nlet prop2 = {{ \\(x : [0][8]) -> x == reverse x }};\ntest_prop (sbv_unint_z3 []) prop2;\ntest_prop (w4_unint_z3 []) prop2;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/crux-mir-comp\/test\/symb_eval\/cryptol\/uninterp.cry","filetype":"cry","content":"module test::symb_eval::cryptol::uninterp where\n\ntype U64 = [64]\n\npow : U64 -> U64 -> U64\npow n k = last vals where\n    sq x = mult x x\n    vals = [1]\n         # [ if i then mult n acc else acc\n           | acc <- map sq vals\n           | i   <- k ]\n\nirreducible : [65]\nirreducible = <| x^^64 + x^^4 + x^^3 + x + 1 |>\n\n\/**\n * Multiply two elements in GF28. [FIPS-197u1] Section 4.2.\n *\/\nmult : U64 -> U64 -> U64\n\/\/ mult x y = pmod (pmult x y) irreducible\nmult = undefined \/\/ definition replaced to check that uninterp is doing something in the test\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/crux-mir-comp\/test\/symb_eval\/cryptol\/basic.cry","filetype":"cry","content":"module test::symb_eval::cryptol::basic where\n\naddByte : [8] -> [8] -> [8]\naddByte x y = x + y\n\ntupleArg : ([8], [8]) -> [8]\ntupleArg (x, y) = x + y\n\ntupleRet : [8] -> [8] -> ([8], [8])\ntupleRet x y = (x + y, x - y)\n\narrayArg : [2][8] -> [8]\narrayArg [x, y] = x + y\n\narrayRet : [8] -> [8] -> [2][8]\narrayRet x y = [x + y, x - y]\n\nxorBits : {n} (fin n) => [n] -> [n] -> [n]\nxorBits x y = x ^ y\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/crux-mir-comp\/test\/symb_eval\/cryptol\/size_poly_nested.cry","filetype":"cry","content":"module test::symb_eval::cryptol::size_poly_nested where\n\nf: {m,n} (fin m, fin n) => [m][n][8] -> [8]\nf xs = sum (join xs)","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/saw-python\/tests\/saw\/test-files\/Foo.cry","filetype":"cry","content":"module Foo where\n\nid : {a} a -> a\nid x = x\n\nx : [8]\nx = 255\n\nadd : {a} (fin a) => [a] -> [a] -> [a]\nadd = (+)\n\nfoo : {foo : [32], bar : [32]} \nfoo = {foo = 23, bar = 99}\n\ngetFoo : {foo : [32], bar : [32]}  -> [32]\ngetFoo x = x.foo\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/drbg\/drbg-helpers.cry","filetype":"cry","content":"import DRBG\nimport AES\n\n\/\/ TODO: the original version of this, keysize = 32 conflicted\n\/\/ in the definition of encrypt_128\ntype keysize = 16 \/\/ keylen \/ 8\n\nmax_seq_number : [blocksize*8]\nmax_seq_number = ~zero\n\ndrbg_generate_seedlen : s2n_drbg -> [seedlen] -> Bit -> ([seedlen], s2n_drbg)\ndrbg_generate_seedlen = drbg_generate `{n=seedlen,blocks=2}\n\nencrypt_128 : [keysize][8] -> [blocksize][8] -> [blocksize][8]\nencrypt_128 key msg =\n  split (block_encrypt (join key) (join msg))\n\nmode_128 = 0\nmode_256 = 1\n\n\/\/ TODO: Tried to simulate the top-level symbolic variable from the\n\/\/ saw script version using undefined below, but in the end\n\/\/ this trick did not work.\n\/\/ Note: I changed this. Originally it was seedsize, but\n\/\/ that appears to be 48 here which prevents some proofs\n\/\/ from going through.\n\/\/type entropy_len = 32\n\/\/fake_entropy : [entropy_len*8]\n\/\/fake_entropy = undefined\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/SHA256.saw","filetype":"saw","content":"import \"SHA256.cry\";\n\nlet check_sha n = do {\n    print (str_concat \"Checking imp_correct for byte count \" (show n));\n    time (prove_print abc {{ imp_correct : [n][8] -> Bit }});\n};\n\nfor [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] check_sha;\nfor [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32] check_sha;\nfor [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48] check_sha;\nfor [49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64] check_sha;\nfor [65, 127, 128, 129, 1000] check_sha;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/Hashing.cry","filetype":"cry","content":"module Hashing where\n\nimport SHA256\n\n\n\/*\ntypedef enum { S2N_HASH_NONE, S2N_HASH_MD5, S2N_HASH_SHA1, S2N_HASH_SHA224, S2N_HASH_SHA256, S2N_HASH_SHA384,\n    S2N_HASH_SHA512, S2N_HASH_MD5_SHA1\n} s2n_hash_algorithm;\n*\/\nS2N_HASH_NONE     = 0:[32]\nS2N_HASH_MD5      = 1:[32]\nS2N_HASH_SHA1     = 2:[32]\nS2N_HASH_SHA224   = 3:[32]\nS2N_HASH_SHA256   = 4:[32]\nS2N_HASH_SHA384   = 5:[32]\nS2N_HASH_SHA512   = 6:[32]\nS2N_HASH_MD5_SHA1 = 7:[32]\n\n\/*\n134 typedef struct SHA256state_st {\n135     SHA_LONG h[8];\n136     SHA_LONG Nl, Nh;\n137     SHA_LONG data[SHA_LBLOCK];\n138     unsigned int num, md_len;\n139 } SHA256_CTX;\n*\/\n\/\/ Looking at the generated LLVM in ':\/src\/hmac.ll' gives the precise\n\/\/ layout, without having to find the definitions of the above\n\/\/ macros.\n\/*\n%struct.SHA512state_st = type { [8 x i64], i64, i64, %union.anon.0, i32, i32 }\n%union.anon.0 = type { [16 x i64] }\n*\/\n\n\/\/ The hash state in s2n is stored in a union, and the largest member\n\/\/ of that union is the SHA512 hash state. So, we need to translate\n\/\/ between SHA512 and SHA256 hash states.\n\/\/\n\/\/ \/usr\/include\/openssl\/sha.h\ntype SHA512_c_state =\n  { h      : [8][64]\n  , Nl     : [64]\n  , Nh     : [64]\n  , u      : [16][64]\n  , num    : [32]\n  , md_len : [32]\n  }\ntype SHA512_c_bits = 8*64+64+64+16*64+32+32\n\njoin512_c_state : SHA512_c_state -> [SHA512_c_bits]\njoin512_c_state st = join st.h # st.Nl # st.Nh # join st.u # st.num # st.md_len\n\ntype SHA256_c_state =\n  { h      : [8][32]\n  , Nl     : [32]     \/\/ The low bits of 'sz'.\n  , Nh     : [32]     \/\/ The high bits of 'sz'.\n  , u      : [16][32] \/\/ The 'block': '[16][32] == [8][64]' when flattened.\n  , num    : [32]     \/\/ The 'n', but extended to 32 bits.\n  , md_len : [32]     \/\/ The value of 'md_len' is always 32,\n  }                   \/\/ i.e. 'SHA256_DIGEST_LENGTH'.\ntype SHA256_c_bits = 8*32+32+32+16*32+32+32\n\njoin256_c_state : SHA256_c_state -> [SHA256_c_bits]\njoin256_c_state st = join st.h # st.Nl # st.Nh # join st.u # st.num # st.md_len\n\ntype SHA256_DIGEST_LENGTH = 32\ntype SHA512_DIGEST_LENGTH = 64\n\n\n\/\/ Recall the 'SHA256State' in our Cryptol model in '.\/SHA256.cry':\n\/*\ntype SHA256State = { h     : [8][32]\n                   , block : [64][8]\n                   , n     : [16]\n                   , sz    : [64]\n                   }\n*\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Basic hash-state translations.\n\n\/\/ The following code describes how to marshall back and forth between a\n\/\/ SHA256 C state and a SHA512 C state. Doing this is unnecessary for the\n\/\/ HMAC verification, but it is necessary to concretely evaluate the specs.\n\/\/ The rest of this section, therefore, does not need to be trusted.\n\n\/\/ I'm using the initial, high order bits of the SHA512 state to\n\/\/ construct the SHA256 state. The LLVM code doesn't make it clear\n\/\/ that this is correct -- it depends on the semantics of 'bitcast' --\n\/\/ but I did an experiment which validates this choice; see\n\/\/ 'examples\/llvm\/union' in the SAWScript repo.\nsha512_c_state_to_sha256_c_state : SHA512_c_state -> SHA256_c_state\nsha512_c_state_to_sha256_c_state st =\n  { h      = split (take bits)\n  , Nl     = take (drop`{front=8*32} bits)\n  , Nh     = take (drop`{front=8*32+32} bits)\n  , u      = split (take (drop`{front=8*32+32+32} bits))\n  , num    = take (drop`{front=8*32+32+32+16*32} bits)\n  , md_len = drop`{front=8*32+32+32+16*32+32} bits\n  }\n  where\n    bits : [SHA256_c_bits]\n    bits = take bits0\n    bits0 : [SHA512_c_bits]\n    bits0 = join512_c_state st\n\n\/\/ We need the original state, 'st0', to compute the trailing SHA512\n\/\/ bits which aren't used in the SHA256 state.\nsha256_c_state_to_sha512_c_state : SHA512_c_state -> SHA256_c_state -> SHA512_c_state\nsha256_c_state_to_sha512_c_state st0 st =\n  { h      = split (take bits)\n  , Nl     = take (drop`{front=8*64} bits)\n  , Nh     = take (drop`{front=8*64+64} bits)\n  , u      = split (take (drop`{front=8*64+64+64} bits))\n  , num    = take (drop`{front=8*64+64+64+16*64} bits)\n  , md_len = drop`{front=8*64+64+64+16*64+32} bits\n  }\n  where\n    bits : [SHA512_c_bits]\n    bits = join256_c_state st # drop bits0\n    bits0 : [SHA512_c_bits]\n    bits0 = join512_c_state st0\n\nsha256_c_state_to_sha256_state : SHA256_c_state -> SHA256State\nsha256_c_state_to_sha256_state st =\n  { h     = st.h\n  , block = split (join st.u)\n  , n     = drop st.num\n  , sz    = st.Nh # st.Nl\n  }\n  where\n    bits : [SHA256_c_bits]\n    bits = join256_c_state st\n\nsha256_state_to_sha256_c_state : SHA256State -> SHA256_c_state\nsha256_state_to_sha256_c_state st =\n  { h      = st.h\n  , Nl     = Nl\n  , Nh     = Nh\n  , u      = split (join st.block)\n  , num    = (zero # st.n) : [32]\n  , md_len = `SHA256_DIGEST_LENGTH : [32]\n  }\n  where\n    [Nh, Nl] = split st.sz\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Composed hash-state translations.\n\nsha512_c_state_to_sha256_state : SHA512_c_state -> SHA256State\nsha512_c_state_to_sha256_state st =\n  sha256_c_state_to_sha256_state (sha512_c_state_to_sha256_c_state st)\n\nsha256_state_to_sha512_c_state : SHA512_c_state -> SHA256State -> SHA512_c_state\nsha256_state_to_sha512_c_state st0 st =\n  sha256_c_state_to_sha512_c_state st0 (sha256_state_to_sha256_c_state st)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ SHA256 specs in terms of the SHA512 C hash state.\n\nsha256_init_sha512_c_state : SHA512_c_state -> SHA512_c_state\nsha256_init_sha512_c_state st0_c_512 = st1_c_512\n  where\n    st0_256 = SHA256Init\n    st1_c_512 = sha256_state_to_sha512_c_state st0_c_512 st0_256\n\nsha256_update_sha512_c_state : {n} (fin n) => SHA512_c_state -> [n][8] -> SHA512_c_state\nsha256_update_sha512_c_state st0_c_512 in = st1_c_512\n  where\n    st0_256 = sha512_c_state_to_sha256_state st0_c_512\n    st1_256 = SHA256Update st0_256 in\n    st1_c_512 = sha256_state_to_sha512_c_state st0_c_512 st1_256\n\n\/\/ We don't return a new 'SHA512_c_state', since it's unspecified (I\n\/\/ think ...).\nsha256_digest_sha512_c_state : SHA512_c_state -> [SHA256_DIGEST_LENGTH][8]\nsha256_digest_sha512_c_state st0_c_512 = out1\n  where\n    st0_256 = sha512_c_state_to_sha256_state st0_c_512\n    out1 = split (SHA256Final st0_256)","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/HMAC_properties.cry","filetype":"cry","content":"module HMAC_properties where\n\nimport HMAC\nimport Hashing\nimport HMAC_iterative\n\n\/\/\/\/\/\/\/\/ Equivalence of implementations \/\/\/\/\/\/\/\/\n\/\/\n\/\/ This is specialized to SHA256, since we don't have concrete\n\/\/ implementations of the other algorithms.\nhmac_c_state : { key_size, msg_size }\n     ( 32 >= width msg_size, 64 >= width (8 * key_size) )\n  => HMAC_c_state -> [key_size][8] -> [msg_size][8] -> [SHA256_DIGEST_LENGTH * 8]\nhmac_c_state st0 key msg = digest\n  where\n  (st1, digest) =\n    hmac_digest_c_state `{block_size=64}\n      (hmac_update_c_state\n        (hmac_init_c_state `{block_size=64,hash_block_size=64,digest_size=SHA256_DIGEST_LENGTH}\n         st0 alg key)\n        msg)\n  \/\/ Specialize to SHA256.\n  alg = S2N_HMAC_SHA256\n\nhmac_c_state_correct : { key_size, msg_size }\n              ( 32 >= width msg_size, 64 >= width (8 * key_size) )\n           => HMAC_c_state -> [key_size][8] -> [msg_size][8] -> Bit\nproperty hmac_c_state_correct st0 key msg =\n  hmacSHA256 key msg == hmac_c_state st0 key msg\n\nhmac_c_state_multi : { key_size, msg_size, msg_chunks}\n     ( 32 >= width msg_size, 64 >= width (8 * key_size), fin msg_chunks )\n  => HMAC_c_state -> [key_size][8] -> [msg_chunks][msg_size][8] -> [SHA256_DIGEST_LENGTH * 8]\nhmac_c_state_multi st0 key msgs = digest\n  where\n    initial_state = (hmac_init_c_state `{block_size=64,hash_block_size=64,digest_size=SHA256_DIGEST_LENGTH}\n         st0 alg key)\n    mid_state = hmac_update_c_state_multi initial_state msgs\n    (st1, digest) = hmac_digest_c_state `{block_size=64} mid_state\n  \/\/ Specialize to SHA256.\n    alg = S2N_HMAC_SHA256\n\nhmac_update_c_state_multi : {msg_size, msg_chunks}\n  ( 32 >= width msg_size, fin msg_chunks)\n  => HMAC_c_state -> [msg_chunks][msg_size][8] -> HMAC_c_state\nhmac_update_c_state_multi st msgs = states ! 0\n  where\n    states = [st] # [hmac_update_c_state s msg | msg <- msgs | s <- states]\n\nhmac_c_state_multi_correct : { key_size, msg_size, msg_chunks }\n              ( 32 >= width msg_size\n              , 64 >= width (8 * key_size)\n              , fin msg_chunks\n              , 32 >= width (msg_chunks * msg_size)\n              , 64 >= width (8 * (64 + msg_size * msg_chunks))\n              )\n           => HMAC_c_state -> [key_size][8] -> [msg_chunks][msg_size][8] -> Bit\nproperty hmac_c_state_multi_correct st0 key msgs =\n    hmacSHA256 key (join msgs) == hmac_c_state_multi st0 key msgs\n\nhmac_update_append x y s =\n  hmac_update_c_state (hmac_update_c_state s x) y == hmac_update_c_state s (x # y)\n\nhash_update_append x y s =\n  hash_update_c_state (hash_update_c_state s x) y == hash_update_c_state s (x # y)\n\nhmac_update_append_init x y k st0 =\n    hmac_update_c_state (hmac_update_c_state s x) y == hmac_update_c_state s (x # y)\n    where\n      s = hmac_init_c_state st0 S2N_HMAC_SHA256 k\n\nproperty hash_update_empty s = hash_update_c_state s [] == s\n\nproperty hmac_update_empty s =\n  s.currently_in_hash_block == s.currently_in_hash_block % (zero # s.block_size)\n  ==>\n  hmac_update_c_state s [] == s\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/SHA256.cry","filetype":"cry","content":"module SHA256 where\n\n\/*\n * SHA256 Functions : Section 4.1.2\n *\/\n\nCh : [32] -> [32] -> [32] -> [32]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [32] -> [32] -> [32] -> [32]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nS0 : [32] -> [32]\nS0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nS1 : [32] -> [32]\nS1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\ns0 : [32] -> [32]\ns0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\ns1 : [32] -> [32]\ns1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n\n\/*\n * SHA256 Constants : Section 4.2.2\n *\/\n\nK : [64][32]\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n     ]\n\n\/*\n * Preprocessing (padding and parsing) for SHA256 : Section 5.1.1 and 5.2.1\n *\/\npreprocess : {msgLen,contentLen,chunks,padding}\n     ( fin msgLen\n     , 64 >= width msgLen                              \/\/ message width fits in a word\n     , contentLen == msgLen + 65                       \/\/ message + header\n     , chunks     == (contentLen+511) \/ 512\n     , padding    == (512 - contentLen % 512) % 512    \/\/ prettier if type #'s could be < 0\n     )\n     => [msgLen] -> [chunks][512]\npreprocess msg = split (msg # [True] # (zero:[padding]) # (`msgLen:[64]))\n\n\/*\n * SHA256 Initial Hash Value :  Section 5.3.3\n *\/\n\nH0 : [8][32]\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\n\/*\n * The SHA256 Hash computation : Section 6.2.2\n *\n * We have split the computation into a message scheduling function, corresponding\n * to step 1 in the documents loop, and a compression function, corresponding to steps 2-4.\n *\/\n\nSHA256MessageSchedule : [16][32] -> [64][32]\nSHA256MessageSchedule M = W where\n    W = M # [ s1 (W@(j-2)) + (W@(j-7)) + s0 (W@(j-15)) + (W@(j-16)) | j <- [16 .. 63]:[_][8] ]\n\n\n\nSHA256Compress : [8][32] -> [64][32] -> [8][32]\nSHA256Compress H W = [as!0 + H@0, bs!0 + H@1, cs!0 + H@2, ds!0 + H@3, es!0 + H@4, fs!0 + H@5, gs!0 + H@6, hs!0 + H@7] where\n    T1 = [h + S1 e + Ch e f g  + k + w | h <- hs | e <- es | f <- fs | g <- gs | k <- K | w <- W]\n    T2 = [S0 a  + Maj a b c  | a <- as | b <- bs | c <- cs]\n    hs = take `{65} ([H@7] # gs)\n    gs = take `{65} ([H@6] # fs)\n    fs = take `{65} ([H@5] # es)\n    es = take `{65} ([H@4] # [d + t1 | d <- ds | t1 <- T1])\n    ds = take `{65} ([H@3] # cs)\n    cs = take `{65} ([H@2] # bs)\n    bs = take `{65} ([H@1] # as)\n    as = take `{65} ([H@0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\nSHA256Block : [8][32] -> [16][32] -> [8][32]\nSHA256Block H M = SHA256Compress H (SHA256MessageSchedule M)\n\n\/*\n * The SHA256' function hashes a preprocessed sequence of blocks with the\n * compression function.  The SHA256 function hashes a sequence of bytes, and\n * is more likely the function that will be similar to those seein in an\n * implementation to be verified.\n *\/\n\nSHA256' : {a} (fin a) => [a][16][32] -> [8][32]\nSHA256' blocks = hash!0 where\n    hash = [H0] # [SHA256Block h b | h <- hash | b <- blocks]\n\nSHA256 : {a} (fin a, 64 >= width (8*a)) => [a][8] -> [256]\nSHA256 msg =   join (SHA256' [ split x | x <- preprocess(join msg)])\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- kats ]\n\nkats = [ (SHA256 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n         , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n       , (SHA256 \"\"\n         ,0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n       , (SHA256 \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n         , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n       \/\/ , ([0x61 | i <- [1..1000000] : [_][32]]\n       \/\/   , 0xcdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0)\n       ]\n\n\/\/\/\/\/\/\/\/ Imperative top level \/\/\/\/\/\/\/\/\n\ntype SHA256State = { h : [8][32]\n                   , block : [64][8]\n                   , n : [16]\n                   , sz : [64]\n                   }\n\nSHA256Init : SHA256State\nSHA256Init = { h = H0\n             , block = zero\n             , n = 0\n             , sz = 0\n             }\n\nSHA256Update1 : SHA256State -> [8] -> SHA256State\nSHA256Update1 s b =\n  if s.n == 64\n    then { h = SHA256Block s.h (split (join s.block))\n         , block = [b] # zero\n         , n = 1\n         , sz = s.sz + 8\n         }\n    else { h = s.h\n         , block = update s.block s.n b\n         , n = s.n + 1\n         , sz = s.sz + 8\n         }\n\nSHA256Update : {n} (fin n) => SHA256State -> [n][8] -> SHA256State\nSHA256Update sinit bs = ss!0\n  where ss = [sinit] # [ SHA256Update1 s b | s <- ss | b <- bs ]\n\n\/\/ Add padding and size and process the final block.\nSHA256Final : SHA256State -> [256]\nSHA256Final s = join (SHA256Block h b')\n  \/\/ Because the message is always made up of bytes, and the size is a\n  \/\/ fixed number of bytes, the 1 pad will always be at least a byte.\n  where s' = SHA256Update1 s 0x80\n        \/\/ Don't need to add zeros. They're already there. Just update\n        \/\/ the count of bytes in this block. After adding the 1 pad, there\n        \/\/ are two possible cases: the size will fit in the current block,\n        \/\/ or it won't.\n        (h, b) = if s'.n <= 56 then (s'.h, s'.block)\n                 else (SHA256Block s'.h (split (join s'.block)), zero)\n        b' = split (join b || (zero # s.sz))\n\nSHA256Imp : {a} (64 >= width (8*a)) => [a][8] -> [256]\nSHA256Imp msg = SHA256Final (SHA256Update SHA256Init msg)\n\nproperty katsPassImp = ~zero == [test == kat | (test,kat) <- katsImp ]\n\nkatsImp = [ (SHA256Imp \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n            , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n          , (SHA256Imp \"\"\n            , 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n          , (SHA256Imp \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n            , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n          \/\/ , ([0x61 | i <- [1..1000000] : [_][32]]\n          \/\/   , 0xcdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0)\n          ]\n\nproperty imp_correct msg = SHA256 msg == SHA256Imp msg\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/modthm.cry","filetype":"cry","content":"valid_block_sizes : [16] -> [16] -> Bit\nvalid_block_sizes hbs bs =\n  \/\/ We're not handling SSLv3 yet.\n  \/\/((bs, hbs) == (40, 64)) ||\n  \/\/((bs, hbs) == (48, 64)) ||\n  ((bs, hbs) == (64, 64)) ||\n  ((bs, hbs) == (128, 128))\n\nmodthm : [32] -> [32] -> [32] -> [16] -> [16] -> Bit\nmodthm x11 x15 x16 hash_block_size block_size =\n  ((((x11 + (x16 % x17)) % x18) + (x15 % x17)) % x18)\n  ==\n  ((x11 + ((x16 + x15) % x17)) % x18)\n  where x17 = zero # hash_block_size\n        x18 = zero # block_size\n\nmodthm_precond : [32] -> [32] -> [32] -> [16] -> [16] -> Bit\nmodthm_precond x11 x15 x16 hash_block_size block_size =\n  if (valid_block_sizes hash_block_size block_size) then\n    modthm x11 x15 x16 hash_block_size block_size\n  else True\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/HMAC_iterative.cry","filetype":"cry","content":"module HMAC_iterative where\n\nimport Array\nimport SHA256\nimport Hashing\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ HMAC (specialized to SHA256).\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nS2N_HMAC_NONE       = 0:[32]\nS2N_HMAC_MD5        = 1:[32]\nS2N_HMAC_SHA1       = 2:[32]\nS2N_HMAC_SHA224     = 3:[32]\nS2N_HMAC_SHA256     = 4:[32]\nS2N_HMAC_SHA384     = 5:[32]\nS2N_HMAC_SHA512     = 6:[32]\nS2N_HMAC_SSLv3_MD5  = 7:[32]\nS2N_HMAC_SSLv3_SHA1 = 8:[32]\n\n    uint8_t xor_pad[128];\n\n    \/* For storing the inner digest *\/\n    uint8_t digest_pad[SHA512_DIGEST_LENGTH];\n};\n*\/\ntype HMAC_c_state =\n  { alg                     : [32]\n  , hash_block_size         : [16]\n  , currently_in_hash_block : [32]\n  , block_size              : [16]\n  , digest_size             : [8]\n  , inner                   : SHA512_c_state\n  , inner_just_key          : SHA512_c_state\n  , outer                   : SHA512_c_state\n  , outer_just_key          : SHA512_c_state\n  , xor_pad                 : [128][8]\n  , digest_pad              : [SHA512_DIGEST_LENGTH][8]\n  }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Deep HMAC specs in terms of C HMAC state.\n\/\/\n\/\/ Here \"deep\" because we reimplement the HMAC functions to call the\n\/\/ corresponding hash functions on the raw C hash states, instead of\n\/\/ converting them to Cryptol SHA256 hash states.\n\ntype ByteArray = Array[64][8]\n\ntype hash_init_ty =\n  SHA512_c_state -> SHA512_c_state\ntype hash_update_ty msg_size =\n  SHA512_c_state -> [msg_size][8] -> SHA512_c_state\ntype hash_digest_ty digest_size =\n  SHA512_c_state -> [digest_size][8]\n\nhash_init_c_state : hash_init_ty\nhash_init_c_state = sha256_init_sha512_c_state\n\/\/ Cryptol does not support polymorphic arguments (rank 2\n\/\/ polymorphism), so making the hash update function a parameter to\n\/\/ the hmac functions is annoying, since we must pass a separate\n\/\/ monomorphic copy for each use at a different type. Instead, we just\n\/\/ define it at the top level, but can leave it uninterpreted in the\n\/\/ \"generic\" verification.\nhash_update_c_state :\n  {msg_size} (fin msg_size) => hash_update_ty msg_size\nhash_update_c_state = sha256_update_sha512_c_state\nhash_update_c_state_unbounded :\n  SHA512_c_state -> ByteArray -> [32] -> SHA512_c_state\nhash_update_c_state_unbounded = undefined\n\n\nhash_digest_c_state :\n  {digest_size} (fin digest_size) => hash_digest_ty digest_size\n\/\/ To support any digest length, we pad and truncate as necessary.\n\/\/ This implementation only makes sense for SHA256 size params, but\n\/\/ that is not a concern since we leave these functions uninterpreted\n\/\/ in the verification against the S2N C code (we want a concrete\n\/\/ implementation for debugging and to compare with our functional spec).\nhash_digest_c_state st =\n  take `{digest_size}\n    (sha256_digest_sha512_c_state st # (zero : [inf][8]))\n\/\/ Cases depending on key size:\n\/\/\n\/\/ * small key (key size <= block size)\n\/\/\n\/\/   copy key into 'xor_pad', up to key size\n\/\/\n\/\/ * large key (key size > block size)\n\/\/\n\/\/   update outer state with key to key size\n\/\/   digest outer state into digest pad at digest size\n\/\/\n\/\/ The C code that follows the key init sets all remaining bytes,\n\/\/ up to block size, to 0x36, and xors the other bytes with 0x36.\n\/\/ This is equivalent to setting upper bytes (i.e. up to block size)\n\/\/ to zero in key init, and then xoring everything with 0x36.\n\/\/\n\/\/ We don't care about 'xor_pad' and 'outer', so we should be able to\n\/\/ just ignore them. But for now we just compute them anyway.\nkey_init_c_state : { key_size, block_size, digest_size }\n        ( fin key_size, fin block_size,\n          SHA512_DIGEST_LENGTH >= digest_size )\n     => SHA512_c_state\n     -> [SHA512_DIGEST_LENGTH][8]\n     -> [key_size][8]\n     -> (SHA512_c_state, [SHA512_DIGEST_LENGTH][8], [block_size][8])\nkey_init_c_state outer0 digest_pad0 key =\n  if `key_size > (`block_size : [max (width key_size) (width block_size)])\n  then (outer2, digest_pad1, hash')\n  else (outer1, digest_pad0, key')\n  where\n  outer1 = hash_init_c_state outer0\n\n  \/\/ Long key.\n  outer2 = hash_update_c_state outer1 key\n  hash : [digest_size][8]\n  hash = hash_digest_c_state outer2\n  digest_pad1 = hash # drop `{digest_size} digest_pad0\n  hash' = take `{block_size} (hash # (zero : [block_size][8]))\n\n  \/\/ Short key.\n  key' = take `{block_size} (key # (zero : [block_size][8]))\n\nkey_init_c_state_unbounded : { block_size, digest_size }\n        ( 16 >= width block_size, SHA512_DIGEST_LENGTH >= digest_size )\n     => SHA512_c_state\n     -> [SHA512_DIGEST_LENGTH][8]\n     -> ByteArray\n     -> [32]\n     -> (SHA512_c_state, [SHA512_DIGEST_LENGTH][8], [block_size][8])\nkey_init_c_state_unbounded outer0 digest_pad0 key klen =\n  if klen > (`block_size : [32])\n  then (outer2, digest_pad1, hash')\n  else (outer1, digest_pad0, key')\n  where\n  outer1 = hash_init_c_state outer0\n\n  \/\/ Long key.\n  outer2 = hash_update_c_state_unbounded outer1 key klen\n  hash : [digest_size][8]\n  hash = hash_digest_c_state outer2\n  digest_pad1 = hash # drop `{digest_size} digest_pad0\n  hash' = take `{block_size} (hash # (zero : [block_size][8]))\n\n  \/\/ Short key.\n  key' = map\n    (\\i -> if (i <$ (0 # klen)) then (arrayLookup key i) else 0)\n    (take`{block_size} [0 .. block_size])\n\nhmac_init_c_state :\n     { key_size, block_size, hash_block_size, digest_size }\n     ( fin key_size\n     , 64 >= width (8*key_size)\n     , 16 >= width hash_block_size\n     , 16 >= width block_size\n     , 8 >= width digest_size\n     , 128 >= block_size\n     , 64 >= digest_size )\n  => HMAC_c_state\n  -> [32]\n  -> [key_size][8]\n  -> HMAC_c_state\nhmac_init_c_state st0 alg key =\n  { alg                     = alg\n  , hash_block_size         = `hash_block_size\n  , currently_in_hash_block = currently_in_hash_block\n  , block_size              = `block_size\n  , digest_size             = `digest_size\n\n  , inner                   = inner\n  , inner_just_key          = inner_just_key\n  , outer                   = outer\n  , outer_just_key          = outer_just_key\n  , xor_pad                 = xor_pad\n  , digest_pad              = digest_pad\n  }\n  where\n    currently_in_hash_block = 0\n\n    k0 : [block_size][8]\n    (outer, digest_pad, k0) =\n      key_init_c_state `{digest_size=digest_size} st0.outer st0.digest_pad key\n    ikey = [ k ^ 0x36 | k <- k0 ]\n    okey = [ k ^ 0x6a | k <- ikey ]\n\n    inner_just_key = hash_update_c_state\n      (hash_init_c_state st0.inner_just_key) ikey\n    inner          = inner_just_key\n    outer_just_key = hash_update_c_state\n      (hash_init_c_state st0.outer_just_key) okey\n    xor_pad = zero hmac_init_c_state_unbounded :\n     { block_size, hash_block_size, digest_size }\n     ( 16 >= width hash_block_size\n     , 16 >= width block_size\n     , 8 >= width digest_size\n     , 128 >= block_size\n     , 64 >= digest_size )\n  => HMAC_c_state\n  -> [32]\n  -> ByteArray\n  -> [32]\n  -> HMAC_c_state\nhmac_init_c_state_unbounded st0 alg key klen =\n  { alg                     = alg\n  , hash_block_size         = `hash_block_size\n  , currently_in_hash_block = currently_in_hash_block\n  , block_size              = `block_size\n  , digest_size             = `digest_size\n\n  , inner                   = inner\n  , inner_just_key          = inner_just_key\n  , outer                   = outer\n  , outer_just_key          = outer_just_key\n  , xor_pad                 = xor_pad\n  , digest_pad              = digest_pad\n  }\n  where\n    currently_in_hash_block = 0\n\n    k0 : [block_size][8]\n    (outer, digest_pad, k0) =\n      key_init_c_state_unbounded `{digest_size=digest_size}\n        st0.outer st0.digest_pad key klen\n    ikey = [ k ^ 0x36 | k <- k0 ]\n    okey = [ k ^ 0x6a | k <- ikey ]\n\n    inner_just_key = hash_update_c_state\n      (hash_init_c_state st0.inner_just_key) ikey\n    inner          = inner_just_key\n    outer_just_key = hash_update_c_state\n      (hash_init_c_state st0.outer_just_key) okey\n    xor_pad = zero hmac_update_c_state : {msg_size} (32 >= width msg_size) =>\n  HMAC_c_state -> [msg_size][8] -> HMAC_c_state\nhmac_update_c_state s m =\n  { inner = hash_update_c_state s.inner m\n  , currently_in_hash_block =\n      (s.currently_in_hash_block + (`msg_size % (zero # s.hash_block_size))) %\n      (zero # s.block_size)\n\n    , alg             = s.alg\n  , hash_block_size = s.hash_block_size\n  , block_size      = s.block_size\n  , digest_size     = s.digest_size\n  , inner_just_key  = s.inner_just_key\n  , outer           = s.outer\n  , outer_just_key  = s.outer_just_key\n  , xor_pad         = s.xor_pad\n  , digest_pad      = s.digest_pad\n  }\n\nhmac_update_c_state_unbounded :\n  HMAC_c_state -> ByteArray -> [32] -> HMAC_c_state\nhmac_update_c_state_unbounded s m sz =\n  { inner = hash_update_c_state_unbounded s.inner m sz\n  , currently_in_hash_block =\n      (s.currently_in_hash_block + (sz % (zero # s.hash_block_size))) %\n      (zero # s.block_size)\n\n    , alg             = s.alg\n  , hash_block_size = s.hash_block_size\n  , block_size      = s.block_size\n  , digest_size     = s.digest_size\n  , inner_just_key  = s.inner_just_key\n  , outer           = s.outer\n  , outer_just_key  = s.outer_just_key\n  , xor_pad         = s.xor_pad\n  , digest_pad      = s.digest_pad\n  }\n\n\n\/\/ TODO: What about `size` argument to `s2n_hmac_digest`? The `size`\n\/\/ argument is supposed to be the \"digest length\" of the underlying\n\/\/ hash. Here we are specializing to SHA256, so `size` would be 32.\nhmac_digest_c_state :\n     { block_size, digest_size }\n     ( 64 >= digest_size\n     , 128 >= block_size )\n  => HMAC_c_state -> (HMAC_c_state, [8 * digest_size])\nhmac_digest_c_state s = (sout, out)\n  where\n    hin : [digest_size][8]\n    hin = hash_digest_c_state inner\n    digest_pad : [SHA512_DIGEST_LENGTH][8]\n    digest_pad = hin # zero\n\n    okey : [block_size][8]\n    okey = take s.xor_pad\n\n    \/\/ The `inner` and `outer` here are probably not accurate:\n    \/\/ in s2n, the `s2n_hash_digest` has been called on them, which\n    \/\/ presumably can change them (calls `SHA256_Final` from\n    \/\/ underlying C crypto lib behind the scenes). However, our\n    \/\/ Cryptol `SHA256Final` does not change the hash state. Even\n    \/\/ if we leave the hash function uninterpreted later, we will\n    \/\/ still need to change the interface of our Cryptol `<hash>Final`\n    \/\/ to additionally return an updated `<hash>State`.\n    \/\/\n    \/\/ However, we probably don't need to say anything about the\n    \/\/ *hash* state after calls to \"final\" functions, since\n    \/\/ 's2n_hash_reset' just calls 's2n_hash_init'. So, the above\n    \/\/ concern is not much of a concern after all.\n\n    \/\/ Our goal is to leave the hash functions (init, update,\n    \/\/ digest\/final) uninterpreted, and so we need the structure of\n    \/\/ our calls to these functions to match the structure of calls in\n    \/\/ the s2n code, since we don't have lemmas giving algebraic\n    \/\/ properties of these functions (e.g. here we'd need\n    \/\/\n    \/\/   update (update st x) y == update st (x # y)\n    \/\/\n    \/\/ ). So, we replace\n    \/\/\n    \/\/outer = SHA256Update SHA256Init (okey # hin)\n    \/\/\n    \/\/ with:\n    outer = hash_update_c_state s.outer_just_key hin\n    inner = s.inner\n\n    out = join (hash_digest_c_state outer)\n\n    sout : HMAC_c_state\n    sout =\n      { inner      = inner\n      , outer      = s.outer_just_key\n      , digest_pad = digest_pad\n\n            , alg                     = s.alg\n      , hash_block_size         = s.hash_block_size\n      , currently_in_hash_block = s.currently_in_hash_block\n      , block_size              = s.block_size\n      , digest_size             = s.digest_size\n      , inner_just_key          = s.inner_just_key\n      , outer_just_key          = s.outer_just_key\n      , xor_pad                 = s.xor_pad\n      }","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/sha512\/SHA.cry","filetype":"cry","content":"module SHA where\n\nsha : {L} (2 * w >= width L) => [L] -> [digest_size]\nsha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))\n\nparameter\n\n  \/** Word size\n    Specifications are based on word size w, rather than digest size (8 * w)\n    or block size (m == 16 * w), in order to avoid confusing Cryptol's type\n    constraint verifier with integer division.\n  *\/\n\n  type w : #\n  type constraint (fin w, w >= 2, 32 >= width w)\n\n  type digest_size : #\n  type constraint (fin digest_size, 8*w >= digest_size)\n\n  \/** The number of iterations in the hash computation\n  (i.e. the number of words in K) *\/\n\n  type j : #\n  type constraint (fin j, j >= 17)\n\n  H0 : [8][w]\n  K  : [j][w]\n\n  \/* FIPS 180-4 defines lowercase and uppercase\n      (respective to the Greek alphabet) sigma functions for SHA-256 and SHA-512.\n      (4.4)-(4.7) SHA-224, SHA-256 (w==32)\n      (4.10)-(4.13) SHA-384, SHA-512, SHA-512\/224, SHA-512\/256 (w==64) *\/\n\n  SIGMA_0 : [w] -> [w]\n  SIGMA_1 : [w] -> [w]\n  sigma_0 : [w] -> [w]\n  sigma_1 : [w] -> [w]\n\n\/\/ Export some of the parameters\nSHAH0 = H0\nS0 = SIGMA_0\nS1 = SIGMA_1\ns0 = sigma_0\ns1 = sigma_1\n\n\/\/ Export Ch, Maj and the block function to be used in SAW proofs\n\/** (4.1) (w==32), (4.2) (w==32), (4.8) (w==64) *\/\nCh : [w] -> [w] -> [w] -> [w]\nCh x y z = (x && y) ^ (~x && z)\n\n\n\/** (4.1) (w==32), (4.3) (w==32), (4.9) (w==64) *\/\nMaj : [w] -> [w] -> [w] -> [w]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nprocessBlock_Common : [8][w] -> [16][w] -> [8][w]\nprocessBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)\n\n\nprivate\n\n  \/** block size corresponding to word size for all SHA algorithms in\n      FIPS 180-4 *\/\n  type block_size = 16 * w\n\n  type num_blocks L     = (L+1+2*w) \/^ block_size\n  type padded_size L    = num_blocks L * block_size\n\n\n  \/**\n    5.1 Padding the Message\n    5.1.1 SHA-1, SHA-224 and SHA-256 (w==32)\n    5.1.2 SHA-384, SHA-512, SHA-512\/224 and SHA-512\/256 (w==64)\n\n  The constraint ensure that the message size, `L`, fits within a\n  (2 * w)-bit word (consistent w\/ Figure 1)\n  *\/\n  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]\n  pad M = M # 0b1 # zero # (`L : [2*w])\n\n  \/**\n    5.2 Parsing the Message\n    5.2.1 SHA-1, SHA-224 and SHA-256 (w==32)\n    5.2.2 SHA-384, SHA-512, SHA-512\/224 and SHA-512\/256 (w==64)\n  *\/\n  parse : {m} [m * block_size] -> [m][block_size]\n  parse = split\n\n  \/**\n  SHA-256 and SHA-512 (and their respective derivatives) use a similar\n  message schedule that can be expressed in the same way relative to their\n  respective sigma functions.\n\n    6.2.2 SHA-256 Hash Computation (w==32, j=64)\n    6.4.2 SHA-512 Hash Computation (w==64, j=80)\n  *\/\n  messageSchedule_Common : [16][w] -> [j][w]\n  messageSchedule_Common Mi = take W\n    where\n    W : [inf][_]\n    W = Mi # [ w1 + s0 w2 + w3 + s1 w4\n             | w1 <- W\n             | w2 <- drop`{1} W\n             | w3 <- drop`{9} W\n             | w4 <- drop`{14} W\n             ]\n\n\n  \/**\n  Amazon S2N's SHA-256 specification includes a compression routine intended\n  to reflect typical implementations.  This same compression routine applies\n  to SHA-512, modulo respective constants, sigma functions,\n  and message schedules.\n  *\/\n\n  compress_Common : [8][w] -> [j][w] -> [8][w]\n  compress_Common H W =\n        [ (as ! 0) + (H @ 0),\n      (bs ! 0) + (H @ 1),\n      (cs ! 0) + (H @ 2),\n      (ds ! 0) + (H @ 3),\n      (es ! 0) + (H @ 4),\n      (fs ! 0) + (H @ 5),\n      (gs ! 0) + (H @ 6),\n      (hs ! 0) + (H @ 7)\n    ]\n    where\n      T1 = [h + S1 e + Ch e f g + k_t + w_t\n                | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]\n      T2 = [ S0 a + Maj a b c | a <- as | b <- bs | c <- cs]\n      hs = take`{j + 1}([H @ 7] # gs)\n      gs = take`{j + 1}([H @ 6] # fs)\n      fs = take`{j + 1}([H @ 5] # es)\n      es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])\n      ds = take`{j + 1}([H @ 3] # cs)\n      cs = take`{j + 1}([H @ 2] # bs)\n      bs = take`{j + 1}([H @ 1] # as)\n      as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n\n  SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]\n  SHA_2_Common' blocks = hash ! 0\n    where\n    hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ SHA imperative specification\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/*\n * This section contains an SHA specification that more closely matches the\n * BoringSSL C implementation to simplify SAW correctness proofs of the\n * implementation.\n *\/\n\n\/\/\/\/\/\/\/\/ Imperative top level \/\/\/\/\/\/\/\/\n\ntype SHAState = { h : [8][w]\n                , block : [w * 2][8]\n                , n : [32]\n                , sz : [w * 2]\n                }\n\n\/\/ Initial state for SHA\nSHAInit : SHAState\nSHAInit = { h = H0\n          , block = zero\n          , n = 0\n          , sz = 0\n          }\n\n\/\/ Process message being hashed, iteratively updating the SHA state with the\n\/\/ input message.\nSHAUpdate : {n} (fin n) => SHAState -> [n][8] -> SHAState\nSHAUpdate sinit bs = ss!0\n  where ss = [sinit] # [ SHAUpdate1 s b | s <- ss | b <- bs ]\n\n\/\/ Add padding and size and process the final block.\nSHAFinal : SHAState -> [digest_size]\nSHAFinal s = take (join (processBlock_Common h b'))\n  \/\/ Because the message is always made up of bytes, and the size is a\n  \/\/ fixed number of bytes, the 1 pad will always be at least a byte.\n  where s' = SHAUpdate1 s 0x80\n        \/\/ Don't need to add zeros. They're already there. Just update\n        \/\/ the count of bytes in this block. After adding the 1 pad, there\n        \/\/ are two possible cases: the size will fit in the current block,\n        \/\/ or it won't.\n        (h, b) = if s'.n <= (`w*2 - (`w\/4)) then (s'.h, s'.block)\n                 else (processBlock_Common s'.h (split (join s'.block)), zero)\n        b' = split (join b || (zero # s.sz))\n\n\/\/ Imperative SHA implementation\nSHAImp : {n} (fin n) => [n][8] -> [digest_size]\nSHAImp msg = SHAFinal (SHAUpdate SHAInit msg)\n\n\nprivate\n\n  \/\/ SHAUpdate1 updates a single byte at position s.n in s.block and return a\n  \/\/ new state to pass to subsequent updates.  If s.n is 128, updates position 0\n  \/\/ to b and zeros the remainder of the block, setting s.n to 1 for the next\n  \/\/ update.\n  SHAUpdate1 : SHAState -> [8] -> SHAState\n  SHAUpdate1 s b =\n    if s.n == (2 * `w - 1)\n      then { h = processBlock_Common s.h (split (join (update s.block s.n b)))\n           , block = zero\n           , n = 0\n           , sz = s.sz + 8\n           }\n      else { h = s.h\n           , block = update s.block s.n b\n           , n = s.n + 1\n           , sz = s.sz + 8\n           }\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/sha512\/solution.saw","filetype":"saw","content":"import \"SHA512.cry\";\n\ninclude \"..\/common\/helpers.saw\";\n\n\n\/\/ Load LLVM bytecode\nm <- llvm_load_module \"sha512.bc\";\n\n\n\/*\n * SHA512 defines\n *\/\n\/\/ Size of a block in bytes\nlet SHA512_CBLOCK = 128;\n\n\/\/ Length of message digest in bytes\nlet SHA512_DIGEST_LENGTH = 64;\n\n\/\/ Size of the SHA512 context struct\nlet SHA512_CTX_SIZE = llvm_sizeof m (llvm_alias \"struct.sha512_state_st\");\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Specifications\n\n\/*\n * This section of the SAW script contains specifications of the functions that\n * SAW will verify.  Each specification can be broken down into 3 components:\n * preconditions, a function call description, and postconditions.\n *\n * A precondition is a predicate that must be true prior to the application of\n * a function for the specification's postcondition to hold.  Preconditions are\n * typically restrictions on function inputs or global state.  For example, a\n * function that returns the first element of an array might have a\n * precondition that the array is not empty.  A specification makes no\n * guarantees about how the function acts when the precondition is violated.\n * In a SAW specification, preconditions are the statements that come before a\n * function call description.  If a function has no preconditions we say that\n * the precondition is \"true\", meaning that the postcondition holds for all\n * possible inputs and program states.\n *\n * A function call description tells SAW how to call the function being\n * specified.  It has the form:\n *     llvm_execute_func [<list of arguments>]\n * These arguments are typically from the preconditions, specification inputs,\n * global variables, and literals.  SAW does not actually execute the function,\n * but rather uses symbolic execution to examine all possible executions\n * through the function, subject to precondition constraints.  For example,\n * if a precondition states that a variable `sha_ptr` is a pointer to an\n * `sha512_state_st` struct:\n *     ctx_ptr <- llvm_alloc (llvm_alias \"struct.sha512_state_st\");\n * And the function call description takes `sha_ptr` as an input:\n *     llvm_execute_func [sha_ptr];\n * Then SAW will reason about the function over all possible `sha512_state_st`\n * structs.  We call `sha_ptr` a symbol because SAW does not evaluate it, but\n * rather treats it as the set of all possible `sha512_state_st` structs.\n *\n * A postcondition is a predicate that must be true following the application\n * of a function, assuming the function's precondition held.  From a logic\n * perspective, you can think of this as:\n *     (<conjunction of preconditions> \/\\ <function application>) ->\n *     <conjunction of postconditions>\n * where \"\/\\\" is logical AND and \"->\" is logical implication.  If a SAW proof\n * succeeds, then SAW guarantees that the postconditions hold following function\n * application, so long as the function's preconditions held just prior to the\n * function's application.  In a SAW specification, postconditions are the\n * statements that come after a function call description.  If a function has\n * no postconditions, then we say that the postcondition is \"true\", meaning\n * that the specification makes no guarantees about the function's behavior.\n *\/\n\n\/*\n * Specifications of functions Sigma0, Sigma1, sigma0, sigma1, and Ch\n *\/\nlet Sigma0_spec = do {\n  x <- llvm_fresh_var \"x\" i64;\n  llvm_execute_func [llvm_term x];\n  llvm_return (llvm_term {{ S0 x }});\n};\n\nlet Sigma1_spec = do {\n  x <- llvm_fresh_var \"x\" i64;\n  llvm_execute_func [llvm_term x];\n  llvm_return (llvm_term {{ S1 x }});\n};\n\nlet sigma0_spec = do {\n  x <- llvm_fresh_var \"x\" i64;\n  llvm_execute_func [llvm_term x];\n  llvm_return (llvm_term {{ s0 x }});\n};\n\nlet sigma1_spec = do {\n  x <- llvm_fresh_var \"x\" i64;\n  llvm_execute_func [llvm_term x];\n  llvm_return (llvm_term {{ s1 x }});\n};\n\nlet Ch_spec = do {\n  x <- llvm_fresh_var \"x\" i64;\n  y <- llvm_fresh_var \"y\" i64;\n  z <- llvm_fresh_var \"z\" i64;\n  llvm_execute_func [llvm_term x, llvm_term y, llvm_term z];\n  llvm_return (llvm_term {{ Ch x y z }});\n};\n\n\/*\n * Specification of block function for SHA512\n *\/\nlet sha512_block_data_order_spec = do {\n  \/\/ Precondition: `state_ptr` points to an array of 8 64 bit integers\n  (state, state_ptr) <- ptr_to_fresh \"state\" (llvm_array 8 i64);\n\n  \/\/ Precondition: `data_ptr` points to a const message block\n  (data, data_ptr) <- ptr_to_fresh_readonly \"data\" (llvm_array SHA512_CBLOCK i8);\n\n  \/\/ Call function with `state_ptr`, `data_ptr`, and the value `1`\n  llvm_execute_func [state_ptr, data_ptr, llvm_term {{ 1 : [64] }}];\n\n  \/\/ Postcondition: The data pointed to by `state_ptr` is equivalent to the\n  \/\/ return value of the processBlock_Common Cryptol spec function applied to `state`\n  \/\/ and `data`.\n  llvm_points_to state_ptr (llvm_term {{ processBlock_Common state (split (join data)) }});\n};\n\n\n\/*\n * Helpers for specifying the SHA512 structs\n *\/\n\/*\n * The next functions all specify structs used in the C SHA implementation.\n * Most of the statements in these are of the form:\n *    llvm_points_to (llvm_field ptr \"name\") (llvm_term {{ term }})\n * which indicates that the field `name` of the struct pointed to by `ptr`\n * contains the value `term`.\n * All statements that do not match these two forms are documented inline\n *\/\n\n\/\/ Specify the sha512_state_st struct from a SHAState\nlet points_to_sha512_state_st_common ptr (h, sz, block, n) num = do {\n  llvm_points_to (llvm_field ptr \"h\") (llvm_term h);\n\n  \/\/ Specify `sha512_state_st.Nl` and `sha512_state_st.Nh` contain `sz`\n  llvm_points_to_at_type (llvm_field ptr \"Nl\") i128 (llvm_term sz);\n\n  if eval_bool {{ `num == 0 }} then do {\n    \/\/ Do not specify anything about `sha512_state_st.p`\n    return ();\n  } else do {\n    \/\/ Specify that the first `num` bytes of `sha512_state_st.p` match the\n    \/\/ first `num` bits of `state.block`.\n    \/\/ Untyped check because the size of `sha512_state_st.p` does not match\n    \/\/ the size of (take`{num} state.block) unless `num` == `SHA512_CBLOCK`\n    llvm_points_to_untyped (llvm_field ptr \"p\") (llvm_term block);\n  };\n\n  llvm_points_to (llvm_field ptr \"num\") (llvm_term n);\n  llvm_points_to (llvm_field ptr \"md_len\") (llvm_term {{ `SHA512_DIGEST_LENGTH : [32] }});\n};\n\nlet pointer_to_fresh_sha512_state_st name n = do {\n  \/\/ Hash value\n  h <- llvm_fresh_var (str_concat name \".h\") (llvm_array 8 i64);\n  \/\/ Message block\n  block <- if eval_bool {{ `n == 0 }} then do {\n    \/\/ Do not specify anything about `sha512_state_st.p`\n    return {{ [] : [0][8] }};\n  } else do {\n    llvm_fresh_var (str_concat name \".block\") (llvm_array n i8);\n  };\n  \/\/ Size\n  sz <- llvm_fresh_var (str_concat name \".sz\") i128;\n  \/\/ Build SHAState, padding `block` with zeros to fit\n  let state = {{ { h = h, block = (block # zero) : [SHA512_CBLOCK][8], n = `n : [32], sz = sz } }};\n\n  \/\/ `ptr` is a pointer to a `sha512_state_st` struct\n  ptr <- llvm_alloc (llvm_alias \"struct.sha512_state_st\");\n  points_to_sha512_state_st_common ptr (h, sz, block, {{ `n : [32]}}) n;\n\n  return (state, ptr);\n};\n\n\/\/ Specify the sha512_state_st struct from a SHAState\nlet points_to_sha512_state_st ptr state num = do {\n points_to_sha512_state_st_common\n   ptr\n   ({{ state.h }}, {{ state.sz }}, {{ take`{num} state.block }}, {{ state.n }}) num;\n};\n\n\n\/*\n * Specifications of SHA512_Init, SHA512_Update, SHA512_Final,\n * and SHA512.\n *\/\nlet SHA512_Init_spec = do {\n  \/\/ Precondition: `sha_ptr` is a pointer to a `sha512_state_st` struct\n  sha_ptr <- llvm_alloc (llvm_alias \"struct.sha512_state_st\");\n\n  \/\/ Call function with `sha_ptr`\n  llvm_execute_func [sha_ptr];\n\n  \/\/ Postcondition: `sha_ptr` holds an initialized SHA512 context\n  points_to_sha512_state_st\n    sha_ptr\n    {{ { h = SHAH0, block = zero : [SHA512_CBLOCK][8], n = 0 : [32], sz = 0 : [128] } }}\n    0;\n\n  \/\/ Postcondition: The function returns 1\n  llvm_return (llvm_term {{ 1 : [32] }});\n};\n\nlet SHA512_Update_spec num len = do {\n  \/\/ Precondition: `sha_ptr` is a pointer to a `sha512_state_st` struct\n  \/\/ Precondition: `sha512_ctx` is a fresh Cryptol SHAState\n  \/\/ Precondition: `sha_ptr` matches `sha512_ctx`.  The message blocks\n  \/\/ of the two must only match up to the first `num` bits.\n  (sha512_ctx, sha_ptr) <- pointer_to_fresh_sha512_state_st \"sha512_ctx\" num;\n\n  \/\/ Precondition: `data` is a fresh array of `len` bytes, and `data_ptr`\n  \/\/ points to `data`.\n  (data, data_ptr) <- ptr_to_fresh_readonly \"data\" (llvm_array len i8);\n\n  \/\/ Call function with `sha_ptr`, `data_ptr`, and `len` as arguments.\n  llvm_execute_func [sha_ptr, data_ptr, llvm_term {{ `len : [64] }}];\n\n  \/\/ Postcondition: The context `sha_ptr` points to matches the result\n  \/\/ of executing the cryptol function `SHAUpdate` on `sha512_ctx` and\n  \/\/ `data`, with the exception of the message block, which must only match up\n  \/\/ to the first `(num + len) % SHA512_CBLOCK` bytes.  This is because the\n  \/\/ C implementation does not clear the unused bytes of message block, and\n  \/\/ therefore the tail end of the block contains garbage.\n  points_to_sha512_state_st\n    sha_ptr\n    {{ SHAUpdate sha512_ctx data }} (eval_size {| (num + len) % SHA512_CBLOCK |});\n\n  \/\/ Postcondition: The function returns 1\n  llvm_return (llvm_term {{ 1 : [32] }});\n};\n\nlet SHA512_Final_spec num = do {\n  \/\/ Precondition: `out_ptr` is allocated and points to an array\n  \/\/ of `SHA512_DIGEST_LENGTH` bytes.\n  out_ptr <- llvm_alloc (llvm_array SHA512_DIGEST_LENGTH i8);\n\n  \/\/ Precondition: `sha_ptr` is a pointer to a `sha512_state_st` struct\n  \/\/ Precondition: `sha512_ctx` is a fresh Cryptol SHAState\n  \/\/ Precondition: `sha_ptr` matches `sha512_ctx`.  The message blocks\n  \/\/ of the two must only match up to the first `num` bits.\n  (sha512_ctx, sha_ptr) <- pointer_to_fresh_sha512_state_st \"sha512_ctx\" num;\n  \n  \/\/ Call function with `out_ptr`, and `sha_ptr`.\n  llvm_execute_func [out_ptr, sha_ptr];\n  \n  \/\/ Postcondition: The data pointed to by `out_ptr` matches the message\n  \/\/ digest returned by the Cryptol function `SHAFinal`.  The reverses,\n  \/\/ splits, and joins transform the Cryptol function's big endian output to\n  \/\/ little endian.\n  llvm_points_to out_ptr (llvm_term {{ split`{SHA512_DIGEST_LENGTH} (SHAFinal sha512_ctx) }});\n\n  \/\/ Postcondition: The function returns 1\n  llvm_return (llvm_term {{ 1 : [32] }});\n};\n\nlet SHA512_spec len = do {\n  \/\/ Precondition: `data` is a fresh const array of `len` bytes, and `data_ptr`\n  \/\/ points to `data`.\n  (data, data_ptr) <- ptr_to_fresh_readonly \"data\" (llvm_array len i8);\n\n  \/\/ Precondition: `out_ptr` is allocated and points to an array\n  \/\/ of `SHA512_DIGEST_LENGTH` bytes.\n  out_ptr <- llvm_alloc (llvm_array SHA512_DIGEST_LENGTH i8);\n    \n  \/\/ Call function with arguments data_ptr, len, and out_ptr.\n  llvm_execute_func\n    [ data_ptr\n    , llvm_term {{ `len : [64] }}\n    , out_ptr\n    ];\n  \n  \/\/ Postcondition: The data pointed to by `out_ptr` matches the message\n  \/\/ digest returned by the Cryptol function `SHAImp`.  The reverses,\n  \/\/ splits, and joins transform the Cryptol function's big endian output to\n  \/\/ little endian.\n  llvm_points_to out_ptr (llvm_term {{ split`{SHA512_DIGEST_LENGTH} (SHAImp data) }});\n\n    llvm_return out_ptr;\n};\n\n\n\/\/ Verify functions Sigma0, Sigma1, sigma0, sigma1, and Ch\n\/\/ satisfy their specifications\n\nSigma0_ov <- llvm_verify m \"Sigma0\"\n  []\n  true\n  Sigma0_spec\n  (w4_unint_z3 []);\n\nSigma1_ov <- llvm_verify m \"Sigma1\"\n  []\n  true\n  Sigma1_spec\n  (w4_unint_z3 []);\n\nsigma0_ov <- llvm_verify m \"sigma0\"\n  []\n  true\n  sigma0_spec\n  (w4_unint_z3 []);\n\nsigma1_ov <- llvm_verify m \"sigma1\"\n  []\n  true\n  sigma1_spec\n  (w4_unint_z3 []);\n\nCh_ov <- llvm_verify m \"Ch\"\n  []\n  true\n  Ch_spec\n  (w4_unint_z3 []);\n\n\/\/ Verify the block data function satisfies the bounded\n\/\/ `sha512_block_data_order_spec` specification\n\nsha512_block_data_order_ov <- llvm_verify m \"sha512_block_data_order\"\n  [Sigma0_ov, Sigma1_ov, sigma0_ov, sigma1_ov, Ch_ov]\n  true\n  sha512_block_data_order_spec\n  (w4_unint_z3 [\"S0\", \"S1\", \"s0\", \"s1\", \"Ch\"]);\n\n\n\/\/ Verify the `SHA512_Init` C function satisfies the `SHA512_Init_spec`\n\/\/ specification\nSHA512_Init_ov <- llvm_verify m \"SHA512_Init\"\n  []\n  true\n  SHA512_Init_spec\n  (w4_unint_z3 []);\n\n\n\/\/ Verify the `SHA512_Update` C function satisfies the\n\/\/ `SHA512_Update_spec` specification.\n\/\/ There are 3 cases to consider to ensure the proof covers all possible code\n\/\/ paths through the update function\n\nSHA512_Update_0_240_ov <- llvm_verify m \"SHA512_Update\"\n  [sha512_block_data_order_ov]\n  true\n  \/\/ num=0, len=240 covers the case with one call to the block function,\n  \/\/ on one block from data, and the rest of data copied in c->data\n  (SHA512_Update_spec 0 240)\n  (w4_unint_z3 [\"processBlock_Common\"]);\nSHA512_Update_0_127_ov <- llvm_verify m \"SHA512_Update\"\n  [sha512_block_data_order_ov]\n  true\n  \/\/ num=0, len=127 covers the case without any calls to the block function,\n  \/\/ and data copied in c->data\n  (SHA512_Update_spec 0 127)\n  (w4_unint_z3 [\"processBlock_Common\"]);\nSHA512_Update_127_241_ov <- llvm_verify m \"SHA512_Update\"\n  [sha512_block_data_order_ov]\n  true\n  \/\/ num=127, len=241 covers the case with two calls to the block function,\n  \/\/ the first one on c->data, the second one on one block from data,\n  \/\/ and the rest of data copied in c->data\n  (SHA512_Update_spec 127 241)\n  (w4_unint_z3 [\"processBlock_Common\"]);\n\n\n\/\/ Verify the `SHA512_Final` C function satisfies the\n\/\/ `SHA512_Final_spec` specification.\n\/\/ There are 2 cases to consider to ensure the proof covers all possible code\n\/\/ paths through the update function\n\nSHA512_Final_111_ov <- llvm_verify m \"SHA512_Final\"\n  [sha512_block_data_order_ov]\n  true\n  \/\/ num=111 covers the case with one call to the block function\n  (SHA512_Final_spec 111)\n  (w4_unint_z3 [\"processBlock_Common\"]);\nSHA512_Final_112_ov <- llvm_verify m \"SHA512_Final\"\n  [sha512_block_data_order_ov]\n  true\n  \/\/ num=112 covers the case with two calls to the block function\n  (SHA512_Final_spec 112)\n  (w4_unint_z3 [\"processBlock_Common\"]);\n\n\n\/\/ Verify the `SHA512` C function satisfies the `SHA512_spec`\n\/\/ specification\nllvm_verify m \"SHA512\"\n  [SHA512_Init_ov, SHA512_Update_0_240_ov, SHA512_Final_112_ov]\n  true\n  (SHA512_spec 240)\n  (w4_unint_z3 [\"processBlock_Common\"]);\n\n\nlet quick_check = true;\nlet target_num = 128;\n\nif quick_check then do {\n  return ();\n} else do {\n  \/\/ this covers the case with all lengths given a target_num.\n  print (str_concat \"Verifying SHA512_Update at target_num=\" (show target_num));\n  let verify_update_at_len len = do {\n    print (str_concat \"Verifying SHA512_Update at len=\" (show len));\n    llvm_verify m \"SHA512_Update\"\n        [sha512_block_data_order_ov]\n        true\n        (SHA512_Update_spec target_num len)\n        (w4_unint_z3 [\"processBlock_Common\"]);\n  };\n  \/\/ Given a fixed `num`, the `lens` cover all possible parameters especially below cases:\n  \/\/ When len = (SHA512_CBLOCK - 1), this covers the case without any calls to the block function, \n  \/\/   and data copied in c->data.\n  \/\/ When len = (SHA512_CBLOCK + 1), this covers the case with one call to the block function, \n  \/\/   on one block from data, and the rest of data copied in c->data.\n  \/\/ When len = (SHA512_CBLOCK + 1), this covers the case with two calls to the block function,\n  \/\/   the first one on c->data,  the second one on one block from data, and the rest of data copied in c->data.\n  \/\/ Note: when num = 0, 'len = 256' check fails due to 'sha512_block_data_order' limit.\n  if eval_bool {{ `target_num == 0 }} then do {\n    lens <- for (eval_list {{ [0 .. (2 * SHA512_CBLOCK - 1)] : [2 * SHA512_CBLOCK][64] }})\n      (\\x -> (return (eval_int x)) : (TopLevel Int));\n    for lens verify_update_at_len;\n  } else do {\n    lens <- for (eval_list {{ [0 .. (2 * SHA512_CBLOCK + 1 - target_num)] : [2 * SHA512_CBLOCK + 2 - target_num][64] }})\n      (\\x -> (return (eval_int x)) : (TopLevel Int));\n    for lens verify_update_at_len;\n  };\n  return ();\n};\n\n\/\/ range of valid indices in the internal block ([0 .. (SHA512_CBLOCK - 1)])\nnums <- for (eval_list {{ [0 .. (SHA512_CBLOCK - 1)] : [SHA512_CBLOCK][64] }})\n  (\\x -> (return (eval_int x)) : (TopLevel Int));\n\nif quick_check then do {\n  return ();\n} else do {\n  let verify_final_at_num num = do {\n    print (str_concat \"Verifying SHA512_Final at num=\" (show num));\n    llvm_verify m \"SHA512_Final\"\n      [sha512_block_data_order_ov]\n      true\n      (SHA512_Final_spec num)\n      (w4_unint_z3 [\"processBlock_Common\"]);\n  };\n  for nums verify_final_at_num;\n  return ();\n};\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/common\/helpers.saw","filetype":"saw","content":"\/*\n * SAW helpers\n *\/\n\/\/ Given a value `v` of type `ty`, allocates and returns a pointer to memory\n\/\/ storing `v`\nlet alloc_init ty v = do {\n  p <- crucible_alloc ty;\n  crucible_points_to p v;\n  return p;\n};\n\n\/\/ Given a value `v` of type `ty`, allocates and returns a read only pointer to\n\/\/ memory storing `v`\nlet alloc_init_readonly ty v = do {\n  p <- crucible_alloc_readonly ty;\n  crucible_points_to p v;\n  return p;\n};\n\n\/\/ Given a name `n` and a type `ty`, allocates a fresh variable `x` of type\n\/\/ `ty` and returns a tuple of `x` and a pointer to `x`.\nlet ptr_to_fresh n ty = do {\n  x <- crucible_fresh_var n ty;\n  p <- alloc_init ty (crucible_term x);\n  return (x, p);\n};\n\n\/\/ Given a name `n` and a type `ty`, allocates a fresh variable `x` of type\n\/\/ `ty` and returns a tuple of `x` and a read only pointer to `x`.\nlet ptr_to_fresh_readonly n ty = do {\n  x <- crucible_fresh_var n ty;\n  p <- alloc_init_readonly ty (crucible_term x);\n  return (x, p);\n};\n\n\/\/ Given a name `n` and a value `v`, assert that the `n` has a value of `v`\nlet global_points_to n v = do {\n  crucible_points_to (crucible_global n) (crucible_term v);\n};\n\n\/\/ Given a name `n` and a value `v`, declare that n is initialized, and assert that has value v\nlet global_alloc_init n v = do {\n  crucible_alloc_global n;\n  global_points_to n v;\n};\n\n\/\/ llvm integer type aliases\nlet i8 = llvm_int 8;\nlet i16 = llvm_int 16;\nlet i32 = llvm_int 32;\nlet i64 = llvm_int 64;\nlet i128 = llvm_int 128;\nlet i384 = llvm_int 384;\nlet i512 = llvm_int 512;\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/memory-safety\/point\/solution.saw","filetype":"saw","content":"include \"..\/..\/common\/helpers.saw\";\n\nm <- llvm_load_module \"point.bc\";\n\nlet point_eq_spec = do {\n    (p1, p1_ptr) <- ptr_to_fresh_readonly \"p1\" (llvm_alias \"struct.point\");\n    (p2, p2_ptr) <- ptr_to_fresh_readonly \"p2\" (llvm_alias \"struct.point\");\n\n    llvm_execute_func [p1_ptr, p2_ptr];\n\n    ret <- llvm_fresh_var \"ret\" (llvm_int 1);\n    llvm_return (llvm_term ret);\n};\n\npoint_eq_ov <- llvm_verify m \"point_eq\" [] true\n    point_eq_spec\n    (w4_unint_z3 []);\n\nlet point_new_spec = do {\n    p_x <- llvm_fresh_var \"p_x\" (llvm_int 32);\n    p_y <- llvm_fresh_var \"p_y\" (llvm_int 32);\n\n    llvm_execute_func [ llvm_term p_x, llvm_term p_y ];\n\n    (ret, ret_ptr) <- ptr_to_fresh \"ret\" (llvm_alias \"struct.point\");\n    llvm_return ret_ptr;\n};\n\npoint_new_ov <- llvm_verify m \"point_new\" [] true\n    point_new_spec\n    (w4_unint_z3 []);\n\nlet point_copy_spec = do {\n    (p, p_ptr) <- ptr_to_fresh_readonly \"p\" (llvm_alias \"struct.point\");\n\n    llvm_execute_func [p_ptr];\n\n    (ret, ret_ptr) <- ptr_to_fresh \"ret\" (llvm_alias \"struct.point\");\n    llvm_return ret_ptr;\n};\n\npoint_copy_ov <- llvm_verify m \"point_copy\" [point_new_ov] true\n    point_copy_spec\n    (w4_unint_z3 []);\n\nlet point_add_spec = do {\n    llvm_alloc_global \"ZERO\";\n    zero_global <- llvm_fresh_var \"zero_global\" (llvm_alias \"struct.point\");\n    llvm_points_to (llvm_global \"ZERO\") (llvm_term zero_global);\n    \n    (p1, p1_ptr) <- ptr_to_fresh_readonly \"p1\" (llvm_alias \"struct.point\");\n    (p2, p2_ptr) <- ptr_to_fresh_readonly \"p2\" (llvm_alias \"struct.point\");\n\n    llvm_execute_func [p1_ptr, p2_ptr];\n\n    (ret, ret_ptr) <- ptr_to_fresh \"ret\" (llvm_alias \"struct.point\");\n    llvm_return ret_ptr;\n};\n\nllvm_verify m \"point_add\"\n    [point_new_ov, point_copy_ov, point_eq_ov]\n    true\n    point_add_spec\n    (w4_unint_z3 []);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/memory-safety\/swap\/solution.saw","filetype":"saw","content":"include \"..\/..\/common\/helpers.saw\";\nswapmod <- llvm_load_module \"swap.bc\";\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Part 1: Swap Different Pointers Spec\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nlet swap_diff_spec = do {\n    (x, xp) <- ptr_to_fresh \"x\" (llvm_int 32);\n    (y, yp) <- ptr_to_fresh \"y\" (llvm_int 32);\n\n    llvm_execute_func [xp, yp];\n\n    x' <- llvm_fresh_var \"x'\" (llvm_int 32);\n    y' <- llvm_fresh_var \"y'\" (llvm_int 32);\n\n    llvm_points_to xp (llvm_term x');\n    llvm_points_to yp (llvm_term y');\n};\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Part 2: Swap Different Pointers Proofs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Verify swap\nswap_diff_ov <- llvm_verify swapmod \"swap\" [] true swap_diff_spec z3;\n\n\/\/ Verify xor_swap\nllvm_verify swapmod \"xor_swap\" [] true swap_diff_spec z3;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Part 3: Swap Same Pointers Spec\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nlet swap_same_spec = do {\n    (x, xp) <- ptr_to_fresh \"x\" (llvm_int 32);\n\n    llvm_execute_func [xp, xp];\n\n    x' <- llvm_fresh_var \"x'\" (llvm_int 32);\n    llvm_points_to xp (llvm_term x');\n};\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Part 4: Swap Same Pointers Proofs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nswap_same_ov <- llvm_verify swapmod \"swap\" [] true swap_same_spec z3;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Part 5: Selection Sort Spec\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nlet selection_sort_spec len = do {\n    (a, a_ptr) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 32));\n\n    llvm_execute_func [a_ptr, (llvm_term {{ `len : [64]}})];\n\n    a' <- llvm_fresh_var \"a'\" (llvm_array len (llvm_int 32));\n\n    llvm_points_to a_ptr (llvm_term a');\n};\n\nllvm_verify swapmod \"selection_sort\" [swap_diff_ov, swap_same_ov] true (selection_sort_spec 2) (do {\n    \/\/simplify (cryptol_ss());\n    \/\/print_goal;\n    z3;\n});\n\nllvm_verify swapmod \"selection_sort\" [swap_diff_ov, swap_same_ov] true (selection_sort_spec 3) (do {\n    \/\/simplify (cryptol_ss());\n    \/\/print_goal;\n    z3;\n});\n\nllvm_verify swapmod \"selection_sort\" [swap_diff_ov, swap_same_ov] true (selection_sort_spec 8) (do {\n    \/\/simplify (cryptol_ss());\n    \/\/print_goal;\n    z3;\n});\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/memory-safety\/popcount\/solution.saw","filetype":"saw","content":"popmod <- llvm_load_module \"popcount.bc\";\n\nlet pop_cryptol_check = do {\n     x <- llvm_fresh_var \"x\" (llvm_int 32);\n     llvm_execute_func [llvm_term x];\n     ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n     llvm_return ( llvm_term ret );\n};\n\n\/\/ same verification against Cryptol spec\nllvm_verify popmod \"pop_count\" [] true pop_cryptol_check yices;\n\n\/\/ Begin Cryptol additional verifications\n\/\/ another tricky implementation\nllvm_verify popmod \"pop_count_mul\" [] true pop_cryptol_check yices;\n\n\/\/ verify the while loop version\nllvm_verify popmod \"pop_count_sparse\" [] true pop_cryptol_check yices;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/memory-safety\/salsa20\/solution.saw","filetype":"saw","content":"include \"..\/..\/common\/helpers.saw\";\n\nlet oneptr_update_func (type : LLVMType) (name : String) = do {\n    (x, p) <- ptr_to_fresh name type;\n    llvm_execute_func [p];\n    x' <- llvm_fresh_var (str_concat name \"'\") type;\n    llvm_points_to p (llvm_term x');\n};\n\nlet quarterround_setup : CrucibleSetup () = do {\n    (y0, p0) <- ptr_to_fresh \"y0\" (llvm_int 32);\n    (y1, p1) <- ptr_to_fresh \"y1\" (llvm_int 32);\n    (y2, p2) <- ptr_to_fresh \"y2\" (llvm_int 32);\n    (y3, p3) <- ptr_to_fresh \"y3\" (llvm_int 32);\n\n    llvm_execute_func [p0, p1, p2, p3];\n\n    y0' <- llvm_fresh_var \"y0'\" (llvm_int 32);\n    y1' <- llvm_fresh_var \"y1'\" (llvm_int 32);\n    y2' <- llvm_fresh_var \"y2'\" (llvm_int 32);\n    y3' <- llvm_fresh_var \"y3'\" (llvm_int 32);\n\n    llvm_points_to p0 (llvm_term y0');\n    llvm_points_to p1 (llvm_term y1');\n    llvm_points_to p2 (llvm_term y2');\n    llvm_points_to p3 (llvm_term y3');\n};\n\nlet rowround_setup =\n  oneptr_update_func (llvm_array 16 (llvm_int 32)) \"y\";\n\nlet columnround_setup =\n  oneptr_update_func (llvm_array 16 (llvm_int 32)) \"x\";\n\nlet doubleround_setup =\n  oneptr_update_func (llvm_array 16 (llvm_int 32)) \"x\";\n\nlet salsa20_setup =\n  oneptr_update_func (llvm_array 64 (llvm_int 8)) \"seq\";\n\nlet salsa20_expansion_32 = do {\n    (n, pn) <- ptr_to_fresh_readonly \"n\" (llvm_array 16 (llvm_int 8));\n    (k, pk) <- ptr_to_fresh_readonly \"k\" (llvm_array 32 (llvm_int 8));\n\n    pks <- llvm_alloc (llvm_array 64 (llvm_int 8));\n\n    llvm_execute_func [pk, pn, pks];\n\n    rks <- llvm_fresh_var \"rks\" (llvm_array 64 (llvm_int 8));\n    llvm_points_to pks (llvm_term rks);\n};\n\nlet s20_encrypt32 n = do {\n    (key, pkey) <- ptr_to_fresh_readonly \"key\" (llvm_array 32 (llvm_int 8));\n    (v, pv)     <- ptr_to_fresh_readonly \"nonce\" (llvm_array 8  (llvm_int 8));\n    (m, pm)     <- ptr_to_fresh \"buf\" (llvm_array n (llvm_int 8));\n\n    llvm_execute_func [ pkey\n                          , pv\n                          , llvm_term {{ 0 : [32] }}\n                          , pm\n                          , llvm_term {{ `n : [32] }}\n                          ];\n\n    m' <- llvm_fresh_var \"m'\" (llvm_array n (llvm_int 8));\n    llvm_points_to pm (llvm_term m');\n\n    ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n    llvm_return (llvm_term ret);\n};\n\nm      <- llvm_load_module \"salsa20.bc\";\nqr     <- llvm_verify m \"s20_quarterround\" []      true quarterround_setup   z3;\nrr     <- llvm_verify m \"s20_rowround\"     [qr]    true rowround_setup       z3;\ncr     <- llvm_verify m \"s20_columnround\"  [qr]    true columnround_setup    z3;\ndr     <- llvm_verify m \"s20_doubleround\"  [cr,rr] true doubleround_setup    z3;\ns20    <- llvm_verify m \"s20_hash\"         [dr]    true salsa20_setup        z3;\ns20e32 <- llvm_verify m \"s20_expand32\"     [s20]   true  salsa20_expansion_32 z3;\ns20encrypt_63 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 63) z3;\ns20encrypt_64 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 64) z3;\ns20encrypt_65 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 65) z3;\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/exercises\/memory-safety\/u128\/solution.saw","filetype":"saw","content":"include \"..\/..\/common\/helpers.saw\";\n\nm <- llvm_load_module \"u128.bc\";\n\n\/\/ The interesting thing about this is that we can model it as a 128-bit int directly in Cryptol! Not an array of 2 64-bit ints.\nlet increment_u128_spec = do {\n    (x, x_ptr) <- ptr_to_fresh \"x\" (llvm_int 128);\n\n    llvm_execute_func [x_ptr];\n\n    x' <- llvm_fresh_var \"x'\" (llvm_int 128);\n    llvm_points_to x_ptr (llvm_term x');\n};\n\nllvm_verify m \"increment_u128\"\n    []\n    true\n    increment_u128_spec\n    (do {\n                w4_unint_z3 [];\n});\n\n\/\/ \"The bcmp() function compares the two byte sequences s1 and s2 of length n each. If they are equal, and in particular if n is zero, bcmp() returns 0. Otherwise it returns a nonzero result.\"\nlet bcmp_spec size = do {\n    (s1, s1_ptr) <- ptr_to_fresh_readonly \"s1\" (llvm_array size (llvm_int 8));\n    (s2, s2_ptr) <- ptr_to_fresh_readonly \"s2\" (llvm_array size (llvm_int 8));\n\n    llvm_execute_func [ s1_ptr, s2_ptr, llvm_term {{ `size : [64]}} ];\n\n    ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n    llvm_return (llvm_term ret);\n};\n\nbcmp_16_ov <- llvm_unsafe_assume_spec m \"bcmp\" (bcmp_spec 16);\n\nlet eq_u128_spec = do {\n    (x, x_ptr) <- ptr_to_fresh_readonly \"x\" (llvm_int 128);\n    (y, y_ptr) <- ptr_to_fresh_readonly \"y\" (llvm_int 128);\n\n    llvm_execute_func [x_ptr, y_ptr];\n\n    ret <- llvm_fresh_var \"ret\" (llvm_int 1);\n    llvm_return (llvm_term ret);\n};\n\nllvm_verify m \"eq_u128\"\n    [bcmp_16_ov]\n    true\n    eq_u128_spec\n    (do {\n                w4_unint_z3 [];\n});\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/functional-correctness\/point\/Point.cry","filetype":"cry","content":"module Point where\n\ntype Point = {x : [32], y : [32]}\n\nPOINT_ZERO : Point\nPOINT_ZERO = zero\n\npoint_add : Point -> Point -> Point\npoint_add p1 p2 = { x = p1.x + p2.x, y = p1.y + p2.y }\n\npoint_add_commutes : Point -> Point -> Bit\nproperty point_add_commutes p1 p2 = point_add p1 p2 == point_add p2 p1","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/functional-correctness\/point\/solution.saw","filetype":"saw","content":"include \"..\/..\/common\/helpers.saw\";\nimport \"Point.cry\";\n\nm <- llvm_load_module \"point.bc\";\n\nlet fresh_point_readonly name = do {\n    p_ptr <- llvm_alloc_readonly (llvm_alias \"struct.point\");\n    p_x <- llvm_fresh_var (str_concat name \".x\") (llvm_int 32);\n    p_y <- llvm_fresh_var (str_concat name \".y\") (llvm_int 32);\n    llvm_points_to p_ptr (llvm_struct_value [ llvm_term p_x, llvm_term p_y]);\n    let p = {{ { x = p_x, y = p_y } }};\n    return (p, p_ptr);\n};\n\nlet point_eq_spec = do {\n    (p1, p1_ptr) <- fresh_point_readonly \"p1\";\n    (p2, p2_ptr) <- fresh_point_readonly \"p2\";\n\n    llvm_execute_func [p1_ptr, p2_ptr];\n\n    \/\/ This is confusing.  p1 == p2 wont work because that produces a Bit, but\n    \/\/ this function wants a [1] as a response.\n    llvm_return (llvm_term {{ [p1 == p2] }});\n};\n\npoint_eq_ov <- llvm_verify m \"point_eq\" [] true\n    point_eq_spec\n    (w4_unint_z3 []);\n\nlet alloc_assign_point p = do {\n    p_ptr <- llvm_alloc (llvm_alias \"struct.point\");\n    llvm_points_to p_ptr (llvm_struct_value [ llvm_term {{ p.x }}, llvm_term {{ p.y }}]);\n    return p_ptr;\n};\n\nlet point_new_spec = do {\n    p_x <- llvm_fresh_var \"p_x\" (llvm_int 32);\n    p_y <- llvm_fresh_var \"p_y\" (llvm_int 32);\n\n    llvm_execute_func [ llvm_term p_x, llvm_term p_y ];\n\n    ret_ptr <- alloc_assign_point {{ {x = p_x, y = p_y } }};\n    llvm_return ret_ptr;\n};\n\npoint_new_ov <- llvm_verify m \"point_new\" [] true\n    point_new_spec\n    (w4_unint_z3 []);\n\nlet point_copy_spec = do {\n    (p, p_ptr) <- fresh_point_readonly \"p\";\n\n    llvm_execute_func [p_ptr];\n\n    ret_ptr <- alloc_assign_point p;\n    llvm_return ret_ptr;\n};\n\npoint_copy_ov <- llvm_verify m \"point_copy\" [point_new_ov] true\n    point_copy_spec\n    (w4_unint_z3 []);\n\nlet point_add_spec = do {\n    let zero_term = llvm_term {{ 0 : [32] }};\n    llvm_alloc_global \"ZERO\";\n    llvm_points_to (llvm_global \"ZERO\") \n                   (llvm_struct_value [zero_term, zero_term]);\n    \n    (p1, p1_ptr) <- fresh_point_readonly \"p1\";\n    (p2, p2_ptr) <- fresh_point_readonly \"p2\";\n\n    llvm_execute_func [p1_ptr, p2_ptr];\n\n    res_ptr <- alloc_assign_point {{ point_add p1 p2 }};\n    llvm_return res_ptr;\n};\n\nllvm_verify m \"point_add\"\n    [point_new_ov, point_copy_ov, point_eq_ov]\n    true\n    point_add_spec\n    (w4_unint_z3 []);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/functional-correctness\/popcount\/solution.saw","filetype":"saw","content":"import \"Popcount.cry\";\n\npopmod <- llvm_load_module \"popcount.bc\";\n\nlet pop_cryptol_check = do {\n     x <- llvm_fresh_var \"x\" (llvm_int 32);\n     llvm_execute_func [llvm_term x];\n     llvm_return ( llvm_term {{ popCount x }} );\n};\n\n\/\/ same verification against Cryptol spec\nllvm_verify popmod \"pop_count\" [] true pop_cryptol_check (do {\n          z3;\n});\n\n\/\/ Begin Cryptol additional verifications\n\/\/ another tricky implementation\nllvm_verify popmod \"pop_count_mul\" [] true pop_cryptol_check yices;\n\n\/\/ verify the while loop version\nllvm_verify popmod \"pop_count_sparse\" [] true pop_cryptol_check yices;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/functional-correctness\/popcount\/Popcount.cry","filetype":"cry","content":"module Popcount where\n\npopCount : [32] -> [32]\npopCount bits = ic ! 0 where\n     ic = [0] # [ if elt then prev + 1 else prev | elt <- bits | prev <- ic]","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/functional-correctness\/salsa20\/solution.saw","filetype":"saw","content":"include \"..\/..\/common\/helpers.saw\";\nimport \"Salsa20.cry\";\n\nlet oneptr_update_func (type : LLVMType) (name : String) (f : Term) = do {\n    (x, p) <- ptr_to_fresh name type;\n    llvm_execute_func [p];\n    llvm_points_to p (llvm_term {{ f x }});\n};\n\nlet quarterround_setup : CrucibleSetup () = do {\n    (y0, p0) <- ptr_to_fresh \"y0\" (llvm_int 32);\n    (y1, p1) <- ptr_to_fresh \"y1\" (llvm_int 32);\n    (y2, p2) <- ptr_to_fresh \"y2\" (llvm_int 32);\n    (y3, p3) <- ptr_to_fresh \"y3\" (llvm_int 32);\n\n    llvm_execute_func [p0, p1, p2, p3];\n\n    let zs = {{ quarterround [y0,y1,y2,y3] }};\n    llvm_points_to p0 (llvm_term {{ zs@0 }});\n    llvm_points_to p1 (llvm_term {{ zs@1 }});\n    llvm_points_to p2 (llvm_term {{ zs@2 }});\n    llvm_points_to p3 (llvm_term {{ zs@3 }});\n};\n\nlet rowround_setup =\n  oneptr_update_func (llvm_array 16 (llvm_int 32)) \"y\" {{ rowround }};\n\nlet columnround_setup =\n  oneptr_update_func (llvm_array 16 (llvm_int 32)) \"x\" {{ columnround }};\n\nlet doubleround_setup =\n  oneptr_update_func (llvm_array 16 (llvm_int 32)) \"x\" {{ doubleround }};\n\nlet salsa20_setup =\n  oneptr_update_func (llvm_array 64 (llvm_int 8)) \"seq\" {{ Salsa20 }};\n\nlet salsa20_expansion_32 = do {\n    (n, pn) <- ptr_to_fresh_readonly \"n\" (llvm_array 16 (llvm_int 8));\n    (k, pk) <- ptr_to_fresh_readonly \"k\" (llvm_array 32 (llvm_int 8));\n\n    pks <- llvm_alloc (llvm_array 64 (llvm_int 8));\n\n    llvm_execute_func [pk, pn, pks];\n\n    let rks = {{ Salsa20_expansion`{a=2}(k, n)}};\n    llvm_points_to pks (llvm_term rks);\n};\n\nlet s20_encrypt32 n = do {\n    (key, pkey) <- ptr_to_fresh_readonly \"key\" (llvm_array 32 (llvm_int 8));\n    (v, pv)     <- ptr_to_fresh_readonly \"nonce\" (llvm_array 8  (llvm_int 8));\n    (m, pm)     <- ptr_to_fresh \"buf\" (llvm_array n (llvm_int 8));\n\n    llvm_execute_func [ pkey\n                          , pv\n                          , llvm_term {{ 0 : [32] }}\n                          , pm\n                          , llvm_term {{ `n : [32] }}\n                          ];\n\n    llvm_points_to pm (llvm_term {{ Salsa20_encrypt (key, v, m) }});\n    llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nm      <- llvm_load_module \"salsa20.bc\";\nqr     <- llvm_verify m \"s20_quarterround\" []      true quarterround_setup   z3;\nrr     <- llvm_verify m \"s20_rowround\"     [qr]    true rowround_setup       z3;\ncr     <- llvm_verify m \"s20_columnround\"  [qr]    true columnround_setup    z3;\ndr     <- llvm_verify m \"s20_doubleround\"  [cr,rr] true doubleround_setup    z3;\ns20    <- llvm_verify m \"s20_hash\"         [dr]    true salsa20_setup        z3;\ns20e32 <- llvm_verify m \"s20_expand32\"     [s20]   true  salsa20_expansion_32 z3;\ns20encrypt_63 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 63) z3;\ns20encrypt_64 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 64) z3;\ns20encrypt_65 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 65) z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/functional-correctness\/u128\/solution.saw","filetype":"saw","content":"include \"..\/..\/common\/helpers.saw\";\n\nm <- llvm_load_module \"u128.bc\";\n\nlet increment_u128_spec = do {\n    (x, x_ptr) <- ptr_to_fresh \"x\" (llvm_int 128);\n\n    llvm_execute_func [x_ptr];\n\n    llvm_points_to x_ptr (llvm_term {{ x + 1 }});\n};\n\n\/\/ NOTE: Solution below is commented out because you need to fix the C code by\n\/\/ changing `x[1]` to `x[0]` on line 7, and `x[0]` to `x[1]` on line 8.  Then\n\/\/ the proof below will go through.\n\/*\nllvm_verify m \"increment_u128\"\n    []\n    true\n    increment_u128_spec\n    (do {\n        simplify (cryptol_ss());\n        print_goal;\n        w4_unint_z3 [];\n});\n*\/\n\n\/\/ \"The bcmp() function compares the two byte sequences s1 and s2 of length n\n\/\/ each. If they are equal, and in particular if n is zero, bcmp() returns 0.\n\/\/ Otherwise it returns a nonzero result.\"\nlet bcmp_spec size = do {\n    (s1, s1_ptr) <- ptr_to_fresh \"s1\" (llvm_array size (llvm_int 8));\n    (s2, s2_ptr) <- ptr_to_fresh \"s2\" (llvm_array size (llvm_int 8));\n\n    llvm_execute_func [ s1_ptr, s2_ptr, llvm_term {{ `size : [64]}} ];\n\n    llvm_return (llvm_term {{ zext`{32} [s1 != s2] }});\n};\n\nbcmp_16_ov <- llvm_unsafe_assume_spec m \"bcmp\" (bcmp_spec 16);\n\nlet eq_u128_spec = do {\n    (x, x_ptr) <- ptr_to_fresh \"x\" (llvm_int 128);\n    (y, y_ptr) <- ptr_to_fresh \"y\" (llvm_int 128);\n\n    llvm_execute_func [x_ptr, y_ptr];\n\n    llvm_return (llvm_term {{ [x == y] : [1] }});\n};\n\nllvm_verify m \"eq_u128\"\n    [bcmp_16_ov]\n    true\n    eq_u128_spec\n    (do {\n                w4_unint_z3 [];\n});\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/exercises\/functional-correctness\/swap\/solution\/Swap.cry","filetype":"cry","content":"module Swap where\n\n\/\/ Given a list and two indices, return a new list with the values at the\n\/\/ indices swapped.\nswap_list : {n} [n][32] -> [64] -> [64] -> [n][32]\nswap_list lst i j = update (update lst i jval) j ival\n    where ival = lst @ i\n          jval = lst @ j\n\nargmin : {n} (fin n) => [n][32] -> [64]\nargmin lst =\n    (foldl' min (-1 : [32], -1 : [64]) [(x, i) | x <- lst | i <- [0...]]).1\n\nselection_sort : {n} (fin n, 64 >= width n) => [n][32] -> [n][32]\nselection_sort lst = go`{0} lst\n    where\n        go : {idx} (fin idx, fin n, 64 >= width idx, 64 >= width n, n >= idx) => [n][32] -> [n][32]\n        go acc =\n            if `idx == `n\n            then acc\n            else go`{min n (idx + 1)}\n                    (swap_list acc `idx (`idx + (argmin (drop`{idx} acc))))\n\n\/\/ NOTE: Have to be careful.  Just running :check on this will likely crash because a random index is likely out of bounds (especailly because `n will default to 0)\nswap_list_same : {n} (fin n) => [64] -> [n][32] -> Bit\nproperty swap_list_same i lst = (swap_list lst i i) == lst\n\nsort_eq : {n} (fin n, 64 >= width n) => [n][32] -> Bit\nproperty sort_eq lst = selection_sort lst == sort lst\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/functional-correctness\/swap\/solution\/solution.saw","filetype":"saw","content":"include \"..\/..\/..\/common\/helpers.saw\";\nimport \"Swap.cry\";\nswapmod <- llvm_load_module \"swap.bc\";\n\nlet swap_diff_spec = do {\n    \/\/ NOTE: Could use ptr_to_fresh instead\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    xp <- llvm_alloc (llvm_int 32);\n    llvm_points_to xp (llvm_term x);\n\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    yp <- llvm_alloc (llvm_int 32);\n    llvm_points_to yp (llvm_term y);\n\n    llvm_execute_func [xp, yp];\n\n    llvm_points_to yp (llvm_term x);\n    llvm_points_to xp (llvm_term y);\n};\n\n\/\/ Verify swap\nswap_diff_ov <- llvm_verify swapmod \"swap\" [] true swap_diff_spec z3;\n\nlet swap_same_spec = do {\n    (x, x_ptr) <- ptr_to_fresh \"x\" (llvm_int 32);\n\n    llvm_execute_func [x_ptr, x_ptr];\n\n    llvm_points_to x_ptr (llvm_term x);\n};\n\nswap_same_ov <- llvm_verify swapmod \"swap\" [] true swap_same_spec z3;\n\n\/\/ Verify xor_swap\nllvm_verify swapmod \"xor_swap\" [] true swap_diff_spec z3;\n\nlet selection_sort_spec len = do {\n    (a, a_ptr) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 32));\n\n    llvm_execute_func [a_ptr, (llvm_term {{ `len : [64]}})];\n\n    llvm_points_to a_ptr (llvm_term {{ selection_sort a }});\n};\n\nlet a_len = 4;\n\n\/\/ Play with the `len` paramter for this exercise.  At len=4 it solves quickly.\n\/\/ At len=8, the term has blown up.  Will it solve at all?\nllvm_verify swapmod \"selection_sort\" [swap_diff_ov, swap_same_ov] true (selection_sort_spec a_len) (do {\n    \/\/simplify (cryptol_ss());\n    \/\/print_goal;\n    z3;\n});\n\n\/\/ Now we crank a_len up and show the original proof blow up.  How can we fix\n\/\/ it?\nlet a_len = 8;\n\nlet argmin_spec len = do {\n    \/\/ NOTE: Need to be careful to use \"ptr_to_fresh_readonly\" here.  I\n    \/\/ originally made the mistake of making this a \"ptr_to_fresh\", which\n    \/\/ broke the input to swap afterwards by effectively wiping the array.\n    (a, a_ptr) <- ptr_to_fresh_readonly \"a\" (llvm_array len (llvm_int 32));\n\n    llvm_execute_func [a_ptr, (llvm_term {{ `len : [64]}})];\n\n    llvm_return (llvm_term {{ argmin a }});\n};\n\n\/\/ NOTE: Another mistake I made was to use the override below.\n\/\/ This works for size a_len, but on the second time through the loop the override\n\/\/ doesn't match because the size of the list has changed!  Ultimately need a\n\/\/ loop here.\nargmin_ovs <- for (eval_list {{ [1..a_len] : [a_len][64]}}) (\\len ->\n    llvm_verify swapmod \"argmin\" [] true (argmin_spec (eval_int len)) z3\n);\n\n\/\/ NOTE: The reason we created a swap_array function was to get \"swap_list\" in\n\/\/ our goal and reduce the number of ITEs, which in turn will help the solver\nlet swap_array_spec len = do {\n    (a, a_ptr) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 32));\n\n    i <- llvm_fresh_var \"i\" (llvm_int 64);\n    j <- llvm_fresh_var \"j\" (llvm_int 64);\n\n    llvm_precond {{ i < `len }};\n    llvm_precond {{ j < `len }};\n\n    llvm_execute_func [ a_ptr, llvm_term i, llvm_term j ];\n\n    llvm_points_to a_ptr (llvm_term {{ swap_list a i j }});\n};\n\nswap_array_ov <- llvm_verify swapmod \"swap_array\"\n    [swap_diff_ov, swap_same_ov]\n    true\n    (swap_array_spec a_len)\n    (w4_unint_z3 []);\n\nsort_ov <- llvm_verify swapmod \"selection_sort_composed\"\n    (concat [swap_diff_ov, swap_same_ov, swap_array_ov] argmin_ovs)\n    true\n    (selection_sort_spec a_len)\n    (do {\n                w4_unint_z3 [];\n});\n\nllvm_verify swapmod \"wacky_sort\"\n    (concat argmin_ovs [sort_ov, swap_array_ov])\n    true\n    (selection_sort_spec a_len)\n    (do {\n                w4_unint_z3 [\"selection_sort\"];\n});\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/exercises\/functional-correctness\/complete-examples\/add\/solution.saw","filetype":"saw","content":"let add_spec = do {\n          x <- llvm_fresh_var \"x\" (llvm_int 32);\n     y <- llvm_fresh_var \"y\" (llvm_int 32);\n\n          llvm_execute_func [llvm_term x, llvm_term y];\n\n          llvm_return (llvm_term {{ x + y }});\n};\n\n\/\/ Load LLVM bitcode to verify\nm <- llvm_load_module \"add.bc\";\n\n\/\/ Verify the `add` function satisfies its specification\nllvm_verify m \"add\" [] true add_spec (do {\n          z3;\n});\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/misc\/rewrite.saw","filetype":"saw","content":"let ss = cryptol_ss ();\nlet crule t = rewrite ss t;\n\nrule <- crule {{ \\(x:[384]) -> join ((split x) : [12][32]) == x }};\nrule_thm <- prove_print (admit \"assume rule\") rule;\n\nprint \"== Original version of rule:\";\nprint_term rule;\nlet rule_ss = addsimps [rule_thm] empty_ss;\nlet t = rewrite rule_ss rule;\nprint \"== Rule rewritten with itself:\";\nprint_term t;\nprint \"== Proof result:\";\nprove_print abc t;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/misc\/mutRecTest.saw","filetype":"saw","content":"import \"mutRecTest.cry\";\n\nlet {{ f = streamFibs    : [8] -> [32] }};\nlet {{ g = streamFibsAlt : [8] -> [32] }};\nlet {{ h = recFibs       : [8] -> [32] }};\nlet {{ i = recFibs2      : [8] -> [32] }};\n\nlet thm1 = {{ f === g }};\nprove_print abc thm1;\n\n\/\/ FIXME, this makes the simulator crash the stack\n\/\/let thm2 x = f x == h x;\n\/\/ prove_print abc thm2;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/misc\/and_assoc.saw","filetype":"saw","content":"let {{ and_assoc (x, y, z : Bit) = ((x && y) && z) == (x && (y && z)) }};\nresult <- prove abc {{ and_assoc }};\nprint result;\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/examples\/misc\/define.saw","filetype":"saw","content":"let twice = {{ \\f x -> f (f x) }};\nlet ident = {{ \\x -> x }};\n\nprint_term {{ twice ident : [8] -> [8] }};\ntwice_id <- define \"twice_id\" {{ twice ident : [8] -> [8] }};\nprint_term twice_id;\nprint {{ twice_id 5 }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/misc\/uninterp.saw","filetype":"saw","content":"let {{ f (x:[64]) = x * x }};\nfsym <- define \"f\" {{ f }};\nlet {{ thm x = ((fsym x) + (fsym x)) == ((fsym x) * 2) }};\nprove_print abc {{ thm }};\n\/\/write_aig \"uninterp.aig\" {{ \\x -> ~(thm x) }};\nprove_print yices {{ thm }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/misc\/prove.saw","filetype":"saw","content":"\/\/ f : [8] -> Bit;\n\/\/ f x = (x + x) == (1 * x);\n\n\nlet f = {{ \\ (x : [8]) -> (x + x) == (1 * x) }};\nr <- prove abc f;\ncaseProofResult r\n  (\\thm -> print \"Q.E.D.\")\n  (\\v -> do { print \"Oops.\" ; print v; print {{ f v }}; });\nprint \"Done.\";\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/sv-comp\/parity.saw","filetype":"saw","content":"include \"sv-comp.saw\";\n\nm <- llvm_load_module \"parity.bc\";\nlet assume = llvm_unsafe_assume_spec m;\nerror_ov <- assume \"__VERIFIER_error\" error_spec;\nnondet_int_ov <- assume \"__VERIFIER_nondet_uint\" nondet_int_spec;\nlet ovs = [error_ov, nondet_int_ov];\nllvm_verify m \"main\" ovs true main_spec yices;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/sv-comp\/sv-comp.saw","filetype":"saw","content":"let error_spec = do {\n    llvm_precond {{ False }};\n    llvm_execute_func [];\n};\n\nlet assume_spec = do {\n    p <- llvm_fresh_var \"p\" (llvm_int 32);\n    llvm_execute_func [llvm_term p];\n    llvm_postcond {{ p != 0 }};\n};\n\nlet nondet_int_spec = do {\n    llvm_execute_func [];\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_return (llvm_term x);\n};\n\nlet main_spec = do {\n    llvm_execute_func [];\n};\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/fresh-post\/fresh-post-good.saw","filetype":"saw","content":"let whoknows_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  y <- llvm_fresh_var \"y\" (llvm_int 32);\n  llvm_return (llvm_term y);\n};\n\nlet example_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  llvm_return (llvm_term {{0:[32]}});\n};\n\nlet one_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_return (llvm_term x);\n};\n\nlet main : TopLevel () = do {\n\n    m <- llvm_load_module \"source.bc\";\n    whoknows <- llvm_unsafe_assume_spec m \"whoknows\" whoknows_spec;\n    llvm_verify m \"example\" [whoknows] false example_spec abc;\n    llvm_verify m \"one\" [] false one_spec ( do { print_goal; abc; } );\n    print \"done\";\n};\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/examples\/fresh-post\/fresh-post-bad.saw","filetype":"saw","content":"let whoknows_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  y <- llvm_fresh_var \"y\" (llvm_int 32);\n  llvm_postcond {{ y < 0x0000FFFF }};\n  llvm_return (llvm_term y);\n};\n\nlet bad_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  llvm_return (llvm_term {{0:[32]}});\n};\n\nm <- llvm_load_module \"source.bc\";\nwhoknows <- llvm_unsafe_assume_spec m \"whoknows\" whoknows_spec;\nfails (llvm_verify m \"bad\" [whoknows] false bad_spec abc);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/partial-spec\/partial-spec.saw","filetype":"saw","content":"let inc_spec : CrucibleSetup () = do {\n  m <- llvm_alloc (llvm_alias \"struct.my_struct\");\n  counter <- llvm_fresh_var \"counter\" (llvm_int 32);\n  llvm_points_to (llvm_field m \"counter\") (llvm_term counter);\n  llvm_execute_func [m];\n  llvm_points_to (llvm_field m \"counter\") (llvm_term {{counter+1}});\n};\n\nlet use_inc_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  llvm_return (llvm_term {{1:[32]}});\n};\n\nlet main : TopLevel () = do {\n    m <- llvm_load_module \"source.bc\";\n    inc <- llvm_verify m \"inc\" [] false inc_spec abc;\n    llvm_verify m \"use_inc\" [inc] false use_inc_spec abc;\n    print \"done\";\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/multi-override\/multi-override.saw","filetype":"saw","content":"import \"imports.cry\";\n\nlet identity_spec n : CrucibleSetup () = do {\n  llvm_execute_func [llvm_term n];\n  llvm_return (llvm_term n);\n};\n\nlet example_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  llvm_return (llvm_term {{3:[32]}});\n};\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet sum_spec n : CrucibleSetup() = do {\n  (arr,arrp) <- ptr_to_fresh \"arr\" (llvm_array n (llvm_int 32));\n\n  llvm_execute_func[arrp, llvm_term {{ `n:[32]}}];\n  llvm_return (llvm_term {{ mysum arr }});\n  llvm_points_to arrp (llvm_term arr);\n};\n\nlet example_sums : CrucibleSetup() = do {\n  llvm_execute_func[];\n  llvm_return (llvm_term {{ 70:[32] }});\n};\n\nlet set_myglobal n : CrucibleSetup() = do {\n  llvm_alloc_global \"myglobal\";\n  old <- llvm_fresh_var \"old\" (llvm_int 32);\n  llvm_precond {{ old < 1000 }};\n  llvm_points_to (llvm_global \"myglobal\") (llvm_term old);\n  llvm_execute_func[llvm_term {{ `n : [32] }}];\n  llvm_points_to (llvm_global \"myglobal\")\n                     (llvm_term {{ `n + old*old : [32] }});\n};\n\nlet myglobal_example : CrucibleSetup() = do {\n  llvm_alloc_global \"myglobal\";\n  llvm_execute_func[];\n  llvm_return (llvm_term {{ 120 : [32] }});\n  llvm_points_to (llvm_global \"myglobal\")\n                 (llvm_term {{ 120 : [32] }});\n};\n\nlet main : TopLevel () = do {\n\n    m <- llvm_load_module \"source.bc\";\n    id1 <- llvm_verify m \"identity\" [] false (identity_spec {{1:[32]}}) abc;\n    id2 <- llvm_verify m \"identity\" [] false (identity_spec {{2:[32]}}) abc;\n    llvm_verify m \"example\"     [id1,id2] false example_spec z3;\n    \/\/llvm_verify \"bad_example\" [id1,id2] false example_spec (do { print_goal; assume_unsat; });\n\n    sum3  <- llvm_verify m \"sum\" [] false (sum_spec  3) z3;\n    sum6  <- llvm_verify m \"sum\" [] false (sum_spec  6) z3;\n    sum10 <- llvm_verify m \"sum\" [] false (sum_spec 10) z3;\n    sum12 <- llvm_verify m \"sum\" [] false (sum_spec 12) z3;\n    llvm_verify m \"example_sums\" [sum3,sum12, sum6,sum10] false example_sums z3;\n\n    set10 <- llvm_verify m \"add_myglobal\" [] false (set_myglobal 10) z3;\n    set20 <- llvm_verify m \"add_myglobal\" [] false (set_myglobal 20) z3;\n    set30 <- llvm_verify m \"add_myglobal\" [] false (set_myglobal 30) z3;\n    llvm_verify m \"myglobal_example\" [set10,set20,set30] false myglobal_example z3;\n    llvm_verify m \"myglobal_example\" [set20,set30,set10] false myglobal_example z3;\n    llvm_verify m \"myglobal_example\" [set30,set10,set20] false myglobal_example z3;\n    print \"done\";\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/llvm\/ptr.saw","filetype":"saw","content":"let alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet add_setup = do {\n    (x, xp) <- ptr_to_fresh \"x\" (llvm_int 32);\n    (y, yp) <- ptr_to_fresh \"y\" (llvm_int 32);\n    llvm_execute_func [xp, yp];\n    llvm_return (llvm_term {{ x + y : [32] }});\n};\n\nlet clear_setup = do {\n    (a, ap) <- ptr_to_fresh \"a\" (llvm_array 10 (llvm_int 32));\n    llvm_execute_func [ap];\n    llvm_points_to ap (llvm_term {{ zero : [10][32] }});\n};\n\nlet copy_setup = do {\n    (a, ap) <- ptr_to_fresh \"a\" (llvm_array 10 (llvm_int 32));\n    (b, bp) <- ptr_to_fresh \"b\" (llvm_array 10 (llvm_int 32));\n    llvm_execute_func [ap, bp];\n    llvm_points_to ap (llvm_term b);\n};\n\nlet main : TopLevel () = do {\n    m <- llvm_load_module \"ptr.bc\";\n    add_ms <- llvm_verify m \"add\" [] false add_setup abc;\n    clear_ms <- llvm_verify m \"clear\" [] false clear_setup abc;\n    copy_ms <- llvm_verify m \"copy\" [] false copy_setup abc;\n    print \"Done.\";\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/llvm\/ptrcheck.saw","filetype":"saw","content":"m <- llvm_load_module \"ptrcheck.bc\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nllvm_verify m \"f\" [] false do {\n    (s, sp) <- ptr_to_fresh \"s\" (llvm_alias \"struct.s\");\n    llvm_execute_func [sp];\n    llvm_return (llvm_term {{ 0 : [32] }});\n} abc;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/llvm\/global.saw","filetype":"saw","content":"let alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet clear_setup = do {\n    llvm_alloc_global \"g\";\n    llvm_execute_func [];\n    llvm_points_to (llvm_global \"g\") (llvm_term {{ 0 : [32] }});\n};\n\nlet set_setup = do {\n    llvm_alloc_global \"g\";\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_execute_func [llvm_term x];\n    llvm_points_to (llvm_global \"g\") (llvm_term x);\n};\n\nlet get_setup = do {\n    llvm_alloc_global \"g\";\n    let g = llvm_global \"g\";\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_points_to g (llvm_term x);\n    llvm_execute_func [llvm_term x];\n    llvm_points_to g (llvm_term x);\n    llvm_return (llvm_term x);\n};\n\nlet main : TopLevel () = do {\n    m <- llvm_load_module \"global.bc\";\n    llvm_verify m \"clear\" [] false clear_setup abc;\n    llvm_verify m \"set\" [] false set_setup abc;\n    llvm_verify m \"get\" [] false get_setup abc;\n    print \"Done.\";\n};\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/llvm\/nested.saw","filetype":"saw","content":"let f_spec = do {\n    tp <- llvm_alloc (llvm_alias \"struct.t\");\n    b <- llvm_fresh_var \"b\" (llvm_int 32);\n\n    \/\/ The following will work if nested.bc is compiled with debug info\n    \/\/ with Clang 3.7 or greater\n    llvm_points_to (llvm_field (llvm_field tp \"n\") \"b\") (llvm_term b);\n\n    \/\/ The following can be a workaround if debug info is not available\n    \/\/llvm_points_to (llvm_elem (llvm_elem tp 1) 1) (llvm_term b);\n\n    llvm_execute_func [tp];\n    llvm_return (llvm_term b);\n};\n\nm <- llvm_load_module \"nested.bc\";\n\nllvm_verify m \"f\" [] false f_spec abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/llvm\/struct.saw","filetype":"saw","content":"let alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet set_spec = do {\n    (x, px) <- ptr_to_fresh \"x\" (llvm_array 2 (llvm_int 32));\n    po <- alloc_init (llvm_alias \"struct.s\") (llvm_struct_value [px]);\n    llvm_execute_func [po];\n    llvm_points_to po (llvm_struct_value [px]);\n    llvm_points_to px (llvm_term {{ [0, 0] : [2][32] }});\n};\n\nlet add_spec = do {\n    (x, px) <- ptr_to_fresh \"x\" (llvm_array 2 (llvm_int 32));\n    po <- alloc_init (llvm_alias \"struct.s\") (llvm_struct_value [px]);\n    llvm_execute_func [po];\n    llvm_return (llvm_term {{ x@0 + x@1 }});\n};\n\nlet id_spec = do {\n    (x, px) <- ptr_to_fresh \"x\" (llvm_array 2 (llvm_int 32));\n    po <- alloc_init (llvm_alias \"struct.s\") (llvm_struct_value [px]);\n    llvm_execute_func [po];\n    llvm_return po;\n};\n\nm <- llvm_load_module \"struct.bc\";\nllvm_verify m \"set_indirect\" [] false set_spec abc;\nllvm_verify m \"add_indirect\" [] false add_spec abc;\nllvm_verify m \"s_id\" [] false id_spec abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/llvm\/assert-null.saw","filetype":"saw","content":"let f_spec1 = do {\n    p <- llvm_alloc (llvm_int 32);\n    llvm_execute_func [p];\n    llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nlet f_spec2 = do {\n    llvm_execute_func [llvm_null];\n    llvm_return (llvm_term {{ 1 : [32] }});\n};\n\nm <- llvm_load_module \"assert-null.bc\";\nllvm_verify m \"f\" [] false f_spec1 abc;\nllvm_verify m \"f\" [] false f_spec2 abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/llvm\/basic.saw","filetype":"saw","content":"let add_setup = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    llvm_execute_func [llvm_term x, llvm_term y];\n    llvm_return (llvm_term {{ x + y : [32] }});\n};\n\nlet dbl_setup = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_execute_func [llvm_term x];\n    llvm_return (llvm_term {{ x + x : [32] }});\n};\n\nm <- llvm_load_module \"basic.bc\";\nadd_ms <- llvm_verify m \"add\" [] false add_setup abc;\nllvm_verify m \"dbl\" [add_ms] false dbl_setup abc;\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/llvm\/assert.saw","filetype":"saw","content":"let f_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_precond {{ x > 0 }};\n  llvm_execute_func [llvm_term x];\n};\n\nm <- llvm_load_module \"assert.bc\";\nllvm_verify m \"f\" [] true f_spec abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/llvm\/nested-full.saw","filetype":"saw","content":"let alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet f_spec = do {\n    a <- llvm_fresh_var \"a\" (llvm_int 32);\n    b <- llvm_fresh_var \"b\" (llvm_int 32);\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    z <- llvm_fresh_var \"z\" (llvm_int 32);\n    let s = (llvm_term {{ (x, (a, b), z) }});\n    p <- alloc_init (llvm_alias \"struct.t\") s;\n    llvm_execute_func [p];\n    llvm_return (llvm_term {{ b }});\n};\n\nm <- llvm_load_module \"nested.bc\";\nllvm_verify m \"f\" [] false f_spec abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/java\/branchsat.saw","filetype":"saw","content":"c <- java_load_class \"BranchTest\";\n\n\/\/ FIXME: make this terminate with the symbolic precondition\n\/\/ The following will not terminate if the last parameter is `false`\njvm_verify c \"f\" [] true\n  do {\n    let x = {{ 6 : [32] }}; \/\/ FIXME\n    \/\/ x <- jvm_fresh_var \"x\" java_int;\n    \/\/ jvm_precond {{ x < 10 }};\n    jvm_execute_func [jvm_term x];\n    jvm_return (jvm_term {{ x * (x - 1) \/ 2 }});\n  }\n  abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/java\/arrays.saw","filetype":"saw","content":"c <- java_load_class \"ArrayTest\";\n\ncopy_ms <-\njvm_verify c \"copy\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    b_ref <- jvm_alloc_array 10 java_int;\n    a <- jvm_fresh_var \"a\" (java_array 10 java_int);\n    jvm_array_is a_ref a;\n    jvm_execute_func [this, a_ref, b_ref];\n    jvm_array_is b_ref a;\n  }\n  abc;\n\nunit_ms <-\njvm_verify c \"unit\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    jvm_execute_func [this, a_ref];\n    jvm_array_is a_ref {{ [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] : [10][32] }};\n  }\n  abc;\n\nclear_ms <-\njvm_verify c \"clear\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    jvm_execute_func [this, a_ref];\n    jvm_array_is a_ref {{ zero : [10][32] }};\n  }\n  abc;\n\nsum_ms <-\njvm_verify c \"sum\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    a <- jvm_fresh_var \"a\" (java_array 10 java_int);\n    jvm_array_is a_ref a;\n    jvm_execute_func [this, a_ref];\n    jvm_return (jvm_term {{ sum a }});\n  }\n  abc;\n\ncomp_ms <-\njvm_verify c \"comp\" [unit_ms] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    jvm_execute_func [this, a_ref];\n    jvm_array_is a_ref {{ [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] : [10][32] }};\n  }\n  abc;\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/java\/alloc.saw","filetype":"saw","content":"c <- java_load_class \"Alloc\";\n\njvm_verify c \"alloc\" [] false\n  do {\n    this <- jvm_alloc_object \"Alloc\";\n    dst_ref <- jvm_alloc_array 10 java_int;\n    src_ref <- jvm_alloc_array 10 java_int;\n    src <- jvm_fresh_var \"src\" (java_array 10 java_int);\n    jvm_array_is src_ref src;\n    jvm_execute_func [this, dst_ref, src_ref];\n    jvm_array_is src_ref src;\n    jvm_array_is dst_ref src;\n  }\n  abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/java\/java_add.saw","filetype":"saw","content":"c <- java_load_class \"Add\";\n\nlet {{\n  add : [32] -> [32] -> [32]\n  add x y = x + y\n}};\n\nms <-\n  jvm_verify c \"add\" [] false\n    do {\n      this <- jvm_alloc_object \"Add\";\n      x <- jvm_fresh_var \"x\" java_int;\n      y <- jvm_fresh_var \"y\" java_int;\n      jvm_execute_func [this, jvm_term x, jvm_term y];\n      jvm_return (jvm_term {{ add x y }});\n    }\n    do {\n      unfolding [\"add\"];\n      z3;\n    };\n\nms' <-\n  jvm_verify c \"dbl\" [ms] false\n    do {\n      this <- jvm_alloc_object \"Add\";\n      x <- jvm_fresh_var \"x\" java_int;\n      jvm_execute_func [this, jvm_term x];\n      jvm_return (jvm_term {{ add x x }});\n    }\n    z3;\n\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/java\/staticfield.saw","filetype":"saw","content":"c <- java_load_class \"sfield.StaticField\";\n\nms_setx <-\n  jvm_verify c \"setx\" [] false\n    do {\n      newx <- jvm_fresh_var \"newx\" java_int;\n      jvm_execute_func [jvm_term newx];\n      jvm_static_field_is \"sfield\/StaticField.x\" (jvm_term newx);\n    }\n    abc;\n\nms_getx <-\n  jvm_verify c \"getx\" [] false\n    do {\n      x <- jvm_fresh_var \"newx\" java_int;\n      jvm_static_field_is \"sfield\/StaticField.x\" (jvm_term x);\n      jvm_execute_func [];\n      jvm_return (jvm_term x);\n    }\n    abc;\n\nprint \"Done.\";\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/java\/get.saw","filetype":"saw","content":"c <- java_load_class \"Get\";\n\njvm_verify c \"get\" [] false\n  do {\n    this <- jvm_alloc_object \"Get\";\n    a <- jvm_alloc_array 4 java_int;\n    j <- jvm_fresh_var \"j\" java_int;\n    jvm_precond {{ j <= 3 }};\n    jvm_execute_func [this, a, jvm_term j];\n    jvm_modifies_array a;\n    jvm_return (jvm_term {{ j }});\n  }\n  abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/java\/fields.saw","filetype":"saw","content":"c <- java_load_class \"Fields\";\n\nms_setx <-\njvm_verify c \"setx\" [] false\n  do {\n    this <- jvm_alloc_object \"Fields\";\n    newx <- jvm_fresh_var \"newx\" java_int;\n    jvm_execute_func [this, jvm_term newx];\n    jvm_field_is this \"x\" (jvm_term newx);\n  }\n  abc;\n\nms_sety <-\njvm_verify c \"sety\" [] false\n  do {\n    this <- jvm_alloc_object \"Fields\";\n    newy <- jvm_fresh_var \"newy\" java_long;\n    jvm_execute_func [this, jvm_term newy];\n    jvm_field_is this \"y\" (jvm_term newy);\n  }\n  abc;\n\nms_unitx <-\njvm_verify c \"unitx\" [] false\n  do {\n    this <- jvm_alloc_object \"Fields\";\n    jvm_execute_func [this];\n    jvm_field_is this \"x\" (jvm_term {{ 1 : [32] }});\n  }\n  abc;\n\nms_unity <-\njvm_verify c \"unity\" [] false\n  do {\n    this <- jvm_alloc_object \"Fields\";\n    jvm_execute_func [this];\n    jvm_field_is this \"y\" (jvm_term {{ 1 : [64] }});\n  }\n  abc;\n\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/java\/return.saw","filetype":"saw","content":"c <- java_load_class \"Return\";\n\nlet fill_spec =\n  do {\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_execute_func [jvm_term x];\n    aref <- jvm_alloc_array 5 java_int;\n    jvm_array_is aref {{ [x, x, x, x, x] }};\n    jvm_return aref;\n  };\n\nfill_ov <- jvm_verify c \"fill\" [] false fill_spec abc;\njvm_verify c \"fillwrap\" [fill_ov] false fill_spec abc;\n\nlet newSimple_spec =\n  do {\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [jvm_term x, jvm_term y];\n    ref <- jvm_alloc_object \"SimpleObj\";\n    jvm_field_is ref \"x\" (jvm_term x);\n    jvm_field_is ref \"y\" (jvm_term y);\n    jvm_return ref;\n  };\n\nnewSimple_ov <- jvm_verify c \"newSimple\" [] false newSimple_spec abc;\njvm_verify c \"newSimpleWrap\" [newSimple_ov] false newSimple_spec abc;\n\njvm_verify c \"newSimpleWrap2\" [newSimple_ov] false\n  do {\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ 2 : [32] }});\n  }\n  abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/java\/java_types.saw","filetype":"saw","content":"set_base 16;\n\nc <- java_load_class \"JavaTypes\";\n\nlet set_spec fname ty =\n  do {\n    this <- jvm_alloc_object \"JavaTypes\";\n    x <- jvm_fresh_var \"x\" ty;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this fname (jvm_term x);\n  };\n\nlet get_spec fname ty =\n  do {\n    this <- jvm_alloc_object \"JavaTypes\";\n    x <- jvm_fresh_var \"x\" ty;\n    jvm_field_is this fname (jvm_term x);\n    jvm_execute_func [this];\n    jvm_return (jvm_term x);\n  };\n\nlet aset_spec fname len ty =\n  do {\n    this <- jvm_alloc_object \"JavaTypes\";\n    aref <- jvm_alloc_array len ty;\n    jvm_execute_func [this, aref];\n    jvm_field_is this fname aref;\n  };\n\nlet aget_spec fname len ty =\n  do {\n    this <- jvm_alloc_object \"JavaTypes\";\n    aref <- jvm_alloc_array len ty;\n    jvm_field_is this fname aref;\n    jvm_execute_func [this];\n    jvm_return aref;\n  };\n\nlet verify_set mname fname ty = jvm_verify c mname [] false (set_spec fname ty) abc;\nlet verify_get mname fname ty = jvm_verify c mname [] false (get_spec fname ty) abc;\nlet verify_aset mname fname n ty = jvm_verify c mname [] false (aset_spec fname n ty) abc;\nlet verify_aget mname fname n ty = jvm_verify c mname [] false (aget_spec fname n ty) abc;\n\nverify_set \"bool_set\"  \"boolfld\" java_bool;\nverify_set \"byte_set\"  \"bfld\" java_byte;\nverify_set \"char_set\"  \"cfld\" java_char;\nverify_set \"short_set\" \"sfld\" java_short;\nverify_set \"int_set\"   \"ifld\" java_int;\nverify_set \"long_set\"  \"lfld\" java_long;\n\nverify_get \"bool_get\"  \"boolfld\" java_bool;\nverify_get \"byte_get\"  \"bfld\" java_byte;\nverify_get \"char_get\"  \"cfld\" java_char;\nverify_get \"short_get\" \"sfld\" java_short;\nverify_get \"int_get\"   \"ifld\" java_int;\nverify_get \"long_get\"  \"lfld\" java_long;\n\nverify_aset \"bool_aset\"  \"boolafld\" 4 java_bool;\nverify_aset \"byte_aset\"  \"bafld\" 4 java_byte;\nverify_aset \"char_aset\"  \"cafld\" 4 java_char;\nverify_aset \"short_aset\" \"safld\" 4 java_short;\nverify_aset \"int_aset\"   \"iafld\" 4 java_int;\nverify_aset \"long_aset\"  \"lafld\" 4 java_long;\n\nverify_aget \"bool_aget\"  \"boolafld\" 4 java_bool;\nverify_aget \"byte_aget\"  \"bafld\" 4 java_byte;\nverify_aget \"char_aget\"  \"cafld\" 4 java_char;\nverify_aget \"short_aget\" \"safld\" 4 java_short;\nverify_aget \"int_aget\"   \"iafld\" 4 java_int;\nverify_aget \"long_aget\"  \"lafld\" 4 java_long;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/java\/classtype.saw","filetype":"saw","content":"c <- java_load_class \"ClassType\";\n\njvm_verify c \"id\" [] false\n  do {\n    this <- jvm_alloc_object \"ClassType\";\n    x_ref <- jvm_alloc_object \"java.lang.Object\";\n    jvm_execute_func [this, x_ref];\n    jvm_return (jvm_term {{ 0 : [32] }});\n  }\n  abc;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/java\/arrayfield.saw","filetype":"saw","content":"c <- java_load_class \"ArrayField\";\n\njvm_verify c \"init\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayField\";\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_execute_func [this, jvm_term x];\n    na <- jvm_alloc_array 5 java_int;\n    jvm_field_is this \"a\" na;\n    jvm_array_is na {{ [x, x, x, x, x] }};\n  }\n  abc;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/chacha20\/chacha20.saw","filetype":"saw","content":"enable_deprecated;\nimport \"..\/..\/deps\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/chacha20.cry\" as chacha20;\n\nprint \"loading LLVM bitcode...\";\nmod <- llvm_load_module \"chacha20.bc\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet i8 = llvm_int 8;\nlet i32 = llvm_int 32;\n\nlet stream_spec len = do {\n  outp <- llvm_alloc (llvm_array len i8);\n  (key, keyp) <- ptr_to_fresh \"key\" (llvm_array 32 i8);\n  (nonce, noncep) <- ptr_to_fresh \"nonce\" (llvm_array 12 i8);\n  counter <- llvm_fresh_var \"counter\" i32;\n\n  llvm_execute_func [ outp\n                    , llvm_term {{ `len : [64] }}\n                    , llvm_term counter\n                    , noncep\n                    , keyp\n                    ];\n\n  llvm_points_to outp (llvm_term {{ chacha20::stream key counter nonce : [len][8] }});\n};\n\nprint \"running verification...\";\ntime (llvm_verify mod \"crypto_stream_chacha20\" [] true (stream_spec 256) abc);\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/chacha20\/chacha20-crucible.saw","filetype":"saw","content":"import \"..\/..\/deps\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/chacha20.cry\" as chacha20;\n\n\/\/ Allocate a pointer of type 'ty', referring to the value 'v'\nlet alloc_init ty v = do {\n  p <- llvm_alloc ty;\n  llvm_points_to p v;\n  return p;\n};\n\n\/\/ Allocate a pointer to a fresh symbolic value\n\/\/ Returns a pair of the symbolic variable and the pointer\nlet ptr_to_fresh n ty = do {\n  x <- llvm_fresh_var n ty;\n  p <- alloc_init ty (llvm_term x);\n  return (x, p);\n};\n\nlet chacha20_setup = do {\n\n\/* The signature of chacha20:\nint\ncrypto_stream_chacha20(unsigned char* out,\n                       unsigned long long olen,\n                       unsigned int counter,\n                       const unsigned char* nonce,\n                       const unsigned char* key)\n*\/\n\n  (_, out_p)       <- ptr_to_fresh       \"out\"     (llvm_array 256 (llvm_int 8));\n  let olen         =                                            {{ 256 : [64] }};\n  counter          <- llvm_fresh_var     \"counter\"                 (llvm_int 32);\n  (nonce, nonce_p) <- ptr_to_fresh       \"nonce\"   (llvm_array 12  (llvm_int 8));\n  (key, key_p)     <- ptr_to_fresh       \"key\"     (llvm_array 32  (llvm_int 8));\n\n  \/\/ symbolically executing the function\n\n  llvm_execute_func\n    [ out_p\n    , llvm_term olen\n    , llvm_term counter\n    , nonce_p\n    , key_p\n    ];\n\n  \/\/ assert the specification\n\n  let spec_result =\n    llvm_term {{ chacha20::stream key counter nonce : [256][8] }};\n\n  llvm_points_to out_p spec_result;\n\n};\n\nprint \"Loading LLVM bitcode...\";\nmod <- llvm_load_module \"chacha20.bc\";\n\nlet solver = abc;\n\nprint \"Testing equality...\";\ntime (llvm_verify mod \"crypto_stream_chacha20\" [] false chacha20_setup solver);\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/ghost\/ghost.saw","filetype":"saw","content":"let next_spec counter : CrucibleSetup () = do {\n  n <- llvm_fresh_var \"n\" (llvm_int 32);\n  llvm_ghost_value counter n;\n  llvm_execute_func [];\n  llvm_ghost_value counter {{n+1}};\n  llvm_return (llvm_term {{n}});\n};\n\nlet example_spec counter : CrucibleSetup () = do {\n  n <- llvm_fresh_var \"nm\" (llvm_int 32);\n  llvm_precond {{n < 2}};\n  llvm_ghost_value counter n;\n  llvm_execute_func [];\n  llvm_ghost_value counter {{n+3}};\n  llvm_return (llvm_term {{n+2}});\n};\n\nlet main : TopLevel () = do {\n    counter <- declare_ghost_state \"ctr\";\n\n    m <- llvm_load_module \"simple.bc\";\n    next <- llvm_unsafe_assume_spec m \"next\" (next_spec counter);\n    llvm_verify m \"example\" [next] false (example_spec counter)\n                (do { print_goal; z3;} );\n    print \"done\";\n};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/salsa20\/salsa.saw","filetype":"saw","content":"import \"Salsa20.cry\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p (llvm_term v);\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty x;\n    return (x, p);\n};\n\nlet oneptr_update_func n ty f = do {\n    (x, p) <- ptr_to_fresh n ty;\n    llvm_execute_func [p];\n    llvm_points_to p (llvm_term {{ f x }});\n};\n\nlet quarterround_setup : CrucibleSetup () = do {\n        y0 <- llvm_fresh_var \"y0\" (llvm_int 32);\n    y1 <- llvm_fresh_var \"y1\" (llvm_int 32);\n    y2 <- llvm_fresh_var \"y2\" (llvm_int 32);\n    y3 <- llvm_fresh_var \"y3\" (llvm_int 32);\n    p0 <- alloc_init (llvm_int 32) {{ y0 }};\n    p1 <- alloc_init (llvm_int 32) {{ y1 }};\n    p2 <- alloc_init (llvm_int 32) {{ y2 }};\n    p3 <- alloc_init (llvm_int 32) {{ y3 }};\n\n    llvm_execute_func [p0, p1, p2, p3];\n\n    let zs = {{ quarterround [y0,y1,y2,y3] }};\n    llvm_points_to p0 (llvm_term {{ zs@0 }});\n    llvm_points_to p1 (llvm_term {{ zs@1 }});\n    llvm_points_to p2 (llvm_term {{ zs@2 }});\n    llvm_points_to p3 (llvm_term {{ zs@3 }});\n};\n\nlet rowround_setup =\n  oneptr_update_func \"y\" (llvm_array 16 (llvm_int 32)) {{ rowround }};\n\nlet columnround_setup =\n  oneptr_update_func \"x\" (llvm_array 16 (llvm_int 32)) {{ columnround }};\n\nlet doubleround_setup =\n  oneptr_update_func \"x\" (llvm_array 16 (llvm_int 32)) {{ doubleround }};\n\nlet salsa20_setup =\n  oneptr_update_func \"seq\" (llvm_array 64 (llvm_int 8)) {{ Salsa20 }};\n\nlet salsa20_djb_setup = do {\n    (input, ip) <- ptr_to_fresh \"input\" (llvm_array 16 (llvm_int 32));\n    (_, op) <- ptr_to_fresh \"output\" (llvm_array 64 (llvm_int 8));\n    llvm_execute_func [op, ip];\n    llvm_points_to op (llvm_term {{\n        Salsa20 (join [ littleendian_inverse x | x <- input ])\n    }});\n};\n\nlet salsa20_expansion_32 = do {\n        k <- llvm_fresh_var \"k\" (llvm_array 32 (llvm_int 8));\n    pk <- llvm_alloc_readonly (llvm_array 32 (llvm_int 8));\n    llvm_points_to pk (llvm_term k);\n    n <- llvm_fresh_var \"n\" (llvm_array 16 (llvm_int 8));\n    pn <- llvm_alloc_readonly (llvm_array 16 (llvm_int 8));\n    llvm_points_to pn (llvm_term n);\n    pks <- llvm_alloc (llvm_array 64 (llvm_int 8));\n    llvm_execute_func [pk, pn, pks];\n    let rks = {{ Salsa20_expansion`{a=2}(k, n)}};\n    llvm_points_to pks (llvm_term rks);\n};\n\nlet s20_encrypt32 n = do {\n    (key, pkey) <- ptr_to_fresh \"key\" (llvm_array 32 (llvm_int 8));\n    (v, pv) <- ptr_to_fresh \"nonce\" (llvm_array 8 (llvm_int 8));\n    (m, pm) <- ptr_to_fresh \"buf\" (llvm_array n (llvm_int 8));\n    llvm_execute_func [ pkey\n                      , pv\n                      , llvm_term {{ 0 : [32] }}\n                      , pm\n                      , llvm_term {{ `n : [32] }}\n                      ];\n    llvm_points_to pm (llvm_term {{ Salsa20_encrypt (key, v, m) }});\n    llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nlet main : TopLevel () = do {\n    m      <- llvm_load_module \"salsa20.bc\";\n    qr     <- llvm_verify m \"s20_quarterround\" []      false quarterround_setup   yices;\n    rr     <- llvm_verify m \"s20_rowround\"     [qr]    false rowround_setup       yices;\n    cr     <- llvm_verify m \"s20_columnround\"  [qr]    false columnround_setup    yices;\n    dr     <- llvm_verify m \"s20_doubleround\"  [cr,rr] false doubleround_setup    yices;\n    s20    <- llvm_verify m \"s20_hash\"         [dr]    false salsa20_setup        yices;\n    s20e32 <- llvm_verify m \"s20_expand32\"     [s20]   true  salsa20_expansion_32 yices;\n    s20encrypt_63 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 63) yices;\n    s20encrypt_64 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 64) yices;\n    s20encrypt_65 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 65) yices;\n\n    djb    <- llvm_load_module \"djb\/salsa20.bc\";\n    s20djb <- llvm_verify djb \"salsa20_wordtobyte\" [] false salsa20_djb_setup     w4_abc_verilog;\n    print \"Done!\";\n};\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/allsat\/allsat_print.saw","filetype":"saw","content":"\/\/ Print all the satisfying assignments for a boolean predicate.\n\/\/\n\/\/ Only works for uncurried predicates, because I don't know\n\/\/ how to write the \"exclude the current solution\" predicate\n\/\/ refinement\n\/\/\n\/\/   \\x -> x != s && p x\n\/\/\n\/\/ for curried predicates 'p'.\n\nrec allsat_print p = do {\n  r <- sat abc p;\n  caseSatResult r\n    (print \"Done!\")\n    (\\s -> do {\n      print s;\n      allsat_print {{ \\x -> x != s \/\\ p x }};\n    });\n};\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/sequential_aigs\/fib.cry","filetype":"cry","content":"import StateMachine\n\n\/\/ Fibonacci state iterators with different state but same output\n\/\/ sequence: 8-bit Fibonacci numbers.\n\/\/\n\/\/ The state transitions, ignoring bit widths, are\n\/\/\n\/\/   (0, (0, 0, 0))       |-> (0, (1, 0, 1))\n\/\/\n\/\/ and\n\/\/\n\/\/   (0, (1, fn, f(n+1))) |-> (fn, (1, f(n+1), f(n+2)))\n\/\/\n\/\/ where 'fn' denotes the 'n'th Fibonacci number.\n\/\/\n\/\/ The first bit of the states indicates whether it's the first\n\/\/ step or not; the sequential circuit gets seeded with all zero\n\/\/ bits.\n\nfib1_no_init : ([1], ([8], [8])) -> ([8], ([8], [8]))\nfib1_no_init (_, (fn, fn1)) = (fn, (fn1, fn2))\n  where\n  fn2 = fn + fn1\n\nfib1 = init_with (0, 1) fib1_no_init\nfib1_state_bits = 1 + 8 + 8 : [8]\n\nfib2 : ([1], ([1], [16], [16])) -> ([8], ([1], [16], [16]))\nfib2 (_, (start, fn , fn1)) = (fn', (1, fn1', fn2))\n  where\n  \/\/ Some (at least Cryptol level) obfuscation.\n  fn1' = (zero # start) * fn1 + (zero # ~start)\n  fn2 = fn + fn1'\n  fn' = drop`{8} fn\n\nfib2_state_bits = 1 + 16 + 16 : [8]\n\n\/\/ Make a buggy version of fib state machine which returns wrong value\n\/\/ when state counter has magic value.\n\/\/\n\/\/ If this were a common pattern for example generation, we could\n\/\/ make a \"magic-value bug\" combinator in the style of 'init_with'.\nmk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n  \/\/ Change output when state has magic value.\n  fn' = fn + (if k == magic then 1 else 0)\n\nmk_buggy_fib magic = init_with (0, 1, 0) (mk_buggy_fib_no_init magic)\ncount_buggy_state_bits : {a} (fin a, width a <= 7) => [a] -> [8]\ncount_buggy_state_bits magic = 1 + 8 + 8 + `a\n\n\/\/ 4-bit counter\nbuggy_fib4_magic = 0xf\nbuggy_fib4 = mk_buggy_fib buggy_fib4_magic\nbuggy_fib4_state_bits = count_buggy_state_bits buggy_fib4_magic\n\n\/\/ 8-bit counter\nbuggy_fib8_magic = 0xff\nbuggy_fib8 = mk_buggy_fib buggy_fib8_magic\nbuggy_fib8_state_bits = count_buggy_state_bits buggy_fib8_magic\n\n\/\/ 12-bit counter\nbuggy_fib12_magic = 0b111111111111\nbuggy_fib12 = mk_buggy_fib buggy_fib12_magic\nbuggy_fib12_state_bits = count_buggy_state_bits buggy_fib12_magic\n\n\/\/ 16-bit counter\nbuggy_fib16_magic = 0xffff\nbuggy_fib16 = mk_buggy_fib buggy_fib16_magic\nbuggy_fib16_state_bits = count_buggy_state_bits buggy_fib16_magic\n\n\/\/ 32-bit counter\nbuggy_fib32_magic = 0xffffffff\nbuggy_fib32 = mk_buggy_fib buggy_fib32_magic\nbuggy_fib32_state_bits = count_buggy_state_bits buggy_fib32_magic\n\n\/\/ 64-bit counter\nbuggy_fib64_magic = 0xffffffffffffffff\nbuggy_fib64 = mk_buggy_fib buggy_fib64_magic\nbuggy_fib64_state_bits = count_buggy_state_bits buggy_fib64_magic\n\n\n\/\/ Tests.\ninputs : [1000][1]\ninputs = zero\n\ntest = equiv fib1 fib2 inputs\n\n\/\/ The states sequences.\nstates1 = exec fib1 inputs\nstates2 = exec fib2 inputs\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/sequential_aigs\/CipherMode.cry","filetype":"cry","content":"module CipherMode where\n\n\/\/ Block-cipher modes of operation.\n\/\/\n\/\/ A mode turns a block transformer into a stream-of-blocks\n\/\/ transformer. In some cases, the stream-of-blocks transformer is\n\/\/ also a stream-of-bits transformer, e.g. for the one-time-pad-style\n\/\/ modes (CFB, OFB, and CTR below).\n\/\/\n\/\/ http:\/\/en.wikipedia.org\/wiki\/Block_cipher_mode_of_operation .\n\nimport StateMachine\n\n\/\/ Block cipher over 'k'-bit keys and 'n'-bit blocks.\n\/\/\n\/\/ We don't actually care about encryption, so these are actually just\n\/\/ keyed block transformers.\ntype BC k n = [k] -> [n] -> [n]\n\n\/\/ Electronic Code Book mode.\necb : {k, n} BC k n -> SM ([k], [n]) [n] (Bool, [k])\necb bc = init i sm\n  where\n  sm : SM [n] [n] [k]\n  sm (block, key) = (ct, key)\n    where\n    ct = bc key block\n  i : [k] -> [k]\n  i key = key\n\n\/\/ Cipher-Block Chaining mode.\ncbc : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\ncbc bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key (state ^ block)\n    state' = ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\n\/\/ Propagating CBC mode.\npcbc : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\npcbc bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key (state ^ block)\n    state' = block ^ ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\n\/\/ Cipher FeedBack mode.\ncfb : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\ncfb bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key state ^ block\n    state' = ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\n\/\/ Output FeedBack mode.\nofb : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\nofb bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    state' = bc key state\n    ct = state' ^ block\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\n\/\/ CounTer Mode.\nctr : {k, n} (fin n, n >= 1) =>\n  BC k (2*n) -> SM (([k], [n]), [2*n]) [2*n] (Bool, ([k], [n], [n]))\nctr bc = init i sm\n  where\n  sm : SM [2*n] [2*n] ([k], [n], [n])\n  sm (block, (key, iv, counter)) = (ct, (key, iv, counter + 1))\n    where\n    ct = bc key (iv # counter) ^ block\n  i : ([k], [n]) -> ([k], [n], [n])\n  i (key, iv) = (key, iv, 0)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/sequential_aigs\/exp.cry","filetype":"cry","content":"\/\/ Compare exponentiation implementations using SAIGs.\n\nimport StateMachine\n\n\/\/ Linear number of multiplications.\n\/*\nr = 1\nwhile p > 0:\n  r *= x\n  --p\nreturn r\n*\/\nexp_ref : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) (Bool, [m]) (Bool, ([m], [n], [m]))\nexp_ref = mk_loop (\\(x, p) -> (x, p, 1)) body\n  where\n  body : Body [m] ([m], [n], [m])\n  body (x, p', r) =\n    if p' == 0\n    then ((True, r), (x, p', r))\n    else ((False, zero), (x, p' - 1, r * x))\n\n\/\/ Logarithmic number of multiplications.\n\/*\nr = 1\nwhile p > 0:\n  if p & 1:\n    r *= x\n  x *= x\n  p >>= 1\nreturn r\n*\/\nexp_opt : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) (Bool, [m]) (Bool, ([m], [n], [m]))\nexp_opt = mk_loop (\\(x, p) -> (x, p, 1)) body\n  where\n  body : Body [m] ([m], [n], [m])\n  body (x', p', r) =\n    if p' == 0\n    then ((True, r), (x', p', r))\n    else ((False, zero), (x' * x', p' >> 1, r'))\n      where\n      r' = if (p' && 1) != 0\n           then r * x'\n           else r\n\nsynced_exp : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  [1] -> SM ([m], [n]) (Bool, [m]) ((Bool, ([m], [n], [m])), (Bool, ([m], [n], [m])))\nsynced_exp bias = sync_loops bias exp_ref exp_opt\n\nmitered_exp : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) Bool ((Bool, ([m], [n], [m])), (Bool, ([m], [n], [m])))\nmitered_exp = miter_loops exp_ref exp_opt\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/sequential_aigs\/StateMachine.cry","filetype":"cry","content":"module StateMachine where\n\n\/\/ A state machine is function of type '(i, s) -> (o, s)',\n\/\/ with input type 'i', state type 's', and output type 'o'.\ntype SM i o s = (i, s) -> (o, s)\n\n\/\/ To run a state machine for 'n' steps, a sequence of 'n'\n\/\/ input values must be provided; the initial state is always\n\/\/ seeded with 'zero : s'.\nrun : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](o,s)\nrun sm is = oss\n  where\n  states = [zero] # [ os.1 | os <- oss ]\n  oss = [ sm (i, s) | i <- is | s <- states ]\n\neval : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](o)\neval sm is = [ os.0 | os <- run sm is ]\n\nexec : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](s)\nexec sm is = [ os.1 | os <- run sm is ]\n\n\/\/ Two state machines are equivalent if their output streams agree\n\/\/ on all input streams. This function checks equivalence at specific\n\/\/ finite input sequences.\nequiv : {n, i, s1, s2, o} (Cmp o, fin n, Zero s1, Zero s2)\n     => SM i o s1 -> SM i o s2 -> [n]i -> Bool\nequiv sm1 sm2 is = all [ o1 == o2 | o1 <- eval sm1 is | o2 <- eval sm2 is ]\n  where\n  all : {m} (fin m) => [m]Bool -> Bool\n  all xs = its ! 0\n    where\n    its = [True] # [ x && it | x <- xs | it <- its ]\n\n\/\/ Because the initial state is always seeded with 'zero : s', it's\n\/\/ common to have boilerplate code which sets up the \"real\" initial state.\n\/\/ This combinator takes the place of that boilerplate.\ninit_with : {i, o, s} s -> SM i o s -> SM i o (Bool, s)\ninit_with s_initial sm (i, (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else s_initial\n  (o, s'') = sm (i, s')\n\n\/\/ A more general initializer which unifies 'init_with' above and\n\/\/ 'mk_loop' below.\n\/\/\n\/\/ The function 'mk_s_initial' computes the initial state from the\n\/\/ first type-'a' input to the state machine, where the input type 'i'\n\/\/ has been extended with initializer input type 'a' to '(a, i)'.\n\/\/ Note that all type-'a' inputs after the first will be ignored, so\n\/\/ this could cause unnecessary work for the prover (e.g. ABC) if it's\n\/\/ unable to realize that these inputs are irrelevant.\ninit : {a, i, o, s}\n  (a -> s) -> SM i o s -> SM (a, i) o (Bool, s)\ninit mk_s_initial sm ((a, i), (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else mk_s_initial a\n  (o, s'') = sm (i, s')\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Miters.\n\/\/\n\/\/ The HWMCC (Hardware Model Checking Competition) provers consider\n\/\/ AIG outputs to represent \"safety properties\" which are \"violated\"\n\/\/ when the output bit is 1. If the circuit has multiple output bits,\n\/\/ then each one is considered a separate safety property. Some\n\/\/ provers, e.g. tip, will attempt to prove each property separately.\n\n\/\/ Miter two statemachines for lock-step equivalence. See also\n\/\/ 'miter_loops' below for an eventual-equivalence miter for loops.\nmiter : {i, o, s1, s2} (Cmp o) =>\n  SM i o s1 -> SM i o s2 -> SM i Bool (s1, s2)\nmiter sm1 sm2 (i, (s1, s2)) = (o, (s1', s2'))\n  where\n  (o1, s1') = sm1 (i, s1)\n  (o2, s2') = sm2 (i, s2)\n  o = o1 != o2\n\n\/\/ For checking equivalence via miters using sequential equivalence\n\/\/ checking: the underlying state machines are equal when their miter\n\/\/ is equal to the const_false state machine.\nconst_false : {i} SM i Bool [1]\nconst_false (_, _) = (False, zero)\n\n\/\/ For comparison to 'const_false' in a miter, to ensure that a given\n\/\/ command works on miters. Some ABC commands, e.g. 'dsec', compare\n\/\/ the current circuit to itself when given only one argument, leading\n\/\/ to false positives when mistakenly using 'dsec' to verify miters.\nconst_true : {i} SM i Bool [1]\nconst_true (_, _) = (True, zero)\n\n\/\/ Pass (the SAIG for) these miters to a verifier to see if it works\n\/\/ on miters.  Create the SAIG with 'write_saig'.\n\/\/\n\/\/ The verification should fail.\nsat_miter : SM [1] Bool ([1], [1])\nsat_miter = miter const_true const_false\n\/\/ The verification should succeed.\nunsat_miter : SM [1] Bool ([1], [1])\nunsat_miter = miter const_true const_true\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Loops.\n\/\/\n\/\/ We can model loops with SAIGs that ignore their input and act like\n\/\/ step functions, producing dummy output until they are done looping,\n\/\/ at which point they produce a constant stream of their result. We\n\/\/ can then compare loops for equivalence by checking they eventually\n\/\/ stabilize to the same constant output stream.\n\n\/\/ A loop has no input, only a state. The output includes a bool\n\/\/ indicating whether the loop has terminated or not.\ntype Body o s = s -> ((Bool, o), s)\n\n\/\/ In order to prove that two loops are equivalent for all initial\n\/\/ states using sequential equivalence checking, we add an input\n\/\/ stream and compute the initial state from the first stream element.\nmk_loop : {i,o,s} (i -> s) -> Body o s -> SM i (Bool, o) (Bool, s)\nmk_loop initializer body (i, (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else initializer i\n  (o, s'') = body s'\n\n\/\/ Run a loop for 'n' steps, seeded with input 'i'.\nrun_loop : {n, i, o, s} (fin n, n >= 1, Zero i, Zero s) =>\n  SM i o s -> i -> [n](o, s)\nrun_loop loop i = run loop ([i] # zero)\n\n\/\/ Sequential equivalence checking (SEC) is lock-step equivalence, so\n\/\/ to compare two loop using SEC we need to ensure that both loops\n\/\/ produce their output in the same step. We can achieve this via a\n\/\/ biased product of streams, which doesn't produce any output until\n\/\/ both internal streams have, at which point it duplicates the stream\n\/\/ it's biased towards.\n\/\/\n\/\/ However, this sounds like a computability theoretic construction --\n\/\/ i.e. it shows something is possible, not that it's feasible in\n\/\/ practice -- and I'm not optimistic that ABC will magically be able\n\/\/ to check the equivalence of such biased joins quickly.\nsync_loops : {i, o, s1, s2} (Zero o) =>\n  [1] -> SM i (Bool, o) s1 -> SM i (Bool, o) s2 -> SM i (Bool, o) (s1, s2)\nsync_loops bias l1 l2 (i, (s1, s2)) = ((done, o'), (s1', s2'))\n  where\n  ((done1, o1), s1') = l1 (i, s1)\n  ((done2, o2), s2') = l2 (i, s2)\n  o = [o1, o2] @ bias\n  done = done1 && done2\n  o' = if done then o else zero\n\n\/\/ Alternatively, we can build a synced miter: run both loops until\n\/\/ they produce output, and then compare the output for equality.  If\n\/\/ two loops are equivalent their miter will be 'const False'.\nmiter_loops : {i, o, s1, s2} (Cmp o) =>\n  SM i (Bool, o) s1 -> SM i (Bool, o) s2 -> SM i Bool (s1, s2)\nmiter_loops l1 l2 (i, (s1, s2)) = (o', (s1', s2'))\n  where\n  ((done1, o1), s1') = l1 (i, s1)\n  ((done2, o2), s2') = l2 (i, s2)\n  done = done1 && done2\n  o' = if done then o1 != o2 else False\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/aes\/aes.saw","filetype":"saw","content":"\/**\n * Cryptol AES property verification.\n *\n * This module efficiently checks that decrypt is the inverse of encrypt.\n *\n * @copyright Galois Inc.\n * @author Eric Mertens <emertens@galois.com>\n *\/\n\nimport \"..\/..\/deps\/cryptol-specs\/Common\/GF28.cry\" as GF28;\nimport \"..\/..\/deps\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES256.cry\";\n\nlet ss0 = cryptol_ss ();\n\nprint \"Verifying that cipher unrolls\";\nunroll_cipher <- prove_print\n    (w4_unint_z3 [\"AddRoundKey\", \"MixColumns\", \"SubBytes\", \"ShiftRows\"])\n    {{ \\w pt -> cipher w pt ==\n    (stateToMsg (AddRoundKey (w@14) (ShiftRows (SubBytes (t 13 (t 12 (t 11 (t 10 (t 9 (t 8 (t 7 (t 6 (t 5 (t 4 (t 3 (t 2 (t 1 (AddRoundKey (w@0) (msgToState pt))))))))))))))))))\n        where\n        t i state = AddRoundKey (w@i) (MixColumns (ShiftRows (SubBytes state))))\n    }};\n\nprint \"Verifying that invCipher unrolls\";\nunroll_invCipher <- prove_print\n    (w4_unint_z3 [\"AddRoundKey\", \"InvMixColumns\", \"InvSubBytes\", \"InvShiftRows\"])\n    {{ \\w ct -> invCipher w ct ==\n    (stateToMsg (AddRoundKey (w@0) (InvSubBytes (InvShiftRows (t 1 (t 2 (t 3 (t 4 (t 5 (t 6 (t 7 (t 8 (t 9 (t 10 (t 11 (t 12 (t 13 (AddRoundKey (w@14) ( msgToState ct))))))))))))))))))\n        where\n        t i state = InvMixColumns (AddRoundKey (w@i) (InvSubBytes (InvShiftRows state))))\n    }};\n\nprint \"Verifying that SBox unfolds\";\n\/* This performance trick is necessary because SAW doesn't memoize sboxTable *\/\nunfold_SBox <- prove_print (unint_z3 [\"inverse\", \"add\", \"rotateR\"])\n  {{ \\i -> (SBox i == GF28::add [b, b >>> 4, b >>> 5, b >>> 6, b >>> 7, 0x63] where b = GF28::inverse i) }};\n\nprint \"Verifying that InvSBox unfolds\";\n\/* This performance trick is necessary because SAW doesn't memoize sboxInvTable *\/\nunfold_SBoxInv <- prove_print (unint_z3 [\"inverse\", \"add\", \"rotateR\"])\n  {{ \\i -> SBoxInv i == GF28::inverse (GF28::add [i >>> 2, i >>> 5, i >>> 7, 0x05]) }};\n\nprint \"Verifying that SBoxInv inverts SBox\";\ninvert_SBox <- prove_print\n    do {\n        simplify (addsimps [unfold_SBox, unfold_SBoxInv] ss0);\n        rme;\n    }\n    {{ \\s -> SBoxInv (SBox s) == s }};\n\nprint \"Verifying that InvSubBytes inverts SubBytes\";\ninvert_SubBytes <- prove_print\n    do {\n        unfolding [\"InvSubBytes\", \"SubBytes\"];\n        simplify (add_prelude_eqs [\"map_map\"] (addsimps [invert_SBox] ss0));\n        rme;\n    }\n    {{ \\s -> InvSubBytes (SubBytes s) == s }};\n\nprint \"Verifying that InvShiftRows inverts ShiftRows\";\ninvert_ShiftRows <- prove_print rme\n    {{ \\s -> InvShiftRows (ShiftRows s) == s }};\n\nprint \"Verifying that InvMixColumns inverts MixColumns\";\ninvert_MixColumns <- prove_print rme\n    {{ \\s -> InvMixColumns (MixColumns s) == s }};\n\nprint \"Verifying that msgToState inverts stateToMsg\";\ninvert_stateToMsg <- prove_print rme {{\\s -> msgToState (stateToMsg s) == s}};\n\nprint \"Verifying that stateToMsg inverts msgToState\";\ninvert_msgToState <- prove_print rme {{\\s -> stateToMsg (msgToState s) == s}};\n\nprint \"Verifying that AddRoundKey is involutive\";\ninvert_AddRoundKey <- prove_print rme\n    {{ \\x y -> AddRoundKey x (AddRoundKey x y) == y }};\n\nprint \"Verifying that invCipher inverts cipher\";\ninvert_cipher <- prove_print do {\n    simplify (addsimps\n        [unroll_cipher, unroll_invCipher, invert_ShiftRows,\n         invert_MixColumns, invert_SubBytes, invert_msgToState,\n         invert_stateToMsg, invert_msgToState, invert_AddRoundKey] ss0);\n    rme;\n   }\n   {{ \\w pt -> invCipher w (cipher w pt) == pt }};\n\nprint \"Verifying that decrypt inverts encrypt\";\nprove_print do {\n    unfolding [\"aesIsCorrect\", \"encrypt\", \"decrypt\"];\n    simplify (addsimps [invert_cipher] ss0);\n    rme;\n   }\n   {{ aesIsCorrect }};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/openssl_aes\/AES128TBox.cry","filetype":"cry","content":"\/\/ Translated from: https:\/\/github.com\/LeventErkok\/sbv\/blob\/ebf80d83d9259fa5ad42d97fdede1ae97323cfa7\/Data\/SBV\/Examples\/Crypto\/AES.hs\n\nmodule AESTBox where\n\ntype GF28 = [8]\ntype Nk = 4\ntype Nb = 4\ntype Nr = 6 + Nk\n\ntype State = [4][Nb * 8]\ntype Key = [Nk][Nb * 8]\ntype RoundKey = State\ntype KS = (RoundKey, [Nr - 1]RoundKey, RoundKey)\n\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y = pmod (pmult x y) <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k =\n  if k == 0 then 1\n  else\n    (if (k && 1) == 1 then gf28Mult n w\n     else w\n       where v = gf28Pow n (k >> 1)\n             w = gf28Mult v v)\n\ntoBytes : [32] -> [4]GF28\ntoBytes x = split`{4} x\n\nfromBytes : [4]GF28 -> [32]\nfromBytes xs = join xs\n\nrotR : [4]GF28 -> [2] -> [4]GF28\nrotR xs n = xs >>> n\n\nroundConstants = take`{16} ([0] # [ gf28Pow 2 (k-1) | k <- [1 ... ] ])\n\nsbox = [ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n         0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n         0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n         0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n         0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n         0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n         0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n         0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n         0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n         0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n         0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n         0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n         0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n         0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n         0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n         0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n         0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n         0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n         0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n         0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n         0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n         0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n         0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n         0x54, 0xbb, 0x16]\n\nunsbox = [ unsboxf i sboxit 0 0 | i <- [ 0 .. 255] ]\n  where sboxit = [ (j, i) | i <- [ 0 .. 255] | j <- sbox ]\n        unsboxf n t i d = if i >= (length t) then d\n                          else (if (k == n) then v\n                                else unsboxf n t (i + 1) d\n                                  where (k, v) = t @ i)\n\naddRoundKey : RoundKey -> State -> State\naddRoundKey k s = k ^ s\n\nkeyExpansion : Key -> [inf]RoundKey\nkeyExpansion key = chop4 keys\n  where keys = key # [nextWord i prev old | i <- [ `Nk ... ] | prev <- drop`{Nk-1} keys | old <- keys]\n        chop4 : {a} [inf]a -> [inf][4]a\n        chop4 xs = split xs\n        subWordRcon : [Nb * 8] -> GF28 -> [Nb * 8]\n        subWordRcon w rc = fromBytes [a ^ rc, b, c, d]\n          where [a, b, c, d] = [ sbox @ i | i <- toBytes w ]\n        nextWord : [8] -> [Nb * 8] -> [Nb * 8] -> [Nb * 8]\n        nextWord i prev old = old ^\n          (if (i % `Nk) == 0 then subWordRcon (join (split`{4} prev <<< 1)) (roundConstants @ (i \/ `Nk))\n           else if (i % `Nk) == 4 \/\\ `Nk > 6 then subWordRcon prev 0\n           else prev)\n\nmETable = [ gf28Mult 0x0E i | i <- [ 0 .. 255 ] ]\nmBTable = [ gf28Mult 0x0B i | i <- [ 0 .. 255 ] ]\nmDTable = [ gf28Mult 0x0D i | i <- [ 0 .. 255 ] ]\nm9Table = [ gf28Mult 0x09 i | i <- [ 0 .. 255 ] ]\nmE i = mETable @ i\nmB i = mBTable @ i\nmD i = mDTable @ i\nm9 i = m9Table @ i\ntables = [ [mE, mB, mD, m9],\n           [m9, mE, mB, mD],\n           [mD, m9, mE, mB],\n           [mB, mD, m9, mE] ]\n\ninvMixColumns : State -> State\ninvMixColumns state = [ fromBytes ce | ce <- transpose (mmult [ toBytes se | se <- state ]) ]\n  where dollar f x = f x\n        dot f fs =  foldr1 (^) (zipWith dollar f fs)\n        mmult n = [ [ (dot r) ne | ne <- n ] | r <- tables ]\n\naesEncryptKeySchedule : Key -> KS\naesEncryptKeySchedule key = (rKeys @ 0, m, rKeys @ `Nr)\n  where rKeys = keyExpansion key\n        m = take`{Nr-1}(tail rKeys)\n\naesDecryptKeySchedule : Key -> KS\naesDecryptKeySchedule key = (rKeys @ `Nr, m, rKeys @ 0)\n  where rKeys = keyExpansion key\n        m = [ invMixColumns k | k <- reverse (take`{Nr-1}(tail rKeys)) ]\n\ndoRounds : {a, b} (fin b) => (Bit -> State -> a -> State) -> (RoundKey, [b]a, a) -> State -> State\ndoRounds rnd (ikey, rkeys, fkey) sIn = rnd True (rs ! 0) fkey\n  where s0 = addRoundKey ikey sIn\n        rs = [s0] # [ rnd False s k | s <- rs | k <- rkeys ]\n\nt0Func : GF28 -> [4]GF28\nt0Func a = [gf28Mult s 2, s, s, gf28Mult s 3] where s = sbox @ a\nt0 = [fromBytes (t0Func a) | a <- [0..255]]\nt1 = [fromBytes (rotR (t0Func a) 1) | a <- [0..255]]\nt2 = [fromBytes (rotR (t0Func a) 2) | a <- [0..255]]\nt3 = [fromBytes (rotR (t0Func a) 3) | a <- [0..255]]\n\naesRound : Bit -> State -> RoundKey -> State\naesRound isFinal s key = addRoundKey d key\n  where d = [ f isFinal i | i <- [ 0 .. 3] ]\n        a = [ toBytes se | se <- s ]\n        f b j = if b then\n                  fromBytes [ sbox @ (a @ ((j+0) % 4) @ 0),\n                              sbox @ (a @ ((j+1) % 4) @ 1),\n                              sbox @ (a @ ((j+2) % 4) @ 2),\n                              sbox @ (a @ ((j+3) % 4) @ 3) ]\n                else\n                  e0 ^ e1 ^ e2 ^ e3\n                    where e0 = t0 @ (a @ ((j+0) % 4) @ 0)\n                          e1 = t1 @ (a @ ((j+1) % 4) @ 1)\n                          e2 = t2 @ (a @ ((j+2) % 4) @ 2)\n                          e3 = t3 @ (a @ ((j+3) % 4) @ 3)\n\n\nu0Func : GF28 -> [4]GF28\nu0Func a = [gf28Mult s 0x0E, gf28Mult s 0x09, gf28Mult s 0x0D, gf28Mult s 0x0B] where s = unsbox @ a\nu0 = [fromBytes (u0Func a) | a <- [0..255]]\nu1 = [fromBytes (rotR (u0Func a) 1) | a <- [0..255]]\nu2 = [fromBytes (rotR (u0Func a) 2) | a <- [0..255]]\nu3 = [fromBytes (rotR (u0Func a) 3) | a <- [0..255]]\n\naesInvRound : Bit -> State -> RoundKey -> State\naesInvRound isFinal s key = addRoundKey d key\n  where d = [ f isFinal i | i <- [ 0 .. 3] ]\n        a = [ toBytes se | se <- s ]\n        f b j = if b then\n                  fromBytes [ unsbox @ (a @ ((j+0) % 4) @ 0),\n                              unsbox @ (a @ ((j+3) % 4) @ 1),\n                              unsbox @ (a @ ((j+2) % 4) @ 2),\n                              unsbox @ (a @ ((j+1) % 4) @ 3) ]\n                else\n                  e0 ^ e1 ^ e2 ^ e3\n                    where e0 = u0 @ (a @ ((j+0) % 4) @ 0)\n                          e1 = u1 @ (a @ ((j+3) % 4) @ 1)\n                          e2 = u2 @ (a @ ((j+2) % 4) @ 2)\n                          e3 = u3 @ (a @ ((j+1) % 4) @ 3)\n\naesEncrypt pt key = doRounds aesRound (aesEncryptKeySchedule key) pt\n\naesDecrypt ct key = doRounds aesInvRound (aesDecryptKeySchedule key) ct\n\n\/\/ Test for Nk == 4 (AES128); comment out the next two properties if Nk != 4\nproperty t128EncTest = aesEncrypt pt k == [0x69c4e0d8, 0x6a7b0430, 0xd8cdb780, 0x70b4c55a]\n  where pt = [ 0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff ]\n        k = [ 0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f ]\n\nproperty t128DecTest = aesDecrypt ct k == [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n  where ct = [ 0x69c4e0d8, 0x6a7b0430, 0xd8cdb780, 0x70b4c55a ]\n        k = [ 0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f ]\n\n\/*\n\/\/ Test for Nk == 6 (AES192); comment out the next two properties if Nk != 6\nproperty t192EncTest = aesEncrypt pt k == [0xdda97ca4, 0x864cdfe0, 0x6eaf70a0, 0xec0d7191]\n  where pt = [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n        k = [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617]\n\nproperty t192DecTest = aesDecrypt ct k == [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n  where ct = [0xdda97ca4, 0x864cdfe0, 0x6eaf70a0, 0xec0d7191]\n        k = [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617]\n*\/\n\n\/*\n\/\/ Test for Nk == 8 (AES256); comment out the next two properties if Nk != 8\nproperty t256EncTest = aesEncrypt pt k == [0x8ea2b7ca, 0x516745bf, 0xeafc4990,0x4b496089]\n  where pt = [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n        k = [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617, 0x18191a1b, 0x1c1d1e1f]\n\nproperty t256DecTest = aesDecrypt ct k == [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n  where ct = [0x8ea2b7ca, 0x516745bf, 0xeafc4990,0x4b496089]\n        k = [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617, 0x18191a1b, 0x1c1d1e1f]\n*\/\n\n\/\/ The top level property that summarizes all earlier test properties.\n\nproperty AESTests = t128EncTest && t128DecTest\n\n\/\/ Checking and proving sboxUnsboxInverse is easy, given its small\n\/\/ state space.\n\nproperty sboxUnsboxInverse (n : [8]) = n == (unsbox @ (sbox @ n))\n\n\/\/ Checking keyExpansionInjective is easy; proving this takes minutes\/hours.\n\/\/ At one time in the past this took under one minute.\n\nproperty keyExpansionInjective k1 k2 =\n  if k1 != k2\n  then aesEncryptKeySchedule k1 != aesEncryptKeySchedule k2\n  else True\n\n\/\/ The standard theorem relating encryption to decryption.  Again, checking\n\/\/ this is easy; proving this takes time.\n\nproperty encDecInverse pt k = (aesDecrypt (aesEncrypt pt k) k) == pt\n\n\/\/ Because there are some problems with loading modules in the current\n\/\/ cryptol-gen, these definitions are copied from Cryptol.Extras.\n\/\/ foldr1 is added for convenience.\n\nfoldr : {a,b,n} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs = ys ! 0\n  where ys = [acc] # [f x a | a <- ys | x <- reverse xs]\n\nfoldr1 : {a, b} (fin b) => (a -> a -> a) -> [1 + b]a -> a\nfoldr1 f xs = foldr f (xs @ 0) (tail xs)\n\nzipWith : {a,b,c,n} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/ecdsa\/cryptol-spec\/ecc.cry","filetype":"cry","content":"module ecc where\n\nimport bv\nimport mod_arith\nimport mul_java\n\nimport Field \/* Defines Field type and generic operations *\/\nimport ec_point_ops\nimport ref_ec_mul\nimport p384_field\nimport p384_ec_point_ops\nimport p384_ec_mul\n\n\/* Scalar multiply operations {{{1 *\/\n\n\ntest_params : ([384], AffinePoint [384], [384], AffinePoint [384])\ntest_params =\n\/\/  (0x7b52dc21312701d79a2465bb9fdf6fd30c4f76cf74787e44348f8217e6ffd5e02ee8c55a7c5d91b452825b1026d26893, {x=0xdf1c86a62d76090308a0d4c371704b36f3bfa41f0dbf8185d297b8a2c811756f0f4be19871cde079c5d43cfd0fab7fe8; y=0x70521fdd9165b0d33e948be941c590f2fbe7e2754ba110ae24089d41773acfdd34701acaafa669a884d3eefbf557d98b}, 0x211bb4730ad83e31aedbd66a5a750e800cf4de096495323ea94a73f25e9bcb5068a9dcc93e98efecb136eb057e6f41a4, {x=0x6bdf86d8f4cdf5b63a6a1e93a75457c0816fa2f3f69bc706ab69a7b5a63d4956d83cc4ca551f6aaf7653b8dd0991a6af; y=0xa8ce019e78abd658350e5885c8fddb172117a24bf157dfdbe8a1831e03758e630784470287c8e25908d931f22581bf97});\n\/\/  (0x6250471849e0c0eb47e9cf2c8e04c9ad0745e358d1cf11fb53e178a3c5b301b5f9e7f62e61c8f2113615cc4ff9927f9b, {x=0x005255b811499293ea986c66b4698e0748284d391130afd3f9febbc71ef3b39fe13a3deaa1489d817b885edf270b1bf6; y=0xc9a1dcdb74a4ae432edea47750d754d918b2f1fd8d9ee612b4f0cf2bebcb0eeef43ef5d0ce90cb75362bd2cfe69bffad}, 0xd9e8d87abffb84c0c06fe47396aa84871f08420561a7d8cc64fef7796fc0ca9a5406a37a054cc8cd57e26a3a7249fdb3, {x=0x8da95367d9e731f86adda9bfae6ff170cf090be5223f3b33c0d7c6c585bfc1330137d237fdc16bd432797a1da1dfa331; y=0x114d8b24d75d0149603aa6eab6ccec1cd83f5baaca7898dd6edd7c2ca91176893102b9fe129a09f9fdb208e18be46d16});\n  (0xe74872524f90425d832a4f264e1f7b9209ec7456e9b4c467d8eac6c68f973ea7fea24f4d3fa8498bb1e26f933eaa261b\n  , { x=0xbbab93c429707b2afe9ac285314d7b40c4ee31531b13291aa9058307cdd038b572fdf2f3a84dc912804fa426fe531a3c\n    , y=0x4c2cffaa333bfd82b575918bb979bf51480c836082c097a03fed5454877b37d2f44f0401d212c16b05052bd383047b31\n    }\n  , 0xd4356773f2b311955542c5835696b9dca9d0e59197d5746bbf7dc079a666d955f74114662e38d31196bf94b060cc0c80\n  , { x=0xd40c63c65b413d0741c56e884f0dca63b822a6f6879d36f9261d9b4a270d5d79a9be790fdfb871b5d6ae9204da692663\n    , y=0x4d6b2b937c85b3c0c3cd2df85e9307cc89e0093f336af3b4531aa126bbdbec466562d8aa0dc1cf360fc1f1d0951e3ad1\n    })\n\n\/* ECDSA Operations {{{1 *\/\n\n\/** Operations for ECDSA abstraction layer *\/\ntype Curve fv gv = {\n    point_ops : PointOps fv gv\n  , base : AffinePoint fv\n  , affinify : JacobianPoint fv -> AffinePoint fv\n  , mul : (gv, AffinePoint fv) -> JacobianPoint fv\n  , twin_mul : (gv, AffinePoint fv, gv, AffinePoint fv) -> JacobianPoint fv\n  }\n\n\/* Create a public key from a private key *\/\ninitialize_public_key : {fv} (Curve [fv] [fv], [fv]) -> AffinePoint [fv]\ninitialize_public_key(c, k) = c.affinify(c.mul(k, c.base))\n\n\/**\n * Reference ECDSA signature algorithm as formalized from [ANSI X9.62-2005, pg 8]\n * Parameters:\n *  Curve c\n *  Private key d of signatory.\n *  Integer e obtained after hashing message on step e)\n *  Ephemeral EC private key in range [1 .. c.curve)\n *\/\necdsa_sign : {fv} (fin fv, fv >= 1) => (Curve [fv] [fv], [fv], [fv], [fv]) -> ([fv], [fv])\necdsa_sign(c,d,e,k) = if is_zero(r) || is_zero(s) then (0,0) else (r, s)\n  where\n    g = c.point_ops.group_field\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    \/* Compute x coordinate of public key. *\/\n    j = (c.affinify(c.mul(k, c.base))).x\n    \/* c) Set r = j mod n *\/\n    r = g.normalize(j)\n    s = g.div(g.add(g.normalize(e), g.mul(d, r)), k)\n\n\/**\n * Reference ECDSA signature verification algorithm as formalized from [ANSI X9.62-2005, pg 9]\n * Parameters\n *  Curve c\n *  Integer e' obtained after hashing message on  step \"c\".\n *  Pair returned by ref_ecdsa_sign algorithm.\n *  Public key of key signatory.\n * Result:\n *  Bit that is True if verification suceeds, and false otherwise.\n *\/\necdsa_public_verify : {fv} (fin fv, fv >= 1)\n   => (Curve [fv] [fv], [fv], ([fv], [fv]), AffinePoint [fv]) -> Bit\necdsa_public_verify(c, e, (r, s), q)\n    \/* h) Compare v and r' if v = r', output \"valid\"; otherwise output \"invalid\". *\/\n   = in_range(s) && (v == r)\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(e, s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n    \/* f) Convert the field element x_r to an integer j as described in A.5 *\/\n    j = f.mul(r2.x, f.sq(f.div(f.field_unit, r2.z)))\n    \/* g) v = j mod n *\/\n    v = g.normalize(j)\n\n\/* This version performs a cheaper sequence of operations, and matches\n * the Java implementation. Correspondence between the reference and\n * implementation versions of ecdsa_public_verify is probably best proved\n * independent of the Java code.\n *\/\necdsa_public_verify_imp :\n  (Curve [384] [384], [384], ([384], [384]), AffinePoint [384]) -> Bit\necdsa_public_verify_imp(c, e, (r, s), q)\n   = in_range(r) && in_range(s) &&\n     ~is_zero(r2.z) &&\n     (g.is_equal(j, r2.x) || ((carrybits == False) && (g.is_equal(k, r2.x))))\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(g.normalize(e), s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n    r2zsq = f.sq(r2.z)\n    j = f.mul(r, r2zsq)\n    sum = r + p384_group_size\n    carrybits = (sum < r) && (sum < p384_group_size)\n    k = f.mul(sum, r2zsq)\n\ntype RsltWithCarry a b = { carrybits : a , rslt : b }\n\np384_incFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_incFieldPrime x = { carrybits = zero # [(bs @ 0)]\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_add(x, p384_prime)\n\np384_decFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_decFieldPrime x = { carrybits = if (bs @ 0) then -1 else 0\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_sub(x, p384_prime)\n\np384_field_cube(x)       = p384_field_mul(x, p384_field_sq(x))\n\n\/** P384 curve operations {{{2 *\/\n\np384_base : AffinePoint [384]\np384_base = nzAffinePoint(\n  join [0xaa87ca22, 0xbe8b0537, 0x8eb1c71e, 0xf320ad74, 0x6e1d3b62, 0x8ba79b98\n       ,0x59f741e0, 0x82542a38, 0x5502f25d, 0xbf55296c, 0x3a545e38, 0x72760ab7],\n  join [0x3617de4a, 0x96262c6f, 0x5d9e98bf, 0x9292dc29, 0xf8f41dbd, 0x289a147c\n       ,0xe9da3113, 0xb5f0b8c0, 0x0a60b1ce, 0x1d7e819d, 0x7a431d7c, 0x90ea0e5f])\n\n\n\np384_group_add : ([384],[384]) -> [384]\np384_group_add = p384_group_field.add\n\np384_curve : Curve [384] [384]\np384_curve =\n  { point_ops = p384_point_ops\n  , base = p384_base\n  , affinify = \\x -> ec_affinify(p384_field, x)\n  , mul = p384_ec_mul\n  , twin_mul = p384_ec_twin_mul\n  }\n\np384_ecdsa_sign : ([384], [384], [384]) -> { r:[384], s:[384] }\np384_ecdsa_sign(d,e,k) = { r = rr, s = ss }\n  where (rr, ss) = ecdsa_sign(p384_curve,d,e,k)\n\np384_ecdsa_public_verify : ([384], [384], [384], AffinePoint [384]) -> Bit\np384_ecdsa_public_verify(e,pr,ps,q) =\n  ecdsa_public_verify_imp(p384_curve,e,(pr,ps),q)\n\n\/* Curve \"a\" parameter, defined in [FIPS-186-3, page 87] to be -3 *\/\np384_a : [384]\np384_a = p384_prime - 3\n\n\/* Curve \"b\" parameter, defined in [FIPS-186-3, page 89] *\/\np384_b : [384]\np384_b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\n\n\n\/* Convert a p384 Jacobian point to an affine point *\/\np384_affinify : JacobianPoint [384] -> AffinePoint [384]\np384_affinify p = ec_affinify(p384_field, p)\n\n\/* Convert a p384 affine point to a Jacobian point *\/\np384_jacobify : AffinePoint [384] -> JacobianPoint [384]\np384_jacobify p = { x = p.x, y = p.y, z = 1 }\n\np384_base4 : JacobianPoint [384]\np384_base4 = p384_ec_double(p384_ec_double(p384_jacobify(p384_base)))\n\np384_base3 : AffinePoint [384]\np384_base3 = p384_affinify(p384_ec_full_sub(p384_base4, p384_base))\n\np384_base5 : AffinePoint [384]\np384_base5 = p384_affinify(p384_ec_full_add(p384_base4, p384_base))\n\n\n\/* Does an affine point lie on the curve? *\/\np384_is_affine_point : AffinePoint [384] -> Bit\np384_is_affine_point p =\n  p384_field_sq(p.y) ==\n  p384_field_add(p384_field_cube(p.x),\n                 p384_field_add(p384_field_mul(p384_a, p.x), p384_b))\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/llvm\/safety\/set.saw","filetype":"saw","content":"let alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet set_bad_spec n = do {\n    (a, ap) <- ptr_to_fresh \"a\" (llvm_array n (llvm_int 32));\n    i <- llvm_fresh_var \"i\" (llvm_int 32);\n    v <- llvm_fresh_var \"v\" (llvm_int 32);\n    llvm_execute_func [ap, llvm_term i, llvm_term v];\n    llvm_points_to ap (llvm_term {{ update a i v }});\n};\n\nlet set_good_spec n = do {\n    (a, ap) <- ptr_to_fresh \"a\" (llvm_array n (llvm_int 32));\n    i <- llvm_fresh_var \"i\" (llvm_int 32);\n    v <- llvm_fresh_var \"v\" (llvm_int 32);\n\n    \/\/ The ` in the following is to convert an unbounded integer into a\n    \/\/ fixed-size bit vector.\n    llvm_precond {{ i < (`n : [32]) }};\n\n    llvm_execute_func [ap, llvm_term i, llvm_term v];\n\n    llvm_points_to ap (llvm_term {{ update a i v }});\n};\n\nm <- llvm_load_module \"set.bc\";\n\nllvm_verify m \"set\" [] false (set_good_spec 10) abc;\nfails (llvm_verify m \"set\" [] false (set_bad_spec 10) abc);\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/llvm\/iterative_average\/test.cry","filetype":"cry","content":"\/\/ Imperative, iterative average.\n\ntype State =\n  { sum : [32]\n  , len : [32]\n  }\n\ninit : State\ninit =\n  { sum = 0\n  , len = 0\n  }\n\nupdatef : {n} (fin n, 32 >= width n) => State -> [n][32] -> State\nupdatef st xs =\n  { sum = st.sum + sum\n  , len = st.len + `n\n  }\n  where\n    sum = sums!0\n    sums = [ 0 ] # [ acc + x | acc <- sums | x <- xs ]\n\ndigest : State -> [32]\ndigest st = st.sum \/ st.len\n\n\/\/ Pure average.\n\navg : {n} (fin n, 32 >= width n) => [n][32] -> [32]\navg xs = sum \/ `n\n  where\n    sum = sums!0\n    sums = [ 0 ] # [ acc + x | acc <- sums | x <- xs ]\n\n\/\/ Tests.\n\nimp_correct : {n} (fin n, 32 >= width n) => [n][32] -> Bool\nproperty imp_correct xs = avg xs == digest (updatef init xs)\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/llvm\/iterative_average\/test.saw","filetype":"saw","content":"import \"test.cry\";\nm <- llvm_load_module \"tmp\/test.bc\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\n\/\/ Verify 'init'.\n\nlet init_spec = do {\n  (s, sp) <- ptr_to_fresh \"st\" (llvm_alias \"struct.state\");\n\n  llvm_execute_func [sp];\n\n  let res = llvm_struct_value [ llvm_term {{ init.sum }}\n                              , llvm_term {{ init.len }}\n                              ];\n  llvm_points_to sp res;\n};\nprint \"Verifying 'init' using 'llvm_verify':\";\ninit_ov <- llvm_verify m \"init\" [] true init_spec abc;\nprint \"\";\n\n\/\/ Verify 'update'.\n\nlet update_spec xs_len = do {\n  (st0, stp) <- ptr_to_fresh \"st\" (llvm_alias \"struct.state\");\n  (xs0, xsp) <- ptr_to_fresh \"xs\" (llvm_array xs_len (llvm_int 32));\n\n  llvm_execute_func [stp, xsp, llvm_term {{ `xs_len : [32] }}];\n\n  let st1 = {{ updatef {sum = st0.0, len = st0.1} xs0 }};\n\n\n  let res = llvm_struct_value [ llvm_term {{ st1.sum }}\n                              , llvm_term {{ st1.len }}\n                              ];\n  llvm_points_to stp res;\n  \/\/ Also prove that the content of xs is unchanged.\n  llvm_points_to xsp (llvm_term xs0);\n};\nprint \"Verifying 'update' using 'llvm_verify':\";\nupdate_ov <- llvm_verify m \"update\" [] true (update_spec 3) abc;\nprint \"\";\n\n\/\/ Verify 'digest'.\n\nlet digest_spec = do {\n  (st0, stp) <- ptr_to_fresh \"st\" (llvm_alias \"struct.state\");\n  avgp <- llvm_alloc (llvm_int 32);\n\n  \/\/ Avoid division by zero\n  llvm_precond {{ st0.1 != 0 }};\n\n  llvm_execute_func [stp, avgp];\n\n  llvm_points_to avgp (llvm_term {{ digest {sum = st0.0, len = st0.1} }});\n  \/\/ Also prove that the content of 'st' is unchanged.\n  llvm_points_to stp (llvm_term st0);\n\n};\nprint \"Verifying 'digest' using 'llvm_verify':\";\ndigest_ov <- llvm_verify m \"digest\" [] true digest_spec abc;\nprint \"\";\n\n\/\/ Verify imperative spec against pure spec.\n\nlet check n = do {\n    print (str_concat \"Checking imp_correct for byte count \" (show n));\n    time (prove_print abc {{ imp_correct`{n} }});\n};\n\nfor [0, 32, 64] check;\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/examples\/llvm\/union\/test.cry","filetype":"cry","content":"type Alg = [32]\nINC_1 = 0 : Alg\nINC_2 = 1 : Alg\n\ntype Inc_1_st =\n  { x : [32]\n  }\n\ntype Inc_2_st =\n  { x : [32]\n  , y : [32]\n  }\n\ntype UNION_BITS = 32+32\n\n\/\/ The 'bits' field contains a enough bits to hold the largest type in\n\/\/ the union, i.e. 'Inc_2_st'.\n\ntype St =\n  { alg : Alg\n  , bits : [UNION_BITS]\n  }\n\nbits_to_inc_1_st : [UNION_BITS] -> Inc_1_st\nbits_to_inc_1_st bits = { x = take`{32} bits }\n\n\/\/ We need the original bits to supply the bits we dropped when\n\/\/ translating to 'Inc_1_st'. Alternatively, we could add another\n\/\/ field to 'Inc_1_st' to hold the extra, otherwise unused bits.\ninc_1_st_to_bits : [UNION_BITS] -> Inc_1_st -> [UNION_BITS]\ninc_1_st_to_bits bits st = st.x # drop`{32} bits\n\nbits_to_inc_2_st : [UNION_BITS] -> Inc_2_st\nbits_to_inc_2_st bits = { x = take`{32} bits, y = drop`{32} bits }\ninc_2_st_to_bits : Inc_2_st -> [UNION_BITS]\ninc_2_st_to_bits st = st.x # st.y\n\ninc : St -> St\ninc st = { alg = st.alg, bits = bits }\n  where\n    bits =\n      if st.alg == INC_1 then\n        inc_1_st_to_bits st.bits\n          (inc_1 (bits_to_inc_1_st st.bits))\n      else\n        inc_2_st_to_bits\n          (inc_2 (bits_to_inc_2_st st.bits))\n\ninc_1 : Inc_1_st -> Inc_1_st\ninc_1 st = { x = st.x + 1 }\n\ninc_2 : Inc_2_st -> Inc_2_st\ninc_2 st = { x = st.x + 1, y = st.y + 1}\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/llvm\/union\/test.saw","filetype":"saw","content":"import \"test.cry\";\nm <- llvm_load_module \"tmp\/test.bc\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\n\/\/ Verify using 'llvm_verify'.\n\n\/\/ The argument 'INC' specifies which 'alg' enum to test.\nlet inc_spec INC = do {\n\n  stp <- llvm_alloc (llvm_alias \"struct.st\");\n\n  \/\/ The union is represented by the largest element type,\n  \/\/ i.e. 'inc_2_st'. The inner '.0' dereferences the union itself.\n  x0 <- llvm_fresh_var \"((st->1).0).0\" (llvm_int 32);\n  y0 <- llvm_fresh_var \"((st->1).0).1\" (llvm_int 32);\n\n  llvm_points_to (llvm_elem stp 0) (llvm_term {{ INC }});\n  llvm_points_to (llvm_elem (llvm_elem (llvm_elem stp 1) 0) 0) (llvm_term x0);\n  llvm_points_to (llvm_elem (llvm_elem (llvm_elem stp 1) 0) 1) (llvm_term y0);\n\n  llvm_execute_func [stp];\n\n  \/\/ We construct an 'inc_2_st' here independent of 'INC', since we\n  \/\/ need to account for all of the bits in the union field 'inc_st',\n  \/\/ and 'inc_1_st' only has half the bits.\n  let inc_2_st0 = {{ { x = x0, y = y0 } }};\n  let st0 = {{\n    { alg = INC\n    , bits = inc_2_st_to_bits inc_2_st0\n    }\n  }};\n  let st1 = {{ inc st0 }};\n  let inc_2_st1 = {{ bits_to_inc_2_st st1.bits }};\n\n  llvm_points_to (llvm_elem stp 0) (llvm_term {{ st1.alg }});\n  llvm_points_to (llvm_elem (llvm_elem (llvm_elem stp 1) 0) 0) (llvm_term {{ inc_2_st1.x }});\n  llvm_points_to (llvm_elem (llvm_elem (llvm_elem stp 1) 0) 1) (llvm_term {{ inc_2_st1.y }});\n\n  llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nprint \"Verifying 'inc_1' using 'llvm_verify':\";\nllvm_verify m \"inc\" [] true (inc_spec {{ INC_1 }}) abc;\nprint \"\";\n\nprint \"Verifying 'inc_2' using 'llvm_verify':\";\nllvm_verify m \"inc\" [] true (inc_spec {{ INC_2 }}) abc;\nprint \"\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/examples\/salsa20\/djb\/util.saw","filetype":"saw","content":"let alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet {{\n    \/* * guard type for given args *\/\n    type guard args_t = args_t -> Bit\n\n    \/* * signature of a pure function with arguments and return types *\/\n    type signature return_t args_t =\n        args_t -> (return_t, args_t)\n}};\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/xordomain.cry","filetype":"cry","content":"\/*\nThis file contains a Cryptol implementation of a specialzed bitwise\nabstract domain that is optimized for the XOR\/AND semiring representation.\nThe standard bitwise domain from \"bitsdomain.cry\" requires 6 bitwise\noperations to compute XOR, whereas AND and OR only requre 2.\nIn this domain, XOR and AND both can be computed in 3 bitwise operations,\nand scalar AND can be computed in 2.\n*\/\n\nmodule xordomain where\n\n\/\/ In this presentation \"val\" is a bitwise upper bound on\n\/\/ the values in the set, and \"unknown\" represents all the\n\/\/ bits whose values are not concretely known\ntype Dom n = { val : [n], unknown : [n] }\n\n\/\/ Membership predicate for the XOR bitwise domain\nmem : {n} (fin n) => Dom n -> [n] -> Bit\nmem a x = a.val == x || a.unknown\n\nbxor : {n} (fin n) => Dom n -> Dom n -> Dom n\nbxor a b = { val = v || u, unknown = u }\n  where\n  v = a.val ^ b.val\n  u = a.unknown || b.unknown\n\nband : {n} (fin n) => Dom n -> Dom n -> Dom n\nband a b = { val = v, unknown = u && v }\n  where\n  v   = a.val && b.val\n  u   = a.unknown || b.unknown\n\nband_scalar : {n} (fin n) => Dom n -> [n] -> Dom n\nband_scalar a x = { val = a.val && x, unknown = a.unknown && x }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Soundness properties\n\ncorrect_bxor : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_bxor a b x y =\n  mem a x ==> mem b y ==> mem (bxor a b) (x ^ y)\n\ncorrect_band : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_band a b x y =\n  mem a x ==> mem b y ==> mem (band a b) (x && y)\n\ncorrect_band_scalar : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_band_scalar a x y =\n  mem a x ==> mem (band_scalar a y) (x && y)\n\nproperty x1 = correct_bxor`{16}\nproperty x2 = correct_band`{16}\nproperty x3 = correct_band_scalar`{16}\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/bvdomain.cry","filetype":"cry","content":"\/*\n\nThis file gives Cryptol implementations for transferring between\nthe various bitvector domain representations and proofs of the\ncorrectness of these operations.\n*\/\n\nmodule bvdomain where\n\nimport arithdomain as A\nimport bitsdomain as B\nimport xordomain as X\n\n\n\/\/ Precondition `x <= mask`.  Find the (arithmetically) smallest\n\/\/  `z` above `x` which is bitwise above `mask`.  In other words\n\/\/ find the smallest `z` such that `x <= z` and `mask || z == z`.\n\nbitwise_round_above : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\nbitwise_round_above x mask = (x && ~q) ^ (mask && q)\n  where\n  q = A::fillright_alt ((x || mask) ^ x)\n\nbra_correct1 : {n} (fin n, n>=1) => [n] -> [n] -> Bit\nbra_correct1 x mask = mask <= x ==> (x <= q \/\\ B::bitle mask q)\n  where\n  q = bitwise_round_above x mask\n\nbra_correct2 : {n} (fin n, n>=1) => [n] -> [n] -> [n] -> Bit\nbra_correct2 x mask q' = (x <= q' \/\\ B::bitle mask q') ==> q <= q'\n  where\n  q = bitwise_round_above x mask\n\nproperty bra1 = bra_correct1`{64}\nproperty bra2 = bra_correct2`{64}\n\n\n\/\/ Precondition `lomask <= x <= himask` and `lomask || himask == himask`.\n\/\/ Find the (arithmetically) smallest `z` above `x` which is bitwise between\n\/\/ `lomask` and `himask`.  In otherwords, find the smallest `z` such that\n\/\/  `x <= z` and `lomask || z = z` and `z || himask == himask`.\nbitwise_round_between : {n} (fin n, n >= 1) => [n] -> [n] -> [n] -> [n]\nbitwise_round_between x lomask himask = if r == 0 then loup else final\n  \/\/ Read these steps from the bottom up...\n  where\n\n  \/\/ Finally mask out the low bits and only set those requried by the lomask\n  final = (upper && ~lowbits) || lomask\n\n  \/\/ add the correcting bit and mask out any extraneous bits set in\n  \/\/ the previous step\n  upper = (z + highbit) && himask\n\n  \/\/ set ourselves up so that when we add the high bit to correct,\n  \/\/ the carry will ripple until it finds a bit position that we\n  \/\/ are allowed to set.\n  z = loup || ~himask\n\n  \/\/ isolate just the highest incorrect bit\n  highbit = rmask ^ lowbits\n\n  \/\/ A mask for all the bits lower than the high bit of r\n  lowbits = rmask >> 1\n\n  \/\/ set all the bits to the right of the highest incorrect bit\n  rmask = A::fillright_alt r\n\n  \/\/ now compute all the bits that are set that are not allowed\n  \/\/ to be set according to the himask\n  r = loup && ~himask\n\n  \/\/ first, round up to the lomask\n  loup = bitwise_round_above x lomask\n\n\nbrb_correct1 : {n} (fin n, n>=1) => [n] -> [n] -> [n] -> Bit\nbrb_correct1 x lomask himask =\n    (B::bitle lomask himask \/\\ lomask <= x \/\\ x <= himask) ==>\n    (x <= q \/\\ B::bitle lomask q \/\\ B::bitle q himask)\n\n  where\n  q = bitwise_round_between x lomask himask\n\nbrb_correct2 : {n} (fin n, n>=1) => [n] -> [n] -> [n] -> [n] -> Bit\nbrb_correct2 x lomask himask q' = (x <= q' \/\\ B::bitle lomask q' \/\\ B::bitle q' himask) ==> q <= q'\n  where\n  q = bitwise_round_between x lomask himask\n\nproperty brb1 = brb_correct1`{64}\nproperty brb2 = brb_correct2`{64}\n\n\/\/ Interesting fact about arithmetic domains: the low values of the two domains\n\/\/ represent overlap candidates.  If neither low value is contained in the other domain,\n\/\/ then they do not overlap.\narith_overlap_candidates : {n} (fin n, n >= 1) => A::Dom n -> A::Dom n -> [n] -> Bit\narith_overlap_candidates a b x =\n  A::mem a x ==>\n  A::mem b x ==>\n  ((A::mem a b.lo \/\\ A::mem b b.lo) \\\/\n   (A::mem a a.lo \/\\ A::mem b a.lo))\n\n\/\/ Bitwise domains, if they overlap, must overlap in some specific points.  The bitwise\n\/\/ union of the low bounds is one.\nbitwise_overlap_candidates : {n} (fin n, n >= 1) => B::Dom n -> B::Dom n -> [n] -> Bit\nbitwise_overlap_candidates a b x =\n  B::mem a x ==>\n  B::mem b x ==>\n  (B::mem a witness \/\\ B::mem b witness)\n\n where\n witness = a.lomask || b.lomask\n\n\/\/ If mixed domains have some common value, then they must definintely overlap at one\n\/\/ of the following three listed candidate points.\nmixed_overlap_candidates : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> [n] -> Bit\nmixed_overlap_candidates a b x =\n  A::mem a x ==>\n  B::mem b x ==>\n  (A::mem a b.lomask \/\\ B::mem b b.lomask) \\\/\n  (A::mem a b.himask \/\\ B::mem b b.himask) \\\/\n  (A::mem a next     \/\\ B::mem b next)\n\n where\n next = bitwise_round_between a.lo b.lomask b.himask\n\n\n\/\/ A mixed domain overlap test.  It relies on testing special candidate overlap values.\n\/\/\n\/\/ If none of the overlap candidates are found in both domains, then the domains do not overlap.\n\/\/ On the other hand, if any canadiate is in both domains, it is a constructive witness of\n\/\/ overlap.\nmixed_domain_overlap : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> Bit\nmixed_domain_overlap a b =\n  A::mem a b.lomask \\\/ A::mem a b.himask \\\/ A::mem a (bitwise_round_between a.lo b.lomask b.himask)\n\n\/\/ If mixed domains have a common element, the overlap test will be true.\ncorrect_mixed_domain_overlap : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> [n] -> Bit\ncorrect_mixed_domain_overlap a b x =\n  A::mem a x ==>\n  B::mem b x ==>\n  mixed_domain_overlap a b\n\n\/\/ If the overlap test is true, then we can find some element they share in common,\n\/\/ provided the bitwise domain is nonempty.\ncorrect_mixed_domain_overlap_inv : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> Bit\ncorrect_mixed_domain_overlap_inv a b =\n  B::nonempty b ==> mixed_domain_overlap a b ==> (A::mem a witness \/\\ B::mem b witness)\n\n where\n witness = if A::mem a b.lomask then b.lomask else\n           if A::mem a b.himask then b.himask else\n           bitwise_round_between a.lo b.lomask b.himask\n\nproperty mx = correct_mixed_domain_overlap`{64}\nproperty mx_inv = correct_mixed_domain_overlap_inv`{64}\n\n\n\/\/ Operations that transfer between the domains\n\narithToBitDom : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n\narithToBitDom a = { lomask = lo, himask = hi }\n  where\n  u  = A::unknowns a\n  hi = a.lo || u\n  lo = hi ^ u\n\nbitToArithDom : {n} (fin n) => B::Dom n -> A::Dom n\nbitToArithDom b = A::range b.lomask b.himask\n\nbitToXorDom : {n} (fin n) => B::Dom n -> X::Dom n\nbitToXorDom b = { val = b.himask, unknown = b.lomask ^ b.himask }\n\nxorToBitDom : {n} (fin n) => X::Dom n -> B::Dom n\nxorToBitDom x = { lomask = x.val ^ x.unknown, himask = x.val }\n\narithToXorDom : {n} (fin n, n >= 1) => A::Dom n -> X::Dom n\narithToXorDom a = { val = a.lo || u, unknown = u }\n  where\n  u = A::unknowns a\n\n\/\/ A small collection of operations that start in one\n\/\/ domain and end in the other\n\npopcount : {n} (fin n, n>=1) => [n] -> [n]\npopcount bs = sum [ zero#[b] | b <- bs ]\n\ncountLeadingZeros : {n} (fin n, n>=1) => [n] -> [n]\ncountLeadingZeros x = loop 0\n where\n loop n =\n   if n >= length x then\n     length x\n   else\n     if x@n then n else loop (n+1)\n\ncountTrailingZeros : {n} (fin n, n>=1) => [n] -> [n]\ncountTrailingZeros xs = countLeadingZeros (reverse xs)\n\n\n\npopcnt : {n} (fin n, n>=1) => B::Dom n -> A::Dom n\npopcnt b = A::range lo hi\n  where\n  lo = popcount b.lomask\n  hi = popcount b.himask\n\nclz : {n} (fin n, n>=1) => B::Dom n -> A::Dom n\nclz b = A::range lo hi\n where\n lo = countLeadingZeros b.himask\n hi = countLeadingZeros b.lomask\n\nctz : {n} (fin n, n>=1) => B::Dom n -> A::Dom n\nctz b = A::range lo hi\n where\n lo = countTrailingZeros b.himask\n hi = countTrailingZeros b.lomask\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Correctness properties\n\ncorrect_arithToBitDom : {n} (fin n, n >= 1) => A::Dom n -> [n] -> Bit\ncorrect_arithToBitDom a x =\n  A::mem a x ==> B::mem (arithToBitDom a) x\n\ncorrect_bitToArithDom : {n} (fin n) => B::Dom n -> [n] -> Bit\ncorrect_bitToArithDom b x =\n  B::mem b x ==> A::mem (bitToArithDom b) x\n\ncorrect_bitToXorDom : {n} (fin n) => B::Dom n -> [n] -> Bit\ncorrect_bitToXorDom b x =\n  B::mem b x == X::mem (bitToXorDom b) x\n\ncorrect_xorToBitDom : {n} (fin n) => X::Dom n -> [n] -> Bit\ncorrect_xorToBitDom b x =\n  X::mem b x == B::mem (xorToBitDom b) x\n\ncorrect_arithToXorDom : {n} (fin n, n >= 1) => A::Dom n -> [n] -> Bit\ncorrect_arithToXorDom a x =\n  A::mem a x ==> X::mem (arithToXorDom a) x\n\nproperty t1 = correct_arithToBitDom`{16}\nproperty t2 = correct_bitToArithDom`{16}\nproperty t3 = correct_bitToXorDom`{16}\nproperty t4 = correct_xorToBitDom`{16}\nproperty t5 = correct_arithToXorDom`{16}\n\ncorrect_popcnt : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit\ncorrect_popcnt a x =\n  B::mem a x ==> A::mem (popcnt a) (popcount x)\n\ncorrect_clz : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit\ncorrect_clz a x =\n  B::mem a x ==> A::mem (clz a) (countLeadingZeros x)\n\ncorrect_ctz : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit\ncorrect_ctz a x =\n  B::mem a x ==> A::mem (ctz a) (countTrailingZeros x)\n\nproperty w1 = correct_popcnt`{16}\nproperty w2 = correct_clz`{16}\nproperty w3 = correct_ctz`{16}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Proofs that the XOR domain is really just an alternate way\n\/\/ to compute the same thing as the bitsdomain operations.\n\/\/ For \"band\" this requires the input domains to be nonempty,\n\/\/ which should be the case for all actual values of interest.\n\nequiv_bxor : {n} (fin n) => B::Dom n -> B::Dom n -> Bit\nequiv_bxor a b =\n  B::bxor a b == xorToBitDom (X::bxor (bitToXorDom a) (bitToXorDom b))\n\nequiv_band : {n} (fin n) => B::Dom n -> B::Dom n -> Bit\nequiv_band a b =\n  B::nonempty a \/\\ B::nonempty b ==>\n  B::band a b == xorToBitDom (X::band (bitToXorDom a) (bitToXorDom b))\n\nequiv_band_scalar : {n} (fin n) => B::Dom n -> [n] -> Bit\nequiv_band_scalar a x =\n  B::band a (B::singleton x) == xorToBitDom (X::band_scalar (bitToXorDom a) x)\n\n\nproperty e1 = equiv_bxor`{16}\nproperty e2 = equiv_band`{16}\nproperty e3 = equiv_band_scalar`{16}\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/bitsdomain.cry","filetype":"cry","content":"\/*\n\nThis file contains a Cryptol implementation of the bitwise\nbitvector abstract domain operations from What4.Utils.BVDomain\n\nIn addition to the algorithms themselves, this file also contains\nspecifications of correctness for each of the operations. All of the\ncorrectness properties can be formally proven (each at some specific\nbit width) by loading this file in cryptol and entering \":prove\".\n\n*\/\nmodule bitsdomain where\n\n\/\/ This type represents _bitwise_ bounds as opposed to the\n\/\/ arithmetic bounds described by BVDom.  Note that\n\/\/ this representation allows the empty set if\n\/\/ lomask is not bitwise below himask.  However, all\n\/\/ the operations (other than intersection) preserve the property\n\/\/ of being nonempty (implied by their various soundness properties).\ntype Dom n = { lomask : [n] , himask : [n] }\n\n\/** Membership predicate that defines the set of concrete values\nrepresented by a bitwise abstract domain element. *\/\nmem : {n} (fin n) => Dom n -> [n] -> Bit\nmem a x = bitle a.lomask x \/\\ bitle x a.himask\n\nbitle : {n} (fin n) => [n] -> [n] -> Bit\nbitle x y = x || y == y\n\nnonempty : {n} (fin n) => Dom n -> Bit\nnonempty b = bitle b.lomask b.himask\n\nsingleton : {n} (fin n) => [n] -> Dom n\nsingleton x = { lomask = x, himask = x }\n\nisSingleton : {n} (fin n) => Dom n -> Bit\nisSingleton a = a.lomask == a.himask\n\ntop : {n} (fin n) => Dom n\ntop = { lomask = 0, himask = ~0 }\n\noverlap : {n} (fin n) => Dom n -> Dom n -> Bit\noverlap a b = nonempty (intersection a b)\n\nintersection : {n} (fin n) => Dom n -> Dom n -> Dom n\nintersection a b = { lomask = a.lomask || b.lomask, himask = a.himask && b.himask }\n\nunion : {n} (fin n) => Dom n -> Dom n -> Dom n\nunion a b = { lomask = a.lomask && b.lomask, himask = a.himask || b.himask }\n\nzero_ext : {m, n} (fin m, m >= n) => Dom n -> Dom m\nzero_ext a = { lomask = zext a.lomask, himask = zext a.himask }\n\nsign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> Dom m\nsign_ext a = { lomask = sext a.lomask, himask = sext a.himask }\n\nconcat : {m, n} (fin m, fin n) => Dom m -> Dom n -> Dom (m + n)\nconcat a b = { lomask = a.lomask # b.lomask, himask = a.himask # b.himask }\n\nshrink : {m, n} (fin m, fin n) => Dom (m + n) -> Dom m\nshrink a = { lomask = take`{m} a.lomask, himask = take`{m} a.himask }\n\ntrunc : {m, n} (fin m, fin n) => Dom (m + n) -> Dom n\ntrunc a = { lomask = drop`{m} a.lomask, himask = drop`{m} a.himask }\n\nbnot : {n} (fin n) => Dom n -> Dom n\nbnot b = { lomask = ~b.himask, himask = ~b.lomask }\n\nband : {n} (fin n) => Dom n -> Dom n -> Dom n\nband a b = { lomask = a.lomask && b.lomask, himask = a.himask && b.himask }\n\nbor : {n} (fin n) => Dom n -> Dom n -> Dom n\nbor a b = { lomask = a.lomask || b.lomask, himask = a.himask || b.himask }\n\n\/\/ Note, this requires quite a few more operations than AND and OR.\n\/\/ See \"xordomain.cry\" for a domain optimized for XOR and AND operations.\nbxor : {n} (fin n) => Dom n -> Dom n -> Dom n\nbxor a b = { lomask = lo, himask = hi }\n  where\n  ua = a.lomask ^ a.himask\n  ub = b.lomask ^ b.himask\n  c  = a.lomask ^ b.lomask\n  u  = ua || ub\n  hi = c || u\n  lo = hi ^ u\n\n\/\/ Note: shift and rotate operations in this domain only apply\n\/\/ when the shift amount is known\nshl : {n} (fin n) => Dom n -> [n] -> Dom n\nshl a x = { lomask = a.lomask << x', himask = a.himask << x' }\n  where x' = if x < `n then x else `n\n\nlshr : {n} (fin n) => Dom n -> [n] -> Dom n\nlshr a x = { lomask = a.lomask >> x', himask = a.himask >> x' }\n  where x' = if x < `n then x else `n\n\nashr : {n} (fin n, n >= 1) => Dom n -> [n] -> Dom n\nashr a x = { lomask = a.lomask >>$ x', himask = a.himask >>$ x' }\n  where x' = if x < `n then x else `n\n\nrol : {n} (fin n) => Dom n -> [n] -> Dom n\nrol a x = { lomask = a.lomask <<< x, himask = a.himask <<< x }\n\nror : {n} (fin n) => Dom n -> [n] -> Dom n\nror a x = { lomask = a.lomask >>> x, himask = a.himask >>> x }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Soundness properties\n\ncorrect_top : {n} (fin n) => [n] -> Bit\ncorrect_top x = mem top x\n\ncorrect_singleton : {n} (fin n) => [n] -> [n] -> Bit\ncorrect_singleton x y = mem (singleton x) y == (x == y)\n\ncorrect_overlap : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_overlap a b x =\n  mem a x ==> mem b x ==> overlap a b\n\ncorrect_overlap_inv : {n} (fin n) => Dom n -> Dom n -> Bit\ncorrect_overlap_inv a b =\n  overlap a b ==> (mem a (a.lomask || b.lomask) \/\\ mem b (a.lomask || b.lomask))\n\ncorrect_union : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_union a b x =\n  (mem a x \\\/ mem b x) ==> mem (union a b) x\n\ncorrect_intersection : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_intersection a b x =\n  (mem a x \/\\ mem b x) == mem (intersection a b) x\n\ncorrect_zero_ext : {m, n} (fin m, m >= n) => Dom n -> [n] -> Bit\ncorrect_zero_ext a x =\n  mem a x ==> mem (zero_ext`{m} a) (zext`{m} x)\n\ncorrect_sign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> [n] -> Bit\ncorrect_sign_ext a x =\n  mem a x ==> mem (sign_ext`{m} a) (sext`{m} x)\n\ncorrect_concat : {m, n} (fin m, fin n) => Dom m -> Dom n -> [m] -> [n] -> Bit\ncorrect_concat a b x y =\n  mem a x ==> mem b y ==> mem (concat a b) (x # y)\n\ncorrect_shrink : {m, n} (fin m, fin n) => Dom (m + n) -> [m+n] -> Bit\ncorrect_shrink a x =\n  mem a x ==> mem (shrink`{m} a) (take`{m} x)\n\ncorrect_trunc : {m, n} (fin m, fin n) => Dom (m + n) -> [m+n] -> Bit\ncorrect_trunc a x =\n  mem a x ==> mem (trunc`{m} a) (drop`{m} x)\n\ncorrect_isSingleton : {n} (fin n) => Dom n -> Bit\ncorrect_isSingleton a =\n  isSingleton a ==> a == singleton a.lomask\n\ncorrect_bnot : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_bnot a x =\n  mem a x == mem (bnot a) (~ x)\n\ncorrect_band : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_band a b x y =\n  mem a x ==> mem b y ==> mem (band a b) (x && y)\n\ncorrect_bor : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_bor a b x y =\n  mem a x ==> mem b y ==> mem (bor a b) (x || y)\n\ncorrect_bxor : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_bxor a b x y =\n  mem a x ==> mem b y ==> mem (bxor a b) (x ^ y)\n\ncorrect_shl : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_shl a x y =\n  mem a x ==> mem (shl a y) (x << y)\n\ncorrect_lshr : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_lshr a x y =\n  mem a x ==> mem (lshr a y) (x >> y)\n\ncorrect_ashr : {n} (fin n, n >= 1) => Dom n -> [n] -> [n] -> Bit\ncorrect_ashr a x y =\n  mem a x ==> mem (ashr a y) (x >>$ y)\n\ncorrect_rol : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_rol a x y =\n  mem a x ==> mem (rol a y) (x <<< y)\n\ncorrect_ror : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_ror a x y =\n  mem a x ==> mem (ror a y) (x >>> y)\n\nproperty b1 = correct_top`{16}\nproperty b2 = correct_singleton`{16}\nproperty b3 = correct_overlap`{16}\nproperty b4 = correct_overlap_inv`{16}\nproperty b5 = correct_union`{8}\nproperty b6 = correct_intersection`{8}\nproperty b7 = correct_zero_ext`{32, 16}\nproperty b8 = correct_sign_ext`{32, 16}\nproperty b9 = correct_concat`{16, 16}\nproperty b10 = correct_shrink`{8, 8}\nproperty b11 = correct_trunc`{8, 8}\nproperty b12 = correct_isSingleton`{16}\n\nproperty l1 = correct_bnot`{16}\nproperty l2 = correct_band`{16}\nproperty l3 = correct_bor`{16}\nproperty l4 = correct_bxor`{16}\n\nproperty s1 = correct_shl`{16}\nproperty s2 = correct_lshr`{16}\nproperty s3 = correct_ashr`{16}\nproperty s4 = correct_rol`{16}\nproperty s5 = correct_ror`{16}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Operations preserve singletons\n\nsingleton_overlap : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_overlap x y =\n  overlap (singleton x) (singleton y) == (x == y)\n\nsingleton_zero_ext : {m, n} (fin m, m >= n) => [n] -> Bit\nsingleton_zero_ext x =\n  zero_ext`{m} (singleton x) == singleton (zext`{m} x)\n\nsingleton_sign_ext : {m, n} (fin m, m >= n, n >= 1) => [n] -> Bit\nsingleton_sign_ext x =\n  sign_ext`{m} (singleton x) == singleton (sext`{m} x)\n\nsingleton_concat : {m, n} (fin m, fin n) => [m] -> [n] -> Bit\nsingleton_concat x y =\n  concat (singleton x) (singleton y) == singleton (x # y)\n\nsingleton_shrink : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_shrink x =\n  shrink`{m} (singleton x) == singleton (take`{m} x)\n\nsingleton_trunc : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_trunc x =\n  trunc`{m} (singleton x) == singleton (drop`{m} x)\n\nsingleton_bnot : {n} (fin n) => [n] -> Bit\nsingleton_bnot x =\n  bnot (singleton x) == singleton (~ x)\n\nsingleton_band : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_band x y =\n  band (singleton x) (singleton y) == singleton (x && y)\n\nsingleton_bor : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_bor x y =\n  bor (singleton x) (singleton y) == singleton (x || y)\n\nsingleton_bxor : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_bxor x y =\n  bxor (singleton x) (singleton y) == singleton (x ^ y)\n\nsingleton_shl : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_shl x y =\n  shl (singleton x) y == singleton (x << y)\n\nsingleton_lshr : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_lshr x y =\n  lshr (singleton x) y == singleton (x >> y)\n\nsingleton_ashr : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ashr x y =\n  ashr (singleton x) y == singleton (x >>$ y)\n\nproperty i01 = singleton_overlap`{16}\nproperty i02 = singleton_zero_ext`{32, 16}\nproperty i03 = singleton_sign_ext`{32, 16}\nproperty i04 = singleton_concat`{16, 16}\nproperty i05 = singleton_shrink`{8, 8}\nproperty i06 = singleton_trunc`{8, 8}\nproperty i07 = singleton_band`{16}\nproperty i08 = singleton_bor`{16}\nproperty i09 = singleton_bxor`{16}\nproperty i10 = singleton_bnot`{16}\nproperty i11 = singleton_shl`{8}\nproperty i12 = singleton_lshr`{8}\nproperty i13 = singleton_ashr`{8}\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/arithdomain.cry","filetype":"cry","content":"\/*\n\nThis file contains a Cryptol implementation of the arithmetic\nbitvector abstract domain operations from module What4.Utils.Domain in what4.\n\nIn addition to the algorithms themselves, this file also contains\nspecifications of correctness for each of the operations. All of the\ncorrectness properties can be formally proven (each at some specific\nbit width) by loading this file in cryptol and entering \":prove\".\n\n*\/\nmodule arithdomain where\n\nbit : {i, n} (fin n, n > i) => [n]\nbit = 1 # (0 : [i])\n\nmask : {i, n} (fin n, n >= i) => [n]\nmask = 0 # (~ 0 : [i])\n\n\/** Checked unsigned addition, asserted not to overflow. *\/\ninfixl 80 .+.\n(.+.) : {n} (fin n) => [n] -> [n] -> [n]\nx .+. y = if carry x y then error \"overflow\" else x + y\n\n\/** Checked unsigned subtraction, asserted not to underflow. *\/\ninfixl 80 .-.\n(.-.) : {n} (fin n) => [n] -> [n] -> [n]\nx .-. y = if x < y then error \"underflow\" else x - y\n\n\/** Minimum of two signed values. *\/\nsmin : {a} (SignedCmp a) => a -> a -> a\nsmin x y = if x <$ y then x else y\n\n\/** Maximum of two signed values. *\/\nsmax : {a} (SignedCmp a) => a -> a -> a\nsmax x y = if x >$ y then x else y\n\ntype Dom n = { lo : [n], sz : [n] }\n\ninterval : {n} (fin n) => [n] -> [n] -> Dom n\ninterval l s = { lo = l, sz = s }\n\nrange : {n} (fin n) => [n] -> [n] -> Dom n\nrange lo hi = interval lo (hi - lo)\n\n\/** Membership predicate that defines the set of concrete values\nrepresented by an abstract domain element. *\/\nmem : {n} (fin n) => Dom n -> [n] -> Bit\nmem a x = x - a.lo <= a.sz\n\numem : {n} (fin n) => ([n], [n]) -> [n] -> Bit\numem (lo, hi) x = lo <= x \/\\ x <= hi\n\nsmem : {n} (fin n, n >= 1) => ([n], [n]) -> [n] -> Bit\nsmem (lo, hi) x = lo <=$ x \/\\ x <=$ hi\n\ntop : {n} (fin n) => Dom n\ntop = interval 0 (~ 0)\n\nsingleton : {n} (fin n) => [n] -> Dom n\nsingleton x = interval x 0\n\nisSingleton : {n} (fin n) => Dom n -> Bit\nisSingleton a = a.sz == 0\n\nubounds : {n} (fin n) => Dom n -> ([n], [n])\nubounds a =\n  if carry a.lo a.sz then (0, ~0) else (a.lo, a.lo + a.sz)\n\nsbounds : {n} (fin n, n >= 1) => Dom n -> ([n], [n])\nsbounds a = (lo - delta, hi - delta)\n  where\n    delta = reverse 1\n    (lo, hi) = ubounds (interval (a.lo + delta) a.sz)\n\n\/** Nonzero signed values in a domain with the least and greatest\nreciprocals. Note that this coincides with the greatest and least\nnonzero values using the unsigned ordering. *\/\nrbounds : {n} (fin n, n >= 1) => Dom n -> ([n], [n])\nrbounds a =\n  if a.lo == 0 then (a_hi, 1) else\n  if a_hi == 0 then (-1, a.lo) else\n  if a_hi < a.lo then (-1, 1) else\n  (a_hi, a.lo)\n  where a_hi = a.lo + a.sz\n\noverlap : {n} (fin n) => Dom n -> Dom n -> Bit\noverlap a b = diff <= b.sz \\\/ carry diff a.sz\n  where diff = a.lo - b.lo\n\n\/\/ To compute the union of two intervals, we choose representatives of\n\/\/ the endpoints modulo 2^n such that their midpoints are no more than\n\/\/ 2^(n-1) apart. In the code below, am and bm are equal to twice the\n\/\/ midpoints of intervals a and b, respectively.\nunion : {n} (fin n) => Dom n -> Dom n -> Dom n\nunion a b =\n  if cw >= size then top else interval (drop`{2} cl) (drop`{2} cw)\n  where\n    size : [n+2]\n    size = bit`{n}\n    am = 2 * zext a.lo .+. zext a.sz\n    bm = 2 * zext b.lo .+. zext b.sz\n    al' = if am .+. size < bm then zext a.lo .+. size else zext a.lo\n    bl' = if bm .+. size < am then zext b.lo .+. size else zext b.lo\n    ah' = al' .+. zext a.sz\n    bh' = bl' .+. zext b.sz\n    cl = min al' bl'\n    ch = max ah' bh'\n    cw = ch .-. cl\n\nzero_ext : {m, n} (fin m, m >= n) => Dom n -> Dom m\nzero_ext a = interval (zext lo) (zext (hi .-. lo))\n  where (lo, hi) = ubounds a\n\nsign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> Dom m\nsign_ext a = interval (sext lo) (zext (hi - lo))\n  where (lo, hi) = sbounds a\n\nconcat : {m, n} (fin m, fin n) => Dom m -> Dom n -> Dom (m + n)\nconcat a b = interval (a.lo # lo) (a.sz # sz)\n  where\n    (lo, hi) = ubounds b\n    sz = hi .-. lo\n\nshrink : {m, n} (fin m, fin n) => Dom (m + n) -> Dom m\nshrink a =\n  if b_sz >= size then top\n  else interval (tail b_lo) (tail b_sz)\n  where\n    size : [1 + m]\n    size = bit`{m}\n    b_lo, b_hi, b_sz : [1 + m]\n    b_lo = take`{back=n} (zext a.lo)\n    b_hi = take`{back=n} (zext a.lo .+. zext a.sz)\n    b_sz = b_hi .-. b_lo\n\ntrunc : {m, n} (fin m, fin n) => Dom (m + n) -> Dom n\ntrunc a =\n  if a.sz > mask`{n} then top\n  else interval (drop`{m} a.lo) (drop`{m} a.sz)\n\nadd : {n} (fin n) => Dom n -> Dom n -> Dom n\nadd a b =\n  if carry a.sz b.sz then top\n  else interval (a.lo + b.lo) (a.sz .+. b.sz)\n\nneg : {n} (fin n) => Dom n -> Dom n\nneg a = interval (- (a.lo + a.sz)) a.sz\n\n\/\/ Turns out, bitwise complement is easy to specify\n\/\/ in this domain also\nbnot : {n} (fin n) => Dom n -> Dom n\nbnot a = interval (~ ah) a.sz\n  where ah = a.lo + a.sz\n\nmul : {n} (fin n) => Dom n -> Dom n -> Dom n\nmul a b =\n  if sz >= bit`{n} then top\n  else interval (drop lo) (drop sz)\n  where\n    (lo, hi) = mulRange (zbounds a) (zbounds b)\n    sz = hi - lo\n\nzbounds : {n} (fin n) => Dom n -> ([1 + n], [1 + n])\nzbounds a = (lo', lo' + zext a.sz)\n  where\n    size : [2 + n]\n    size = bit`{n}\n    lo' = if 2 * zext a.lo .+. zext a.sz >= size then 0b1 # a.lo else 0b0 # a.lo\n\nmulRange : {m, n} (fin m, fin n, m >= 1, n >= 1) => ([m], [m]) -> ([n], [n]) -> ([m+n], [m+n])\nmulRange (xl, xh) (yl, yh) = (zl, zh)\n  where\n    (xlyl, xlyh) = scaleRange xl (yl, yh)\n    (xhyl, xhyh) = scaleRange xh (yl, yh)\n    zl = smin xlyl xhyl\n    zh = smax xlyh xhyh\n\nscaleRange : {m, n} (fin m, fin n, m >= 1, n >= 1) => [m] -> ([n], [n]) -> ([m+n], [m+n])\nscaleRange k (lo, hi) = if k <$ 0 then (hi', lo') else (lo', hi')\n  where\n    lo' = sext k * sext lo\n    hi' = sext k * sext hi\n\nudiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nudiv a b = range cl ch\n  where\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    bl' = max 1 bl \/\/ assume that division by 0 does not happen\n    bh' = max 1 bh \/\/ assume that division by 0 does not happen\n    cl = al \/ bh'\n    ch = ah \/ bl'\n\nurem : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nurem a b =\n  if ql == qh then range rl rh\n  else interval 0 (bh - 1)\n  where\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    bl' = max 1 bl \/\/ assume that division by 0 does not happen\n    bh' = max 1 bh\n    (ql, rl) = (al \/ bh', al % bh')\n    (qh, rh) = (ah \/ bl', ah % bl')\n\n\/\/ The first argument is an ordinary signed interval, but the second\n\/\/ argument is a reciaprocal interval: The arguments should satisfy 'al\n\/\/ <=$ ah' (signed) and '1\/bl <= 1\/bh' (signed), or equivalently, 'bh\n\/\/ <= bl' (unsigned).\nsdivRange : {n} (fin n, n >= 1) => ([n], [n]) -> ([n], [n]) -> ([1+n], [1+n])\nsdivRange (al, ah) (bl, bh) = (ql, qh)\n  where\n    (ql1, qh1) = shrinkRange (al, ah) bh\n    (ql2, qh2) = shrinkRange (al, ah) bl\n    ql = smin ql1 ql2\n    qh = smax qh1 qh2\n\n\/\/ Extra bit of output is to handle the 'INTMIN \/ -1' overflow case.\nshrinkRange : {n} (fin n, n >= 1) => ([n], [n]) -> [n] -> ([1+n], [1+n])\nshrinkRange (lo, hi) k =\n  if k >$ 0 then (lo .\/. k, hi .\/. k) else\n  if k <$ 0 then (hi .\/. k, lo .\/. k) else (sext lo, sext hi)\n  where\n    x .\/. y = sext x \/$ sext y\n\nsdiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nsdiv a b =\n  if sz >= bit`{n} then top\n  else interval (drop lo) (drop sz)\n  where\n    (lo, hi) = sdivRange (sbounds a) (rbounds b)\n    sz = hi - lo\n\nsrem : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nsrem a b =\n  if ql == qh then\n    (if ql <$ 0\n     then range (al - drop ql * bl) (ah - drop ql * bh)\n     else range (al - drop ql * bh) (ah - drop ql * bl))\n  else range rl rh\n  where\n    (al, ah) = sbounds a\n    (bl, bh) = sbounds b\n    (ql, qh) = sdivRange (al, ah) (rbounds b)\n    rl = if al <$ 0 then smin (bl+1) (-bh+1) else 0\n    rh = if ah >$ 0 then smax (-bl-1) (bh-1) else 0\n\nshl : {n} (fin n) => Dom n -> Dom n -> Dom n\nshl a b =\n  if sz > mask`{n} then top\n  else interval (drop lo) (drop sz)\n  where\n    al, ah : [n + 1]\n    (al, ah) = zbounds a\n    bl, bh : [n]\n    (bl, bh) = ubounds b\n    \/\/ [n + 2] is enough to avoid signed overflow in shift\n    cl, ch : [n + 2]\n    cl = if bl < `n then 1 << bl else bit`{n}\n    ch = if bh < `n then 1 << bh else bit`{n}\n    (lo, hi) = mulRange (al, ah) (cl, ch)\n    sz = hi - lo\n\nlshr : {n} (fin n) => Dom n -> Dom n -> Dom n\nlshr a b = interval cl (ch - cl)\n  where\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    cl = al >> bh\n    ch = ah >> bl\n\nashr : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nashr a b = interval cl (ch - cl)\n  where\n    (al, ah) = sbounds a\n    (bl, bh) = ubounds b\n    cl = al >>$ (if al <$ 0 then bl else bh)\n    ch = ah >>$ (if ah <$ 0 then bh else bl)\n\nult : {n} (fin n) => Dom n -> Dom n -> Bit\nult a b = (ubounds a).1 < (ubounds b).0\n\nule : {n} (fin n) => Dom n -> Dom n -> Bit\nule a b = (ubounds a).1 <= (ubounds b).0\n\nslt : {n} (fin n, n >= 1) => Dom n -> Dom n -> Bit\nslt a b = (sbounds a).1 <$ (sbounds b).0\n\nsle : {n} (fin n, n >= 1) => Dom n -> Dom n -> Bit\nsle a b = (sbounds a).1 <=$ (sbounds b).0\n\nult_sum_common_equiv : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nult_sum_common_equiv a b c =\n  if al == ah \/\\ bl == bh \/\\ al == bl\n    then True\n    else if ~(carry cl c.sz)\n      then check_same_wrap_interval cl ch\n      else check_same_wrap_interval cl mask`{n} \/\\ check_same_wrap_interval 0 ch\n  where\n    (cl, ch) = (c.lo, c.lo + c.sz)\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    check_same_wrap_interval lo hi =\n      ~(carry ah hi) \/\\ ~(carry bh hi) \\\/ carry al lo \/\\ carry bl lo\n\n\/\/ A bitmask indicating which bits cannot be determined\n\/\/ given the interval information in the given domain\nunknowns : {n} (fin n, n >= 1) => Dom n -> [n]\nunknowns a = if carry a.lo a.sz then ~0 else bits\n where\n bits = fillright diff\n diff = a.lo ^ (a.lo + a.sz)\n\nfillright : {n} (fin n, n >= 1) => [n] -> [n]\nfillright x = tail (scanl (||) False x)\n\nfillright_alt : {n} (fin n, n >= 1) => [n] -> [n]\nfillright_alt x = x || ((1 << lg2 x) - 1)\n\nproperty fillright_equiv x = fillright`{16} x == fillright_alt x\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Correctness properties\n\ninfix 20 =@=\n\n\/** Equivalence of bitvector domains. *\/\n(=@=) : {n} (fin n) => Dom n -> Dom n -> Bit\na =@= b = (a.sz == ~0 \/\\ b.sz == ~0) \\\/ (a == b)\n\ninfix 5 <==>\n\n(<==>) : Bit -> Bit -> Bit\n(<==>) = (==)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Soundness properties\n\ncorrect_top : {n} (fin n) => [n] -> Bit\ncorrect_top x = mem top x\n\ncorrect_ubounds : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_ubounds a x =\n  mem a x ==> umem (ubounds a) x\n\ncorrect_sbounds : {n} (fin n, n >= 1) => Dom n -> [n] -> Bit\ncorrect_sbounds a x =\n  mem a x ==> smem (sbounds a) x\n\ncorrect_singleton : {n} (fin n) => [n] -> [n] -> Bit\ncorrect_singleton x y =\n  mem (singleton x) y <==> x == y\n\ncorrect_overlap : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_overlap a b x =\n  mem a x ==> mem b x ==> overlap a b\n\ncorrect_overlap_inv : {n} (fin n) => Dom n -> Dom n -> Bit\ncorrect_overlap_inv a b =\n  overlap a b ==> (mem a witness \/\\ mem b witness)\n\n where\n witness = if mem a b.lo then b.lo else a.lo\n\ncorrect_union : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_union a b x =\n  (mem a x \\\/ mem b x) ==> mem (union a b) x\n\ncorrect_zero_ext : {m, n} (fin m, m >= n) => Dom n -> [n] -> Bit\ncorrect_zero_ext a x =\n  mem a x ==> mem (zero_ext`{m} a) (zext`{m} x)\n\ncorrect_sign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> [n] -> Bit\ncorrect_sign_ext a x =\n  mem a x ==> mem (sign_ext`{m} a) (sext`{m} x)\n\ncorrect_concat : {m, n} (fin m, fin n) => Dom m -> Dom n -> [m] -> [n] -> Bit\ncorrect_concat a b x y =\n  mem a x ==> mem b y ==> mem (concat a b) (x # y)\n\ncorrect_shrink : {m, n} (fin m, fin n) => Dom (m + n) -> [m + n] -> Bit\ncorrect_shrink a x =\n  mem a x ==> mem (shrink`{m} a) (take`{m} x)\n\ncorrect_trunc : {m, n} (fin m, fin n) => Dom (m + n) -> [m + n] -> Bit\ncorrect_trunc a x =\n  mem a x ==> mem (trunc`{m} a) (drop`{m} x)\n\ncorrect_add : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_add a b x y =\n  mem a x ==> mem b y ==> mem (add a b) (x + y)\n\ncorrect_neg : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_neg a x =\n  mem a x <==> mem (neg a) (- x)\n\ncorrect_mul : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_mul a b x y =\n  mem a x ==> mem b y ==> mem (mul a b) (x * y)\n\ncorrect_mulRange : {n} (fin n, n >= 1) => ([n], [n]) -> ([n], [n]) -> [n] -> [n] -> Bit\ncorrect_mulRange a b x y =\n  smem a x ==> smem b y ==> smem (mulRange a b) (sext x * sext y)\n\ncorrect_udiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_udiv a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (udiv a b) (x \/ y)\n\ncorrect_urem : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_urem a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (urem a b) (x % y)\n\ncorrect_sdivRange : {n} (fin n, n >= 1) => ([n], [n]) -> ([n], [n]) -> [n] -> [n] -> Bit\ncorrect_sdivRange a b x y =\n  smem a x ==> umem b y ==> y != 0 ==> smem (sdivRange a (b.1, b.0)) (sext x \/$ sext y)\n\ncorrect_shrinkRange : {n} (fin n, n >= 1) => ([n], [n]) -> [n] -> [n] -> Bit\ncorrect_shrinkRange a x y =\n  smem a x ==> y != 0 ==> smem (shrinkRange a y) (sext x \/$ sext y)\n\ncorrect_sdiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_sdiv a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (sdiv a b) (x \/$ y)\n\ncorrect_srem : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_srem a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (srem a b) (x %$ y)\n\ncorrect_shl : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_shl a b x y =\n  mem a x ==> mem b y ==> mem (shl a b) (x << y)\n\ncorrect_lshr : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_lshr a b x y =\n  mem a x ==> mem b y ==> mem (lshr a b) (x >> y)\n\ncorrect_ashr : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_ashr a b x y =\n  mem a x ==> mem b y ==> mem (ashr a b) (x >>$ y)\n\ncorrect_slt : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_slt a b x y =\n  slt a b ==> mem a x ==> mem b y ==> x <$ y\n\ncorrect_sle : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_sle a b x y =\n  sle a b ==> mem a x ==> mem b y ==> x <=$ y\n\ncorrect_ult : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_ult a b x y =\n  ult a b ==> mem a x ==> mem b y ==> x < y\n\ncorrect_ule : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_ule a b x y =\n  ule a b ==> mem a x ==> mem b y ==> x <= y\n\ncorrect_ult_sum_common_equiv :\n  {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n -> [n] -> [n] -> [n] -> Bit\ncorrect_ult_sum_common_equiv a b c x y z =\n  ult_sum_common_equiv a b c ==>\n  mem a x ==> mem b y ==> mem c z ==>\n  (x + z < y + z <==> x < y)\n\ncorrect_bnot : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_bnot a x =\n  mem a x <==> mem (bnot a) (~ x)\n\ncorrect_isSingleton : {n} (fin n) => Dom n -> Bit\ncorrect_isSingleton a =\n  isSingleton a ==> a == singleton a.lo\n\ncorrect_unknowns : {n} (fin n, n >= 1) => Dom n -> [n] -> [n] -> Bit\ncorrect_unknowns a x y =\n  mem a x ==> mem a y ==> (x || unknowns a) == (y || unknowns a)\n\nproperty p1 = correct_top`{16}\nproperty p2 = correct_ubounds`{16}\nproperty p3 = correct_sbounds`{16}\nproperty p4 = correct_singleton`{16}\nproperty p5 = correct_overlap`{16}\nproperty p5_inv = correct_overlap_inv`{16}\nproperty p6 = correct_union`{8}\nproperty p7 = correct_zero_ext`{32, 16}\nproperty p8 = correct_sign_ext`{32, 16}\nproperty p9 = correct_concat`{16, 16}\nproperty p10 = correct_shrink`{8, 8}\nproperty p11 = correct_trunc`{8, 8}\nproperty p12 = correct_unknowns`{16}\nproperty p13 = correct_isSingleton`{16}\n\nproperty a1 = correct_add`{8}\nproperty a2 = correct_neg`{16}\nproperty a3 = correct_mul`{4}\nproperty a4 = correct_udiv`{8}\nproperty a5 = correct_urem`{6}\nproperty a6 = correct_sdiv`{6}\nproperty a7 = correct_srem`{6}\nproperty a8 = correct_bnot`{16}\nproperty a9 = correct_sdivRange`{6}\n\nproperty s1 = correct_shl`{8}\nproperty s2 = correct_lshr`{8}\nproperty s3 = correct_ashr`{8}\n\nproperty o1 = correct_slt`{16}\nproperty o2 = correct_sle`{16}\nproperty o3 = correct_ult`{16}\nproperty o4 = correct_ule`{16}\nproperty o5 = correct_ult_sum_common_equiv`{4}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Operations preserve singletons\n\nsingleton_overlap : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_overlap x y =\n  overlap (singleton x) (singleton y) == (x == y)\n\nsingleton_zero_ext : {m, n} (fin m, m >= n) => [n] -> Bit\nsingleton_zero_ext x =\n  zero_ext`{m} (singleton x) == singleton (zext`{m} x)\n\nsingleton_sign_ext : {m, n} (fin m, m >= n, n >= 1) => [n] -> Bit\nsingleton_sign_ext x =\n  sign_ext`{m} (singleton x) == singleton (sext`{m} x)\n\nsingleton_concat : {m, n} (fin m, fin n) => [m] -> [n] -> Bit\nsingleton_concat x y =\n  concat (singleton x) (singleton y) == singleton (x # y)\n\nsingleton_shrink : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_shrink x =\n  shrink`{m} (singleton x) == singleton (take`{m} x)\n\nsingleton_trunc : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_trunc x =\n  trunc`{m} (singleton x) == singleton (drop`{m} x)\n\nsingleton_add : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_add x y =\n  add (singleton x) (singleton y) == singleton (x + y)\n\nsingleton_neg : {n} (fin n) => [n] -> Bit\nsingleton_neg x =\n  neg (singleton x) == singleton (- x)\n\nsingleton_mul : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_mul x y =\n  mul (singleton x) (singleton y) == singleton (x * y)\n\nsingleton_mulRange : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_mulRange x y =\n  mulRange (x, x) (y, y) == (sext x * sext y, sext x * sext y)\n\nsingleton_udiv : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_udiv x y =\n  y != 0 ==> udiv (singleton x) (singleton y) == singleton (x \/ y)\n\nsingleton_urem : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_urem x y =\n  y != 0 ==> urem (singleton x) (singleton y) == singleton (x % y)\n\nsingleton_sdiv : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_sdiv x y =\n  y != 0 ==> sdiv (singleton x) (singleton y) == singleton (x \/$ y)\n\nsingleton_srem : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_srem x y =\n  y != 0 ==> srem (singleton x) (singleton y) == singleton (x %$ y)\n\nsingleton_shl : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_shl x y =\n  shl (singleton x) (singleton y) == singleton (x << y)\n\nsingleton_lshr : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_lshr x y =\n  lshr (singleton x) (singleton y) == singleton (x >> y)\n\nsingleton_ashr : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ashr x y =\n  ashr (singleton x) (singleton y) == singleton (x >>$ y)\n\nsingleton_slt : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_slt x y =\n  slt (singleton x) (singleton y) == (x <$ y)\n\nsingleton_sle : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_sle x y =\n  sle (singleton x) (singleton y) == (x <=$ y)\n\nsingleton_ult : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ult x y =\n  ult (singleton x) (singleton y) == (x < y)\n\nsingleton_ule : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ule x y =\n  ule (singleton x) (singleton y) == (x <= y)\n\nproperty i01 = singleton_overlap`{16}\nproperty i02 = singleton_zero_ext`{32, 16}\nproperty i03 = singleton_sign_ext`{32, 16}\nproperty i04 = singleton_concat`{16, 16}\nproperty i05 = singleton_shrink`{8, 8}\nproperty i06 = singleton_trunc`{8, 8}\nproperty i07 = singleton_add`{8}\nproperty i08 = singleton_neg`{16}\nproperty i09 = singleton_mul`{4}\nproperty i10 = singleton_udiv`{8}\nproperty i11 = singleton_urem`{8}\nproperty i12 = singleton_sdiv`{8}\nproperty i13 = singleton_srem`{8}\nproperty i14 = singleton_shl`{8}\nproperty i15 = singleton_lshr`{8}\nproperty i16 = singleton_ashr`{8}\nproperty i17 = singleton_slt`{16}\nproperty i18 = singleton_sle`{16}\nproperty i19 = singleton_ult`{16}\nproperty i20 = singleton_ule`{16}\n\ncomm_overlap : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_overlap a b = overlap a b <==> overlap b a\n\ncomm_add : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_add a b = add a b == add b a\n\nassoc_add : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nassoc_add a b c = add a (add b c) =@= add (add a b) c\n\ncomm_mul : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_mul a b = mul a b == mul b a\n\n\/* mul is not associative! *\/\nassoc_mul : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nassoc_mul a b c = mul a (mul b c) =@= mul (mul a b) c\n\ncomm_mulRange :\n  {i, j} (fin i, fin j, i >= 1, j >= 1) => ([i], [i]) -> ([j], [j]) -> Bit\ncomm_mulRange a b =\n  a.0 <=$ a.1 ==> b.0 <=$ b.1 ==> mulRange a b == mulRange b a\n\nassoc_mulRange :\n  {i, j, k} (fin i, fin j, fin k, i >= 1, j >= 1, k >= 1) =>\n  ([i], [i]) -> ([j], [j]) -> ([k], [k]) -> Bit\nassoc_mulRange a b c =\n  a.0 <=$ a.1 ==>\n  b.0 <=$ b.1 ==>\n  c.0 <=$ c.1 ==>\n  mulRange a (mulRange b c) == mulRange (mulRange a b) c\n\nproperty c1 = comm_overlap`{16}\nproperty c2 = comm_add`{16}\nproperty c3 = assoc_add`{16}\nproperty c4 = comm_mul`{4}\nproperty c5 = comm_mulRange`{4,4}\nproperty c6 = assoc_mulRange`{3,3,3}\n\ncomm_union : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_union a b = union a b == union b a\n\n\/* union is actually not associative! *\/\nassoc_union : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nassoc_union a b c = union a (union b c) == union (union a b) c\n\n\/* union always has a lower bound equal to one of the input lower bounds *\/\nlo_union : {n} (fin n) => Dom n -> Dom n -> Bit\nlo_union a b =\n  union a b == top \\\/ (union a b).lo == a.lo \\\/ (union a b).lo == b.lo\n\n\/* union always has an upper bound equal to one of the input upper bounds *\/\nhi_union : {n} (fin n) => Dom n -> Dom n -> Bit\nhi_union a b = c == top \\\/ c_hi == a_hi \\\/ c_hi == b_hi\n  where\n    c = union a b\n    a_hi = a.lo + a.sz\n    b_hi = b.lo + b.sz\n    c_hi = c.lo + c.sz\n\n\/* union doesn't return top unless necessary *\/\nnontriv_union : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\nnontriv_union a b x =\n  union a b =@= top ==> mem a x \\\/ mem b x\n\n\/* union of opposite intervals prefers to exclude zero *\/\nnonzero_union : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nnonzero_union lo sz =\n  mem (union a b) half \/\\\n  (~ mem a 0 ==> ~ mem b 0 ==> ~ mem (union a b) 0)\n  where\n    half : [n]\n    half = reverse 1\n    a = interval lo sz\n    b = interval (lo + half) sz\n\nproperty u1 = comm_union`{16}\nproperty u2 = lo_union`{16}\nproperty u3 = hi_union`{16}\nproperty u4 = nontriv_union`{8}\nproperty u5 = nonzero_union`{16}\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/deps\/cryptol\/tests\/enum\/BasicEnums.cry","filetype":"cry","content":"\/** Custom docs for E1 *\/\nenum E1  = A | B | C\nenum M a = N | J a\nenum N n a =\n  | \/** Note that we allow a starting | *\/ X [n]\n  | Y [n-2]\n  | Z a\n\n\n\/\/  Pattern matching\n\nc1 e =\n  case e of\n    A -> 1 : [8]\n    B -> 2\n    C -> 3\n\nc2 : {n} (n>=2) => N n [n] -> [n]\nc2 e =\n  case e of\n    X a -> a\n    Y b -> zero`{[2]} # b\n    Z a -> a\n\nc3 e = case e of A -> 1 : [8]; B -> 2; C -> 3\n\n\/\/ Construction\n\ne1 = N\ne2 = Y 3\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/deps\/cryptol\/tests\/issues\/issue_1867.cry","filetype":"cry","content":"module Param where\n\nparameter\n  type n : #\n  myparam : [n]\n\nfoo : {m} [m][n] -> [m][n]\nfoo = map ((&&) myparam)\n\nbar = map ((&&) myparam)","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/ffs_gen_aig.saw","filetype":"saw","content":"cls <- java_load_class \"FFS\";\nbc <- llvm_load_module \"ffs.bc\";\njava_ffs_ref <- jvm_extract cls \"ffs_ref\";\njava_ffs_imp <- jvm_extract cls \"ffs_imp\";\nc_ffs_ref <- llvm_extract bc \"ffs_ref\";\nc_ffs_imp <- llvm_extract bc \"ffs_imp\";\nwrite_aig \"java_ffs_ref.aig\" java_ffs_ref;\nwrite_aig \"java_ffs_imp.aig\" java_ffs_imp;\nwrite_aig \"c_ffs_ref.aig\" c_ffs_ref;\nwrite_aig \"c_ffs_imp.aig\" c_ffs_imp;\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/ffs_llvm.saw","filetype":"saw","content":"set_base 16;\n\nprint \"Extracting reference term: ffs_ref\";\nl <- llvm_load_module \"ffs.bc\";\nffs_ref <- llvm_extract l \"ffs_ref\";\n\nprint \"Extracting implementation term: ffs_imp\";\nffs_imp <- llvm_extract l \"ffs_imp\";\n\nprint \"Extracting implementation term: ffs_musl\";\nffs_musl <- llvm_extract l \"ffs_musl\";\n\nprint \"Extracting buggy term: ffs_bug\";\nffs_bug <- llvm_extract l \"ffs_bug\";\n\nprint \"Proving equivalence: ffs_ref == ffs_imp\";\nlet thm1 = {{ \\x -> ffs_ref x == ffs_imp x }};\nresult <- prove abc thm1;\nprint result;\n\nprint \"Proving equivalence: ffs_ref == ffs_musl\";\nlet thm2 = {{ \\x -> ffs_ref x == ffs_musl x }};\nresult <- prove abc thm2;\nprint result;\n\nprint \"Finding bug via sat search: ffs_ref != ffs_bug\";\nlet thm3 = {{ \\x -> ffs_ref x != ffs_bug x }};\nresult <- sat abc thm3;\nprint result;\n\nprint \"Finding bug via failed proof: ffs_ref == ffs_bug\";\nlet thm4 = {{ \\x -> ffs_ref x == ffs_bug x }};\nresult <- prove abc thm4;\nprint result;\n\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/NQueens.cry","filetype":"cry","content":"\/* To see this in action, try:\n\n  :sat nQueens : (Solution n)\n  where n is the board-size\n\n  You may find that cvc4 takes a long time for solutions bigger than 5.\n  For those sizes, we have had good luck with both Yices and Z3.  \n\n  To do that,\n\n  :set prover=Z3\n  or\n  :set prover=yices\n*\/\n\nall : {n, a} (fin n) => (a -> Bit, [n]a) -> Bit\nall (f, xs) = [ f x | x <- xs ] == ~zero\n\ncontains xs e = [ x == e | x <- xs ] != zero\n\ndistinct : {n,a} (fin n, Cmp a) => [n]a -> Bit\ndistinct xs =\n    [ if n1 < n2 then x != y else True\n    | (x,n1) <- numXs , (y,n2) <- numXs\n    ] == ~zero\n  where\n  numXs = [ (x,n) | x <- xs | n <- [ (0:[width n]) ... ] ]\n\ntype Position n = [width (n - 1)]\n\ntype Board n = [n](Position n)\n\ntype Solution n = Board n -> Bit\n\ncheckDiag : {n} (fin n, n >= 1) => Board n -> (Position n, Position n) -> Bit\ncheckDiag qs (i, j) = (i >= j) || (diffR != diffC)\n  where   qi = qs @ i\n          qj = qs @ j\n          diffR = if qi >= qj then qi-qj else qj-qi\n          diffC = j - i                   \/\/ we know i < j\n\nnQueens : {n} (fin n, n >= 1) => Solution n\nnQueens qs = all (inRange qs, qs) && all (checkDiag qs, ijs `{n}) && distinct qs\n\nijs : {n}(fin n, n>= 1)=> [_](Position n, Position n)\nijs = [ (i, j) | i <- [0 .. (n-1)], j <- [0 .. (n-1)]]\n\ninRange : {n} (fin n, n >= 1) => Board n -> Position n -> Bit\ninRange qs x = x <= `(n - 1)\n\nproperty nQueensProve x = (nQueens x) == False\n\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/ffs_compare_aig.saw","filetype":"saw","content":"java_ffs_ref <- read_aig \"java_ffs_ref.aig\";\njava_ffs_imp <- read_aig \"java_ffs_imp.aig\";\nc_ffs_ref <- read_aig \"c_ffs_ref.aig\";\nc_ffs_imp <- read_aig \"c_ffs_imp.aig\";\n\nlet thm1 = {{ \\x -> java_ffs_ref x == java_ffs_imp x }};\nprove_print abc thm1;\n\nlet thm2 = {{ \\x -> c_ffs_ref x == c_ffs_imp x }};\nprove_print abc thm2;\n\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/nqueens.saw","filetype":"saw","content":"import \"NQueens.cry\";\n\nprint {{ nQueens [0,1,2,3,4,5,6,7] }};\n\nsat_print abc {{ nQueens`{8} }};\n\nprint {{ nQueens [3,1,6,2,5,7,4,0] }};\n","variant":"hybrid","set":"holdout"}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/Cipher.cry","filetype":"cry","content":"module Cipher where\n\ntype Cipher KeySize BlockSize =\n  { encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  , decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  }\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/double.saw","filetype":"saw","content":"l <- llvm_load_module \"double.bc\";\ndouble_imp <- llvm_extract l \"double_imp\";\ndouble_ref <- llvm_extract l \"double_ref\";\nlet thm = {{ \\x -> double_ref x == double_imp x }};\n\nr <- prove yices thm;\nprint r;\n\nr <- prove z3 thm;\nprint r;\n\nlet thm_neg = {{ \\x -> ~(thm x) }};\nwrite_smtlib2 \"double.smt2\" thm_neg;\n\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/dotprod.saw","filetype":"saw","content":"import \"dotprod.cry\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet dotprod_spec n = do {\n    let nt = llvm_term {{ `n : [32] }};\n    (xs, xsp) <- ptr_to_fresh \"xs\" (llvm_array n (llvm_int 32));\n    (ys, ysp) <- ptr_to_fresh \"ys\" (llvm_array n (llvm_int 32));\n    llvm_execute_func [xsp, ysp, nt];\n    llvm_return (llvm_term {{ dotprod xs ys }});\n};\n\nm <- llvm_load_module \"dotprod.bc\";\n\ndotprod_ov <- llvm_verify m \"dotprod\" [] true (dotprod_spec 10) z3;\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/ffs.cry","filetype":"cry","content":"\/\/ return the index of the first non-zero bit (big-endian bit order)\nffs_ref: [32] -> [32]\nffs_ref x = ixs!0 where\n    ixs = [0] # [ if (x && (1 << i)) != 0 then (i+1) else prev\n                | prev <- ixs\n                | i <- [31, 30 .. 0]:[32][32]\n                ]\n\nffs_imp: [32] -> [32]\nffs_imp i = if (i'''' > 0) then (n'''' + ((i'''' + 1) && 1)) else 0 where\n    n = 1\n    (n', i') =       if (zero==(i && 0x0000ffff))    then (n + 16, i >> 16) else (n, i)\n    (n'', i'') =     if (zero==(i' && 0x000000ff))   then (n' + 8, i' >> 8) else (n', i')\n    (n''', i''') =   if (zero==(i'' && 0x0000000f))  then (n'' + 4, i'' >> 4) else (n'',i'')\n    (n'''', i'''') = if (zero==(i''' && 0x00000003)) then (n''' + 2, i''' >> 2) else (n''', i''')\n\nproperty ffs_correct x = ffs_ref x == ffs_imp x\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/des3.saw","filetype":"saw","content":"import \"DES.cry\";\n\nprint \"proving dec_enc...\";\nlet prop1 = {{ \\key msg -> decrypt key (encrypt key msg) == msg }};\ndec_enc <- prove_print w4_abc_verilog {{prop1}};\n\nprint dec_enc;\n\nprint \"proving enc_dec...\";\nlet prop2 = {{ \\key msg -> encrypt key (decrypt key msg) == msg }};\nenc_dec <- prove_print w4_abc_verilog {{prop2}};\n\nprint enc_dec;\n\nlet ss = addsimp dec_enc (addsimp enc_dec basic_ss);\n\nlet {{ enc3 k1 k2 k3 msg = encrypt k3 (decrypt k2 (encrypt k1 msg)) }};\nlet {{ dec3 k1 k2 k3 msg = decrypt k1 (encrypt k2 (decrypt k3 msg)) }};\n\nprint \"proving dec3_enc3...\";\nlet {{ prop3 k1 k2 k3 msg = dec3 k1 k2 k3 (enc3 k1 k2 k3 msg) == msg }};\nprove_print do {\n    unfolding [\"prop3\"];\n    unfolding [\"dec3\", \"enc3\"];\n    simplify ss;\n    print_goal;\n    w4_abc_verilog;\n} {{prop3}};\n\nprint \"proving enc3_dec3...\";\nlet {{ prop4 k1 k2 k3 msg = enc3 k1 k2 k3 (dec3 k1 k2 k3 msg) == msg }};\nprove_print do {\n    unfolding [\"prop4\"];\n    unfolding [\"dec3\", \"enc3\"];\n    simplify ss;\n    print_goal;\n    w4_abc_verilog;\n} {{prop4}};\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/ffs_compare.saw","filetype":"saw","content":"import \"ffs.cry\";\nj <- java_load_class \"FFS\";\njava_ffs_ref <- jvm_extract j \"ffs_ref\";\njava_ffs_imp <- jvm_extract j \"ffs_imp\";\n\nl <- llvm_load_module \"ffs.bc\";\nc_ffs_ref <- llvm_extract l \"ffs_ref\";\nc_ffs_imp <- llvm_extract l \"ffs_imp\";\n\nprint \"java ref <-> java imp\";\nlet thm1 = {{ \\x -> java_ffs_ref x == java_ffs_imp x }};\nprove_print abc thm1;\n\nprint \"c ref <-> c imp\";\nlet thm2 = {{ \\x -> c_ffs_ref x == c_ffs_imp x }};\nprove_print abc thm2;\n\nprint \"java imp <-> c imp\";\nlet thm3 = {{ \\x -> java_ffs_imp x == c_ffs_imp x }};\nprove_print abc thm3;\n\nprint \"cryptol imp <-> c imp\";\nlet thm4 = {{ \\x -> ffs_imp x == c_ffs_imp x }};\nprove_print abc thm4;\n\nprint \"cryptol imp <-> cryptol ref\";\nlet thm5 = {{ \\x -> ffs_imp x == ffs_ref x }};\nprove_print abc thm5;\n\nprint \"Done.\";\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/doc\/rust-verification-with-saw\/code\/salsa20\/Salsa20Extras.cry","filetype":"cry","content":"module Salsa20Extras where\n\nimport Salsa20\n\ntype STATE_WORDS = 16\ntype BLOCK_SIZE = 64\n\ncounter_setup : [STATE_WORDS][32] -> [64] -> [STATE_WORDS][32]\ncounter_setup state counter =\n  updates state [8, 9] [drop counter, drop (counter >> 32)]\n\napply_keystream : [32] -> [STATE_WORDS][32] -> [64] -> [BLOCK_SIZE][8] -> [BLOCK_SIZE][8]\napply_keystream count state0 counter output =\n    output ^ littleendian_state_inverse state2\n  where\n    state1 = counter_setup state0 counter\n    state2 = Salsa20_rounds count state1 state1\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-script\/doc\/rust-verification-with-saw\/code\/salsa20\/Salsa20.cry","filetype":"cry","content":"\/\/ see http:\/\/cr.yp.to\/snuffle\/spec.pdf\n\nmodule Salsa20 where\n\nquarterround : [4][32] -> [4][32]\nquarterround [y0, y1, y2, y3] = [z0, z1, z2, z3]\n  where\n    z1 = y1 ^ ((y0 + y3) <<< 0x7)\n    z2 = y2 ^ ((z1 + y0) <<< 0x9)\n    z3 = y3 ^ ((z2 + z1) <<< 0xd)\n    z0 = y0 ^ ((z3 + z2) <<< 0x12)\n\nproperty quarterround_passes_tests =\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000000] == [0x00000000, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (quarterround [0x00000001, 0x00000000, 0x00000000, 0x00000000] == [0x08008145, 0x00000080, 0x00010200, 0x20500000]) \/\\\n  (quarterround [0x00000000, 0x00000001, 0x00000000, 0x00000000] == [0x88000100, 0x00000001, 0x00000200, 0x00402000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000001, 0x00000000] == [0x80040000, 0x00000000, 0x00000001, 0x00002000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000001] == [0x00048044, 0x00000080, 0x00010000, 0x20100001]) \/\\\n  (quarterround [0xe7e8c006, 0xc4f9417d, 0x6479b4b2, 0x68c67137] == [0xe876d72b, 0x9361dfd5, 0xf1460244, 0x948541a3]) \/\\\n  (quarterround [0xd3917c5b, 0x55f1c407, 0x52a58a7a, 0x8f887a3b] == [0x3e2f308c, 0xd90a8f36, 0x6ab2a923, 0x2883524c])\n\nrowround : [16][32] -> [16][32]\nrowround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =\n    [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]\n  where\n    [ z0,  z1,  z2,  z3] = quarterround [ y0,  y1,  y2,  y3]\n    [ z5,  z6,  z7,  z4] = quarterround [ y5,  y6,  y7,  y4]\n    [z10, z11,  z8,  z9] = quarterround [y10, y11,  y8,  y9]\n    [z15, z12, z13, z14] = quarterround [y15, y12, y13, y14]\n\nproperty rowround_passes_tests =\n  (rowround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n            [0x08008145, 0x00000080, 0x00010200, 0x20500000,\n             0x20100001, 0x00048044, 0x00000080, 0x00010000,\n             0x00000001, 0x00002000, 0x80040000, 0x00000000,\n             0x00000001, 0x00000200, 0x00402000, 0x88000100]) \/\\\n  (rowround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n             0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n             0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n             0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n            [0xa890d39d, 0x65d71596, 0xe9487daa, 0xc8ca6a86,\n             0x949d2192, 0x764b7754, 0xe408d9b9, 0x7a41b4d1,\n             0x3402e183, 0x3c3af432, 0x50669f96, 0xd89ef0a8,\n             0x0040ede5, 0xb545fbce, 0xd257ed4f, 0x1818882d])\n\n\nrowround_opt : [16][32] -> [16][32]\nrowround_opt ys = join [ (quarterround (yi<<<i))>>>i | yi <- split ys | i <- [0 .. 3] ]\n\nproperty rowround_opt_is_rowround ys = rowround ys == rowround_opt ys\n\ncolumnround : [16][32] -> [16][32]\ncolumnround [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15] =\n    [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15]\n  where\n    [ y0,  y4,  y8, y12] = quarterround [ x0,  x4,  x8, x12]\n    [ y5,  y9, y13,  y1] = quarterround [ x5,  x9, x13,  x1]\n    [y10, y14,  y2,  y6] = quarterround [x10, x14,  x2,  x6]\n    [y15,  y3,  y7, y11] = quarterround [x15,  x3,  x7, x11]\n\nproperty columnround_passes_tests =\n  (columnround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x10090288, 0x00000000, 0x00000000, 0x00000000,\n                0x00000101, 0x00000000, 0x00000000, 0x00000000,\n                0x00020401, 0x00000000, 0x00000000, 0x00000000,\n                0x40a04001, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (columnround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n                0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n                0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n                0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n               [0x8c9d190a, 0xce8e4c90, 0x1ef8e9d3, 0x1326a71a,\n                0x90a20123, 0xead3c4f3, 0x63a091a0, 0xf0708d69,\n                0x789b010c, 0xd195a681, 0xeb7d5504, 0xa774135c,\n                0x481c2027, 0x53a8e4b5, 0x4c1f89c5, 0x3f78c9c8])\n\n\ncolumnround_opt : [16][32] -> [16][32]\ncolumnround_opt xs = join (transpose [ (quarterround (xi<<<i))>>>i | xi <- transpose(split xs) | i <- [0 .. 3] ])\n\ncolumnround_opt_is_columnround xs = columnround xs == columnround_opt xs\n\nproperty columnround_is_transpose_of_rowround ys =\n  rowround ys == join(transpose(split`{4}(columnround xs)))\n  where xs = join(transpose(split`{4} ys))\n\ndoubleround : [16][32] -> [16][32]\ndoubleround(xs) = rowround(columnround(xs))\n\nproperty doubleround_passes_tests =\n  (doubleround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x8186a22d, 0x0040a284, 0x82479210, 0x06929051,\n                0x08000090, 0x02402200, 0x00004000, 0x00800000,\n                0x00010200, 0x20400000, 0x08008104, 0x00000000,\n                0x20500000, 0xa0000040, 0x0008180a, 0x612a8020]) \/\\\n  (doubleround [0xde501066, 0x6f9eb8f7, 0xe4fbbd9b, 0x454e3f57,\n                0xb75540d3, 0x43e93a4c, 0x3a6f2aa0, 0x726d6b36,\n                0x9243f484, 0x9145d1e8, 0x4fa9d247, 0xdc8dee11,\n                0x054bf545, 0x254dd653, 0xd9421b6d, 0x67b276c1] ==\n               [0xccaaf672, 0x23d960f7, 0x9153e63a, 0xcd9a60d0,\n                0x50440492, 0xf07cad19, 0xae344aa0, 0xdf4cfdfc,\n                0xca531c29, 0x8e7943db, 0xac1680cd, 0xd503ca00,\n                0xa74b2ad6, 0xbc331c5c, 0x1dda24c7, 0xee928277])\n\nlittleendian : [4][8] -> [32]\nlittleendian b = join(reverse b)\n\nproperty littleendian_passes_tests =\n  (littleendian [  0,   0,   0,   0] == 0x00000000) \/\\\n  (littleendian [ 86,  75,  30,   9] == 0x091e4b56) \/\\\n  (littleendian [255, 255, 255, 250] == 0xfaffffff)\n\nlittleendian_inverse : {n} (fin n) => [8 * n] -> [n][8]\nlittleendian_inverse b = reverse(split b)\n\nproperty littleendian_is_invertable b = littleendian_inverse(littleendian b) == b\n\nlittleendian_state : [64][8] -> [16][32]\nlittleendian_state b = [littleendian xi | xi <- split b]\n\nlittleendian_state_inverse : [16][32] -> [64][8]\nlittleendian_state_inverse w = join (map littleendian_inverse w)\n\nproperty littleendian_state_is_invertable b = littleendian_state_inverse(littleendian_state b) == b\n\nSalsa20 : [32] -> [64][8] -> [64][8]\nSalsa20 count xs = littleendian_state_inverse (Salsa20_rounds count xw xw)\n  where\n    xw = littleendian_state xs\n\nSalsa20_rounds : [32] -> [16][32] -> [16][32] -> [16][32]\nSalsa20_rounds count xw xw' = xw + zs@(count\/2)\n  where\n    zs = [xw'] # [ doubleround zi | zi <- zs ]\n\nproperty Salsa20_passes_tests =\n  (Salsa20 20 [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0] ==\n              [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]) \/\\\n  (Salsa20 20 [211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37, 191, 187, 234, 136,\n                49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,  86,  16, 179, 207,\n                31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113, 238,  55, 204,  36,\n                79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,  88, 118, 104,  54] ==\n              [109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,  26, 110, 170, 154,\n                29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,  69, 144,  51,  57,\n               118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35,  27, 111, 114, 114,\n               219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158, 179,  19,  48, 202]) \/\\\n  (Salsa20 20 [ 88, 118, 104,  54,  79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,\n               191, 187, 234, 136, 211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37,\n                86,  16, 179, 207,  49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,\n               238,  55, 204,  36,  31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113] ==\n              [179,  19,  48, 202, 219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158,\n                26, 110, 170, 154, 109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,\n                69, 144,  51,  57,  29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,\n                27, 111, 114, 114, 118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35])\n\nproperty Salsa20_has_no_collisions x1 x2 =\n  if(x1 != x2) then (doubleround x1) != (doubleround x2) else True\n\n\/\/ Salsa 20 supports two key sizes, [16][8] and [32][8]\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([32], [16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(count, k, n) = Salsa20 count (Salsa20_init(k, n))\n\nSalsa20_init : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_init(k, n) = x\n  where\n    [s0, s1, s2, s3] = split \"expand 32-byte k\" : [4][4][8]\n    [t0, t1, t2, t3] = split \"expand 16-byte k\" : [4][4][8]\n    x = if(`a == 2) then s0 # k0 # s1 # n # s2 # k1 # s3\n                    else t0 # k0 # t1 # n # t2 # k0 # t3\n    [k0, k1] = (split(k#zero)):[2][16][8]\n\nSalsa20_encrypt_with_offset : {a, l} (a >= 1, 2 >= a, l <= 2^^70) =>\n    ([32], [16*a][8], [8][8], [64], [l][8]) -> [l][8]\nSalsa20_encrypt_with_offset(count, k, v, o, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(count, k, v#(littleendian_inverse (o + i))) | i <- [0, 1 ... ] ])\n    c = m ^ salsa\n\nSalsa20_encrypt : {a, l} (a >= 1, 2 >= a, l <= 2^^70) => ([32], [16*a][8], [8][8], [l][8]) -> [l][8]\nSalsa20_encrypt(count, k, v, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(count, k, v#(littleendian_inverse i)) | i <- [0, 1 ... ] ])\n    c = m ^ salsa\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/otherTests\/cryptol-saw-core\/instance.cry","filetype":"cry","content":"\/* instance Zero Bit *\/\nzeroBit : Bit\nzeroBit = zero\n\n\/* instance Zero Integer *\/\nzeroInteger : Integer\nzeroInteger = zero\n\n\/* instance Zero Rational *\/\nzeroRational : Rational\nzeroRational = zero\n\n\/* instance (fin n, n >= 1) => Zero (Z n) *\/\nzeroZ : {n} (fin n, n >= 1) => Z n\nzeroZ = zero\n\n\/* instance Zero [n] *\/\nzeroWord : {n} [n]\nzeroWord = zero\n\n\/* instance (Zero a) => Zero [n]a *\/\nzeroSeq : {n, a} (Zero a) => [n]a\nzeroSeq = zero\n\n\/* instance (ValidFloat e p) => Zero (Float e p) *\/\nzeroFloat : {e, p} (ValidFloat e p) => Float e p\nzeroFloat = zero\n\n\/* instance (Zero b) => Zero (a -> b) *\/\nzeroFun : {a, b} (Zero b) => a -> b\nzeroFun = zero\n\n\/* instance Zero () *\/\nzeroUnit : ()\nzeroUnit = zero\n\n\/* instance (Zero a, Zero b, ...) => Zero (a, b, ...) *\/\nzeroTuple : {a, b} (Zero a, Zero b) => (a, b)\nzeroTuple = zero\n\n\/* instance Zero {} *\/\nzeroEmpty : {}\nzeroEmpty = zero\n\n\/* instance (Zero a, Zero b, ...) => Zero { x : a, y : b, ... } *\/\nzeroRecord : {a, b} (Zero a, Zero b) => {x : a, y : b}\nzeroRecord = zero\n\n\/* instance Logic Bit *\/\nlogicBit : Bit -> Bit\nlogicBit = complement\n\n\/* instance Logic [n] *\/\nlogicWord : {n} [n] -> [n]\nlogicWord = complement\n\n\/* instance (Logic a) => Logic [n]a *\/\nlogicSeq : {n, a} (Logic a) => [n]a -> [n]a\nlogicSeq = complement\n\n\/* instance (Logic b) => Logic (a -> b) *\/\nlogicFun : {a, b} (Logic b) => (a -> b) -> (a -> b)\nlogicFun = complement\n\n\/* instance Logic () *\/\nlogicUnit : () -> ()\nlogicUnit = complement\n\n\/* instance (Logic a, Logic b, ...) => Logic (a, b, ...) *\/\nlogicTuple : {a, b} (Logic a, Logic b) => (a, b) -> (a, b)\nlogicTuple = complement\n\n\/* instance Logic {} *\/\nlogicEmpty : {} -> {}\nlogicEmpty = complement\n\n\/* instance (Logic a, Logic b, ...) => Logic { x : a, y : b, ... } *\/\nlogicRecord : {a, b} (Logic a, Logic b) => {x : a, y : b} -> {x : a, y : b}\nlogicRecord = complement\n\n\/* instance Ring Integer *\/\nringInteger : Integer -> Integer\nringInteger = negate\n\n\/* instance Ring Rational *\/\nringRational : Rational -> Rational\nringRational = negate\n\n\/* instance (fin n, n >= 1) => Ring (Z n) *\/\nringZ : {n} (fin n, n >= 1) => Z n -> Z n\nringZ = negate\n\n\/* instance (fin n) => Ring [n] *\/\nringWord : {n} (fin n) => [n] -> [n]\nringWord = negate\n\n\/\/ NOTE: 'instance Ring a => Ring [n]a' holds for any type 'a'\n\/\/ distinct from 'Bit'.\n\n\/* instance Ring [n]Integer *\/\nringSeqInteger : {n} [n]Integer -> [n]Integer\nringSeqInteger = negate\n\n\/* instance Ring [n]Rational *\/\nringSeqRational : {n} [n]Rational -> [n]Rational\nringSeqRational = negate\n\n\/* instance (fin k, k >= 1) => Ring [n](Z k) *\/\nringSeqZ : {n, k} (fin k, k >= 1) => [n](Z k) -> [n](Z k)\nringSeqZ = negate\n\n\/* instance (Ring [k]a) => Ring [n][k]a *\/\nringSeqSeq : {n, k, a} (Ring ([k]a)) => [n][k]a -> [n][k]a\nringSeqSeq = negate\n\n\/* instance (Ring b) => Ring [n](a -> b) *\/\nringSeqFun : {n, a, b} (Ring b) => [n](a -> b) -> [n](a -> b)\nringSeqFun = negate\n\n\/* instance Ring [n]() *\/\nringSeqUnit : {n} [n]() -> [n]()\nringSeqUnit = negate\n\n\/* instance (Ring a, Ring b) => Ring [n](a, b) *\/\nringSeqTuple : {n, a, b} (Ring a, Ring b) => [n](a, b) -> [n](a, b)\nringSeqTuple = negate\n\n\/* instance Ring [n]{} *\/\nringSeqEmpty : {n} [n]{} -> [n]{}\nringSeqEmpty = negate\n\n\/* instance (Ring a, Ring b) => Ring [n]{x : a, y : b} *\/\nringSeqRecord : {n, a, b} (Ring a, Ring b) => [n]{x : a, y : b} -> [n]{x : a, y : b}\nringSeqRecord = negate\n\n\/* instance (ValidFloat e p) => Ring (Float e p) *\/\nringFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p\nringFloat = negate\n\n\/* instance (Ring b) => Ring (a -> b) *\/\nringFun : {a, b} (Ring b) => (a -> b) -> (a -> b)\nringFun = negate\n\n\/* instance Ring () *\/\nringUnit : () -> ()\nringUnit = negate\n\n\/* instance (Ring a, Ring b, ...) => Ring (a, b, ...) *\/\nringTuple : {a, b} (Ring a, Ring b) => (a, b) -> (a, b)\nringTuple = negate\n\n\/* instance Ring {} *\/\nringEmpty : {} -> {}\nringEmpty = negate\n\n\/* instance (Ring a, Ring b, ...) => Ring { x : a, y : b, ... } *\/\nringRecord : {a, b} (Ring a, Ring b) => {x : a, y : b} -> {x : a, y : b}\nringRecord = negate\n\n\/* instance Integral Integer *\/\nintegralInteger : Integer -> Integer -> Integer\nintegralInteger = (%)\n\n\/* instance (fin n) => Integral [n] *\/\nintegralWord : {n} (fin n) => [n] -> [n] -> [n]\nintegralWord = (%)\n\n\/* instance Field Rational *\/\nfieldRational : Rational -> Rational\nfieldRational = recip\n\n\/* instance (ValidFloat e p) => Field (Float e p) *\/\nfieldFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p\nfieldFloat = recip\n\n\/* instance (prime p) => Field (Z p) *\/\nfieldZ : {p} prime p => Z p -> Z p\nfieldZ = recip\n\n\/* instance Round Rational *\/\nroundRational : Rational -> Integer\nroundRational = floor\n\n\/* instance (ValidFloat e p) => Round (Float e p) *\/\nroundFloat : {e, p} (ValidFloat e p) => Float e p -> Integer\nroundFloat = floor\n\n\/* instance Eq Bit *\/\neqBit : Bit -> Bit -> Bit\neqBit = (==)\n\n\/* instance Eq Integer *\/\neqInteger : Integer -> Integer -> Bit\neqInteger = (==)\n\n\/* instance Eq Rational *\/\neqRational : Rational -> Rational -> Bit\neqRational = (==)\n\n\/* instance (fin n, n >= 1) => Eq (Z n) *\/\neqZ : {n} (fin n, n >= 1) => Z n -> Z n -> Bit\neqZ = (==)\n\n\/* instance (fin n) => Eq [n] *\/\neqWord : {n} (fin n) => [n] -> [n] -> Bit\neqWord = (==)\n\n\/* instance (fin n, Eq a) => Eq [n]a *\/\neqSeq : {n, a} (fin n, Eq a) => [n]a -> [n]a -> Bit\neqSeq = (==)\n\n\/* instance (ValidFloat e p) => Eq (Float e p) *\/\neqFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p -> Bit\neqFloat = (==)\n\n\/* instance Eq () *\/\neqUnit : () -> () -> Bit\neqUnit = (==)\n\n\/* instance (Eq a, Eq b, ...) => Eq (a, b, ...) *\/\neqTuple : {a, b} (Eq a, Eq b) => (a, b) -> (a, b) -> Bit\neqTuple = (==)\n\n\/* instance Eq {} *\/\neqEmpty : {} -> {} -> Bit\neqEmpty = (==)\n\n\/* instance (Eq a, Eq b, ...) => Eq { x : a, y : b, ... } *\/\neqRecord : {a, b} (Eq a, Eq b) => {x : a, y : b} ->  {x : a, y : b} -> Bit\neqRecord = (==)\n\n\/* instance Cmp Bit *\/\ncmpBit : Bit -> Bit -> Bit\ncmpBit = (<)\n\n\/* instance Cmp Integer *\/\ncmpInteger : Integer -> Integer -> Bit\ncmpInteger = (<)\n\n\/* instance Cmp Rational *\/\ncmpRational : Rational -> Rational -> Bit\ncmpRational = (<)\n\n\/* instance (fin n) => Cmp [n] *\/\ncmpWord : {n} (fin n) => [n] -> [n] -> Bit\ncmpWord = (<)\n\n\/* instance (fin n, Cmp a) => Cmp [n]a *\/\ncmpSeq : {n, a} (fin n, Cmp a) => [n]a -> [n]a -> Bit\ncmpSeq = (<)\n\n\/* instance (ValidFloat e p) => Cmp (Float e p) *\/\ncmpFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p -> Bit\ncmpFloat = (<)\n\n\/* instance Cmp () *\/\ncmpUnit : () -> () -> Bit\ncmpUnit = (<)\n\n\/* instance (Cmp a, Cmp b, ...) => Cmp (a, b, ...) *\/\ncmpTuple : {a, b} (Cmp a, Cmp b) => (a, b) -> (a, b) -> Bit\ncmpTuple = (<)\n\n\/* instance Cmp {} *\/\ncmpEmpty : {} -> {} -> Bit\ncmpEmpty = (<)\n\n\/* instance (Cmp a, Cmp b, ...) => Cmp { x : a, y : b, ... } *\/\ncmpRecord : {a, b} (Cmp a, Cmp b) => {x : a, y : b} ->  {x : a, y : b} -> Bit\ncmpRecord = (<)\n\n\/* instance (fin n, n >= 1) => SignedCmp [n] *\/\nsignedCmpWord : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsignedCmpWord = (<$)\n\n\/\/ NOTE: 'instance (fin n, SignedCmp a) => SignedCmp ([n]a)' holds for\n\/\/ any type 'a' distinct from 'Bit'.\n\n\/* instance (fin n, SignedCmp [k]a) => SignedCmp [n][k]a *\/\nsignedCmpSeqSeq : {n, k, a} (fin n, SignedCmp ([k]a)) => [n][k]a -> [n][k]a -> Bit\nsignedCmpSeqSeq = (<$)\n\n\/* instance (fin n) => SignedCmp [n]() *\/\nsignedCmpSeqUnit : {n} (fin n) => [n]() -> [n]() -> Bit\nsignedCmpSeqUnit = (<$)\n\n\/* instance (SignedCmp a, SignedCmp b) => SignedCmp [n](a, b) *\/\nsignedCmpSeqTuple : {n, a, b} (fin n, SignedCmp a, SignedCmp b) => [n](a, b) -> [n](a, b) -> Bit\nsignedCmpSeqTuple = (<$)\n\n\/* instance SignedCmp [n]{} *\/\nsignedCmpSeqEmpty : {n} (fin n) => [n]{} -> [n]{} -> Bit\nsignedCmpSeqEmpty = (<$)\n\n\/* instance (SignedCmp a, SignedCmp b) => SignedCmp [n]{x : a, y : b} *\/\nsignedCmpSeqRecord : {n, a, b} (fin n, SignedCmp a, SignedCmp b) => [n]{x : a, y : b} -> [n]{x : a, y : b} -> Bit\nsignedCmpSeqRecord = (<$)\n\n\/* instance SignedCmp () *\/\nsignedCmpUnit : () -> () -> Bit\nsignedCmpUnit = (<$)\n\n\/* instance (SignedCmp a, SignedCmp b, ...) => SignedCmp (a, b, ...) *\/\nsignedCmpTuple : {a, b} (SignedCmp a, SignedCmp b) => (a, b) -> (a, b) -> Bit\nsignedCmpTuple = (<$)\n\n\/* instance SignedCmp {} *\/\nsignedCmpEmpty : {} -> {} -> Bit\nsignedCmpEmpty = (<$)\n\n\/* instance (SignedCmp a, SignedCmp b, ...) => SignedCmp { x : a, y : b, ... } *\/\nsignedCmpRecord : {a, b} (SignedCmp a, SignedCmp b) => {x : a, y : b} ->  {x : a, y : b} -> Bit\nsignedCmpRecord = (<$)\n\n\/* instance (1 >= val) => Literal val Bit *\/\nliteralBit : {val} (1 >= val) => Bit\nliteralBit = `val\n\n\/* instance (fin val) => Literal val Integer *\/\nliteralInteger : {val} (fin val) => Integer\nliteralInteger = `val\n\n\/* instance (fin val) => Literal val Rational *\/\nliteralRational : {val} (fin val) => Rational\nliteralRational = `val\n\n\/* instance (fin val, fin n, n >= 1, n > val) => Literal val (Z n) *\/\nliteralZ : {val, n} (fin val, fin n, n >= 1, n > val) => Z n\nliteralZ = `val\n\n\/* instance (fin val, fin n, n >= width val) => Literal val [n] *\/\nliteralWord : {val, n} (fin val, fin n, n >= width val) => [n]\nliteralWord = `val\n\n\/* instance (2 >= val) => LiteralLessThan val Bit *\/\nliteralLessThanBit : {val} (1 >= val) => [val]Bit\nliteralLessThanBit = [0..<val]\n\n\/* instance LiteralLessThan val Integer *\/\nliteralLessThanInteger : {val} (fin val) => [val]Integer\nliteralLessThanInteger = [0..<val]\n\n\/* instance LiteralLessThan val Rational *\/\nliteralLessThanRational : {val} (fin val) => [val]Rational\nliteralLessThanRational = [0..<val]\n\n\/* instance (fin n, n >= 1, n >= val) => LiteralLessThan val (Z n) *\/\nliteralLessThanZ : {val, n} (fin n, n >= 1, n >= val) => [val](Z n)\nliteralLessThanZ = [0..<val]\n\n\/* instance (fin n, n >= width val) => LiteralLessThan val [n] *\/\nliteralLessThanWord : {val, n} (fin n, n >= lg2 val) => [val][n]\nliteralLessThanWord = [0..<val]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-script\/otherTests\/cryptol-saw-core\/superclass.cry","filetype":"cry","content":"zeroRing : {a} (Ring a) => a\nzeroRing = zero\n\nzeroLogic : {a} (Logic a) => a\nzeroLogic = zero\n\nzeroIntegral : {a} (Integral a) => a\nzeroIntegral = zero\n\nzeroField : {a} (Field a) => a\nzeroField = zero\n\nzeroRound : {a} (Round a) => a\nzeroRound = zero\n\nfromIntIntegral : {a} (Integral a) => a\nfromIntIntegral = fromInteger 42\n\nfromIntField : {a} (Field a) => a\nfromIntField = fromInteger 42\n\nfromIntRound : {a} (Round a) => a\nfromIntRound = fromInteger 42\n\nrecipRound : {a} (Round a) => a -> Integer\nrecipRound x = trunc (recip x)\n\ncompareRound : {a} (Round a) => a -> a -> Bit\ncompareRound x y = x < y\n\neqCmp : {a} (Cmp a) => a -> a -> Bit\neqCmp x y = x == y\n","variant":"hybrid","set":"supervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/ModDivZ.cry","filetype":"cry","content":"\/\/ Modular division for Z n types\n\nmodule Common::ModDivZ where\n\neven k = k % 2 == 0\n\n\/\/ Calulate x \/ y in F_p using Euler's binary gcd algorithm\nmoddiv : {p}(fin p, p >= 3) => Z p -> Z p -> Z p  \/\/ p prime!\nmoddiv x y = if y == 0 then error \"division by 0\"  \/\/ zero has no inverse\n                       else fromInteger (egcd `p 0 (fromZ y) (fromZ x))\n    where\n\n    egcd : Integer -> Integer -> Integer -> Integer -> Integer\n    egcd a ra b rb =  \/\/ a odd!\n        if b == 0 then ra\n         | even b then egcd a ra (   b    \/ 2) (half rb)\n         | a < b  then egcd a ra ((b - a) \/ 2) (half ((rb - ra) % `p))\n                  else egcd b rb ((a - b) \/ 2) (half ((ra - rb) % `p))\n\n    half : Integer -> Integer\n    half k = (if even k then k else (k + `p)) \/ 2\n\n(%\/) = moddiv  \/\/ infix form of operator\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/mul_java.cry","filetype":"cry","content":"module Common::mul_java where\n\nimport Common::bv\n\nmul_java_inner : (Bit, [24][32], [32], [32], [32], [64]) -> { mji_a : [24][32], mji_d : [64]}\nmul_java_inner (azero, a, ij, xi, yj, d) = { mji_a = a', mji_d = d' >> 32 }\n  where\n    m        = zext(xi) * zext(yj)\n    d'       = d + m + zext(aij)\n    a'       = update a ij (drop(d'))\n    aij      = if ~azero then a @ ij else 0\n\n\/*\naset : {n, is} (fin n, fin is, n >= is, is >= lg2 n, n >= 32, is >= max(lg2 n, 6)) =>\n          ([n], [is], [is]) -> [n]\n*\/\naset (a, i, x) = (a && imask) || x'\n  where\n    imask = ~(zext(0xFFFFFFFF : [32]) << (i*32))\n    x' = zext(x) << (i*32)\n\naset_768 : ([768], [32], [32]) -> [768]\naset_768 = aset\n\ntoJavaArray : [384] -> [12][32]\ntoJavaArray x = reverse (split x)\n\nfromJavaArray : [12][32] -> [384]\nfromJavaArray x = join (reverse x)\n\n\/\/ Matches java implementation; computes safe_product.\nmul_java : ([768], [384], [384]) -> [768]\nmul_java (a0, x, y) = join (reverse (a_final!0))\n  where\n    l   = 12 : [32]\n    x'  = toJavaArray x\n    y'  = toJavaArray y\n    a0' = reverse (split a0) : [24][32]\n\n    \/* First loop in Java implementation *\/\n    a_first : [13]([64],[24][32])\n    a_first = [ (zero : [64], a0' : [24][32]) ]\n            # [ (res.mji_d, res.mji_a)\n                   where res = mul_java_inner(True, a, j, x'@0, y'@j, d)\n              | (d, a) <- a_first\n              | j      <- [0..11]\n              ]\n    (d_first_final, a_first_final) = a_first!0\n    ad_first_final = update a_first_final l (drop(d_first_final):[32])\n\n    \/* Second loop in Java implementation *\/\n    a_final : [12][24][32]\n    a_final = [ ad_first_final ]\n            # [ ad_inner_final\n                 where\n                   \/* Inner loop in Java implementation *\/\n                   a_inner : [13]([64],[24][32],[32])\n                   a_inner = [ ( zero : [64] , a, i) ]\n                           # [ (res.mji_d, res.mji_a, ij+1)\n                                where\n                                  res = mul_java_inner(False, ai, ij, x'@i, y'@j, d)\n                             | (d, ai, ij) <- a_inner\n                             | j          <- [0..(12-1)]:[12][32]\n                             ]\n\n                   (d_inner_final, a_inner_final, ij_final) = a_inner!0\n                   ad_inner_final = update a_inner_final ij_final (drop(d_inner_final))\n              | a <- a_final\n              | i <- [1..11]\n              ]\n\nsq_java_inner1 : ([24][32], [32], [64]) -> { mji_a : [24][32], mji_d : [64]}\nsq_java_inner1 (a, ij, c) = { mji_a = a' , mji_d = c'' }\n  where\n    aij = a @ ij\n    c' = c + (zext(aij) << 1)\n    a' = update a ij (drop(c'))\n    c'' = c' >> 32\n\nsq_java_inner2 : ([24][32], [32], [32], [64]) ->\n                 { mji_a : [24][32], mji_d : [64]}\nsq_java_inner2 (a, ij, xati, c) = { mji_a = a' , mji_d = c'' }\n  where\n    aij = a @ ij\n    xi = zext(xati) : [64]\n    m = xi * xi\n    c' = c + (m && 0x00000000FFFFFFFF) + (zext(aij) << 1)\n    a' = update a ij (drop(c'))\n    c'' = (c' >> 32) + (m >> 32)\n\nsq_java_loop : ([24][32], [384]) -> [24][32]\nsq_java_loop(a0, x) = a_mid!0\n  where\n    \/* Second loop in Java implementation *\/\n    l = 12 : [32]\n    x'  = toJavaArray x\n    a_mid   = [ a0 ]\n            # [ ad_inner_final\n                 where\n                   \/* Inner loop in Java implementation *\/\n                   a_inner = [ ( zero : [64] , a, i+i+1) ]\n                           # [ (res.mji_d, res.mji_a, ij+1)\n                                where\n                                  res = if j+i < l then\n                                          mul_java_inner(False, ai, ij, x'@i, x'@(j+i), d)\n                                        else zero\n                             | (d, ai, ij) <- a_inner\n                             | j          <- [1..(12-1)]\n                             ]\n                   (d_inner_final, a_inner_final, ij_final) = a_inner!i\n                   ad_inner_final = update a_inner_final ij_final (drop(d_inner_final))\n              | a <- a_mid\n              | i <- [1..(12-2)]\n              ]\n\nsq_java : ([768], [384]) -> [768]\nsq_java (a0, x) = join (reverse ad_final_final)\n  where\n    l   = 12 : [32]\n    x'  = toJavaArray x\n    a0' = reverse (split a0) : [24][32]\n    x0 = x'@0\n    \/* First loop in Java implementation *\/\n    a_first = [ (zero : [64], a0' : [24][32]) ]\n            # [ (res.mji_d, res.mji_a)\n                 where res = mul_java_inner(True, a, j, x0, x'@j, d)\n              | (d, a) <- a_first\n              | j      <- [1..11]\n              ]\n    (d_first_final, a_first_final) = a_first!0\n    ad_first_final = update a_first_final l (drop(d_first_final))\n\n    mid_res = mul_java_inner(True, sq_java_loop(ad_first_final, x), 0, x0, x0, 0)\n\n    \/* Third loop in Java implementation *\/\n    a_final : [12]([64],[24][32],[32])\n    a_final = [ (mid_res.mji_d, mid_res.mji_a, 1) ]\n            # [ (res'.mji_d, res'.mji_a, ij+2)\n                where\n                   res = sq_java_inner1(a, ij, c)\n                   res' = sq_java_inner2(res.mji_a, ij+1, x'@(i:[32]), res.mji_d)\n              | (c, a, ij) <- a_final\n              | i      <- [1..11]\n              ]\n    (d_final_final, a_final_final, ij_final) = a_final!0\n    ad_final_final = update a_final_final ((l << 1) - 1) (drop(d_final_final))\n\naset_384 : ([384], [32], [32]) -> [384]\naset_384(a, i, x) = fromJavaArray (update (toJavaArray a) i x)\n\njava_lashr32 : [64] -> [64]\njava_lashr32 x = take(sext(x) : [96])\n\ngroup_red_aux_java : ([384], [32], [32], [64], [64]) ->\n                     { gra_r: [384] , gra_b : [64] }\ngroup_red_aux_java(r, aj, j, c, b) = { gra_r = r' , gra_b = b'' }\n  where\n    rj, m, b' : [64]\n    rj = zext(toJavaArray r @ j)\n    m = c * zext(aj)\n    b' = b + rj - zext(drop(m):[32])\n    r' = aset_384(r, j, drop(b'))\n    b'' = java_lashr32(b') - (m >> 32)\n\ngroup_mul_aux_java : ([384], [32], [32], [32], [64]) ->\n                     { gra_r: [384] , gra_b : [64] }\ngroup_mul_aux_java(r, yj, j, xi, c) = { gra_r = r' , gra_b = c'' }\n  where\n    rj, m, c' : [64]\n    rj = zext(toJavaArray r @ j)\n    m = zext(xi) * zext(yj)\n    c' = c + rj + zext(drop(m):[32])\n    r' = aset_384(r, j, drop(c'))\n    c'' = (c' >> 32) + (m >> 32)\n\np384_group_red : ([384], [384], [64]) -> [384]\np384_group_red(order, r, c) = r'''\n  where\n    order' = toJavaArray order\n    loop : [13]([384],[64])\n    loop = [ (r, zero : [64]) ] #\n           [ (res.gra_r, res.gra_b)\n              where res = group_red_aux_java(rj, order'@j, j, c, bi)\n           | (rj, bi) <- loop\n           | j <- [0..11]\n           ]\n    (r', b) = loop!0\n    c' = c + b\n    (r'', c'') = if c' != 0 then\n                   (r' - order, c' + (if r' >= order then 0 else -1))\n                 else (r', c')\n    r''' = if c'' != 0 then r'' - order else r''\n\np384_group_mul : ([384], [384], [384]) -> [384]\np384_group_mul(order, x, y) = r'\n  where\n    xa = toJavaArray x\n    ya = toJavaArray y\n    outer : [13][384]\n    outer = [ (zero : [384]) ] #\n            [ p384_group_red(order, rn, cn)\n               where\n                 r0 : [384]\n                 r0 = p384_group_red(order,\n                                     ro << (32 : [9]),\n                                     zext(take(ro):[32]))\n                 inner : [13]([384], [64])\n                 inner = [ (r0, 0) ] #\n                         [ (res.gra_r, res.gra_b)\n                            where\n                              res = group_mul_aux_java(rj, ya@j, j, xa@(i:[32]), cj)\n                         | j <- [0..11]\n                         | (rj, cj) <- inner\n                         ]\n                 (rn, cn) = inner!0\n            | i <- reverse [0..11]\n            | ro <- outer\n            ]\n    r = outer!0\n    r' = if order <= r then r - order else r\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/utils.cry","filetype":"cry","content":"module Common::utils where\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\nintegerToBV : {m} (fin m) => Integer -> [m]\nintegerToBV x = fromInteger x\n\nintegerFromBV : {m} (fin m) => [m] -> Integer\nintegerFromBV x = toInteger x\n\nintegerModulusFromBV : {m} (fin m) => [m] -> Integer\nintegerModulusFromBV x = if (integerFromBV x) < 3 then 3 else (integerFromBV x)\n\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\nmul2 x = x + x\nmul3 x = x + mul2 x\nmul4 x = mul2(mul2 x)\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = fromInteger (if isEven xint then xint\/2 else ((xint + `p) \/ 2))\n  where\n    xint = fromZ x\n\nhalf_correct : {p} (fin p, p >= 3, isOdd p) => Z p -> Bit\nproperty half_correct x = half x + half x == x\n\nmp_mod_inv : {n} (fin n, n >= 1) => Z n -> Z n\nmp_mod_inv c = if c == 0 then error \"Zero does not have a multiplicative inverse\"\n               else fromInteger (if u'' == 1 then x1'' else x2'')\n  where\n    innercond (a, x) = isEven a\n    innerbody (a, x) = (a \/ 2, if isEven x then x \/ 2 else (x + `n) \/ 2)\n\n    outtercond (u, v, x1, x2) = (u != 1) \/\\ (v != 1)\n    outterbody (u, v, x1, x2) = if(u' >= v') then (u' - v', v', x1' - x2' % `n, x2')\n                                             else (u', v' - u', x1', x2' - x1' % `n)\n      where\n        (u', x1') = while innercond innerbody (u, x1)\n        (v', x2') = while innercond innerbody (v, x2)\n\n    (u'', _, x1'', x2'') = while outtercond outterbody (fromZ c, `n, 1, 0)\n\n\/\/ Note, this property will only hold when the modulus is prime\nmp_mod_inv_correct : {a} (fin a, a >=2) => Z a -> Bit\nproperty mp_mod_inv_correct x = x != 0 ==> x * mp_mod_inv x == 1\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC.cry","filetype":"cry","content":"module Primitive::Symmetric::MAC::HMAC where\n\nimport Primitive::Keyless::Hash::SHA256\n\nhmacSHA256 : {pwBytes, msgBytes}\n             (fin pwBytes, fin msgBytes\n             , 32 >= width msgBytes\n             , 64 >= width (8*pwBytes)\n             , 64 >= width (8 * (64 + msgBytes))\n             ) => [pwBytes][8] -> [msgBytes][8] -> [256]\nhmacSHA256 = hmac `{blockLength=64} SHA256 SHA256 SHA256\n\nkinit : { pwBytes, blockLength, digest }\n        ( fin pwBytes, fin blockLength, fin digest )\n     => ([pwBytes][8] -> [8*digest])\n     -> [pwBytes][8]\n     -> [blockLength][8]\nkinit hash key =\n  if `pwBytes > (`blockLength : [max (width pwBytes) (width blockLength)])\n  then take `{blockLength} (split (hash key) # (zero : [blockLength][8]))\n  else take `{blockLength} (key # (zero : [blockLength][8]))\n\n\/\/ Due to limitations of the type system we must accept two\n\/\/ separate arguments (both aledgedly the same) for two\n\/\/ separate length inputs.\nhmac : { msgBytes, pwBytes, digest, blockLength }\n       ( fin pwBytes, fin digest, fin blockLength )\n    => ([blockLength + msgBytes][8] -> [8*digest])\n    -> ([blockLength + digest][8] -> [8*digest])\n    -> ([pwBytes][8] -> [8*digest])\n    -> [pwBytes][8]\n    -> [msgBytes][8]\n    -> [digest*8]\nhmac hash hash2 hash3 key message = hash2 (okey # internal)\n where\n   ks : [blockLength][8]\n   ks = kinit hash3 key\n   okey = [k ^ 0x5C | k <- ks]\n   ikey = [k ^ 0x36 | k <- ks]\n   internal = split (hash (ikey # message))\n\n\n\n\n\n\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_256_GCM.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM where\n\nimport Primitive::Symmetric::Cipher::Block::AES\n\n\naes_hw_encrypt : [16][8] -> [32][8] -> [16][8]\naes_hw_encrypt in key = split (aesEncrypt ((join in), (join key)))\n\n\ngcm_pmult_pmod : [128] -> [128] -> [128]\ngcm_pmult_pmod X Y = reverse (pmod (pmult (reverse X) (reverse Y)) <| x^^128 + x^^7 + x^^2 + x + 1|>)\n\ngcm_polyval_mul : {n} (fin n) => [2 * (1 + n)] -> [2 * (1 + n)] -> [4 * (1 + n)]\ngcm_polyval_mul X Y = (0 : [1]) # pmult X Y\n\ngcm_polyval_red : [256] -> [128]\ngcm_polyval_red X = reverse (pmod (reverse X) <| x^^128 + x^^7 + x^^2 + x + 1|>)\n\ngcm_polyval : [128] -> [128] -> [128]\ngcm_polyval X Y = gcm_polyval_red (gcm_polyval_mul X Y)\n\ngcm_init_H : [128] -> [128]\ngcm_init_H Xi = pmod (Xi # (0 : [1]))  <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\n\ntype AES_GCM_Ctx =\n  { key : [32][8]\n  , iv : [12][8]\n  , Xi : [16][8]\n  , len : [64]\n  }\n\n\nget_H : AES_GCM_Ctx -> [2][64]\nget_H ctx = split (join (aes_hw_encrypt zero ctx.key))\n\nEKi : AES_GCM_Ctx -> [32] -> [16][8]\nEKi ctx i = aes_hw_encrypt (ctx.iv # (split (i + 1))) ctx.key\n\nEKij : AES_GCM_Ctx -> [32] -> [4] -> [8]\nEKij ctx i j = (EKi ctx i) @ j\n\n\ncipher_update : {n} (fin n) => [32] -> AES_GCM_Ctx -> [n][8] -> AES_GCM_Ctx\ncipher_update enc ctx in = ctx'\n  where\n    enc_bytes = if enc ! 0\n      then ctr32_encrypt ctx in\n      else in\n    ctx' = foldl cipher_update_byte ctx enc_bytes\n\nctr32_encrypt : {n} (fin n) => AES_GCM_Ctx -> [n][8] -> [n][8]\nctr32_encrypt ctx in = out\n  where\n    out = [ byte ^ (EKij ctx ((take`{32} (drop`{28} i)) + 1) (drop`{60} i)) | byte <- in | i <- [ctx.len ...] ]\n\ncipher_update_byte : AES_GCM_Ctx -> [8] -> AES_GCM_Ctx\ncipher_update_byte ctx byte = ctx'\n  where\n    H = join (get_H ctx)\n    n = ctx.len % 16\n    Xi' = update ctx.Xi n ((ctx.Xi @ n) ^ byte)\n    len' = ctx.len + 1\n    Xi'' = if (len' % 16) == 0\n      then split (gcm_pmult_pmod H (join Xi'))\n      else Xi'\n    ctx' =\n      { key = ctx.key\n      , iv = ctx.iv\n      , Xi = Xi''\n      , len = len'\n      }\n\ncipher_final : AES_GCM_Ctx -> [16][8]\ncipher_final ctx = (split (gcm_pmult_pmod H Xi'')) ^ (EKi ctx 0)\n  where\n    H = join (get_H ctx)\n    Xi' = if (ctx.len % 16) != 0\n      then gcm_pmult_pmod H (join ctx.Xi)\n      else join ctx.Xi\n    Xi'' = Xi' ^ (0 # (ctx.len * 8))\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_GCM.cry","filetype":"cry","content":"\/\/Test vectors from http:\/\/luca-giuzzi.unibs.it\/corsi\/Support\/papers-cryptography\/gcm-spec.pdf\n\nmodule Primitive::Symmetric::Cipher::Authenticated::AES_GCM where\nimport `Primitive::Symmetric::Cipher::Authenticated::GCM\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\n\nproperty testPass0 = gcmEnc `{K=128, IV=96, AAD=0, T=128} {E=encrypt} {key=zero, iv=zero, pt=[], aad=[]} ==\n                              {ct = [], tag = 0x58e2fccefa7e3061367f1d57a4e7455a}\n\nproperty testPass1 = gcmEnc `{K=128, IV=96, AAD=0, T=128} {E=encrypt} {key=zero, iv=zero, pt=zero, aad=[]} ==\n                              {ct = 0x0388dace60b6a392f328c2b971b2fe78, tag = 0xab6e47d42cec13bdf53a67b21257bddf}\n\nproperty testPass2 = gcmEnc `{K=128, IV=96, AAD=0, T=128} {E=encrypt} {key=0xfeffe9928665731c6d6a8f9467308308, iv=0xcafebabefacedbaddecaf888,         pt=0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b391aafd255, aad=[]} ==\n    {ct = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091473f5985,\n    tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4}\n\nproperty testPass3 = gcmEnc `{K=128, IV=96, AAD=160, T=128} {E=encrypt} {key=0xfeffe9928665731c6d6a8f9467308308,                                            iv=0xcafebabefacedbaddecaf888,\n    pt=0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39,\n    aad=0xfeedfacedeadbeeffeedfacedeadbeefabaddad2} ==\n    {ct=0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091,\n    tag=0x5bc94fbc3221a5db94fae95ae7121a47}\n\n\/\/ A test case from aesgcmtest.c\n\/\/ Test passes\nproperty testPass4 = gcmEnc `{K=256, IV=96, AAD=128, T=128} {E=encrypt} {key=0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f,\n    iv=0x99aa3e68ed8173a0eed06684, pt=0xf56e87055bc32d0eeb31b2eacc2bf2a5, aad=0x4d23c3cec334b49bdb370c437fec78de} ==\n   {ct=0xf7264413a84c0e7cd536867eb9f21736, tag=0x67ba0510262ae487d737ee6298f77e0c}\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Authenticated::GCM where\n\nparameter\n  \/** Key size *\/\n  type K : #\n  type constraint (fin K)\n\n  \/** Size of initialization vector *\/\n  type IV : #\n  type constraint (64 >= width IV, IV >= 1)\n\n  \/** Size of additional authenticated data *\/\n  type AAD  : #\n  type constraint (64 >= width AAD)\n\n  \/** Size of authentication tag *\/\n  type T : #\n  type constraint (128 >= T, T >= 64)\n\n  \/** Block encryption function *\/\n  E : [K] -> [128] -> [128]\n\ngcmEnc :\n  {n} (2^^39 - 256 >= n) =>\n      { key : [K], iv : [IV], aad : [AAD], pt : [n] } -> { ct : [n], tag : [T] }\ngcmEnc input = { ct = C, tag = T }\n  where (C,T) = enc_dec input.key input.iv input.aad input.pt\n\ngcmDec :\n  {n} (2^^39 - 256 >= n) =>\n  { key : [K], iv  : [IV], aad : [AAD], ct  : [n], tag : [T] } ->\n  { valid : Bool, pt : [n] }\ngcmDec input = if input.tag == T then { valid = True, pt = P }\n                                  else { valid = False, pt = 0 }\n  where (P,T) = enc_dec input.key input.iv input.aad input.ct\n\n\n\n\/**\nThe basic functionality between encryption and decryption.\nIn the case of decryption, the plain text is only valid if the tags match.\n*\/\nenc_dec :\n  {n} ((2^^39 - 256) >= n) => [K] -> [IV] -> [AAD] -> [n] -> ([n], [T])\nenc_dec K IV A P = (C,T)\n  where\n  H  = (E K 0)\n\n  Y0 = ifWidth`{96} IV (\\IV96 -> IV96 # 1)\n                       (GHASH H [] IV)\n\n  Ys = [Y0] # [ y+1 | y <- Ys ]\n\n  Cs = [ p ^ (E K y) | p <- blockify P | y <- drop`{1} Ys ]\n  C  = unblockify Cs\n\n  T = take (GHASH H A C ^ (E K Y0))\n\n\n\/** Section 2.3, equation (2) *\/\nGHASH : {C,A} (64 >= width C, 64 >= width A) => [128] -> [A] -> [C] -> [128]\nGHASH H A C = step (XS ! 0) (wa # wc)\n  where\n  wa = `A : [64]\n  wc = `C : [64]\n\n  XS = [0] # [ step X' B | X' <- XS | B <- blockify A # blockify C ]\n\n  step x b = mult (x ^ b) H\n\n\n\n\/** Section 2.5, multiplication in GF(2^^128)\n\nThis is simple polynomial multipliation and reduction in Cryptol.\nSomewhat oddly, when thinking of the 128-bits as polynomials,\nthe spec treats the most significant bit as the 0 power,\nwhich is the reason for the `reverse` operations.\n*\/\nmult : [128] -> [128] -> [128]\nmult X Y = reverse (pmod (pmult (reverse X) (reverse Y)) irred)\n  where irred = <| 1 + x + x^^2 + x^^7 + x^^128 |>\n\n\n\/** Create blocks as described in the spec, first paragraph of Section 2.3.\nBasically we split into 128-bit chunk and pad the last one with 0. *\/\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify msg = split (msg # 0)\n\n\/** Join back the blocks, dropping any additional padding. *\/\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify ms = take (join ms)\n\n\nifWidth : {w,n,a} (fin n, fin w) => [n] -> ([w] -> a) -> a -> a\nifWidth thing yep nope = if `w == (`n : [max (width w) (width n)])\n                            then yep (take (thing # (zero : [inf])))\n                            else nope\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/DES.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::DES where\n\nimport Primitive::Symmetric::Cipher::Block::Cipher\n\n\/\/ DES API\nDES : Cipher 64 64\nDES =\n    { encrypt key pt = des (expandKey key) pt\n    , decrypt key ct = des (reverse (expandKey key)) ct\n    }\n\ndes keys pt = (swap (split lst)) @@ FPz\n  where\n        pt' = pt @@ IPz\n        iv  = [ round (k, split lr)\n              | k  <- keys\n              | lr <- [pt'] # iv ]\n        lst = iv @ (length keys - 1)\n\nround : ([48],[2][32]) -> [64]\nround (k, [l, r]) = r # (l ^ f (r, k))\n\n\/\/ f : {a} (a >= 6) => ([2^^(a-1)],[48]) -> [32]\n\/\/ f : {b} (b >= 1, 6 == lg2 b) => ([b - 1], [48]) -> [32]\nf (r, k) = (SBox(k ^ (r @@ EPz))) @@ PPz\n\nswap [a, b] = b # a\n\n\/\/ Key expansion\n\nexpandKey : [64] -> [16][48]\nexpandKey key = expand (split (key @@ KPz))\n\nexpand: [2][28] -> [16][48]\nexpand [kl, kr] =\n    [ ((kl <<< i) # (kr <<< i)) @@ CPz\n    | i <- sums [ 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 ] ]\n\nsums : [16][8] -> [16][8]\nsums xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\nzeroBasify XP = [ i - 1 | i <- XP ]\nKPz = zeroBasify KP\nCPz = zeroBasify CP\nPPz = zeroBasify PP\nEPz = zeroBasify EP\nIPz = zeroBasify IP\nFPz = zeroBasify FP\n\nKP : [56][6]\nKP  = [57,49,41,33,25,17, 9, 1,58,50,42,34,26,18,\n       10, 2,59,51,43,35,27,19,11, 3,60,52,44,36,\n       63,55,47,39,31,23,15, 7,62,54,46,38,30,22,\n       14, 6,61,53,45,37,29,21,13, 5,28,20,12, 4\n      ]\n\n\nCP : [48][6]\nCP  = [14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,\n       23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,\n       41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,\n       44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32\n      ]\n\nPP : [32][6]\nPP = [16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,\n       2,  8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25\n     ]\n\nEP : [48][6]\nEP  = [32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,\n        8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,\n       16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,\n       24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1\n      ]\n\n\nIP : [64][7]\nIP = [58, 50, 42, 34, 26, 18, 10,  2, 60, 52, 44, 36, 28, 20, 12,  4,\n      62, 54, 46, 38, 30, 22, 14,  6, 64, 56, 48, 40, 32, 24, 16,  8,\n      57, 49, 41, 33, 25, 17,  9,  1, 59, 51, 43, 35, 27, 19, 11,  3,\n      61, 53, 45, 37, 29, 21, 13,  5, 63, 55, 47, 39, 31, 23, 15,  7\n     ]\n\nFP : [64][7]\nFP = [40,  8, 48, 16, 56, 24, 64, 32, 39,  7, 47, 15, 55, 23, 63, 31,\n      38,  6, 46, 14, 54, 22, 62, 30, 37,  5, 45, 13, 53, 21, 61, 29,\n      36,  4, 44, 12, 52, 20, 60, 28, 35,  3, 43, 11, 51, 19, 59, 27,\n      34,  2, 42, 10, 50, 18, 58, 26, 33,  1, 41,  9, 49, 17, 57, 25\n     ]\n\n\/\/ Sboxen\nSBox : [48] -> [32]\nSBox x = join [ sbox (n, b) | n <- [1 .. 8] | b <- split x ]\n\nsbox : ([4], [6]) -> [4]\nsbox (n, x) = (s @ [b1, b6] @ [b2, b3, b4, b5])\n  where s = sboxes @ (n - 1)\n        b1 = x @ 0\n        b2 = x @ 1\n        b3 = x @ 2\n        b4 = x @ 3\n        b5 = x @ 4\n        b6 = x @ 5\n\n\/\/ here are all the SBoxes\n\nsboxes = [ sbox1, sbox2, sbox3, sbox4, sbox5, sbox6, sbox7, sbox8 ]\n\nsbox1 : [4][16][4]\nsbox1 = [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],\n         [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],\n         [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],\n         [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]\n        ]\nsbox2 : [4][16][4]\nsbox2 = [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],\n         [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],\n         [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],\n         [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]\n        ]\n\nsbox3 : [4][16][4]\nsbox3 = [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],\n         [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],\n         [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],\n         [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]\n        ]\n\nsbox4 : [4][16][4]\nsbox4 = [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],\n         [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],\n         [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],\n         [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]\n        ]\n\nsbox5 : [4][16][4]\nsbox5 = [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],\n         [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],\n         [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],\n         [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]\n        ]\n\nsbox6 : [4][16][4]\nsbox6 = [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],\n         [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],\n         [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],\n         [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]\n        ]\n\nsbox7 : [4][16][4]\nsbox7 = [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],\n         [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],\n         [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],\n         [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]\n        ]\n\nsbox8 : [4][16][4]\nsbox8 = [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],\n         [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],\n         [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],\n         [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]\n        ]\n\n\nproperty DESCorrect key msg = DES.decrypt key (DES.encrypt key msg) == msg\n\n\ntestmsgs = [0x1122334455667788\n           ,0x99aabbccddeeff00\n           ,0x41AD068548809D02\n           ,0xB10F843097A0F932]\n\ntestkeys = [0x752878397493CB70\n          ,0x752878397493CB70\n          ,0x0001020304050607\n          ,0x2BD6459F82C5B300]\n\ntestct = [0xB5219EE81AA7499D\n         ,0x2196687E13973856\n         ,0x0011223344556677\n         ,0xEA024714AD5C4D84]\n\nproperty testsPass = and [ DES.encrypt key msg == ct\n                         | key <- testkeys | msg <- testmsgs | ct <- testct ]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/PRINCE.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::PRINCE where\ntype princeBlockSize = 64\ntype princeKeySize = 128\ntype State = [4][4][4]\ntype Round = 4\n\n\/\/S-box\n\nsbox = [0xb, 0xf, 0x3, 0x2, 0xa, 0xc, 0x9, 0x1, 0x6, 0x7, 0x8, 0x0, 0xe, 0x5, 0xd, 0x4]\nsboxInv = [0xb, 0x7, 0x3, 0x2, 0xf, 0xd, 0x8, 0x9, 0xa, 0x6, 0x4, 0x0, 0x5, 0xe, 0xc, 0x1]\n\n\/\/ Round Constant (RC)\n\nRC = [0x0000000000000000, 0x13198a2e03707344, 0xa4093822299f31d0, 0x082efa98ec4e6c89, 0x452821e638d01377, 0xbe5466cf34e90c6c, 0x7ef84f78fd955cb1, 0x85840851f1ac43aa, 0xc882d32f25323c54, 0x64a51195e0e3610d, 0xd3b5a399ca0c2399, 0xc0ac29b7c97c50dd]\n\n\/\/Extend key to 192bits\n\nextendKey :[princeKeySize] -> ([64], [64], [64])\nextendKey key = (K!0, K', K!1) \n          where K = split key:[2][64]\n                K' = ((K!0) >>> 1) ^ ((K!0) >> 63)\n\/\/Message to state\n\nmsgToState:[princeBlockSize] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg :State -> [princeBlockSize]\nstateToMsg st = join (join st)\n\n\/\/Substitute Sbox\n\nSubCell :[4] -> [4]\nSubCell st = sbox@st\n\nSubCells : State -> State\nSubCells st = [ [ SubCell b | b<- row ] | row <- st ]\n\n\/\/Substitute Inverse Sbox\n\nInvSubCell :[4] -> [4]\nInvSubCell st = sboxInv@st\n\nInvSubCells : State -> State\nInvSubCells st = [ [ InvSubCell b | b<- row ] | row <- st ]\n\n\/\/Shift Rows\nperm  = [0x0, 0x5, 0xa, 0xf, 0x4, 0x9, 0xe, 0x3, 0x8, 0xd, 0x2, 0x7, 0xc, 0x1, 0x6, 0xb]\ninv_perm = [0x0, 0xd, 0xa, 0x7, 0x4, 0x1, 0xe, 0xb, 0x8, 0x5, 0x2, 0xf, 0xc,0x9, 0x6, 0x3]\n\nShiftRows : State -> State\nShiftRows state = split [State_16@i\n                  | i <-  perm]\n                where State_16 = join state\nInvShiftRows : State -> State\nInvShiftRows state = split [State_16@i\n                  | i <-  inv_perm]\n                where State_16 = join state\n\n\/\/ Linear Layer\n\nm0 = [ 0x0, 0x4, 0x2, 0x1]\nm1 = [ 0x8, 0x0, 0x2, 0x1]\nm2 = [ 0x8, 0x4, 0x0, 0x1]\nm3 = [ 0x8, 0x4, 0x2, 0x0]\n\nM0 = [ [m0, m1, m2, m3], [m1, m2, m3, m0], [m2, m3, m0, m1], [m3, m0, m1, m2] ]\nM1 = [ [m1, m2, m3, m0], [m2, m3, m0, m1], [m3, m0, m1, m2], [m0, m1, m2, m3] ]\n\nM' = [ M0, M1, M1, M0]\n\n\n\/\/ m0\n\ndefm1 : [16] -> [16]\ndefm1 st = res \n where  res = b15 # b14 # b13 # b12 # b11 # b10 # b9 # b8 # b7 # b6 # b5 # b4 # b3 # b2 # b1 # b0\n        b0 = [st!4 ^ st!8 ^ st!12]\n        b1 = [st!1 ^ st!9 ^ st!13]\n        b2 = [st!2 ^ st!6 ^ st!14]\n        b3 = [st!3 ^ st!7 ^ st!11]\n        b4 = [st!0 ^ st!4 ^ st!8]\n        b5 = [st!5 ^ st!9 ^ st!13]\n        b6 = [st!2 ^ st!10 ^ st!14]\n        b7 = [st!3 ^ st!7 ^ st!15]\n        b8 = [st!0 ^ st!4 ^ st!12]\n        b9 = [st!1 ^ st!5 ^ st!9]\n        b10 = [st!6 ^ st!10 ^ st!14]\n        b11 = [st!3 ^ st!11 ^ st!15]\n        b12 = [st!0 ^ st!8 ^ st!12]\n        b13 = [st!1 ^ st!5 ^ st!13]\n        b14 = [st!2 ^ st!6 ^ st!10]\n        b15 = [st!7 ^ st!11 ^ st!15]\n\n\/\/ m1\n\ndefm0 : [16] -> [16]\ndefm0 st = res\n  where res = b15 # b14 # b13 # b12 # b11 # b10 # b9 # b8 # b7 # b6 # b5 # b4 # b3 # b2 # b1 # b0\n        b0 = [st!0 ^ st!4 ^ st!8]\n        b1 = [st!5 ^ st!9 ^ st!13]\n        b2 = [st!2 ^ st!10 ^ st!14]\n        b3 = [st!3 ^ st!7 ^ st!15]\n        b4 = [st!0 ^ st!4 ^ st!12]\n        b5 = [st!1 ^ st!5 ^ st!9]\n        b6 = [st!6 ^ st!10 ^ st!14]\n        b7 = [st!3 ^ st!11 ^ st!15]\n        b8 = [st!0 ^ st!8 ^ st!12]\n        b9 = [st!1 ^ st!5 ^ st!13]\n        b10 = [st!2 ^ st!6 ^ st!10]\n        b11 = [st!7 ^ st!11 ^ st!15]\n        b12 = [st!4 ^ st!8 ^ st!12]\n        b13 = [st!1 ^ st!9 ^ st!13]\n        b14 = [st!2 ^ st!6 ^ st!14]\n        b15 = [st!3 ^ st!7 ^ st!11]\n\n\/\/ M'\n\ndefMPrime: State -> State\ndefMPrime st = [rt3] # [rt2] # [rt1] # [rt0]\n      where rt0 = split (defm0 (join (st!0))):[4][4]\n            rt1 = split (defm1 (join (st!1))):[4][4]\n            rt2 = split (defm1 (join (st!2))):[4][4]\n            rt3 = split (defm0 (join (st!3))):[4][4]\n\n\n\/\/ first rounds\nfirstRounds : State -> State -> [Round] -> State\nfirstRounds pt key r = res\n           where   pt' =  SubCells(pt)\n                   pt'' = defMPrime (pt')\n                   pt''' = ShiftRows (pt'')\n                   res = pt''' ^ (split (split (RC@r))) ^ key\n                   \n\/\/ last rounds\n\nlastRounds : State -> State -> [Round] -> State\nlastRounds pt key r = res\n           where   pt' =  pt ^ key ^ (split (split (RC@r)))\n                   pt'' = InvShiftRows( pt')\n                   pt''' = defMPrime (pt'')\n                   res = InvSubCells (pt''')\n\nprinceCore : State -> State -> State\nprinceCore pt key  = addRC11\n           where addRC0 = pt ^ key ^ (split (split (RC@0)))\n                 firstR = [(firstRounds addRC0 key 1)] # [ (firstRounds res key i)\n                                                         | i <- [2,3..5]\n                                                         | res <- firstR\n                                                         ]\n                 subSbox = SubCells (firstR!0)\n                 linLayer = defMPrime (subSbox)\n                 subInvSbox = InvSubCells (linLayer)\n                 lastR = [(lastRounds subInvSbox  key 6) ] # [ (lastRounds res key i)\n                                                             | i <- [7,8..10]\n                                                             | res <- lastR\n                                                             ]\n                 addRC11 = (lastR!0) ^ key^ (split (split (RC@11)))\n                 \n\n\nprinceEncrypt : ([princeKeySize], [princeBlockSize]) -> [princeBlockSize]\nprinceEncrypt (key, pt) =  stateToMsg postWhiten\n            where  extk = extendKey (key)\n                   preWhiten = msgToState(pt) ^ msgToState (extk.0)\n                   coreEnc =  (princeCore preWhiten (msgToState (extk.2)))\n                   postWhiten = coreEnc ^ (msgToState (extk.1))\n\/\/Extend key to 192bits\n\nextendKeyDec :[princeKeySize] -> ([64], [64], [64])\nextendKeyDec key = (K', K!0, K!1) \n          where K = split key:[2][64]\n                K' = ((K!0) >>> 1) ^ ((K!0) >> 63)\n\n\/\/ Decryption\n\nprinceDecrypt : ([princeKeySize], [princeBlockSize]) -> [princeBlockSize]\nprinceDecrypt ( key, ct) = stateToMsg postWhiten\n            where alpha_padd = join((split(key):[32][4])^ (split (0xc0ac29b7c97c50dd0000000000000000):[32][4]))\n                  extk = extendKeyDec alpha_padd \n                  preWhiten = msgToState(ct) ^ msgToState (extk.0)\n                  coreEnc =  (princeCore preWhiten (msgToState (extk.2)))\n                  postWhiten = coreEnc ^ (msgToState (extk.1))\n\n\/\/correctness\n\nproperty princeCorrect key m = princeDecrypt ( key, princeEncrypt(key, m)) == m\n\n\/\/Helper functions to run the experiments\n\nprinceEncrypt64 : ([princeBlockSize], [princeBlockSize]) -> [princeBlockSize]\nprinceEncrypt64 (key, pt) = princeEncrypt(key#zero, pt)\n\nprinceDecrypt64 : ([princeBlockSize], [princeBlockSize]) -> [princeBlockSize]\nprinceDecrypt64 (key, ct) = princeDecrypt(key#zero, ct)\n\nproperty princeCorrect' key m = princeDecrypt64 (key, princeEncrypt64 (key, m)) == m\n\nprinceEncrypt128 : ([princeKeySize], [princeKeySize]) -> [princeKeySize]\nprinceEncrypt128 (key, pt) = princeEncrypt(key, (take`{64} pt))# zero\n\n\/\/ Testing\n\ntests = [t01, t02, t03, t04, t05, t06, t07]\nproperty testsPass = and tests\n\nt01 = princeEncrypt (zero, zero) == 0x818665aa0d02dfda\n\nt02 = princeEncrypt (zero, 0xffffffffffffffff) == 0x604ae6ca03c20ada\n\nt03 = princeEncrypt ( 0xffffffffffffffff0000000000000000, zero) == 0x78a54cbe737bb7ef\n\nt04 = princeEncrypt (0xffffffffffffffffffffffffffffffff, zero) == 0xb9f952807615743f\n\nt05 = princeEncrypt (0x0000000000000000ffffffffffffffff, zero) == 0x9fb51935fc3df524\n\nt06 = princeEncrypt (0x0000000000000000fedcba9876543210, 0x0123456789abcdef) == 0x1f24bb8638e813d3\n\nt07 = princeEncrypt (0xfedcba98765432100000000000000000, 0x0123456789abcdef) == 0xae25ad3ca8fa9ccf\n                                                                                                                         \n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES_parameterized.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::AES_parameterized where\n\nimport `Primitive::Symmetric::Cipher::Block::AES::Algorithm as AES\nimport `Primitive::Symmetric::Cipher::Block::AES::ExpandKey\nimport Primitive::Symmetric::Cipher::Block::AES::TBox\n\ntype constraint ValidKey k m = (k == 128 + m * 64, 2 >= m)\n\ntype EncKey m = AES::KeySchedule m\ntype DecKey m = AES::KeySchedule m\n\n\nencrypt : {k,m} ValidKey k m => [k] -> [128] -> [128]\nencrypt k = encryptWithSchedule (expandKeyEnc k)\n\ndecrypt : {k,m} ValidKey k m => [k] -> [128] -> [128]\ndecrypt k = decryptWithSchedule (expandKeyDec k)\n\n\nexpandKeyEnc : {k,m} ValidKey k m => [k] -> EncKey m\nexpandKeyEnc = expandKey`{Nk = AES::Nk m, Nr = AES::Nr m}\n\nencryptWithSchedule : {k,m} ValidKey k m => EncKey m -> [128] -> [128]\nencryptWithSchedule = AES::encrypt params\n\n\n\nexpandKeyDec : {k,m} ValidKey k m => [k] -> EncKey m\nexpandKeyDec k = makeDecKey (expandKey`{Nk = AES::Nk m, Nr = AES::Nr m} k)\n\ndecryptWithSchedule : {k,m} ValidKey k m => DecKey m -> [128] -> [128]\ndecryptWithSchedule = AES::decrypt params\n\n\nparams = { encRound = AESRound, decRound = AESInvRound }\n\nproperty test k pt = decrypt k (encrypt k pt) == pt\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AESKeyWrapPadded.cry","filetype":"cry","content":"\/\/ This is a close implementation of RFC 5649:\n\/\/ https:\/\/tools.ietf.org\/html\/rfc5649\n\nmodule Primitive::Symmetric::Cipher::Block::AESKeyWrapPadded where\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Block::AESKeyWrap\n\n\/\/ Most significant bits of alternate initial value (Section 3)\nAlternativeIV : [4][8]\nAlternativeIV = [0xA6, 0x59, 0x59, 0xA6]\n\n\/\/ Pad a plaintext out to the nearest 8 bytes\npadPlaintext : {n, m} (fin n, (n+m) % 8 == 0, m <= 7) => [n][8] -> [n + m][8]\npadPlaintext p = p # zero\n\n\/\/ Wrap `plaintext` using `key` as the encryption key.  `iv` is the most\n\/\/ significant 4 bytes of the alternative initial value (see Section 3 of\n\/\/ RFC 5649).  This function implements the algorithm from Section 4.1.\naesWrapKeyPadded : {n, m} (n >= 1 , n < 2^^32 , (n+m) % 8 == 0 , m <= 7) =>\n                   [AESKeySize] -> [4][8] -> [n][8] -> [n+m+8][8]\naesWrapKeyPadded key iv plaintext =\n  if `n <= 8\n  \/\/ If padded plaintext is 8 bytes, encrypt in AEC ECB mode.  The `drop` and\n  \/\/ append of `zero` have no effect at runtime and exist to make the types\n  \/\/ work out, as the type checker cannot deduce that `n <= 8` in this branch.\n  then (split (aesEncrypt (drop (join (AIV # P)), key))) # zero\n  \/\/ Otherwise perform standard key wrap algorithm on padded plaintext.  The\n  \/\/ `drop` and append of `zero` have runtime effect and exist to make the\n  \/\/ types work out, as the type checker cannot deduce that `n >= 16` in this\n  \/\/ branch.\n  else drop (aesWrapKey key AIV ((P # zero) : [max 16 (n+m)][8]))\n  where\n    \/\/ Append padding\n    P = padPlaintext`{n, m} plaintext\n    \/\/ Compute alternative initial value\n    AIV = iv # (split`{4,8} (`n : [32]))\n\n\/\/ Unwrap `ciphertext` using `key` as the key encryption key.  `iv` is most\n\/\/ significant 4 bytes of the expected initial value.  This function implements\n\/\/ the algorithm from Section 4.2.  It also performs the integrity check from\n\/\/ Section 3.  This function returns a tuple where the first element indicates\n\/\/ whether or not the integrity check passed (`True` indicates the check\n\/\/ passed), the second element is the size of the plaintext, and the final\n\/\/ element is the decrypted plaintext with the added padding.  The caller of\n\/\/ the function must remove this padding themselves.  If the integrity check\n\/\/ fails, the second and third elements will be zeros.\naesUnwrapKeyPadded : {n} (fin n, n >= 16, n % 8 == 0, width n <= 32) =>\n                     [AESKeySize] -> [4][8] -> [n][8] -> (Bit, [4][8], [n-8][8])\naesUnwrapKeyPadded key iv ciphertext = if valid\n                                       then (True, size, P)\n                                       else (False, zero, zero)\n  where\n    S : [n][8]\n    S = if `n == 16\n        \/\/ If the cipher text is 16 bytes, decrypt in AES ECB mode.  The `drop`\n        \/\/ and append of `zero` have no effect at runtime and exist to make the\n        \/\/ types work out, as the type checker cannot deduce that `n == 16` in\n        \/\/ this branch.\n        then (split (aesDecrypt (drop (join ciphertext), key))) # zero\n        \/\/ Otherwise perform the standard key unwrap algorithm.  The `drop`\n        \/\/ and append of `zero` have no effect at runtime and exist to make the\n        \/\/ types work out, as the type checker cannot deduce that `n >= 24` in\n        \/\/ this branch.\n        else drop (split`{each=8} (join (([A'] # R'))))\n          where\n            (A', R') = aesUnwrapKeyUnchecked key ((ciphertext # zero) : [max 24 n][8])\n    \/\/ Break decrypted ciphertext into the most significant 4 bytes of the IV,\n    \/\/ the size of the plaintext without padding, and the plaintext with\n    \/\/ padding\n    iv' : [4][8]\n    size : [4][8]\n    P : [n-8][8]\n    iv' # size # P = S\n        valid =\n      \/\/ Most significant bytes of IV should match `iv`\n      (iv' == iv) &&\n      \/\/ n - 16 < size <= n - 8\n      (((`n : [32]) - 16) < (join size)) &&\n      ((join size) <= ((`n : [32]) - 8)) &&\n      \/\/ All bytes of the padding must be zeros\n      and [(i < (join size)) || (x == zero) | x <- P | i <- [0...]]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/LED.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::LED where\n\ntype GF24 = [4]\ntype State = [4][4]GF24\ntype LEDKeySize64 = 64\ntype LEDKeySize128 = 128\ntype LEDBlockSize = 64\n\/\/ Number of rounds 32 for 64, 48 for 128\ntype Rn = [6]\ntype steps = 8 \n\/\/type steps = 12\n\/\/ Number of rounds\ntype Nr = steps*4\n\n\/\/Number of steps\ntype Ns = 8\n\n\/\/ GF24 operations\n\ngf24Add : {n} (fin n) => [n]GF24 -> GF24\ngf24Add ps = sums ! 0\n      where sums = [zero] # [p^s | p <- ps | s <- sums]\nirreducible = <| x^^4 + x + 1 |>\n\n\/\/ Polynomial multiplication in GF24\n\ngf24Mult : (GF24, GF24) -> GF24\ngf24Mult (x , y) = pmod (pmult x y) irreducible\n\n\/\/ Define a power of an element in GF24\n\ngf24Pow : (GF24, [4]) -> GF24\ngf24Pow (n , k) = pow k\n        where sq x = gf24Mult (x, x)\n              odd x = x ! 0\n              pow i = if i == 0 then 1\n                      else if odd i\n                           then gf24Mult(n, sq (pow (i >> 1)))\n                           else sq (pow (i >> 1))\n\n\/\/ self adding gives zero\n\npolySelfAdd' : GF24 -> Bit\nproperty polySelfAdd' x = x ^ x == zero\n\n\n\/\/ Inverse of an element in GF24\n\ngf24Inverse : GF24 -> GF24\ngf24Inverse x = gf24Pow (x, 14)\n\n\/\/Dot product in GF24\n\ngf24DotProduct : {n} (fin n) => ([n]GF24, [n]GF24) -> GF24\ngf24DotProduct  (xs, ys) = gf24Add [ gf24Mult (x, y) | x <- xs\n                                                     | y <- ys ]\n\n\/\/ Vector Multiplication\n\ngf24VectorMult : {n, m} (fin n) => ([n]GF24, [m][n]GF24) -> [m]GF24\ngf24VectorMult (v, ms) = [ gf24DotProduct(v, m) | m <- ms ]\n\n\/\/ Matrix Multiplication\n\ngf24MatrixMult : {n, m, k} (fin m) => ([n][m]GF24, [m][k]GF24) -> [n][k]GF24\ngf24MatrixMult (xss, yss) = [ gf24VectorMult(xs, yss') | xs <- xss ]\n   where yss' = transpose yss\n                                                       \n\n\/\/ LED re-uses PRESENT Sbox\n\nsbox : [16] GF24\n\nsbox = [0xc, 0x5, 0x6, 0xb, 0x9, 0x0, 0xa, 0xd, 0x3, 0xe, 0xf, 0x8, 0x4, 0x7, 0x1, 0x2]\n\n\/\/arrange_pt : [64]Bit -> [4][4]GF24\n\n\/\/Converting a 64-bit message to a State and back\n\nmsgToState : [64] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg : State -> [64]\nstateToMsg st = join (join st)\n\n\/\/ Split key (128-bits) in to two matrices of size 64 each\nsplitKey1 : [128] -> State\nsplitKey1  key =  msgToState(seed@0)\n          where seed : [2][64]\n                seed = split(key)\n\n\nsplitKey2 : [128] -> State\nsplitKey2  key =  msgToState(seed@1)\n          where seed : [2][64]\n                seed = split(key)\n          \n\nAddRoundKey: (State, State) -> State\nAddRoundKey (rk , s) = rk^s\n\n\/\/ Each round has the follwoing transformations\n\n\/\/round constants for 48-rounds\n\nrcTab : [48][8]\nrcTab = [0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3E, \n                    0x3D, 0x3B, 0x37, 0x2F, 0x1E, 0x3C, 0x39,\n                    0x33, 0x27, 0x0E, 0x1D, 0x3A, 0x35, 0x2B,\n                    0x16, 0x2C, 0x18, 0x30, 0x21, 0x02, 0x05,\n                    0x0B, 0x17, 0x2E, 0x1C, 0x38, 0x31, 0x23,\n                    0x06, 0x0D, 0x1B, 0x36, 0x2D, 0x1A, 0x34,\n                    0x29, 0x12, 0x24, 0x08, 0x11, 0x22, 0x04]\n\n      \n\/\/ Define a matrix to add in each round\n\naddConst64 : Rn -> State\naddConst128 : Rn -> State\n\/* addconst function for 128bit key size *\/\n\/\/uncomment this for 128bit key size\n\naddConst128 rn  = [[ 8, rcpad(rcTab, rn, [5, 4, 3]) , 0, 0], [9, rcpad(rcTab, rn, [2, 1, 0]) , 0, 0], [2, rcpad(rcTab, rn, [5, 4, 3]), 0, 0], [3, rcpad(rcTab, rn, [2, 1, 0]), 0, 0]] \n\n\/* addconst function for 64bit key size *\/\n\/\/uncomment this for 64bit key size\n\naddConst64 rn  =[[ 4, rcpad(rcTab, rn, [5, 4, 3]) , 0, 0], [5, rcpad(rcTab, rn, [2, 1, 0]) , 0, 0], [2, rcpad(rcTab, rn, [5, 4, 3]), 0, 0], [3, rcpad(rcTab, rn, [2, 1, 0]), 0, 0]] \n\n\n\/\/padding (rc5||rc4||rc3) or (rc2||rc1||rc0)\n\nrcpad : ([48][8], Rn, [3][3]) -> GF24\nrcpad (rct, rn, indcs) = (0b0 # ((rct @ rn):[8]) !! indcs)\n\n\/\/ Add constatns\n\nAddConst64 : (Rn, State) -> State\nAddConst64 (rn, st) = st ^ (addConst64 rn)\n\nAddConst128 : (Rn, State) -> State\nAddConst128 (rn, st) = st ^ (addConst128 rn)\n                    \n\/\/Each nibble in the array state is replaced with PRESENT Sbox\n\nSubCell : GF24 -> GF24\nSubCell b = sbox @ b\n\nSubCells : State -> State\nSubCells state = [ [SubCell b | b <- row] | row <- state]\n\nShiftRows : State -> State\nShiftRows state = [ row <<< shiftAmount | row <- state\n                                        | shiftAmount <- [0..3]\n                  ]\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> shiftAmount | row <- state\n                                           | shiftAmount <- [0 .. 3]\n                     ]\nMDS : State\n\nMDS = [ [ 0x4, 0x1, 0x2, 0x2],\n            [ 0x8, 0x6, 0x5, 0x6],\n            [ 0xB, 0xE, 0xA, 0x9],\n            [ 0x2, 0x2, 0xF, 0xB] ]\n\n\/\/ Replace each column vector v of state S by MDS.v\n\nMixColumns : State -> State\nMixColumns state = transpose [gf24VectorMult (row, MDS)| row <- state']\n           where state' = transpose state\n\n\/\/ ONE Round\n\nroundXform64 : (Rn, State) -> State\nroundXform64 (rn, st) = MixColumns (ShiftRows( SubCells (AddConst64 (rn, st))))\n\n\n\/\/four rounds\n\nfourRoundXform64 : ([6], State) -> State\nfourRoundXform64 (stp, st) = roundXform64 ((4*stp+3), (roundXform64 ((4*stp+2), (roundXform64 ((4*stp+1), (roundXform64 ((4*stp+0), st)))))))\n\n\/\/ ONE Round\n\nroundXform128 : (Rn, State) -> State\nroundXform128 (rn, st) = MixColumns (ShiftRows( SubCells (AddConst128 (rn, st))))\n\n\n\/\/four rounds\n\nfourRoundXform128 : ([6], State) -> State\nfourRoundXform128 (stp, st) = roundXform128 ((4*stp+3), (roundXform128 ((4*stp+2), (roundXform128 ((4*stp+1), (roundXform128 ((4*stp+0), st)))))))\n\n\n\/\/ LED Encryption\n                       \n\/\/Encryption with the keysize of 64bits\n\nledEncrypt64 : ([LEDKeySize64], [LEDBlockSize])  -> [LEDBlockSize]\nledEncrypt64 (key, pt) = stateToMsg(addrk8)\n              where pt_st = msgToState(pt)\n                    key_st1 =  msgToState(key)\n                    key_st2 = msgToState(key)\n                    addrk0 = (AddRoundKey(pt_st, key_st1))\n                    step0 = (fourRoundXform64 (0, addrk0))        \n                    addrk1 = (AddRoundKey(step0, key_st2))\n                    step1 = (fourRoundXform64 (1, addrk1))\n                    addrk2 = (AddRoundKey(step1, key_st1))\n                    step2 = (fourRoundXform64 (2, addrk2))\n                    addrk3 = (AddRoundKey(step2, key_st2))\n                    step3 = (fourRoundXform64 (3, addrk3))\n                    addrk4 = (AddRoundKey(step3, key_st1))\n                    step4 = (fourRoundXform64 (4, addrk4))\n                    addrk5 = (AddRoundKey(step4, key_st2))\n                    step5 = (fourRoundXform64 (5, addrk5))\n                    addrk6 = (AddRoundKey(step5, key_st1))\n                    step6 = (fourRoundXform64 (6, addrk6))\n                    addrk7 = (AddRoundKey(step6, key_st2))\n                    step7 = (fourRoundXform64 (7, addrk7))\n                    addrk8 = (AddRoundKey(step7, key_st1))\n\n                   \n\/\/ Encryption with the keysize of 128bits\n\nledEncrypt128 : ([LEDKeySize128], [LEDBlockSize])  -> [LEDBlockSize]\nledEncrypt128 ( key, pt) = stateToMsg(addrk12)\n              where pt_st = msgToState(pt)\n                    \/* splitting the key in two with 64bits each*\/\n                    key_st1 = splitKey1(key)\n                    key_st2 = splitKey2(key)\n                    addrk0 = (AddRoundKey(pt_st, key_st1))\n                    step0 = (fourRoundXform128 (0, addrk0))        \n                    addrk1 = (AddRoundKey(step0, key_st2))\n                    step1 = (fourRoundXform128 (1, addrk1))\n                    addrk2 = (AddRoundKey(step1, key_st1))\n                    step2 = (fourRoundXform128 (2, addrk2))\n                    addrk3 = (AddRoundKey(step2, key_st2))\n                    step3 = (fourRoundXform128 (3, addrk3))\n                    addrk4 = (AddRoundKey(step3, key_st1))\n                    step4 = (fourRoundXform128 (4, addrk4))\n                    addrk5 = (AddRoundKey(step4, key_st2))\n                    step5 = (fourRoundXform128 (5, addrk5))\n                    addrk6 = (AddRoundKey(step5, key_st1))\n                    step6 = (fourRoundXform128 (6, addrk6))\n                    addrk7 = (AddRoundKey(step6, key_st2))\n                    step7 = (fourRoundXform128 (7, addrk7))\n                    addrk8 = (AddRoundKey(step7, key_st1))\n                    step8 = (fourRoundXform128 (8, addrk8))\n                    addrk9 = (AddRoundKey(step8, key_st2))\n                    step9 = (fourRoundXform128 (9, addrk9))\n                    addrk10 = (AddRoundKey(step9, key_st1))\n                    step10 = (fourRoundXform128 (10, addrk10))\n                    addrk11 = (AddRoundKey(step10, key_st2))\n                    step11 = (fourRoundXform128 (11, addrk11))\n                    addrk12 = (AddRoundKey(step11, key_st1))\n\n\/\/ Helper to run the experiments\n\n\nledEncrypt64' : ([LEDBlockSize], [LEDBlockSize]) -> [LEDBlockSize]\nledEncrypt64' (key, pt) = ledEncrypt128 (key#zero, pt)\n\nledEncrypt128' : ([LEDKeySize128], [LEDKeySize128]) -> [LEDKeySize128]\nledEncrypt128' (key, pt) = ledEncrypt128(key, (take`{64} pt))# zero\n\n\n\/\/ Testing\n\ntests = [test64_1, test64_2, test128_1, test128_2]\nproperty testsPass = and tests\n\n\/\/Keysize: 64bits\n\nproperty test64_1  = ledEncrypt64 (zero, zero) == 0x39c2401003a0c798\nproperty test64_2 = ledEncrypt64 (0x0123456789abcdef, 0x0123456789abcdef) == 0xa003551e3893fc58\n\n\/\/keysize: 128bits\n\nproperty test128_1 = ledEncrypt128 (zero, zero) == 0x3decb2a0850cdba1\nproperty test128_2 = ledEncrypt128 (0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0xd6b824587f014fc2\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/SHACAL.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::SHACAL where\n\nimport Primitive::Keyless::Hash::SHA256\nimport Primitive::Keyless::Hash::SHA1\n\n\/**SHACAL1**\/\n\n\ntype shacal1Block = 160\ntype shacal1Key = 512\n\n\n\nshacal1Encrypt : ([shacal1Key], [shacal1Block]) -> [shacal1Block]\nshacal1Encrypt (key, pt) = join (block (pt', key'))\n              where pt' = split pt : [5][32]\n                    key' = split key : [16][32]\n\n\/\/ Helper function to analyse the PGV hash function constructions\n\nshacal1Encrypt160 : ([shacal1Block], [shacal1Block]) -> [shacal1Block]\nshacal1Encrypt160 (key, pt) = shacal1Encrypt(key#zero, pt)\n\nshacal1Encrypt512 : ([shacal1Key], [shacal1Key]) -> [shacal1Key]\nshacal1Encrypt512 (key, pt) = shacal1Encrypt(key, (take`{160} pt))#zero\n\n\n\/\/ \/\/Added 10 test vectors for more vectors, please visit:  https:\/\/www.cosic.esat.kuleuven.be\/nessie\/tweaks.html\n\nproperty shacal1TestsPass = and [shacal1Encrypt(key, plain) == cipher | (key, plain, cipher) <- tVector1]\n\ntVector1 = [ (0x8#zero, zero, 0x0FFD8D43B4E33C7C53461BD10F27A5461050D90D)\n           , (0x4#zero, zero, 0xB9C60AA972B49CA04D5A0D9B9E08B2A2BA138C93)\n           , (0x2#zero, zero, 0x3FA618501A3D10E3CAEB3CA06B8B47A16F8E3D9E)\n           , (0x1#zero, zero, 0x2B4AFB3268C32F86B89BB745EC85F24702B38498)\n           , (0x08#zero, zero, 0x58E782A1D205E53DD2901F0F302F8894D0A3B05B)\n           , (0x04#zero, zero, 0xB345AD4DC877D0BFCF760EE25056D21C7DB2F868)\n           , (0x02#zero, zero, 0x334C5A595919EA33E5EB467657AAE3ED825207D3)\n           , (0x01#zero, zero, 0x5F686F27819DF939F877099A222D01EE955F6E66)\n           , (0x008#zero, zero, 0x62BE68D266A28F7E6B44A83E62A476FFD627AF0E)\n           , (0x004#zero, zero, 0x2D5265CD2E72B52B6477F341816F2BB554428BC5)]\n\n\n\/**SHACAL2**\/\n\n\n\ntype shacal2Block = 256\ntype shacal2Key = 512\n\nshacal2Encrypt : ([shacal2Key], [shacal2Block]) -> [shacal2Block]\nshacal2Encrypt (key, pt) = join (SHA256Block pt' key')\n              where pt' = split pt : [8][32]\n                    key' = split key : [16][32]\n\n\/\/ Helper function to analyse the PGV hash function constructions\n\nshacal2Encrypt256 : ([shacal2Block], [shacal2Block]) -> [shacal2Block]\nshacal2Encrypt256 (key, pt) = shacal2Encrypt(key#zero, pt)\n\nshacal2Encrypt512 : ([shacal2Key], [shacal2Key]) -> [shacal2Key]\nshacal2Encrypt512 (key, pt) = shacal2Encrypt(key, (take`{256} pt))#zero\n\n\/\/Testing\n\/\/Added 10 test vectors for more vectors, please visit:  https:\/\/www.cosic.esat.kuleuven.be\/nessie\/tweaks.html\n\nproperty shacal2TestsPass = and [shacal2Encrypt(key, plain) == cipher | (key, plain, cipher) <- tVector2]\n\ntVector2 = [ (0x8#zero, zero, 0x361AB6322FA9E7A7BB23818D839E01BDDAFDF47305426EDD297AEDB9F6202BAE)\n           , (0x4#zero, zero, 0xF3BAF53E5301E08813F8BE6F651BB19E9722151FF15063BA42A6FEF7CF3BF3D7)\n           , (0x1#zero, zero, 0xAE70E355CB7E26FF12421F46CDAD5CB98367FE0E86CC234EDF97481765CD1AD9)\n           , (0x08#zero, zero, 0x00CECD0B01311F881018E7A20BCE169766C089D91FF161346C4E1BD122EA199F)\n           , (0x08#zero, zero, 0x00CECD0B01311F881018E7A20BCE169766C089D91FF161346C4E1BD122EA199F)\n           , (0x04#zero, zero, 0x47A879CB6785AD37119C450CD50E9A36FE318FA8E7B6C6E0FA963430122F33CD)\n           , (0x02#zero, zero, 0xCF3D53B9F9F7CA2C66738A4C09CEA9212C056F525BDC26F263FBA1B482EDF503)\n           , (0x01#zero, zero, 0xA274D404E83E82817389A2CB7B528C792A0E80DE879A5A67DE633B0B7DD57B7B)\n           , (0x008#zero, zero, 0x09B3AB9332301D4E3C239D192A4221AFD43F6829A705D396FA96BDE1E716BC38)\n           , (0x004#zero, zero, 0xD3B9AB867A6868C4400D200979055C8F9E3A6BFB40D1F9E376B9EC89223D7050)]\n\n","variant":"hybrid","set":"holdout"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/simon.cry","filetype":"cry","content":"\/* Cryptol specification of the Simon block cipher\n * Author: David Lazar\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::simon where\n\nSimon32_64    = encrypt `{n=16,m=4,T=32,j=0}\nSimon48_72    = encrypt `{n=24,m=3,T=36,j=0}\nSimon48_96    = encrypt `{n=24,m=4,T=36,j=1}\nSimon64_96    = encrypt `{n=32,m=3,T=42,j=2}\nSimon64_128   = encrypt `{n=32,m=4,T=44,j=3}\nSimon96_96    = encrypt `{n=48,m=2,T=52,j=2}\nSimon96_144   = encrypt `{n=48,m=3,T=54,j=3}\nSimon128_128  = encrypt `{n=64,m=2,T=68,j=2}\nSimon128_192  = encrypt `{n=64,m=3,T=69,j=3}\nSimon128_256  = encrypt `{n=64,m=4,T=72,j=4}\n\nSimon32_64'   = decrypt `{n=16,m=4,T=32,j=0}\nSimon48_72'   = decrypt `{n=24,m=3,T=36,j=0}\nSimon48_96'   = decrypt `{n=24,m=4,T=36,j=1}\nSimon64_96'   = decrypt `{n=32,m=3,T=42,j=2}\nSimon64_128'  = decrypt `{n=32,m=4,T=44,j=3}\nSimon96_96'   = decrypt `{n=48,m=2,T=52,j=2}\nSimon96_144'  = decrypt `{n=48,m=3,T=54,j=3}\nSimon128_128' = decrypt `{n=64,m=2,T=68,j=2}\nSimon128_192' = decrypt `{n=64,m=3,T=69,j=3}\nSimon128_256' = decrypt `{n=64,m=4,T=72,j=4}\n\nproperty correctSimon32_64 k b   = Simon32_64' k (Simon32_64 k b) == b\nproperty correctSimon64_96 k b   = Simon64_96' k (Simon64_96 k b) == b\nproperty correctSimon96_144 k b  = Simon96_144' k (Simon96_144 k b) == b\nproperty correctSimon128_128 k b = Simon128_128' k (Simon128_128 k b) == b\nproperty correctSimon128_256 k b = Simon128_256' k (Simon128_256 k b) == b\n\nproperty uniqueExpandSimon32_64 k1 k2 = (k1 == k2) || (expandKey `{n=16,m=4,T=32,j=0} k1 != expandKey `{n=16,m=4,T=32,j=0} k2)\nproperty uniqueExpandSimon48_72 k1 k2 = (k1 == k2) || (expandKey `{n=24,m=3,T=36,j=0} k1 != expandKey `{n=24,m=3,T=36,j=0} k2)\nproperty uniqueExpandSimon48_96 k1 k2 = (k1 == k2) || (expandKey `{n=24,m=4,T=36,j=1} k1 != expandKey `{n=24,m=4,T=36,j=1} k2)\nproperty uniqueExpandSimon64_96 k1 k2 = (k1 == k2) || (expandKey `{n=32,m=3,T=42,j=2} k1 != expandKey `{n=32,m=3,T=42,j=2} k2)\nproperty uniqueExpandSimon64_128 k1 k2 = (k1 == k2) || (expandKey `{n=32,m=4,T=44,j=3} k1 != expandKey `{n=32,m=4,T=44,j=3} k2)\nproperty uniqueExpandSimon96_96 k1 k2 = (k1 == k2) || (expandKey `{n=48,m=2,T=52,j=2} k1 != expandKey `{n=48,m=2,T=52,j=2} k2)\nproperty uniqueExpandSimon96_144 k1 k2 = (k1 == k2) || (expandKey `{n=48,m=3,T=54,j=3} k1 != expandKey `{n=48,m=3,T=54,j=3} k2)\nproperty uniqueExpandSimon128_128 k1 k2 = (k1 == k2) || (expandKey `{n=64,m=2,T=68,j=2} k1 != expandKey `{n=64,m=2,T=68,j=2} k2)\nproperty uniqueExpandSimon128_192 k1 k2 = (k1 == k2) || (expandKey `{n=64,m=3,T=69,j=3} k1 != expandKey `{n=64,m=3,T=69,j=3} k2)\nproperty uniqueExpandSimon128_256 k1 k2 = (k1 == k2) || (expandKey `{n=64,m=4,T=72,j=4} k1 != expandKey `{n=64,m=4,T=72,j=4} k2)\n\n\/\/ A weak key theorem would look something like:\n\/\/ :prove exists (\\k1 -> exists (\\k2 -> forall (\\x -> Simon32_64 k1 (Simon32_64 k2 x) != x)))\n\n\nR k (x, y) = (y ^ f x ^ k, x)\n\n\/\/ inverse\nR' k (x, y) = (y, x ^ f y ^ k)\n\nf x = ((x <<< 1) && (x <<< 8)) ^ (x <<< 2)\n\n\nencrypt : {n, m, T, j}\n    ( fin n, fin m, fin T, fin j\n    , n >= 2, 4 >= m, T >= 4, T-1 >= m\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\nencrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [ R k b | b <- bs | k <- ks ]\n    ks = expandKey `{n=n,m=m,T=T,j=j} (reverse k0)\n\ndecrypt : {n, m, T, j}\n    ( fin n, fin m, fin T, fin j\n    , n >= 2, 4 >= m, T >= 4, T-1 >= m\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\ndecrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [ R' k b | b <- bs | k <- reverse ks ]\n    ks = expandKey `{n=n,m=m,T=T,j=j} (reverse k0)\n\n\nexpandKey : {n, m, T, j}\n    ( fin n, fin m, fin T, fin j\n    , n >= 2, 4 >= m, T >= 4, T-1 >= m\n    ) => [m][n] -> [T][n]\nexpandKey k0 = k\n  where\n    k = k0 # [ r where\n                    o = k @ (i - 1) >>> 3\n                    p = if `m == 4 then o ^ k @ (i - 3) else o\n                    q = p ^ p >>> 1\n                    r = ~ k @ (i - `m) ^ q ^ z ^ 3\n                    z = Z @ `j @ ((i - `m) % 62)\n             | i <- [m .. T - 1]\n             ]\n\nZ = [[1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0,\n      0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1,\n      0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0],\n     [1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0,\n      0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1,\n      0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0],\n     [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,\n      0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1,\n      1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1],\n     [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1,\n      0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0,\n      0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1],\n     [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1,\n      1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1,\n      0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1]]\n\ntests = [t01,t02,t03,t04,t05,t06,t07,t08,t09]\nproperty testsPass = and tests\n\nt00 = Simon32_64   [0x1918, 0x1110, 0x0908, 0x0100] (0x6565, 0x6877) == (0xc69b, 0xe9bb)\nt01 = Simon48_72   [0x121110, 0x0a0908, 0x020100] (0x612067, 0x6e696c) == (0xdae5ac, 0x292cac)\nt02 = Simon48_96   [0x1a1918, 0x121110, 0x0a0908, 0x020100] (0x726963, 0x20646e) == (0x6e06a5, 0xacf156)\nt03 = Simon64_96   [0x13121110, 0x0b0a0908, 0x03020100] (0x6f722067, 0x6e696c63) == (0x5ca2e27f, 0x111a8fc8)\nt04 = Simon64_128  [0x1b1a1918, 0x13121110, 0x0b0a0908, 0x03020100] (0x656b696c, 0x20646e75) == (0x44c8fc20, 0xb9dfa07a)\nt05 = Simon96_96   [0x0d0c0b0a0908, 0x050403020100] (0x2072616c6c69, 0x702065687420) == (0x602807a462b4, 0x69063d8ff082)\nt06 = Simon96_144  [0x151413121110, 0x0d0c0b0a0908, 0x050403020100] (0x746168742074, 0x73756420666f) == (0xecad1c6c451e, 0x3f59c5db1ae9)\nt07 = Simon128_128 [0x0f0e0d0c0b0a0908, 0x0706050403020100] (0x6373656420737265, 0x6c6c657661727420) == (0x49681b1e1e54fe3f, 0x65aa832af84e0bbc)\nt08 = Simon128_192 [0x1716151413121110, 0x0f0e0d0c0b0a0908, 0x0706050403020100] (0x206572656874206e, 0x6568772065626972) == (0xc4ac61effcdc0d4f, 0x6c9c8d6e2597b85b)\nt09 = Simon128_256 [0x1f1e1d1c1b1a1918, 0x1716151413121110, 0x0f0e0d0c0b0a0908, 0x0706050403020100] (0x74206e69206d6f6f, 0x6d69732061207369) == (0x8d2b5579afc8a3a0, 0x3bf72a87efe7b868)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AESKeyWrap.cry","filetype":"cry","content":"\/\/ This is a close implementation of RFC 3394:\n\/\/ https:\/\/tools.ietf.org\/html\/rfc3394\n\/\/ RFC 3394 provides two equivalent descriptions of AES Key Wrap, one using\n\/\/ shifting and the other using indexing.  This specification closely matches\n\/\/ the index-based algorithm description as that description is more similar\n\/\/ to the BoringSSL AES Key Wrap implementation.\n\nmodule Primitive::Symmetric::Cipher::Block::AESKeyWrap where\nimport Primitive::Symmetric::Cipher::Block::AES\n\n\/\/ Default intial value (Section 2.2.3)\nDefaultIV : [8][8]\nDefaultIV = [0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6]\n\n\/\/ Wrap `plaintext` using `key` as the key encryption key.  `iv` is the initial\n\/\/ value to use.  This function implements the algorithm from Section 2.2.1\n\/\/ using the index-based definition.\naesWrapKey : {n} (fin n, n >= 16, n % 8 == 0, width (n \/ 8) <= 64) =>\n             [AESKeySize] -> [8][8] -> [n][8] -> [n+8][8]\naesWrapKey key iv plaintext = split (join C)\n  where\n        A = join iv\n    R = split`{parts=n\/8, each=64} (join plaintext)\n        intermediates = [(A, R)] # [wrapRound key s j | s <- intermediates\n                                                  | j <- [0..5]]\n        (A', R') = intermediates ! 0\n    C = [A'] # R'\n\n\/\/ Unwrap `ciphertext` using `key` as the key encryption key.  `iv` is the\n\/\/ expected initial value.  This function implements the algorithm from Section\n\/\/ 2.2.2 using the index-based definition.  It also checks the key data\n\/\/ integrity using `iv` (Section 2.2.3).  This function returns a tuple where\n\/\/ the first element indicates  whether or not the integrity check passed\n\/\/ (`True` indicates the check passed), and the second element is the decrypted\n\/\/ plain text.  If the integrity check fails, the second element will be all\n\/\/ zeros.\naesUnwrapKey : {n} (fin n, n >= 24, n % 8 == 0, width (n \/ 8) <= 64) =>\n               [AESKeySize] -> [8][8] -> [n][8] -> (Bit, [n-8][8])\naesUnwrapKey key iv ciphertext = if (join iv) == A'\n                                 then (True, split (join R'))\n                                 else (False, zero)\n  where\n    (A', R') = aesUnwrapKeyUnchecked key ciphertext\n\n\/\/ This function performs steps 1 and 2 of the unwrap key algorithm from\n\/\/ Section 2.2.2 using the index-based definition.\naesUnwrapKeyUnchecked : {n} (fin n, n >= 24, n % 8 == 0, width (n \/ 8) <= 64) =>\n                        [AESKeySize] -> [n][8] -> ([64], [n\/8 - 1][64])\naesUnwrapKeyUnchecked key ciphertext = intermediates ! 0\n  where\n        A = join (take`{8} ciphertext)\n    R = split`{parts=(n-8)\/8, each=64} (join (drop`{8} ciphertext))\n    \/\/ Step 2: Compute intermediate values\n    intermediates = [(A, R)] # [unwrapRound key s j | s <- intermediates\n                                                    | j <- [5, 4 .. 0]]\n\nprivate\n    \/*\n   * This section contains helper functions for wrapping and unwrapping keys.\n   * These functions make use of the notation defined in Section 2.1 of\n   * RFC 3394.\n   *\/\n\n  \/\/ Body of inner loop of step 2 of key wrap algorithm (Section 2.2.1)\n  wrapBlock : {n} (fin n, width n <= 64) =>\n              [AESKeySize] -> ([64], [n][64]) -> [64] -> [64] -> ([64], [n][64])\n  wrapBlock key (A, R) j i = (A', R')\n    where B  = aesEncrypt (A # (R @ (i-1)), key)\n          A' = (take`{64} B) ^ (((`n : [64]) * j) + i)\n          R' = update R (i-1) (drop`{64} B)\n\n  \/\/ Body of inner loop of step 2 of key unwrap algorithm (Section 2.2.2)\n  unwrapBlock : {n} (fin n, width n <= 64) =>\n                [AESKeySize] -> ([64], [n][64]) -> [64] -> [64] -> ([64], [n][64])\n  unwrapBlock key (A, R) j i = (A', R')\n    where B  = aesDecrypt ((A ^ (((`n : [64]) * j) + i)) # (R @ (i-1)), key)\n          A' = take`{64} B\n          R' = update R (i-1) (drop`{64} B)\n\n  \/\/ A single round of the key wrap algorithm (Section 2.2.1, step 2)\n  wrapRound : {n} (fin n, n >= 1, width n <= 64) =>\n              [AESKeySize] -> ([64], [n][64]) -> [64] -> ([64], [n][64])\n  wrapRound key (A, R) j = wrappedBlocks ! 0\n    where wrappedBlocks = [(A, R)] # [wrapBlock key s j i | s <- wrappedBlocks\n                                                          | i <- [1..n]]\n\n  \/\/ A single round of the key unwrap algorithm (Section 2.2.2, step 2)\n  unwrapRound : {n} (fin n, n >= 1, width n <= 64) =>\n                [AESKeySize] -> ([64], [n][64]) -> [64] -> ([64], [n][64])\n  unwrapRound key (A, R) j = unwrappedBlocks ! 0\n    where unwrappedBlocks = [(A, R)] # [unwrapBlock key s j i | s <- unwrappedBlocks\n                                                              | i <- [n, n-1 .. 1]]\n","variant":"hybrid","set":"supervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/speck.cry","filetype":"cry","content":"\/* Cryptol specification of the Speck block cipher\n * Author: David Lazar\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::speck where\n\nSpeck32_64    = encrypt`{n = 16, m = 4, T = 22}\nSpeck48_72    = encrypt`{n = 24, m = 3, T = 22}\nSpeck48_96    = encrypt`{n = 24, m = 4, T = 23}\nSpeck64_96    = encrypt`{n = 32, m = 3, T = 26}\nSpeck64_128   = encrypt`{n = 32, m = 4, T = 27}\nSpeck96_96    = encrypt`{n = 48, m = 2, T = 28}\nSpeck96_144   = encrypt`{n = 48, m = 3, T = 29}\nSpeck128_128  = encrypt`{n = 64, m = 2, T = 32}\nSpeck128_192  = encrypt`{n = 64, m = 3, T = 33}\nSpeck128_256  = encrypt`{n = 64, m = 4, T = 34}\n\nSpeck32_64'   = decrypt`{n = 16, m = 4, T = 22}\nSpeck48_72'   = decrypt`{n = 24, m = 3, T = 22}\nSpeck48_96'   = decrypt`{n = 24, m = 4, T = 23}\nSpeck64_96'   = decrypt`{n = 32, m = 3, T = 26}\nSpeck64_128'  = decrypt`{n = 32, m = 4, T = 27}\nSpeck96_96'   = decrypt`{n = 48, m = 2, T = 28}\nSpeck96_144'  = decrypt`{n = 48, m = 3, T = 29}\nSpeck128_128' = decrypt`{n = 64, m = 2, T = 32}\nSpeck128_192' = decrypt`{n = 64, m = 3, T = 33}\nSpeck128_256' = decrypt`{n = 64, m = 4, T = 34}\n\nproperty correctSpeck32_64 (k, b) = Speck32_64' k (Speck32_64 k b) == b\nproperty correctSpeck64_96 (k, b) = Speck64_96' k (Speck64_96 k b) == b\nproperty correctSpeck96_144 (k, b) = Speck96_144' k (Speck96_144 k b) == b\nproperty correctSpeck128_128 (k, b) = Speck128_128' k (Speck128_128 k b) == b\nproperty correctSpeck128_256 (k, b) = Speck128_256' k (Speck128_256 k b) == b\n\n\nR : {n} (fin n) => [n] -> ([n], [n]) -> ([n], [n])\nR k (x, y) = f2 (f1 k (x, y))\n\nR' : {n} (fin n) => [n] -> ([n], [n]) -> ([n], [n])\nR' k (x, y) = ((x ^ k) - z <<< (if `n == 16 then 7 else 8), z)\n  where z = (x ^ y) >>> (if `n == 16 then 2 else 3)\n\nf1 : {n} (fin n) => [n] -> ([n], [n]) -> ([n], [n])\nf1 k (x, y) = (y, (x >>> (if `n == 16 then 7 else 8)) + y ^ k)\n\nf2 : {n} (fin n) => ([n], [n]) -> ([n], [n])\nf2 (x, y) = (y, x <<< (if `n == 16 then 2 else 3) ^ y)\n\n\nencrypt : {n, m, T}\n    ( fin n, fin m, fin T\n    , m >= 2, T >= 2, n >= 2\n    , n >= width (T-2)\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\nencrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [R k b | b <- bs | k <- ks]\n    ks = expandKey`{n = n, m = m, T = T} (reverse k0)\n\n\ndecrypt : {n, m, T}\n    ( fin n, fin m, fin T\n    , m >= 2, T >= 2, n >= 2\n    , n >= width (T-2)\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\ndecrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [R' k b | b <- bs | k <- reverse ks]\n    ks = expandKey`{n = n, m = m, T = T} (reverse k0)\n\n\nexpandKey : {n, m, T}\n    ( fin n, fin m, fin T\n    , m >= 2, n >= 2, T >= 2\n    , n >= width (T-2)\n    ) => [m][n] -> [T][n]\nexpandKey K = ks\n  where\n    ls = drop`{1} K # [snd (f1 i (l, k)) | l <- ls | k <- ks | i <- [0 .. T - 2]]\n    ks = take`{1} K # [snd (f2 (k, l)) | l <- drop`{m - 1} ls | k <- ks]\n    snd (x, y) = y\n\n\nproperty testsPass = and tests\n\ntests = [t01, t02, t03, t04, t05, t06, t07, t08, t09]\n\nt00 = Speck32_64 [0x1918, 0x1110, 0x0908, 0x0100] (0x6574, 0x694C) == (0xA868, 0x42F2)\nt01 = Speck48_72 [0x121110, 0x0A0908, 0x020100] (0x20796C, 0x6C6172) == (0xC049A5, 0x385ADC)\nt02 = Speck48_96 [0x1A1918, 0x121110, 0x0A0908, 0x020100] (0x6D2073, 0x696874) == (0x735E10, 0xB6445D)\nt03 = Speck64_96 [0x13121110, 0x0B0A0908, 0x03020100] (0x74614620, 0x736E6165) == (0x9F7952EC, 0x4175946C)\nt04 = Speck64_128 [0x1B1A1918, 0x13121110, 0x0B0A0908, 0x03020100] (0x3B726574, 0x7475432D) == (0x8C6FA548, 0x454E028B)\nt05 = Speck96_96 [0x0D0C0B0A0908, 0x050403020100] (0x65776F68202C, 0x656761737520) == (0x9E4D09AB7178, 0x62BDDE8F79AA)\nt06 = Speck96_144 [0x151413121110, 0x0D0C0B0A0908, 0x050403020100] (0x656D6974206E, 0x69202C726576) == (0x2BF31072228A, 0x7AE440252EE6)\nt07 = Speck128_128 [0x0F0E0D0C0B0A0908, 0x0706050403020100] (0x6C61766975716520, 0x7469206564616D20) == (0xA65D985179783265, 0x7860FEDF5C570D18)\nt08 = Speck128_192 [0x1716151413121110, 0x0F0E0D0C0B0A0908, 0x0706050403020100] (0x7261482066656968, 0x43206F7420746E65) == (0x1BE4CF3A13135566, 0xF9BC185DE03C1886)\nt09 = Speck128_256 [0x1F1E1D1C1B1A1918, 0x1716151413121110, 0x0F0E0D0C0B0A0908, 0x0706050403020100] (0x65736F6874206E49, 0x202E72656E6F6F70) == (0x4109010405C0F53E, 0x4EEEB48D9C188F43)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/TripleDES.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::TripleDES where\n\nimport Primitive::Symmetric::Cipher::Block::DES\n\nblockEncrypt : ([64],[64],[64],[64]) -> [64]\nblockEncrypt (k1,k2,k3,data) = result where\n    ex     = DES.encrypt k1 data\n    dx     = DES.decrypt k2 ex\n    result = DES.encrypt k3 dx\n\n\/\/ Test vectors from NIST 800-67\n\nKey1, Key2, Key3 : [64]\nKey1 = 0x0123456789ABCDEF\nKey2 = 0x23456789ABCDEF01\nKey3 = 0x456789ABCDEF0123\n\nP1, P2, P3 : [64]\nPlainText = \"The qufck brown fox jump\"\n\/\/ Yes, that's the correct phrase.. (see the 7th letter of the phrase).\n\/\/ It's supposed to be \"the quick...\" but they made a mistake in transcribing\n\/\/ the ASCII into hex.\n[P1, P2, P3] = split`{3} (join PlainText)\n\nC1, C2, C3 : [64]\nC1 = 0xA826FD8CE53B855F\nC2 = 0xCCE21C8112256FE6\nC3 = 0x68D5C05DD9B6B900\n\ntest_B1_1 = blockEncrypt (Key1, Key2, Key3, P1) == C1\ntest_B1_2 = blockEncrypt (Key1, Key2, Key3, P2) == C2\ntest_B1_3 = blockEncrypt (Key1, Key2, Key3, P3) == C3\n\nproperty testsPass = and [test_B1_1, test_B1_2, test_B1_3]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CBC.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC where\nimport Primitive::Symmetric::Cipher::Block::TripleDES\n\n\/\/ Test vectors from https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/TDES_CBC.pdf\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncbcTDesEnc : {n} (fin n) => k1 -> k2 -> k3->iv -> [n]block -> [n]block\ncbcTDesEnc k1 k2 k3 iv ps = cs\n    where cs = [ blockEncrypt (k1, k2, k3, (p ^ c')) | p <- ps | c' <- [iv] # cs ]\n\n\/\/ Number of blocks := 2\n\ntestKey ={ k1=0x0123456789ABCDEF, k2=0x23456789ABCDEF01, k3=0x456789ABCDEF0123,      iv=0xF69F2445DF4F9B17 }\ntestPt = [[0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]]\ntestCt = [[0x2079C3D53AA763E1, 0x93B79E2569AB5262, 0x516570481F25B50F, 0x73C0BDA85C8E0DA7]]\n\nproperty testPass = and [(cbcTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv ps) == cs\n                        | ps <- testPt | cs <- testCt]\n","variant":"hybrid","set":"supervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CBC.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::CBC where\n\n\/\/ set the sizes\ntype iv = [128]\ntype block = [128]\n\n\ncbcEnc : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncbcEnc enc k iv ps = cs\n    where cs = [ enc k (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbcDec : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncbcDec dec k iv cs = [ (dec k c) ^ c' | c <- cs | c' <- [iv] # cs ]\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AES_CBC.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::AES_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::CBC\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty cbcEncCorrect encrypt k c ps = (cbcDec encrypt k c (cbcEnc encrypt k c ps)) == ps\n\n\/\/ Test vectors from https:\/\/tools.ietf.org\/html\/rfc3602\n\n\/\/ No. of blocks := 1\n\ntestKey = [0x06a9214036b8a15b512e03d534120006]\ntestIv = [0x3dafba429d9eb430b422da802c9fac41]\ntestPt = [[join \"Single block msg\"]]\ntestCt = [[0xe353779c1079aeb82708942dbe77181a]]\n\nproperty testEncCbcPassB1 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey | iv <- testIv | ps <- testPt | cs <- testCt ]\n\n\/\/ No. of blocks := 2\n\ntestKey2 = [0xc286696d887c9aa0611bbb3e2025a45a]\ntestIv2 = [0x562e17996d093d28ddb3ba695a2e6f58]\ntestPt2 = [[0x000102030405060708090a0b0c0d0e0f, 0x101112131415161718191a1b1c1d1e1f]]\ntestCt2 = [[0xd296cd94c2cccf8a3a863028b5e1dc0a, 0x7586602d253cfff91b8266bea6d61ab1]]\n\nproperty testEncCbcPassB2 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey2 | iv <- testIv2 | ps <- testPt2 | cs <- testCt2 ]\n                                \n\n\/\/ No. of blocks := 3\n\ntestKey3 = [0x6c3ea0477630ce21a2ce334aa746c2cd]\ntestIv3 = [0xc782dc4c098c66cbd9cd27d825682c81]\ntestPt3 = [[0x5468697320697320612034382d627974, 0x65206d65737361676520286578616374, 0x6c7920332041455320626c6f636b7329]]\ntestCt3 = [[0xd0a02b3836451753d493665d33f0e886, 0x2dea54cdb293abc7506939276772f8d5, 0x021c19216bad525c8579695d83ba2684]]\n\nproperty testEncCbcPassB3 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey3 | iv <- testIv3 | ps <- testPt3 | cs <- testCt3 ]\n\n\/\/ No. of blocks := 4\n\ntestKey4 = [0x56e47a38c5598974bc46903dba290349]\ntestIv4 = [0x8ce82eefbea0da3c44699ed7db51b7d9]\ntestPt4 = [[0xa0a1a2a3a4a5a6a7a8a9aaabacadaeaf, 0xb0b1b2b3b4b5b6b7b8b9babbbcbdbebf, 0xc0c1c2c3c4c5c6c7c8c9cacbcccdcecf, 0xd0d1d2d3d4d5d6d7d8d9dadbdcdddedf]]\ntestCt4 = [[0xc30e32ffedc0774e6aff6af0869f71aa, 0x0f3af07a9a31a9c684db207eb0ef8e4e, 0x35907aa632c3ffdf868bb7b29d3d46ad, 0x83ce9f9a102ee99d49a53e87f4c3da55]]\n\nproperty testEncCbcPassB4 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey4 | iv <- testIv4 | ps <- testPt4 | cs <- testCt4 ]\n","variant":"hybrid","set":"supervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CTR.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::CTR where\n\n\/\/ set the sizes\ntype ic = [128]\ntype block = [128]\n\n\nctrEnc : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> ic -> [n]block -> [n]block\nctrEnc enc k c ps = cs\n    where cs = [(enc k c')^p | p <- ps | c' <- ctrs]\n          ctrs = [c+i | i<- [0...]]\n\nctrDec : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> ic -> [n]block -> [n]block\nctrDec enc k c cs = ps\n    where ps = [(enc k c')^ct | ct <- cs | c' <- ctrs]\n          ctrs = [c+i | i<- [0...]]\n\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CFB.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::TDES_CFB where\nimport Primitive::Symmetric::Cipher::Block::TripleDES\n\n\/\/ Test vectors from https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/TDES_CFB.pdf\n\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncfbTDesEnc : {n} (fin n) => k1 -> k2 -> k3->iv -> [n]block -> [n]block\ncfbTDesEnc k1 k2 k3 iv ps = cs\n    where cs = [ blockEncrypt (k1, k2, k3,  c')^p | p <- ps | c' <- [iv] # cs ]\n\n\/\/ Number of blocks := 4\n\ntestKey ={ k1=0x0123456789ABCDEF, k2=0x23456789ABCDEF01, k3=0x456789ABCDEF0123,      iv=0xF69F2445DF4F9B17 }\ntestPt = [[0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]]\ntestCt = [[0x078BB74E59CE7ED6, 0x7666DE9CF95EAF3F, 0xE9ED6BB460F45152, 0x8A5F9FE4ED710918]]\n\nproperty testPass = and [(cfbTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv ps) == cs\n                        | ps <- testPt | cs <- testCt]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AES_CTR.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::AES_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::CTR\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty ctrEncCorrect enc k c ps = (ctrDec enc k c (ctrEnc enc k c ps)) == ps\n\nk = 0x2b7e151628aed2a6abf7158809cf4f3c\nic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\nplaintext = [0x6bc1bee22e409f96e93d7e117393172a, 0xae2d8a571e03ac9c9eb76fac45af8e51, 0x30c81c46a35ce411e5fbc1191a0a52ef, 0xf69f2445df4f9b17ad2b417be66c3710]\nciphertext = [0x874d6191b620e3261bef6864990db6ce, 0x9806f66b7970fdff8617187bb9fffdff, 0x5ae4df3edbd5d35e5b4f09020db03eab, 0x1e031dda2fbe03d1792170a0f3009cee]\n\nproperty testPass = (ctrEnc encrypt k ic plaintext) == ciphertext\n\n","variant":"hybrid","set":"supervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CFB.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::CFB where\n\n\/\/ set the sizes\ntype iv = [128]\ntype block = [128]\n\n\ncfbEnc : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncfbEnc enc k iv ps = cs\n    where cs = [ (enc k c')^p | p <- ps | c' <- [iv] # cs ]\n\ncfbDec : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncfbDec enc k iv cs = [ (enc k c')^c | c <- cs | c' <- [iv] # cs ]\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AES_CFB.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Modes::AES_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::CFB\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty cfbEncCorrect encrypt k c ps = (cfbDec encrypt k c (cfbEnc encrypt k c ps)) == ps\n\n\/\/ Test vectors from https:\/\/nvlpubs.nist.gov\/nistpubs\/Legacy\/SP\/nistspecialpublication800-38a.pdf\n\/\/ No. of blocks := 1\n\ntestKey = [0x2b7e151628aed2a6abf7158809cf4f3c]\ntestIv = [0x000102030405060708090a0b0c0d0e0f]\ntestPt = [[0x6bc1bee22e409f96e93d7e117393172a]]\ntestCt = [[0x3b3fd92eb72dad20333449f8e83cfb4a]]\n\nproperty testEncCfbPassB1 = and [ (cfbEnc encrypt k iv ps) == cs\n                                | k <- testKey | iv <- testIv | ps <- testPt | cs <- testCt ]\n\n\/\/ No. of blocks := 2\n\ntestKey2 = [0x2b7e151628aed2a6abf7158809cf4f3c]\ntestIv2 = [0x000102030405060708090a0b0c0d0e0f]\ntestPt2 = [[0x6bc1bee22e409f96e93d7e117393172a, 0xae2d8a571e03ac9c9eb76fac45af8e51, 0x30c81c46a35ce411e5fbc1191a0a52ef, 0xf69f2445df4f9b17ad2b417be66c3710]]\ntestCt2 = [[0x3b3fd92eb72dad20333449f8e83cfb4a, 0xc8a64537a0b3a93fcde3cdad9f1ce58b, 0x26751f67a3cbb140b1808cf187a4f4df, 0xc04b05357c5d1c0eeac4c66f9ff7f2e6]]\n\nproperty testEncCfbPassB2 = and [ (cfbEnc encrypt k iv ps) == cs\n                                | k <- testKey2 | iv <- testIv2 | ps <- testPt2 | cs <- testCt2 ]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Tests\/TestAESKeyWrap.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::Tests::TestAESKeyWrap where\n\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Block::AESKeyWrap\n\n\/\/ This section contains tests of the Key Wrap specifications using test\n\/\/ vectors from Section 4 of RFC 3394.\n\n\/\/ 256-bit key encryption key (KEK) used to encrypt the key data\nKEK256 : [AESKeySize]\nKEK256 = 0x000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\n\n\/\/ 128-bit key data to encrypt\nKeyData128 : [16][8]\nKeyData128 = split 0x00112233445566778899AABBCCDDEEFF\n\n\/\/ Expected ciphertext from encrypting KeyData128 with KEK256\nCiphertext128_256 : [24][8]\nCiphertext128_256 = split 0x64E8C3F9CE0F5BA263E9777905818A2A93C8191E7D6E8AE7\n\n\/\/ Test wrapping and unwrapping of KeyData128 with KEK256 (Section 4.3)\nproperty testWrap128_256 = (aesWrapKey KEK256 DefaultIV KeyData128) == Ciphertext128_256\nproperty testUnwrap128_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext128_256) == (True, KeyData128)\n\n\/\/ 192-bit key data to encrypt\nKeyData192 : [24][8]\nKeyData192 = split 0x00112233445566778899AABBCCDDEEFF0001020304050607\n\n\/\/ Expected ciphertext from encrypting KeyData192 with KEK256\nCiphertext192_256 : [32][8]\nCiphertext192_256 = split 0xA8F9BC1612C68B3FF6E6F4FBE30E71E4769C8B80A32CB8958CD5D17D6B254DA1\n\n\/\/ Test wrapping and unwrapping of KeyData192 with KEK256 (Section 4.5)\nproperty testWrap192_256 = (aesWrapKey KEK256 DefaultIV KeyData192) == Ciphertext192_256\nproperty testUnwrap192_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext192_256) == (True, KeyData192)\n\n\/\/ 256-bit key data to encrypt\nKeyData256 : [32][8]\nKeyData256 = split 0x00112233445566778899AABBCCDDEEFF000102030405060708090A0B0C0D0E0F\n\n\/\/ Expected ciphertext from encrypting KeyData256 with KEK256\nCiphertext256_256 : [40][8]\nCiphertext256_256 = split 0x28C9F404C4B810F4CBCCB35CFB87F8263F5786E2D80ED326CBC7F0E71A99F43BFB988B9B7A02DD21\n\n\/\/ Test wrapping and unwrapping of KeyData256 with KEK256 (Section 4.6)\nproperty testWrap256_256 = (aesWrapKey KEK256 DefaultIV KeyData256) == Ciphertext256_256\nproperty testUnwrap256_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext256_256) == (True, KeyData256)\n\n\/*\n * The following tests come from the NIST Key Wrap Validation System (KWVS)\n * KW-AD-AES256 test vectors.\n *\/\n\n\/\/COUNT = 0\nKCount0 = 0x80aa997327a4806b6a7a41a52b86c3710386f932786ef79676fafb90b8263c5f\nPCount0 = split`{each=8} 0x0a256ba75cfa03aaa02ba94203f15baa\nCCount0 = split`{each=8} 0x423c960d8a2ac4c1d33d3d977bf0a91559f99c8acd293d43\nproperty Count0Wrap = (aesWrapKey KCount0 DefaultIV PCount0) == CCount0\nproperty Count0Unwrap = (aesUnwrapKey KCount0 DefaultIV CCount0) == (True, PCount0)\n\n\/\/COUNT = 1\nKCount1 = 0x2d104bc65c5f78e92993bd78b27d8e59a8a1f7c64b55b05be5df30f96ff04767\nCCount1 = split`{each=8} 0xe69fc01ea73e11bb4bc7485044145f824cfd535528b76517\nPCount1 = split`{each=8} 0xf8d46471445228d2ef399755360bdd6e\nproperty Count1Wrap = (aesWrapKey KCount1 DefaultIV PCount1) == CCount1\nproperty Count1Unwrap = (aesUnwrapKey KCount1 DefaultIV CCount1) == (True, PCount1)\n\n\/\/COUNT = 2\nKCount2 = 0xd963c8f1d3d2392629823fd1df3f644c8690f602c94e5d5818309d7c05e5427f\nCCount2 = split`{each=8} 0x177c6217f7fd6c94cbd4a9f512b1416c869328e3084e09ea\nPCount2 = split`{each=8} 0x451d0222ec29755d9c69165a5d109727\nproperty Count2Wrap = (aesWrapKey KCount2 DefaultIV PCount2) == CCount2\nproperty Count2Unwrap = (aesUnwrapKey KCount2 DefaultIV CCount2) == (True, PCount2)\n\n\/\/COUNT = 3\nKCount3 = 0xe594f0067cedb74e883e7746d29ba725c884c25375323f367cf49d17ad0f567b\nCCount3 = split`{each=8} 0x3b51ae2b0e3ddeed94efd7bfdc22630187e1f7624d15ed78\nPCount3 = split`{each=8} 0x587e3f6c75644bb5c3db9c74714f5556\nproperty Count3Wrap = (aesWrapKey KCount3 DefaultIV PCount3) == CCount3\nproperty Count3Unwrap = (aesUnwrapKey KCount3 DefaultIV CCount3) == (True, PCount3)\n\n\/\/COUNT = 4 (validation failure)\nKCount4 = 0x08c936b25b567a0aa679c29f201bf8b190327df0c2563e39cee061f149f4d91b\nCCount4 = split`{each=8} 0xe227eb8ae9d239ccd8928adec39c28810ca9b3dc1f366444\nproperty Count4Unwrap = (aesUnwrapKey KCount4 DefaultIV CCount4) == (False, zero)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/GF28.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::AES::GF28 where\n\ntype GF28 = [8]\n\n\/** The irreducable polynomial *\/\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\n\/** Sum up a bunch of GF28 values *\/\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\n\/** Multiply two GF28 values *\/\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y = pmod (pmult x y) irreducible\n\n\/** A GF28 value to a scalar power *\/\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k = pow k\n  where   sq x  = gf28Mult x x\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult n (sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\n\/** Compute the inverse of a value *\/\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow x 254\n\n\/** Dot product of two vectors *\/\ngf28DotProduct : {n} (fin n) => [n]GF28 -> [n]GF28 -> GF28\ngf28DotProduct xs ys = gf28Add [ gf28Mult x y | x <- xs | y <- ys ]\n\n\/** Multiply a matrix by a vector *\/\ngf28VectorMult : {n, m} (fin n) => [n]GF28 -> [m][n]GF28 -> [m]GF28\ngf28VectorMult v ms = [ gf28DotProduct v m | m <- ms ]\n\n\/** Multiply two matrices *\/\ngf28MatrixMult : {n, m, k} (fin m) => [n][m]GF28 -> [m][k]GF28 -> [n][k]GF28\ngf28MatrixMult xss yss = [ gf28VectorMult xs yss' | xs <- xss ]\n   where yss' = transpose yss\n\n\n","variant":"hybrid","set":"supervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Algorithm.cry","filetype":"cry","content":"\/\/ This is a fairly close implementation of the FIPS-197 standard:\n\/\/   http:\/\/csrc.nist.gov\/publications\/fips\/fips197\/fips-197.pdf\n\nmodule Primitive::Symmetric::Cipher::Block::AES::Algorithm where\n\nimport Primitive::Symmetric::Cipher::Block::AES::State (State, RoundKey, msgToState, stateToMsg)\nimport Primitive::Symmetric::Cipher::Block::AES::Round (AESFinalRound, AESFinalInvRound)\n\nparameter\n  \/** 0: AES128, 1: AES192, 2: AES256 *\/\n  type Mode : #\n\n  type constraint (2 >= Mode)\n\n  encRound     : RoundKey -> State -> State\n  decRound     : RoundKey -> State -> State\n\n\n\/** Number of 32 bit words in the key *\/\ntype Nk = 4 + 2 * Mode\n\n\/** Number of rounds *\/\ntype Nr = 6 + Nk\n\n\/** Key size in bits *\/\ntype AESKeySize  = 32 * Nk\n\n\/** The keys for all the rounds *\/\ntype KeySchedule = (RoundKey, [Nr-1]RoundKey, RoundKey)\n\n\/** AES Encryption with an expanded key.\nThis is useful if many things will be encrypted with the same key. *\/\nencrypt : KeySchedule -> [128] -> [128]\nencrypt (kInit,ks,kFinal) pt =\n                            stateToMsg (AESFinalRound kFinal (rounds ! 0))\n  where\n  state0 = kInit ^ msgToState pt\n  rounds = [state0] # [ encRound rk s | rk <- ks | s <- rounds ]\n\n\/** AES decryption with an expanded key.\nThis is useful if many things will be decrypted with the same key. *\/\ndecrypt : KeySchedule -> [128] -> [128]\ndecrypt (kInit, ks, kFinal) ct =\n                          stateToMsg (AESFinalInvRound kFinal (rounds ! 0))\n  where\n  state0 = kInit ^ msgToState ct\n  rounds = [state0] # [ decRound rk s | rk <- ks | s <- rounds ]\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/SBox.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::AES::SBox where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::SubBytePlain\n\ntype SBox = [256] GF28\n\nsbox : SBox\nsbox = [ SubByte x | x <- [0 .. 255] ]\n\nsboxInv : SBox\nsboxInv = [ InvSubByte x | x <- [0 .. 255] ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/ExpandKey.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::AES::ExpandKey where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SubByteSBox\n\nparameter\n  \/** Number of 32 bit words in the key *\/\n  type Nk : #\n  type constraint (8 >= width Nk, Nk >= 1)\n\n  \/** Number of rounds *\/\n  type Nr : #\n  type constraint (8 >= width Nr, Nr >= 2)\n\nexpandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)\nexpandKey key = ( keys @ 0\n                , keys @@ ([1 .. (Nr - 1)] : [_][8])\n                , keys @ (`Nr : [8])\n                )\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = expandKeyForever seed\n\n\nexpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nexpandKeyForever seed = [ transpose g | g <- split (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord i prev old\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\n\/\/ Key expansion\nRcon : [8] -> [4]GF28\nRcon i = [ gf28Pow <| x |> (i-1), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nNextWord : [8] ->[4][8] -> [4][8] -> [4][8]\nNextWord i prev old = old ^ mask\n   where mask = if i % nk == 0\n                then SubWord (RotWord(prev)) ^ Rcon (i \/ `Nk)\n                else if (nk > 6) && (i % nk == 4)\n                     then SubWord prev\n                     else prev\n\n         nk = `Nk : [8]\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/SubByteSBox.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::AES::SubByteSBox where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::SBox\n\nSubByte : GF28 -> GF28\nSubByte b = sbox @ b\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = sboxInv @ b\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Round.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::AES::Round where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SubByteSBox\n\n\/** One round of AES *\/\nAESRound : RoundKey -> State -> State\nAESRound rk s = rk ^ MixColumns (ShiftRows (SubBytes s))\n\nSubBytes : State -> State\nSubBytes state = [ [ SubByte b | b <- row ] | row <- state ]\n\nShiftRows : State -> State\nShiftRows state = [ row <<< i | row <- state | i : [2] <- [0 .. 3] ]\n\nMixColumns : State -> State\nMixColumns state = gf28MatrixMult m state\n    where m = [ [2,3,1,1] >>> i | i <- [0 .. 3] ]\n\n\/** The final AES round *\/\nAESFinalRound : RoundKey -> State -> State\nAESFinalRound rk s = rk ^ ShiftRows (SubBytes s)\n\n\n\n\/** One inverse round of AES *\/\nAESInvRound : RoundKey -> State -> State\nAESInvRound rk s = InvMixColumns (rk ^ InvSubBytes (InvShiftRows s))\n\nInvSubBytes : State -> State\nInvSubBytes state = [ [ InvSubByte b | b <- row ] | row <- state ]\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> shiftAmount | row <- state\n                                           | shiftAmount : [2] <- [0 .. 3]\n                     ]\n\nInvMixColumns : State -> State\nInvMixColumns state = gf28MatrixMult m state\n    where m = [[0x0e, 0x0b, 0x0d, 0x09] >>> i | i <- [0 .. 3] ]\n\n\/** The final inverted AES round *\/\nAESFinalInvRound : RoundKey -> State -> State\nAESFinalInvRound rk s = rk ^ InvSubBytes (InvShiftRows s)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/SubBytePlain.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::AES::SubBytePlain where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\n\n\/\/ The SubBytes transform and its inverse\nSubByte : GF28 -> GF28\nSubByte b = xformByte (gf28Inverse b)\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = gf28Inverse (xformByte' b)\n\n\n\/\/ The affine transform and its inverse\nxformByte : GF28 -> GF28\nxformByte b = gf28Add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n   where c = 0x63\n\nxformByte' : GF28 -> GF28\nxformByte' b = gf28Add [(b >>> 2), (b >>> 5), (b >>> 7), d] where d = 0x05\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/TBox.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::AES::TBox where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SBox\nimport Primitive::Symmetric::Cipher::Block::AES::Round\n\n\nAESRound    rk st = genRound ShiftRows    tbox    rk st\n\/\/ AESInvRound rk st = genRound InvShiftRows tboxInv (InvMixColumns rk) st\nAESInvRound rk st = genRound InvShiftRows tboxInv rk st\n\n\nmakeDecKey (a,xs,b) = (b, [ InvMixColumns rk | rk <- reverse xs ], a)\n\ngenRound : (State -> State) -> TBox -> RoundKey -> State -> State\ngenRound shift boxes rk st =\n  rk ^ transpose [ add [ box @ i | box <- boxes | i <- col ]\n                 | col <- transpose (shift st) ]\n  where add [ a, b, c, d ] = a ^ b ^ c ^ d\n\n\n\n\/\/ Computing the TBoxes\ntype TBox = [4][256][4]GF28\n\ntbox : TBox\ntbox = mkTBox [ 0x02, 0x01, 0x01, 0x03 ] sbox\n\ntboxInv : TBox\ntboxInv = mkTBox [ 0x0e, 0x09, 0x0d, 0x0b ] sboxInv\n\nmkTBox : [4]GF28 -> SBox -> TBox\nmkTBox seed box = [ [ a >>> i | a <- t0 ] | i <- [0 .. 3] ]\n  where\n  t0 = [ [ gf28Mult c s | c <- seed ] | s <- box ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/State.cry","filetype":"cry","content":"module Primitive::Symmetric::Cipher::Block::AES::State where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\n\ntype State       = [4][Nb]GF28\ntype Nb          = 4\ntype RoundKey    = State\n\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Hash\/HMAC.cry","filetype":"cry","content":"\/*\n * This is a simple implementation of HMAC with SHA-384\n *\/\n\nmodule Primitive::Keyless::Hash::HMAC where\n\nimport Primitive::Keyless::Hash::SHA384\n\n\/\/ Pad or hash `key`, depending on its length, until it is 128 bytes long\nkey_init : {key_size} (fin key_size) => [key_size][8] -> [128][8]\nkey_init key =\n  take`{128} (if `key_size <= 128\n              then key # (zero : [inf][8])\n              else (split`{48} (SHAImp key)) # (zero : [inf][8]))\n\ntype HMACState = { i_ctx  : SHAState\n                 , o_ctx  : SHAState\n                 , md_ctx : SHAState\n                 }\n\n\/\/ HMAC-SHA384 init function\nHMACInit : {key_size} (fin key_size) => [key_size][8] -> HMACState\nHMACInit key =\n  { i_ctx  = i_state\n  , o_ctx  = SHAUpdate SHAInit opad\n  , md_ctx = i_state\n  }\n  where key'    = key_init key\n        ipad    = [ k ^ 0x36 | k <- key' ]\n        opad    = [ k ^ 0x5c | k <- key' ]\n        i_state = SHAUpdate SHAInit ipad\n\n\/\/ HMAC-SHA384 update function\nHMACUpdate : {n} (fin n) => HMACState -> [n][8] -> HMACState\nHMACUpdate state data = { i_ctx = state.i_ctx\n                        , o_ctx = state.o_ctx\n                        , md_ctx = SHAUpdate state.md_ctx data\n                        }\n\n\/\/ HMAC-SHA384 final function\nHMACFinal : HMACState -> [48][8]\nHMACFinal state = split`{48} (SHAFinal o_ctx')\n  where o_ctx' = SHAUpdate state.o_ctx buf\n        buf = split`{48} (SHAFinal state.md_ctx)\n\n\/\/ HMAC-SHA384 implementation\nHMAC : {n, m} (fin n, fin m) => [n][8] -> [m][8] -> [48][8]\nHMAC key data = HMACFinal (HMACUpdate (HMACInit key) data)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Hash\/SHA1.cry","filetype":"cry","content":"module Primitive::Keyless::Hash::SHA1 where\n\nsha1 : {n} (width (8*n) <= 64) => [n][8] -> [160]\nsha1 msg = sha1' pmsg\n    where\n        pmsg = pad(join(msg))\n\nsha1' : {chunks} (fin chunks) => [chunks][512] -> [160]\nsha1' pmsg = join (Hs!0)\n  where\n    Hs = [[0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]] #\n         [ block(H, split(M))\n         | H <- Hs\n         | M <- pmsg\n         ]\n\n\/*\nAs a summary, a \"1\" followed by m \"0\"s followed by a 64-\n   bit integer are appended to the end of the message to produce a\n   padded message of length 512 * n.  The 64-bit integer is the length\n   of the original message.  The padded message is then processed by the\n   SHA-1 as n 512-bit blocks.\n*\/\n\npad : {msgLen}\n     ( fin msgLen\n     , 64 >= width msgLen                             \/\/ message width fits in a word\n     )\n     => [msgLen] -> [(msgLen + 65) \/^ 512][512]\npad msg = split (msg # [True] # (zero:[padLen]) # (`msgLen:[64]))\n    where type padLen     = (msgLen + 65) %^ 512\n\nf : ([8], [32], [32], [32]) -> [32]\nf (t, x, y, z) =\n       if (0 <= t)  \/\\ (t <= 19) then (x && y) ^ (~x && z)\n        | (20 <= t) \/\\ (t <= 39) then x ^ y ^ z\n        | (40 <= t) \/\\ (t <= 59) then (x && y) ^ (x && z) ^ (y && z)\n        | (60 <= t) \/\\ (t <= 79) then x ^ y ^ z\n        else error \"f: t out of range\"\n\nKs : [80][32]\nKs = [ 0x5a827999 | t <- [0..19]  ]\n   # [ 0x6ed9eba1 | t <- [20..39] ]\n   # [ 0x8f1bbcdc | t <- [40..59] ]\n   # [ 0xca62c1d6 | t <- [60..79] ]\n\nblock : ([5][32], [16][32]) -> [5][32]\nblock ([H0, H1, H2, H3, H4], M) =\n [(H0+As@80), (H1+Bs@80), (H2+Cs@80), (H3+Ds@80), (H4+Es@80)]\n  where\n    Ws : [80][32]\n    Ws = M # [ (W3 ^ W8 ^ W14 ^ W16) <<< 1\n             | W16 <- drop`{16 - 16} Ws\n             | W14 <- drop`{16 - 14} Ws\n             | W8  <- drop`{16 - 8}  Ws\n             | W3  <- drop`{16 - 3}  Ws\n             | t <- [16..79]\n             ]\n    As = [H0] # TEMP\n    Bs = [H1] # As\n    Cs = [H2] # [ B <<< 30 | B <- Bs ]\n    Ds = [H3] # Cs\n    Es = [H4] # Ds\n    TEMP : [80][32]\n    TEMP = [ (A <<< 5) + f(t, B, C, D) + E + W + K\n           | A <- As | B <- Bs | C <- Cs | D <- Ds | E <- Es\n           | W <- Ws | K <- Ks\n           | t <- [0..79]\n           ]\n\n\nt0 = sha1 \"\" == 0xda39a3ee5e6b4b0d3255bfef95601890afd80709\n\n\/\/ Sample messages and their digests from FIPS180-1 appendix.\n\nt1 = sha1 \"abc\" == 0xA9993E364706816ABA3E25717850C26C9CD0D89D\nt2 = sha1 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\" ==\n     0x84983E441C3BD26EBAAE4AA1F95129E5E54670F1\nt3 = sha1 [ 'a' | i <- [1..1000000] ] ==\n     0x34AA973CD4C4DAA4F61EEB2BDBAD27316534016F\n\nproperty testsPass = and [t0, t1, t2, t3]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Hash\/MD5.cry","filetype":"cry","content":"module Primitive::Keyless::Hash::MD5 where\n\n\/\/ Swap byte order from network to host order (long word)\nntohl : [32] -> [32]\nntohl w = join (reverse (groupBy`{8} w))\n\n\/\/ Swap byte order from host to network order (long word)\nhtonl : [32] -> [32]\nhtonl w = join (reverse (groupBy`{8} w))\n\n\/\/ Swap byte order from host to network order (long long word)\nhtonll : [64] -> [64]\nhtonll w = join (reverse (groupBy`{8} w))\n\n\/\/ apply a function to every element of a sequence\nmap : {n, a, b} (a -> b) -> [n]a -> [n]b\nmap f xs = [ f x | x <- xs ]\n\n\/\/ fold with left associativity\nfoldl : {n, a, b} (fin n) => a -> (a -> b -> a) -> [n]b -> a\nfoldl seed f xs = res ! 0\n  where res = [seed] # [ f a x | a <- res\n                               | x <- xs\n                       ]\n\n\/\/ Test driver.  Given a sequence of bytes, calculate the MD5 sum.\ntest s = md5 (join s)\n\n\/\/ Reference implementation of MD5 on exactly 16 bytes.\n\nmd5_ref : [16][8] -> [16][8]\nmd5_ref msg = map reverse (groupBy`{8} (md5 (join (map reverse msg))))\n\nmd5_ref' : [128] -> [128]\nmd5_ref' msg = join (md5_ref (groupBy`{8} msg))\n\n\n\n\/\/ The state of the MD5 algorithm after each 512 bit block\n\/\/ consists of 4 32-bit words.\ntype MD5State = ([32],[32],[32],[32])\n\n\/\/ Main MD5 algorithm.\n\/\/\n\/\/ First, pad the message to a multiple of 512 bits.\n\/\/ Next, initialize the MD5 state using the fixed values from the RFC.\n\/\/ Then, process each message block in turn by computing\n\/\/ the MD5 rounds using the message block.  Add the result\n\/\/ of the final round to the current MD5 state.\n\/\/ Finally, return the current MD5 state after all blocks are processed,\n\/\/ interpreting the 4 32-bit words as a single 128-bit sequence.\n\nmd5 : {a} (64 >= width a) => [a] -> [128]\nmd5 msg = md5output finalState\n    where\n      type p = (a + 65) %^ 512\n      type b = (a + 65) \/^ 512\n\n      finalState : MD5State\n      finalState = foldl initialMD5State processBlock blocks\n\n      blocks : [b][512]\n      blocks = groupBy`{512} (pad `{a,p} msg)\n\n      add : MD5State -> MD5State -> MD5State\n      add (a, b, c, d) (e, f, g, h) = (a + e, b + f, c + g, d + h)\n\n      processBlock : MD5State -> [512] -> MD5State\n      processBlock st blk = add st (computeRounds (decodeBlock blk) st)\n\n\n\/\/ Initial seed for the digest rounds\n\/\/\n\/\/ See RFC 1321, section 3.3\n\ninitialMD5State : MD5State\ninitialMD5State = (A, B, C, D)\n where\n   f x = ntohl (join x)\n   A = f [ 0x01, 0x23, 0x45, 0x67 ]\n   B = f [ 0x89, 0xAB, 0xCD, 0xEF ]\n   C = f [ 0xFE, 0xDC, 0xBA, 0x98 ]\n   D = f [ 0x76, 0x54, 0x32, 0x10 ]\n\n\n\/\/ Each MD5 message block 512 bits long, interpreted as a sequence of 16 32-bit words\n\/\/ Each word is given as a sequence of 4 bytes, with LEAST significant byte first\n\/\/ Each byte is given as a sequence of 8 bits, with MOST significant bit first\n\/\/\n\/\/ The output of the algorithm is a sequence of 4 words, interpreted as above\n\/\/\n\/\/ See RFC 1321, section 2\n\ndecodeBlock : [512] -> [16][32]\ndecodeBlock s = map ntohl (groupBy`{32} s)\n\n\n\/\/ Interpret 4 32-bit words as a single 128-bit sequence\n\/\/\n\/\/ See RFC 1321 section 3.5\n\nmd5output : MD5State -> [128]\nmd5output (a,b,c,d) = htonl a # htonl b # htonl c # htonl d\n\n\n\n\/\/ Given an arbitrary byte sequence whose length can be described\n\/\/ by a 64-bit number, pad the message so it is exactly a multiple of 512.\n\/\/\n\/\/ This is done by adding a single 1 bit to the end of the message, and\n\/\/ then adding enough zero bits to make the whole message 64 bits shorter\n\/\/ than a multiple of 512.  The size (in bits) of the original message is\n\/\/ then appended to complete the padded message.\n\/\/\n\/\/ See RFC 1321, sections 3.1 and 3.2\n\npad : {a, p} (fin p, 64 >= width a) => [a] -> [65 + (a + p)]\npad msg =\n    msg # [True] # zero # htonll sz\n    where\n      sz : [64]\n      sz = length msg\n\n\n\n\/\/ Given a message block (interpreted as 16 32-bit words) and a current MD5 state\n\/\/ (as 4 32-bit words) compute the values of all the rounds of the MD5 algorithm.\n\/\/\n\/\/ In the main MD5 function, the final round will be used to compute the next MD5 state.\n\/\/\n\/\/ See RFC 1321, section 3.4\n\ncomputeRounds : [16][32] -> MD5State -> MD5State\ncomputeRounds msg st = rounds (msg,st) @ 64\n\nrounds : ([16][32], MD5State) -> [65]MD5State\nrounds (msg, (a0, b0, c0, d0)) =\n    [ (a, b, c, d) | a <- as\n                   | b <- bs\n                   | c <- cs\n                   | d <- ds\n    ]\n    where\n      bs =\n          [b0] #\n          [box (i, a, b, c, d, m, t, s) | i <- [0 .. 63]\n                                        | a <- as\n                                        | b <- bs\n                                        | c <- cs\n                                        | d <- ds\n                                        | m <- join [m @@ p | m <- [msg, msg, msg, msg]\n                                                            | p <- permutes\n                                                    ]\n                                        | t <- sineTbl\n                                        | s <- s_constants\n          ]\n      cs = [c0] # bs\n      ds = [d0] # cs\n      as = [a0] # ds\n\n\n\/\/ 'S' constants from the MD5 algorithm, used to indicated how many\n\/\/ bits to rotate in the box function.\n\/\/\n\/\/ See RFC 1321, section 3.4, and the appendix on page 10\n\ns_constants : [64][6]\ns_constants =\n   repeat4 [7, 12, 17, 22] #\n   repeat4 [5,  9, 14, 20] #\n   repeat4 [4, 11, 16, 23] #\n   repeat4 [6, 10, 15, 21]\n where\n   repeat4 abcd = abcd # abcd # abcd # abcd\n\n\n\/\/ This table of permutations indicates which word of the message block to\n\/\/ use in a given MD5 round.  Its structure is most evident via observing\n\/\/ the indices of the message block in the order they are used in the MD5\n\/\/ reference implementation.\n\/\/\n\/\/ See the appendix of RFC 1321, starting on page 13.\n\npermutes : [4][16][4]\npermutes =\n    [ [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15]\n    , [ 1,  6, 11,  0,  5, 10, 15,  4,  9, 14,  3,  8, 13,  2,  7, 12]\n    , [ 5,  8, 11, 14,  1,  4,  7, 10, 13,  0,  3,  6,  9, 12, 15,  2]\n    , [ 0,  7, 14,  5, 12,  3, 10,  1,  8, 15,  6, 13,  4, 11,  2,  9]\n    ]\n\n\n\/\/ The main \"box\" operation.  The first argument indicates\n\/\/ the round number, which is used to select between the box\n\/\/ operations, F, G, H, and I.\n\/\/\n\/\/ See RFC 1321, section 3.4\n\nbox : ([6], [32], [32], [32], [32], [32], [32], [6]) -> [32]\nbox (i, a, b, c, d, m, t, s) =\n    b + (a + boxfunc (i, b, c, d) + m + t <<< s)\n\nboxfunc : ([6],[32],[32],[32]) -> [32]\nboxfunc (i, b, c, d) =\n    if i < 16 then F (b, c, d) else\n    if i < 32 then G (b, c, d) else\n    if i < 48 then H (b, c, d) else\n                   I (b, c, d)\n\nF : ([32], [32], [32]) -> [32]\nF (x, y, z) = x && y || (~x) && z\n\nG : ([32], [32], [32]) -> [32]\nG (x, y, z) = x && z || y && ~z\n\nH : ([32], [32], [32]) -> [32]\nH (x, y, z) = x ^ y ^ z\n\nI : ([32], [32], [32]) -> [32]\nI (x, y, z) = y ^ (x || ~z)\n\n\n\/\/ The table of values generated from the sin function, as described\n\/\/ in RFC 1321, section 3.4.  These values are transcribed from\n\/\/ the appendix, starting on page 13.\n\nsineTbl : [64][32]\nsineTbl =\n    [0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE, 0xF57C0FAF,\n     0x4787C62A, 0xA8304613, 0xFD469501, 0x698098D8, 0x8B44F7AF,\n     0xFFFF5BB1, 0x895CD7BE, 0x6B901122, 0xFD987193, 0xA679438E,\n     0x49B40821, 0xF61E2562, 0xC040B340, 0x265E5A51, 0xE9B6C7AA,\n     0xD62F105D, 0x02441453, 0xD8A1E681, 0xE7D3FBC8, 0x21E1CDE6,\n     0xC33707D6, 0xF4D50D87, 0x455A14ED, 0xA9E3E905, 0xFCEFA3F8,\n     0x676F02D9, 0x8D2A4C8A, 0xFFFA3942, 0x8771F681, 0x6D9D6122,\n     0xFDE5380C, 0xA4BEEA44, 0x4BDECFA9, 0xF6BB4B60, 0xBEBFBC70,\n     0x289B7EC6, 0xEAA127FA, 0xD4EF3085, 0x04881D05, 0xD9D4D039,\n     0xE6DB99E5, 0x1FA27CF8, 0xC4AC5665, 0xF4292244, 0x432AFF97,\n     0xAB9423A7, 0xFC93A039, 0x655B59C3, 0x8F0CCC92, 0xFFEFF47D,\n     0x85845DD1, 0x6FA87E4F, 0xFE2CE6E0, 0xA3014314, 0x4E0811A1,\n     0xF7537E82, 0xBD3AF235, 0x2AD7D2BB, 0xEB86D391]\n\n\n\/\/ The MD5 test suite from RFC 1321, appendix A.5\n\nr0 = test \"\"\n  == 0xd41d8cd98f00b204e9800998ecf8427e\n\nr1 = test \"a\"\n  == 0x0cc175b9c0f1b6a831c399e269772661\n\nr2 = test \"abc\"\n  == 0x900150983cd24fb0d6963f7d28e17f72\n\nr3 = test \"message digest\"\n  == 0xf96b697d7cb7938d525a2f31aaf161d0\n\nr4 = test \"abcdefghijklmnopqrstuvwxyz\"\n  == 0xc3fcd3d76192e4007dfb496cca67e13b\n\nr5 = test \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n  == 0xd174ab98d277d9f5a5611c2c9f419d9f\n\nr6 = test \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n  == 0x57edf4a22be3c955ac49da2e2107b67a\n\nr7 = test \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n  == 0x8215ef0796a20bcaaae116d3876c664a\n\nr8 = test (join (repeat`{1000000} \"a\") )\n  == 0x7707d6ae4e027c70eea2a935c2296f21\n\nproperty testsPass = and [ r0, r1, r2, r3, r4, r5, r6, r7, r8 ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Generator\/DRBG.cry","filetype":"cry","content":"module Primitive::Keyless::Generator::DRBG where\n\nimport Primitive::Symmetric::Cipher::Block::AES\n\ntype keylen   = AESKeySize type blocklen = 128 type seedlen  = 256 \/\/ bits, 256 bits fixed by table 3 for AES-128\ntype reseed_limit = 2 ^^ 35 \/\/ max number of bytes to generate before reseeding\n\ntype blocksize = 16 \/\/ blocklen \/ 8\ntype keysize = 32 \/\/ keylen \/ 8\ntype seedsize = 48\n\ntype cipher_ctx = { key : [keylen] }\n\nblock_encrypt : [keylen] -> [blocklen] -> [blocklen]\nblock_encrypt key data = aesEncrypt(data, key)\n\ntype s2n_drbg =\n  { bytes_used : [64]\n  , ctx : cipher_ctx\n  , v : [blocklen]\n  }\n\ndrbg_generate_internal : {n, blocks}\n                         ( fin n, fin blocks, n >= 1, n <= 8192\n                         , n == blocklen * blocks)\n                      => s2n_drbg\n                      -> ([n], s2n_drbg)\ndrbg_generate_internal drbg =\n  (join [ block_encrypt drbg.ctx.key (drbg.v + i) | i <- [1 .. blocks]], drbg')\n    where drbg' = { bytes_used = drbg.bytes_used + `(blocks * blocksize)\n                  , ctx = drbg.ctx\n                  , v = drbg.v + `blocks\n                  }\n\ndrbg_instantiate : {ps_size}\n                   (fin ps_size)\n                => [seedlen]\n                -> [ps_size]\n                -> s2n_drbg\ndrbg_instantiate entropy ps = drbg_reseed zero entropy ps'\n  where\n    \/* pad ps with zeros if needed to reach seedlen\n       otherwise truncate to seedlen *\/\n    ps' = take `{seedlen} (ps # (zero : [seedlen]))\n\n\/* Should bytes used be reset before the update? s2n doesn't\n   it seems like the NIST spec counts that update as the first\n\n   we limit ps_size to a maximum of seedlen because this is an\n   implementation specific choice made by s2n*\/\ndrbg_reseed : {ps_size}\n              (ps_size <= seedlen)\n           => s2n_drbg\n           -> [seedlen]\n           -> [ps_size]\n\t   -> s2n_drbg\ndrbg_reseed drbg entropy ps = drbg''\n  where\n    drbg' = drbg_update (entropy ^ (ps # zero)) drbg\n    drbg'' = { v = drbg'.v, ctx = drbg'.ctx, bytes_used = 0}\n\ndrbg_uninstantiate : s2n_drbg -> s2n_drbg\ndrbg_uninstantiate drbg = zero\n\n\/* This is the spec of the s2n code, in that it reseeds automatically\n   if reseed is required. This is in opposition to the spec, which\n   requires an error code.\n\n   We are curious about why s2n_drbg counts a number of bytes used,\n   while the spec tracks a number of calls to generate. We don't\n   belive that this is buggy behavior, since if we call the maximum\n   size with generate each time, we will reseed before the spec would\n   require it. *\/\ndrbg_generate : {n, blocks} (fin n, fin blocks, n >= 1, n <= 8192,\n                             blocks * blocklen >= n,\n                             (blocks - 1) * blocklen <= n - 1) =>\n                s2n_drbg -> [seedlen] -> Bit ->\n                ([n], s2n_drbg)\ndrbg_generate drbg entropy reseed_p = (take enc_result, drbg_out)\n  where\n    \/\/ Re-seed if we have exceeded the limit, or if reseed_p is set\n    drbg_r =\n      if reseed_p \\\/ drbg.bytes_used + `n * 8 + `blocklen * 8 >= `reseed_limit then\n        drbg_reseed drbg entropy (zero : [256])\n      else drbg\n    \/\/ Encrypt v+1, v+2, ..., v + ceil (n \/ blocklen)\n    (enc_result, drbg_v) = drbg_generate_internal `{blocks=blocks} drbg_r\n    \/\/ Update the drbg state\n    drbg_out = drbg_update zero drbg_v\n\n\/* What is ctr_len? We think it is >= blocklen, so\n   we go to the else branch of 2.1 every time *\/\ndrbg_update : [seedlen] -> s2n_drbg -> s2n_drbg\ndrbg_update data drbg = result\n  where\n    \/\/ NOTE: blocklen * seedlen \/ blocklen is seedlen in our case, but might be\n    \/\/ different if seedlen isn't a multiple of blocklen\n    type blocks = (seedlen + blocklen -1)\/blocklen\n    \/\/ Encrypt v+1, v+2, ..., v + ceil (seedlen \/ blocklen)\n    (enc_result, _) = drbg_generate_internal `{blocks=blocks} drbg\n    \/\/ XOR the additional input data with the first bits of enc_result\n    data_xor = (take enc_result) ^ data\n    \/\/ Return the first half of data_xor as the new key, and the last half of it\n    \/\/ as the new value for v\n    result = { bytes_used = drbg.bytes_used + (`blocks * `blocksize)\n             , ctx = { key = take data_xor }\n             , v = drop data_xor\n             }\n\n\n\/* Example test vectors from\n\n   https:\/\/csrc.nist.gov\/Projects\/Cryptographic-Algorithm-Validation-Program\/Random-Number-Generators\n\n   for CTR_DRBG.\n*\/\n\n\/* [AES-128 no df]\n   [PredictionResistance = False]\n   [EntropyInputLen = 256]\n   [NonceLen = 0]\n   [PersonalizationStringLen = 0]\n   [AdditionalInputLen = 0]\n   [ReturnedBitsLen = 512] <- value of type parameter n\n*\/\n\n\n\ntestInstantiate0 = {entropy = 0xed1e7f21ef66ea5d8e2a85b9337245445b71d6393a4eecb0e63c193d0f72f9a9,\n                    pString = zero : [0],\n                        Key = 0xb5fc83ef1518da3cb85598ee9795001e,\n                         \tV = 0x58f90cf75af84f221514db847ec007d1}\n\ntestInstantiatedrbg0 = drbg_instantiate`{ps_size=0} testInstantiate0.entropy testInstantiate0.pString\n\ntestInstantiate0Pass = testInstantiatedrbg0.v == testInstantiate0.V \/\\ testInstantiatedrbg0.ctx.key == testInstantiate0.Key\n\ntestReseed0 = {entropyReseed = 0x303fb519f0a4e17d6df0b6426aa0ecb2a36079bd48be47ad2a8dbfe48da3efad,\n            \t           Key = 0x577a79cc512258c3e255fcf3f4cf0c1a,\n                        \t V = 0x531599fd616f33678192928bf771bb2b}\n\ntestReseed0Pass = drbgreseed.v == testReseed0.V \/\\ drbgreseed.ctx.key == testReseed0.Key\n                where drbgreseed = drbg_reseed`{ps_size=0} testInstantiatedrbg0 testReseed0.entropyReseed zero\n\ntestGenerate0 = {\tKey = 0xac373fb3773597b0d6cb6f37e6b59293,\n                \tV   = 0xcd9bf115d35c60cbf7f2ebac8e43f53b}\n\ntestGeneratedrbg0 = (drbg_generate`{n=512} testInstantiatedrbg0 testReseed0.entropyReseed True).1\n\ntestGenerate0Pass = testGeneratedrbg0.v == testGenerate0.V \/\\ testGeneratedrbg0.ctx.key == testGenerate0.Key\n\ntestGenerateSnd0 = {returnedBits = 0xf80111d08e874672f32f42997133a5210f7a9375e22cea70587f9cfafebe0f6a6aa2eb68e7dd9164536d53fa020fcab20f54caddfab7d6d91e5ffec1dfd8deaa,\n                 \tKey = 0x964c57946a104aa93fc3c2137bb9bc11,\n                 \tV   = 0x9d58008033ac007c9ead254bfa8de2b6}\n\ntestGenerateSnd0Pass = and [ result == testGenerateSnd0.returnedBits\n                           , drbg.ctx.key == testGenerateSnd0.Key\n                           , drbg.v == testGenerateSnd0.V ]\n                     where (result,drbg) = drbg_generate`{n=512} testGeneratedrbg0 zero False\n\n\nproperty testsPass = and [testInstantiate0Pass, testReseed0Pass, testGenerate0Pass, testGenerateSnd0Pass]","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DilithiumR1BV.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::DilithiumR1BV where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Common::mod_arith\nimport Primitive::Asymmetric::Cipher::RSA\nimport Primitive::Asymmetric::Signature::testDilithium\n\n\n\/\/ These parameters are fixed for all four recommended implementations\ntype qbits = 23\ntype q = 0x7fe001 type n = 0x100 d = 0xe\nwc= 0x3c gamma1 = ((`q) - 1) \/ 16:[qbits]\ngamma2 = ( gamma1 \/ 2 ):[qbits]\nalpha = (2*gamma2):[qbits]\n\n\/\/ Parameters for Number Theoretic Transform (NTT)\nrootOfUnity    = 1753 :[qbits]\nrootOfUnityInv = 731434 : [qbits]\nninv           = 8347681 : [qbits]\n\n\/\/ Parameterize the types based on the following implemenations\n\/* Weak, Medium, Recommended, and VeryHigh*\/\nparameter\n    type k : #\n    type constraint (fin k, k>=3, k<=6)\n    type l : #\n    type constraint (fin l, l>=2, l<=5)\n    eta : [4]\n    beta : [qbits]\n    omega : [qbits]\n\n\/\/ Integer polynomials; a superset of ring R referenced in specification\ntype intPoly        = [n][qbits]\ntype intPolyVec dim = [dim]intPoly\n\n\/\/ Polynomials; a superset of ring R_q referenced in specification\ntype poly        = [n][qbits] \/\/ This is R_q, actually defines a super set of R_q\ntype polyVec dim = [dim]poly\n\n\/\/ Polynomials in NTT representation\ntype nttPoly          = [n][qbits]\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k}\ntype SecretKey = {rho : [256]\n                    , K  : [256]\n                    , tr : [384]\n                    , s1 : polyVec l\n                    , s2 : polyVec k\n                    , t0 : intPolyVec k}\ntype SEEDBYTES = 32\n\n\/* Generate public and private keys *\/\n\/\/Gen : [SEEDBYTES*8] -> (PublicKey,SecretKey)\nGen seed = (pk, sk)\n    where\n      randoms = split`{3} (join (SHA3::toBytes (take`{768} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))\n      (rho, rho', K) = (randoms@0, randoms@1, randoms@2)\n      A       = ExpandA rho\n      s1      = PolyUniformEtaV`{dim=l} rho' zero\n      s2      = PolyUniformEtaV`{dim=k} rho' (zero + `l)\n      s1ntt   = map ntt s1\n      As1     = map nttinv (nttMatMul A s1ntt)\n      t       = paddV As1 s2\n      (t1,t0) = Power2RoundV t\n      tr      = CRH (rho#(pack_t1 t1))\n      pk      = { rho = rho, t1 = t1}\n      sk      = { rho = rho, K = K, tr = tr, s1 = s1, s2 = s2, t0 = t0}\n\n\/\/ Known Answer Test\n\/\/ To check this property, it is necessary to import testDilithium\n\n\/*test_key_gen = (pk.rho#(pack_t1 pk.t1) == testCase0.pk) \/\\\n    ((sk.rho#sk.K#sk.tr#(pack_polyeta sk.s1)#(pack_polyeta sk.s2)#(pack_t0 sk.t0)) == testCase0.sk)\n    where\n    seed     = 0x7c9935a0b07694aa0c6d10e4db6b1add2fd81a25ccb148032dcd739936737f2d\n    (pk, sk) = Gen seed\n*\/\n\/* Generate signature for message M *\/      \nSign : {mbytes} (fin mbytes, mbytes>=1) => SecretKey -> [mbytes*8] -> (polyVec l, [k][n], poly)\nSign sk M = (final_state.z, h, nttinv final_state.c')\n     where\n      A     = ExpandA sk.rho \/\/checked\n      mu    = CRH`{b=48+mbytes} (sk.tr#M) \/\/ checked\n      kappa = zero:Integer\n      s1'   = map ntt sk.s1 \/\/checked\n      s2'   = map ntt sk.s2 \/\/ checked\n      t0'   = map ntt (IPVtoPV sk.t0) \/\/checked\n\n      init : sign_var_types\n      init = {z=zero,r0=zero,r1=zero,t0'=t0',c'=zero,w=zero,w1=zero\n             ,s1'=s1',s2'=s2',cs2=zero,K=sk.K,mu=mu,A=A,kappa=kappa}\n\n      final_state = dowhile sign_condition sign_body init\n      ct0         = map nttinv (nttVecConstMul final_state.c' final_state.t0')\n      h           = MakeHintV (psubV zero ct0\n                              ,paddV (psubV final_state.w final_state.cs2) (ct0)\n                              ,2*gamma2\n                              )\n\n\n\n\ntype sign_var_types = { z   : polyVec l\n                          , r0  : intPolyVec k\n                          , r1  : intPolyVec k\n                          , t0' : nttVec k\n                          , c'  : nttPoly\n                          , w   : polyVec k\n                          , w1  : intPolyVec k\n                          , s1' : nttVec l\n                          , s2' : nttVec k\n                          , cs2 : polyVec k\n                          , K   : [256]\n                          , mu  : [384]\n                          , A   : nttMat k l\n                          , kappa: Integer}\n\n\nsign_condition : sign_var_types -> Bit\nsign_condition sv = fail1 \\\/ fail2\n               where\n                    fail1 = ((infNormPolyVec (PVtoIPV sv.z)) >= (gamma1-beta))\n                            \\\/ ((infNormPolyVec sv.r0) >= (gamma2-beta))\n                            \\\/ (sv.r1 != sv.w1)\n                    fail2 = ((infNormPolyVec (PVtoIPV ct0)) >= gamma2) \n                            \\\/ ( (foldl (+) 0 (map ones h)) > omega )\n                    ct0   = map nttinv (nttVecConstMul sv.c' sv.t0')\n                    h     = MakeHintV (psubV zero ct0\n                                      ,paddV (psubV sv.w sv.cs2) (ct0)\n                                      ,2*gamma2\n                                      )\n\n\nsign_body : sign_var_types -> sign_var_types\nsign_body sv = {z=z,r0=r0,r1=r1,t0'=sv.t0',c'=c',w=w,w1=w1,s1'=sv.s1',s2'=sv.s2',\n                   cs2=cs2,K=sv.K,mu=sv.mu,A=sv.A,kappa=(sv.kappa+1)}\n              where\n                y   = ExpandMask(sv.K,sv.mu,sv.kappa)\/\/ checked\n                y'  = map ntt y \/\/ checked\n                w   = map nttinv (nttMatMul sv.A y') \/\/ checked\n                w1  = HighBitsV (w, 2 * gamma2) \/\/ checked\n                c'  = ntt ( H (sv.mu,w1) )                 cs1 = map nttinv (nttVecConstMul c' sv.s1')\n                cs2 = map nttinv (nttVecConstMul c' sv.s2')\n                z   = paddV y cs1\n                (r1, r0) = DecomposeV (psubV w cs2, 2 * gamma2)\n\n\n\n\n\/*Verify : {mbytes} (fin mbytes, mbytes>=1) => PublicKey -> [mbytes*8] -> (polyVec l, [k][n], poly) -> Bit\nVerify pk M (z, h, c) = crit1 && crit2 && crit3\n       where\n        A        = ExpandA pk.rho\n        mu       = CRH`{b=48+mbytes} ((CRH (pk.rho#(pack_t1 pk.t1)))#M)\n        zntt     = map ntt z\n        t1ntt    = map ntt (IPVtoPV pk.t1)\n        ct1ntt   = nttVecConstMul (psub zero c) t1ntt\n        ct1ntt2d = map (\\p -> map (\\x -> x*(2^^d)) p) ct1ntt \n        Az       = nttMatMul A zntt\n        w1'      = UseHintV (h, paddV Az ct1ntt2d, 2*gamma2)\n        zint     = PVtoIPV z\n        zinf     = infNormPolyVec zint\n        crit1    = zinf < gamma1 - beta\n        crit2    = c == H(mu,w1')\n        crit3    = (foldl (+) 0 (map ones h)) <= omega*\/\n\n\n\n\npack_w : intPolyVec k -> [4*n*k]\npack_w w = join [pack_poly p | p <- wBV ]\n    where\n    wBV = map (\\p -> map (\\x -> drop`{15} x:[8]) p) w\n    pack2 : [2][8] -> [8]\n    pack2 xs = xs@0 || (xs@1 << 4)\n    pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\n    \/*pack_polyeta : {m} (fin m, m >= 1) =>  polyVec m -> [4*n*m]\npack_polyeta s = join [ join [elt p i | i <- [0..(n\/2)-1]:[_][8] ] | p <- s ]\n             where\n              elt : poly -> [qbits] -> [qbits]\n              elt p i = (c (toInteger (p@(2*i+0)))) || ((c (toInteger (p@(2*i+1)))) << 4)\n              c : Integer -> [qbits]\n              c num = if num > eta then  (`q + eta - num) else  (eta - num)\n\npack_t0 : intPolyVec k -> [k*3584]\npack_t0 t0 = join [ pack_poly p | p <- t0 ]\n        where\n          tmp : intPoly -> [8] -> [8] -> [qbits]\n          tmp p i j =  (2^^13 - p@(4*i+j))\n\n          pack_poly : intPoly -> [3584]\n          pack_poly p = join [ join [drop`{24} (tmp p i 0),\n                     drop`{24} (((tmp p i 0) >> 8) || ((tmp p i 1) << 6)),\n                     drop`{24} ((tmp p i 1) >> 2),\n                     drop`{24} (((tmp p i 1) >> 10) || ((tmp p i 2) << 4)),\n                     drop`{24} ((tmp p i 2) >> 4),\n                     drop`{24} (((tmp p i 2) >> 12) || ((tmp p i 3) << 2)),\n                     drop`{24} ((tmp p i 3) >> 6)\n                     ] | i <- [0..(n\/4-1)] ] *\/\n\n\n\/\/ d must be 14 for this to work, and n must be 256\n\npack_t1 : intPolyVec k -> [k*288*8]\npack_t1 t1 = join [pack_poly p | p <- t1BV]\n        where\n              t1BV = map (\\p -> map (\\x -> drop`{14} x) p) t1\n              pack8 : [8][9] -> [9][8]\n              pack8 xs = map drop`{1} [ xs@0 && zero#0xFF\n                                      , xs@0 >> 8 || ((xs@1 && zero#0x7F) << 1)\n                                      , xs@1 >> 7 || ((xs@2 && zero#0x3F) << 2)\n                                      , xs@2 >> 6 || ((xs@3 && zero#0x1F) << 3)\n                                      , xs@3 >> 5 || ((xs@4 && zero#0x0F) << 4)\n                                      , xs@4 >> 4 || ((xs@5 && zero#0x07) << 5)\n                                      , xs@5 >> 3 || ((xs@6 && zero#0x03) << 6)\n                                      , xs@6 >> 2 || ((xs@7 && zero#0x01) << 7)\n                                      , xs@7 >> 1\n                                      ]\n              pack_poly p = join [join (pack8 xs) | xs <- split p : [32][8][_]]\n\n\/*pack_sig : (polyVec l, [k][n], poly) -> [SIG_SIZE_PACKED]\npack_sig (z, h, c) =\n        where s0 = polyz_pack (z)\n              s1 = encode (h)\n              s2 = encode (c)\npolyz_pack : poly ->[n*qbits]\npolyz_pack a = [  | i <- [0..n\/2] ]*\/\n\n\/\/ Only works when n=256\nPolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [8] -> polyVec dim\nPolyUniformEtaV rho nonce = [PolyUniformEta rho (nonce + j) | j <- [0..(dim-1)]:[dim][8]]\n\nPolyUniformEta : [SEEDBYTES*8] -> [8] -> poly\nPolyUniformEta rho nonce = map (\\x -> (zero#eta:[23]) - x) (map (\\x-> (zero#x):[23]) (take`{n} withinEta))\n    where\n        seed = rho#nonce\n        randoms = ((join (SHA3::toBytes (take`{2*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))#zero)\n        withinEta = randomsInRangeDouble genS (2*eta) randoms\n\n        genS : [8] -> [2][4]\n        genS byte = [t0, t1]\n            where\n            t0 = drop`{4} (byte && 0x0F)\n            t1 = drop`{4} (byte >> 4)\n\n\n\nH : ([384],intPolyVec k) -> poly\nH (mu,w) = map fromInteger (SampleInBall ss samples)\n  where\n    w_packed = pack_w w\n    randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n    ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n    extByte : [8] -> [8]\n    extByte x = x\n\n    samples : [60][8]\n    samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\n\nSampleInBall : [60] -> [60][8] -> [256]Integer\nSampleInBall signs jsamples = ys ! 0\n              where\n              ys = [ zero:[256]Integer ]\n                    # [ if i==j then update y i ((-1:Integer)^^(toInteger [s]))\n                        else updates y [j,i] [(-1:Integer)^^(toInteger [s]),y@j] | i <- [196..255]\n                                                                  | j <- jsamples\n                                                                  | s <- signs\n                                                                  | y <- ys\n                      ]\n\n\nExpandMask : ([SEEDBYTES*8], [384], Integer) -> polyVec l\nExpandMask  (K, mu, kappa) = [samplePoly K mu kappa i `l | i <- [0..(l-1)] ]\n\n\nsamplePoly : [SEEDBYTES*8] -> [384] -> Integer -> Integer -> Integer -> poly\nsamplePoly K mu kappa i dim = (map (\\x -> (`q+gamma1-1-(zero#x))) coeffs)\n    where\n        (upper:[20])      =  drop`{3}(2*gamma1-2):[20]\n        kappaBytes = join (reverse (split (fromInteger (dim*kappa+i):[16]):[2][8])) \/\/ LEB order\n        s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes (K#mu#kappaBytes)))))) \/\/ checked\n        (coeffs:[n][20])   = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\n\nextractPolyElt : [40] -> [2][20]\nextractPolyElt bits = [zero#int1, zero#int2]\n                where\n                [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n                int1 = b2'*2^^16 + b1*2^^8 +  b0\n                int2 = b4*2^^12 + b3*2^^4 +  b2''\n                b2'  = b2 && 15\n                \/\/b2'' = b2\/(16:[20])\n                b2'' = b2\/16\n\/\/ seed should be in little endian byte order\nCRH : {b} (fin b, b>=1) => [b*8] -> [384]\nCRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\n\nExpandA : [SEEDBYTES*8] -> [k][l]nttPoly\nExpandA rho = [ [elt i j | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n        where\n          elt i j = matrixPoly rho i j\n\n\nmatrixPoly : [SEEDBYTES*8] -> [width k] -> [width l] -> nttPoly\nmatrixPoly rho i j = take`{n} [ drop`{1} elt | elt <- randomElts ]\n            where\n            randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n            s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n            b          = 2^^4*(zero#j:[8])+(zero#i:[8])\n\n\nextractMatElt : [24] -> [24]\nextractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n                where\n                  [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n                  b2' = (2^^23-1) && b2 \/\/ Typo in paper; following C implementation\n\n\n\/*\n\n  Supporting Algorithms; see Figure 3\n\n*\/\n\nPower2Round : [qbits] -> ([qbits],[qbits]) -> ([qbits],[qbits])\nPower2Round q (r,d') = ((r'-r0)\/2^^d',r0)\n            where r' = mod_pow (zero#q, r, 1)\n                  r0 = centered_mod r' (2^^d')\n\nPower2RoundV : {dim} (fin dim, dim >= 1) => polyVec dim -> ([dim]intPoly,[dim]intPoly)\nPower2RoundV v = unzip (map polyPower2Round v)\n              where\n              polyPower2Round p = unzip [ Power2Round `q (zero#r, zero#d)\n                                        | r <- p\n                                        ]\n\nDecompose : [qbits] -> ([qbits],[qbits]) -> ([qbits],[qbits])\nDecompose q (r,a) = if (r' - r0) == ((zero#q-1):[qbits]) then (zero:[qbits], (zero#r0 - 1):[qbits])\n                                        else (((r' - r0) \/ a):[qbits], (zero#r0):[qbits])\n          where r' =  mod_pow (zero#q, r, 1)\n                r0 = centered_mod r' a\n\nDecomposeV : (polyVec k , [qbits]) -> (intPolyVec k, intPolyVec k)\nDecomposeV (r,a) = unzip [ DecomposePoly p | p <- r ]\n            where\n            DecomposePoly p = unzip [Decompose `q (zero#x,a) | x <- p]\n\nHighBits : [qbits] -> ([qbits],[qbits]) -> [qbits]\nHighBits q (r,a) = (Decompose q (r,a)).0\n\nHighBitsV : (polyVec k , [qbits]) -> intPolyVec k\nHighBitsV (r,a) = r1\n          where\n            (r1,r0) = DecomposeV (r,a)\n\n\nLowBits : [qbits] -> ([qbits],[qbits]) -> [qbits]\nLowBits q (r,a) = (Decompose q (r,a)).1\n\n\nMakeHint : [qbits] -> ([qbits],[qbits], [qbits]) -> Bit\nMakeHint q (z,r,a) = r1 != v1\n          where r1 = HighBits q (r,a)\n                v1 = HighBits q (r + z,a)\n\nMakeHintV : (polyVec k, polyVec k, [qbits]) -> [k][n]\nMakeHintV (z,r,a) = [[x1 != x2 | x1 <- p1 | x2 <- p2] | p1 <- r1 | p2 <- v1]\n          where\n            r1 = HighBitsV (r,a)\n            v1 = HighBitsV (polyVecSum z r,a)\n\n\nUseHint : [qbits] -> (Bit,[qbits], [qbits]) -> [qbits]\nUseHint q (h,r,a) = if h then zero#r1' else r1\n        where\n          (m :[qbits]) = ((zero#q - 1) \/ a)\n          (r1, r0) = Decompose q (r, a)\n          r1'      = if r0 > 0 then mod_pow (m, (r1 + 1), 1) else mod_pow (m, (r1 - 1), 1)\n\n\nUseHintV : ([k][n], polyVec k, [qbits]) -> intPolyVec k\nUseHintV (hvec, rvec, a) = [polyUseHint hpoly rpoly\n                              | hpoly <- hvec\n                              | rpoly <- rvec\n                              ]\n            where\n            polyUseHint hpoly rpoly = [ UseHint `q (h, zero#r, a)\n                                      | h <- hpoly\n                                      | r <- rpoly\n                                      ]\n\n\n\n\n\/*\n\n  Utility functions\n\n*\/\n\nones : {a} (fin a, a >= 1) => [a] -> [qbits]\nones bv = foldl (+) 0 bva\n      where\n        bva = map (\\x-> zero#x:[qbits]) (split bv:[_][1])\n\nIPVtoPV : {dim} (fin dim, dim >= 1) => intPolyVec dim -> polyVec dim\nIPVtoPV intp = map (\\p -> map drop`{qbits-qbits}p) intp\n\n\nPVtoIPV : {dim} (fin dim, dim >= 1) => polyVec dim -> intPolyVec dim\nPVtoIPV pvec = map (\\p -> map (\\i -> zero#i) p) pvec\n\n\ncentered_mod : [qbits] -> [qbits] -> [qbits]\ncentered_mod x n = if r > (n\/2) then r - n\n                    else r\n              where r = x % n\n\n\nrandomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\nrandomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                else randomsInRange createElt upperCrit randomTail\n                                where\n                                elt        = createElt (take`{a} randoms)\n                                randomTail = drop`{a} randoms\n\nrandomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\nrandomsInRanges createElt uppers randoms =\n                if elt <= head uppers\n                then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                else randomsInRanges createElt uppers randomTail\n                where\n                  elt          = createElt (take`{a} randoms)\n                  randomTail   = drop`{a} randoms\n                  uppersRotate = uppers <<< 1\n\n\nrandomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\n\/\/ Correction and checked with the C code\nrandomsInRangeDouble createElt upper randoms =\n                if (elts@1 <= upper) then [elts@1, elts@1] # (randomsInRangeDouble createElt upper randomTail)\n                else (randomsInRangeDouble createElt upper randomTail)\n                where\n                elts       = createElt (take`{2*a} randoms)\n                randomTail = drop`{2*a} randoms\n\n\/*\n\n  Supporting polynomial and polynomial vector functions\n\n*\/\n\nntt : poly -> nttPoly\nntt p = nttp\n     where\n      r k = rootOfUnity^^k\n      exponents = join [ [BVtoZ`{q} i, (256+(BVtoZ`{q} i))] | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n      nttp = [ fromInteger (fromZ (sum [ (BVtoZ`{q} (p@idx)) | idx<-[0..(n-1)]:[n][width n] | i<-[0..(n-1)]:[n](Z q)]))\n             | k <- exponents\n             ]\n\nnttinv : nttPoly -> poly\nnttinv p' = p'\n    \/\/ Dilithium uses a non-standard ordering of elements in the NTT domain; this function reorders the elements.\nreorder : nttPoly -> nttPoly\nreorder a = join [ [a1 @ i, a2 @ i] | i <- [0..127]:[_][8] ]\n        where\n          a1 = a @@ [ (i-1)\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n          a2 = reverse (a @@ [ (511 - (zero#i):[9])\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ])\n\n\n\n\/\/ Operations on NTT polynomials\n\nnttMatMul : {dim1,dim2} (fin dim1,fin dim2) => nttMat dim1 dim2 -> nttVec dim2 -> nttVec dim1\nnttMatMul mat vec = [ nttDotProduct v vec | v <- mat ]\n\nnttDotProduct : {dim} (fin dim) => nttVec dim -> nttVec dim -> nttPoly\nnttDotProduct v1 v2 = foldl padd (zero:nttPoly) [ nttPolyMult p1 p2 | p1 <- v1 | p2 <- v2 ]\n\nnttPolyMult : nttPoly -> nttPoly -> nttPoly\nnttPolyMult p1 p2 = [ x * y | x <- p1 | y <- p2]\n\nnttVecConstMul : {dim} (fin dim) => nttPoly -> nttVec dim -> nttVec dim\nnttVecConstMul c v = map (nttPolyMult c) v\n\npolyVecSum :  {dim} (fin dim) => polyVec dim -> polyVec dim -> polyVec dim\npolyVecSum v1 v2 = map nttinv (paddV v1' v2')\n            where\n            v1' = map ntt v1\n            v2' = map ntt v2\n\n\/\/ Polynomial addition and subtraction\npadd : [n][qbits] -> [n][qbits] -> [n][qbits]\npadd p1 p2 = [ x + y | x <- p1 | y <- p2 ]\n\n\npsub : [n][qbits] -> [n][qbits] -> [n][qbits]\npsub p1 p2 = [ x - y | x <- p1 | y <- p2 ]\n\n\npsubV : {dim} (fin dim) => [dim][n][qbits] -> [dim][n][qbits] -> [dim][n][qbits]\npsubV v1 v2 = zipWith psub v1 v2\n\n\npaddV : {dim} (fin dim) => [dim][n][qbits] -> [dim][n][qbits] -> [dim][n][qbits]\npaddV v1 v2 = zipWith padd v1 v2\n\n\n\n\/\/ Aux functions\n\ninfNorm : [qbits] -> [qbits]\ninfNorm x =  (centered_mod x `q)\n\ninfNormPoly : intPoly -> [qbits]\ninfNormPoly p = foldl max 0 p_centered\n            where\n              p_centered = map infNorm p\n\ninfNormPolyVec : {dim} (fin dim, dim>=1) => intPolyVec dim -> [qbits]\ninfNormPolyVec v = foldl max 0 (map infNormPoly v)\n\n\n\n\n\n","variant":"hybrid","set":"holdout"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DilithiumR1Int.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::DilithiumR1Int where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Primitive::Asymmetric::Signature::testDilithium\nimport Primitive::Asymmetric::Signature::signFinal\n\nimport Primitive::Asymmetric::Signature::testCase2\n\n\n\/\/ Recommended Parameters\ntype q = 8380421\ntype n = 256 \ntype k = 5\ntype l = 4\nd      = 14\nwc     = 60\ngamma1 = ((`q : Integer) - 1) \/ 16 \ngamma2 = (gamma1 \/ 2)\neta    = 5\nbeta   = 275\nomega  = 96 : Integer\nqbits  = 23\n\/\/POLZ_SIZE_PACKED = ((`n*(qbits - 3))\/8)\n\/\/SIG_SIZE_PACKED = (`l*POLZ_SIZE_PACKED + (omega + `k) + (`n\/8 + 8))\n\n\n\n\/\/ Parameters for Number Theoretic Transform (NTT)\nrootOfUnity    = 1753 : (Z q)\nrootOfUnityInv = 731434 : (Z q)\nninv           = 8347681 : (Z q)\n\n\/\/ Integer polynomials; a superset of ring R referenced in specification\ntype intPoly        = [n]Integer\ntype intPolyVec dim = [dim]intPoly\n\n\/\/ Polynomials; a superset of ring R_q referenced in specification\ntype poly        = [n](Z q) \/\/ This is R_q, actually defines a super set of R_q\ntype polyVec dim = [dim]poly \n\n\/\/ Polynomials in NTT representation\ntype nttPoly          = [n](Z q)\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\n\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k} \ntype SecretKey = {rho : [256]\n                 , K  : [256]\n                 , tr : [384]\n                 , s1 : polyVec l\n                 , s2 : polyVec k\n                 , t0 : intPolyVec k}\n\n\n\/* Generate public and private keys *\/\nGen : [256] -> (PublicKey,SecretKey)\nGen seed = (pk, sk)\n    where\n      randoms = split`{3} (join (SHA3::toBytes (take`{768} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))\n      (rho, rho', K) = (randoms@0, randoms@1, randoms@2)\n      A       = ExpandA rho\n      s1      = PolyUniformEtaV`{dim=l} rho' zero\n      s2      = PolyUniformEtaV`{dim=k} rho' (zero + `l)\n      s1ntt   = map ntt s1\n      As1     = map nttinv (nttMatMul A s1ntt)\n      t       = paddV As1 s2\n      (t1,t0) = Power2RoundV t\n      tr      = CRH (rho#(pack_t1 t1))\n      pk      = { rho = rho, t1 = t1}\n      sk      = { rho = rho, K = K, tr = tr, s1 = s1, s2 = s2, t0 = t0}\n\n\/\/ Known Answer Test\n\/\/ To check this property, it is necessary to import testDilithium\n\ntest_key_gen = (pk.rho#(pack_t1 pk.t1) == testCase0.pk)\n\/\/\/\\\n  \/\/  ((sk.rho#sk.K#sk.tr#(pack_polyeta sk.s1)#(pack_polyeta sk.s2)#(pack_t0 sk.t0)) == testCase0.sk)\n    where\n    seed     = 0x7c9935a0b07694aa0c6d10e4db6b1add2fd81a25ccb148032dcd739936737f2d\n    (pk, sk) = Gen seed\n\n\/* Generate signature for message M *\/      \nSign : {mbytes} (fin mbytes, mbytes>=1) => SecretKey -> [mbytes*8] -> (polyVec l, [k][n], poly)\nSign sk M = (final_state.z, h, nttinv final_state.c')\n     where\n      A     = ExpandA sk.rho \/\/checked\n      mu    = CRH`{b=48+mbytes} (sk.tr#M) \/\/ checked\n      kappa = zero:Integer\n      s1'   = map ntt sk.s1 \/\/checked\n      s2'   = map ntt sk.s2 \/\/ checked\n      t0'   = map ntt (IPVtoPV sk.t0) \/\/checked\n\n      init : sign_var_types\n      init = {z=zero,r0=zero,r1=zero,t0'=t0',c'=zero,w=zero,w1=zero\n             ,s1'=s1',s2'=s2',cs2=zero,K=sk.K,mu=mu,A=A,kappa=kappa}\n\n      final_state = dowhile sign_condition sign_body init\n      ct0         = map nttinv (nttVecConstMul final_state.c' final_state.t0')\n      h           = MakeHintV (psubV zero ct0\n                              ,paddV (psubV final_state.w final_state.cs2) (ct0)\n                              ,2*gamma2\n                              )\n\nprivate\n\n    type sign_var_types = { z   : polyVec l\n                          , r0  : intPolyVec k\n                          , r1  : intPolyVec k\n                          , t0' : nttVec k\n                          , c'  : nttPoly\n                          , w   : polyVec k\n                          , w1  : intPolyVec k\n                          , s1' : nttVec l\n                          , s2' : nttVec k\n                          , cs2 : polyVec k\n                          , K   : [256]\n                          , mu  : [384]\n                          , A   : nttMat k l\n                          , kappa: Integer}\n\n\n    sign_condition : sign_var_types -> Bit\n    sign_condition sv = fail1 \\\/ fail2 \n                   where\n                    fail1 = ((infNormPolyVec (PVtoIPV sv.z)) >= (gamma1-beta))\n                            \\\/ ((infNormPolyVec sv.r0) >= (gamma2-beta))\n                            \\\/ (sv.r1 != sv.w1)\n                    fail2 = ((infNormPolyVec (PVtoIPV ct0)) >= gamma2) \n                            \\\/ ( (foldl (+) 0 (map ones h)) > omega )\n                    ct0   = map nttinv (nttVecConstMul sv.c' sv.t0')\n                    h     = MakeHintV (psubV zero ct0\n                                      ,paddV (psubV sv.w sv.cs2) (ct0)\n                                      ,2*gamma2\n                                      )\n\n\n    sign_body : sign_var_types -> sign_var_types\n    sign_body sv = {z=z,r0=r0,r1=r1,t0'=sv.t0',c'=c',w=w,w1=w1,s1'=sv.s1',s2'=sv.s2',\n                   cs2=cs2,K=sv.K,mu=sv.mu,A=sv.A,kappa=(sv.kappa+1)}\n              where\n                y   = ExpandMask(sv.K,sv.mu,sv.kappa)\/\/ checked\n                y'  = map ntt y \/\/ checked\n                w   = map nttinv (nttMatMul sv.A y') \/\/ checked\n                w1  = HighBitsV (w, 2 * gamma2) \/\/ checked\n                c'  = ntt ( H (sv.mu,w1) )                 cs1 = map nttinv (nttVecConstMul c' sv.s1')\n                cs2 = map nttinv (nttVecConstMul c' sv.s2')\n                z   = paddV y cs1\n                (r1, r0) = DecomposeV (psubV w cs2, 2 * gamma2)\n\n\n\n\nVerify : {mbytes} (fin mbytes, mbytes>=1) => PublicKey -> [mbytes*8] -> (polyVec l, [k][n], poly) -> Bit\nVerify pk M (z, h, c) = crit1 && crit2 && crit3\n       where\n        A        = ExpandA pk.rho\n        mu       = CRH`{b=48+mbytes} ((CRH (pk.rho#(pack_t1 pk.t1)))#M)\n        zntt     = map ntt z\n        t1ntt    = map ntt (IPVtoPV pk.t1)\n        ct1ntt   = nttVecConstMul (psub zero c) t1ntt\n        ct1ntt2d = map (\\p -> map (\\x -> x*(2^^d)) p) ct1ntt \n        Az       = nttMatMul A zntt\n        w1'      = UseHintV (h, paddV Az ct1ntt2d, 2*gamma2)\n        zint     = PVtoIPV z\n        zinf     = infNormPolyVec zint\n        crit1    = zinf < gamma1 - beta\n        crit2    = c == H(mu,w1')\n        crit3    = (foldl (+) 0 (map ones h)) <= omega\n\n\n\nprivate\n    pack_w : intPolyVec k -> [4*n*k]\n    pack_w w = join [pack_poly p | p <- wBV ]\n                where\n                wBV = map (\\p -> map (\\x -> fromInteger x:[8]) p) w\n\n                pack2 : [2][8] -> [8]\n                pack2 xs = xs@0 || (xs@1 << 4)\n\n                pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\n    pack_polyeta : {m} (fin m, m >= 1) =>  polyVec m -> [4*n*m]\n    pack_polyeta s = join [ join [elt p i | i <- [0..(n\/2)-1]:[_][8] ] | p <- s ]\n                 where\n                  elt : poly -> [8] -> [8]\n                  elt p i = (c (fromZ`{q} (p@(2*i+0)))) || ((c (fromZ`{q} (p@(2*i+1)))) << 4)\n                  c : Integer -> [8]\n                  c num = if num > eta then fromInteger (`q + eta - num) else fromInteger (eta - num)\n\n    pack_t0 : intPolyVec k -> [k*3584]\n    pack_t0 t0 = join [ pack_poly p | p <- t0 ]\n            where\n              tmp : intPoly -> [8] -> [8] -> [32]\n              tmp p i j = fromInteger (2^^13 - p@(4*i+j))\n\n              pack_poly : intPoly -> [3584]\n              pack_poly p = join [ join [drop`{24} (tmp p i 0),\n                         drop`{24} (((tmp p i 0) >> 8) || ((tmp p i 1) << 6)),\n                         drop`{24} ((tmp p i 1) >> 2),\n                         drop`{24} (((tmp p i 1) >> 10) || ((tmp p i 2) << 4)),\n                         drop`{24} ((tmp p i 2) >> 4),\n                         drop`{24} (((tmp p i 2) >> 12) || ((tmp p i 3) << 2)),\n                         drop`{24} ((tmp p i 3) >> 6)\n                         ] | i <- [0..(n\/4-1)] ]\n\n\n    \/\/ d must be 14 for this to work, and n must be 256\n    pack_t1 : intPolyVec k -> [k*288*8]\n    pack_t1 t1 = join [pack_poly p | p <- t1BV]\n            where\n              t1BV = map (\\p -> map (\\x -> fromInteger x:[9]) p) t1\n\n              pack8 : [8][9] -> [9][8]\n              pack8 xs = map drop`{1} [ xs@0 && zero#0xFF\n                                      , xs@0 >> 8 || ((xs@1 && zero#0x7F) << 1)\n                                      , xs@1 >> 7 || ((xs@2 && zero#0x3F) << 2)\n                                      , xs@2 >> 6 || ((xs@3 && zero#0x1F) << 3)\n                                      , xs@3 >> 5 || ((xs@4 && zero#0x0F) << 4)\n                                      , xs@4 >> 4 || ((xs@5 && zero#0x07) << 5)\n                                      , xs@5 >> 3 || ((xs@6 && zero#0x03) << 6)\n                                      , xs@6 >> 2 || ((xs@7 && zero#0x01) << 7)\n                                      , xs@7 >> 1\n                                      ]\n              pack_poly p = join [join (pack8 xs) | xs <- split p : [32][8][_]]\n\n    \/*pack_sig : (polyVec l, [k][n], poly) -> [SIG_SIZE_PACKED]\n    pack_sig (z, h, c) =\n            where s0 = polyz_pack (z)\n                  s1 = encode (h)\n                  s2 = encode (c)\n    polyz_pack : poly ->[n*qbits]\n    polyz_pack a = [  | i <- [0..n\/2] ] *\/\n\n    \/\/ Only works when n=256\n    PolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [8] -> polyVec dim\n    PolyUniformEtaV rho nonce = [PolyUniformEta rho (nonce + j) | j <- [0..(dim-1)]:[dim][8]]\n\n    PolyUniformEta : [256] -> [8] -> poly\n    PolyUniformEta rho nonce = map (\\x -> eta - x) (map BVtoZ (take`{n} withinEta))\n                   where\n                    seed = rho#nonce\n                    randoms = ((join (SHA3::toBytes (take`{2*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))#zero)\n                    withinEta = randomsInRangeDouble genS (2*eta) randoms\n\n                    genS : [8] -> [2][4]\n                    genS byte = [t0, t1]\n                         where\n                          t0 = drop`{4} (byte && 0x0F)\n                          t1 = drop`{4} (byte >> 4)\n\n\n\n    H : ([384],intPolyVec k) -> poly\n    H (mu,w) = map fromInteger (SampleInBall ss samples)\n      where\n        w_packed = pack_w w\n        randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n        ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n        extByte : [8] -> [8]\n        extByte x = x\n\n        samples : [60][8]\n        samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\n\n    SampleInBall : [60] -> [60][8] -> [256]Integer\n    SampleInBall signs jsamples = ys ! 0\n                  where\n                  ys = [ zero:[256]Integer ]\n                        # [ if i==j then update y i ((-1:Integer)^^(toInteger [s]))\n                            else updates y [j,i] [(-1:Integer)^^(toInteger [s]),y@j] | i <- [196..255]\n                                                                      | j <- jsamples\n                                                                      | s <- signs\n                                                                      | y <- ys\n                          ]\n\n\n    ExpandMask : ([256], [384], Integer) -> polyVec l\n    ExpandMask  (K, mu, kappa) = [samplePoly K mu kappa i `l | i <- [0..(l-1)] ]\n\n\n    samplePoly : [256] -> [384] -> Integer -> Integer -> Integer -> poly\n    samplePoly K mu kappa i dim = [fromInteger (`q + gamma1 - 1 - (toInteger vj)) | vj <- coeffs]\n                where\n                upper      = fromInteger (2*gamma1-2) : [20]\n                kappaBytes = join (reverse (split (fromInteger (dim*kappa+i):[16]):[2][8])) \/\/ LEB order\n                s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes (K#mu#kappaBytes)))))) \/\/ checked\n                coeffs     = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\n\n    extractPolyElt : [40] -> [2][20]\n    extractPolyElt bits = [int1, int2]\n                    where\n                    [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n                    int1 = b2'*2^^16 + b1*2^^8 +  b0\n                    int2 = b4*2^^12 + b3*2^^4 +  b2''\n                    b2'  = b2 && 15\n                    \/\/b2'' = b2\/(16:[20])\n                    b2'' = b2\/16\n    \/\/ seed should be in little endian byte order\n    CRH : {b} (fin b, b>=1) => [b*8] -> [384]\n    CRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\n\n    ExpandA : [256] -> [k][l]nttPoly \n    ExpandA rho = [ [elt i j | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n            where\n              elt i j = matrixPoly rho i j\n\n\n    matrixPoly : [256] -> [width k] -> [width l] -> nttPoly\n    matrixPoly rho i j = take`{n} [ BVtoZ elt | elt <- randomElts ]\n                where\n                randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n                s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n                b          = 16*(zero#j:[8])+(zero#i:[8])\n\n\n    extractMatElt : [24] -> [24]\n    extractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n                    where\n                      [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n                      b2' = (2^^23-1) && b2 \/\/ Typo in paper; following C implementation\n\n\n    \/*\n\n      Supporting Algorithms; see Figure 3\n\n    *\/\n\n    Power2Round : Integer -> (Integer,Integer) -> (Integer,Integer)\n    Power2Round q (r,d') = ((r'-r0)\/2^^d',r0)\n                where r' = r % q\n                      r0 = centered_mod r' (2^^d')\n\n    Power2RoundV : {dim} (fin dim, dim >= 1) => polyVec dim -> ([dim]intPoly,[dim]intPoly)\n    Power2RoundV v = unzip (map polyPower2Round v)\n                  where\n                  polyPower2Round p = unzip [ Power2Round `q ( (fromZ r ) ,d)\n                                            | r <- p\n                                            ]\n\n    Decompose : Integer -> (Integer,Integer) -> (Integer,Integer)\n    Decompose q (r,a) = if (r' - r0) == (q - 1) then (0, r0 - 1)\n                        else ((r' - r0) \/ a, r0)\n              where r' = r % q\n                    r0 = centered_mod r' a\n\n    DecomposeV : (polyVec k , Integer) -> (intPolyVec k, intPolyVec k)\n    DecomposeV (r,a) = unzip [ DecomposePoly p | p <- r ]\n                where\n                DecomposePoly p = unzip [Decompose `q (fromZ x,a) | x <- p]\n\n    HighBits : Integer -> (Integer,Integer) -> Integer\n    HighBits q (r,a) = (Decompose q (r,a)).0\n\n    HighBitsV : (polyVec k , Integer) -> intPolyVec k\n    HighBitsV (r,a) = r1\n              where\n                (r1,r0) = DecomposeV (r,a)\n\n\n    LowBits : Integer -> (Integer,Integer) -> Integer\n    LowBits q (r,a) = (Decompose q (r,a)).1\n\n\n    MakeHint : Integer -> (Integer,Integer,Integer) -> Bit\n    MakeHint q (z,r,a) = r1 != v1\n              where r1 = HighBits q (r,a)\n                    v1 = HighBits q (r + z,a)\n\n    MakeHintV : (polyVec k, polyVec k, Integer) -> [k][n]\n    MakeHintV (z,r,a) = [[x1 != x2 | x1 <- p1 | x2 <- p2] | p1 <- r1 | p2 <- v1]\n              where\n                r1 = HighBitsV (r,a)\n                v1 = HighBitsV (polyVecSum z r,a)\n\n\n    UseHint : Integer -> (Bit,Integer,Integer) -> Integer\n    UseHint q (h,r,a) = if h then r1' else r1\n            where\n              m        = (q - 1) \/ a\n              (r1, r0) = Decompose q (r, a)\n              r1'      = if r0 > 0 then (r1 + 1) % m else (r1 - 1) % m\n\n\n    UseHintV : ([k][n], polyVec k, Integer) -> intPolyVec k\n    UseHintV (hvec, rvec, a) = [polyUseHint hpoly rpoly\n                                  | hpoly <- hvec\n                                  | rpoly <- rvec\n                                  ]\n                where\n                polyUseHint hpoly rpoly = [ UseHint `q (h,fromZ r,a)\n                                          | h <- hpoly\n                                          | r <- rpoly\n                                          ]\n\n\n\n\n    \/*\n\n      Utility functions\n\n    *\/\n\n    ones : {a} (fin a, a >= 1) => [a] -> Integer\n    ones bv = foldl (+) 0 bva\n          where\n          bva = map toInteger (split bv:[_][1])\n\n    IPVtoPV : {dim} (fin dim, dim >= 1) => intPolyVec dim -> polyVec dim\n    IPVtoPV intp = map (\\p -> map fromInteger p) intp\n\n\n    PVtoIPV : {dim} (fin dim, dim >= 1) => polyVec dim -> intPolyVec dim\n    PVtoIPV pvec = map (\\p -> map fromZ p) pvec\n\n\n    centered_mod : Integer -> Integer -> Integer\n    centered_mod x n = if r > (n\/2) then r - n\n                        else r\n                  where r = x % n\n\n\n    randomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\n    randomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                    then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                    else randomsInRange createElt upperCrit randomTail\n                                    where\n                                    elt        = createElt (take`{a} randoms) \n                                    randomTail = drop`{a} randoms\n\n    randomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\n    randomsInRanges createElt uppers randoms =\n                    if elt <= head uppers\n                    then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                    else randomsInRanges createElt uppers randomTail\n                    where\n                      elt          = createElt (take`{a} randoms) \n                      randomTail   = drop`{a} randoms\n                      uppersRotate = uppers <<< 1\n\n\n    randomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\n    \/*randomsInRangeDouble createElt upper randoms =\n                    if (elts@0 <= upper) \/\\ (elts@1 <= upper)\n                    then  elts#(randomsInRangeDouble createElt upper randomTail)\n                    else\n                      if (elts@0 <= upper)\n                      then [ elts@0 ]#(randomsInRangeDouble createElt upper randomTail)\n                      else\n                        if (elts@1 <= upper)\n                        then [ elts@1 ]#(randomsInRangeDouble createElt upper randomTail)\n                        else randomsInRangeDouble createElt upper randomTail\n                    where\n                      elts       = createElt (take`{2*a} randoms) \n                      randomTail = drop`{2*a} randoms*\/\n\/\/ Correction and checked with the C code\n    randomsInRangeDouble createElt upper randoms =\n                    if (elts@1 <= upper) then [elts@1, elts@1] # (randomsInRangeDouble createElt upper randomTail)\n                    else (randomsInRangeDouble createElt upper randomTail)\n                    where\n                    elts       = createElt (take`{2*a} randoms)\n                    randomTail = drop`{2*a} randoms\n\n    \/*\n\n      Supporting polynomial and polynomial vector functions\n\n    *\/\n\n    ntt : poly -> nttPoly\n    ntt p = nttp\n         where\n          r k = rootOfUnity^^k\n          exponents = join [ [BVtoZ`{q} i, (256+(BVtoZ`{q} i))] | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n          nttp = [ sum [ p@idx * (r k)^^(i) | idx<-[0..(n-1)]:[n][width n] | i<-[0..(n-1)]:[n](Z q)]\n                 | k <- exponents \n                 ]\n\n    nttinv : nttPoly -> poly\n    nttinv p' = p\n           where\n            pu = reorder p'\n            r' i = rootOfUnityInv^^(i*2)\n            p = [ninv*(rootOfUnityInv^^i) * sum [pu@jdx * (r' ((i*j)))\n                                                    | jdx<-[0..(n-1)]:[n][width n]\n                                                    | j<-[0..(n-1)]:[n](Z q)\n                                                    ]\n                | i <- [0..255]\n                ]\n\n    \/\/ Dilithium uses a non-standard ordering of elements in the NTT domain; this function reorders the elements.\n    reorder : nttPoly -> nttPoly\n    reorder a = join [ [a1 @ i, a2 @ i] | i <- [0..127]:[_][8] ]\n            where\n              a1 = a @@ [ (i-1)\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n              a2 = reverse (a @@ [ (511 - (zero#i):[9])\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ])\n\n\n\n    \/\/ Operations on NTT polynomials\n\n    nttMatMul : {dim1,dim2} (fin dim1,fin dim2) => nttMat dim1 dim2 -> nttVec dim2 -> nttVec dim1\n    nttMatMul mat vec = [ nttDotProduct v vec | v <- mat ]\n\n    nttDotProduct : {dim} (fin dim) => nttVec dim -> nttVec dim -> nttPoly\n    nttDotProduct v1 v2 = foldl padd (zero:nttPoly) [ nttPolyMult p1 p2 | p1 <- v1 | p2 <- v2 ]\n\n    nttPolyMult : nttPoly -> nttPoly -> nttPoly\n    nttPolyMult p1 p2 = [ x * y | x <- p1 | y <- p2]\n\n    nttVecConstMul : {dim} (fin dim) => nttPoly -> nttVec dim -> nttVec dim\n    nttVecConstMul c v = map (nttPolyMult c) v\n\n    polyVecSum :  {dim} (fin dim) => polyVec dim -> polyVec dim -> polyVec dim\n    polyVecSum v1 v2 = map nttinv (paddV v1' v2')\n                where\n                v1' = map ntt v1\n                v2' = map ntt v2\n\n    \/\/ Polynomial addition and subtraction\n    padd : [n](Z q) -> [n](Z q) -> [n](Z q)\n    padd p1 p2 = [ x + y | x <- p1 | y <- p2 ]\n\n\n    psub : [n](Z q) -> [n](Z q) -> [n](Z q)\n    psub p1 p2 = [ x - y | x <- p1 | y <- p2 ]\n\n\n    psubV : {dim} (fin dim) => [dim][n](Z q) -> [dim][n](Z q) -> [dim][n](Z q)\n    psubV v1 v2 = zipWith psub v1 v2\n\n\n    paddV : {dim} (fin dim) => [dim][n](Z q) -> [dim][n](Z q) -> [dim][n](Z q)\n    paddV v1 v2 = zipWith padd v1 v2\n\n\n\n    \/\/ Aux functions\n\n    infNorm : Integer -> Integer\n    infNorm x = abs (centered_mod x `q)\n\n    infNormPoly : intPoly -> Integer\n    infNormPoly p = foldl max 0 p_centered\n                where\n                  p_centered = map infNorm p\n\n    infNormPolyVec : {dim} (fin dim, dim>=1) => intPolyVec dim -> Integer\n    infNormPolyVec v = foldl max 0 (map infNormPoly v)\n\n\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\nimport Common::utils\n\nsign : Z q -> Z q -> Z p -> (Z q, Z q)\nsign d z k = (r, s)\n  where {x = x1, y = _} = ec_affinify (ec_mult k G)\n        r = ZtoZ x1\n        s = (mp_mod_inv (ZtoZ k)) * (z + r*d)\n\nprivate_to_public : Z q -> ProjectivePoint p\nprivate_to_public d = ec_mult (ZtoZ d) G\n\nverify : Z q -> ProjectivePoint p -> (Z q, Z q) -> Bit\nverify z Q (r, s) = r == ZtoZ j\n  where w = mp_mod_inv s\n        u1 = z * w\n        u2 = r * w\n        {x = x1, y = _, z = z1} = ec_twin_mult (ZtoZ u1) G (ZtoZ u2) Q\n        j = x1 * (mp_mod_inv z1)^^2\n\n\/\/Examples\nG_compress R = ec_compress (ec_affinify G) == R\n\nfull_add_example : AffinePoint p -> AffinePoint p -> AffinePoint p -> Bit\nfull_add_example R S T =\n  ec_affinify (ec_full_add (ec_projectify S) (ec_projectify T)) == R\n\nfull_subtract_example : AffinePoint p -> AffinePoint p -> AffinePoint p -> Bit\nfull_subtract_example R S T =\n  ec_affinify (ec_full_sub (ec_projectify S) (ec_projectify T)) == R\n\ndouble_example : AffinePoint p -> AffinePoint p -> Bit\ndouble_example R S =\n  ec_affinify (ec_double (ec_projectify S)) == R\n\nscalar_multiply_example : AffinePoint p -> AffinePoint p -> Z p -> Bit\nscalar_multiply_example R S d =\n  ec_affinify (ec_mult d (ec_projectify S)) == R\n\njoint_scalar_multiply_example : AffinePoint p -> AffinePoint p -> AffinePoint p -> Z p -> Z p -> Bit\njoint_scalar_multiply_example R S T d e =\n  ec_affinify (ec_twin_mult d (ec_projectify S) e (ec_projectify T)) == R\n\nmp_mod_sqrt_correct x = (mp_mod_sqrt (x ^^ 2)) ^^ 2 == (x ^^ 2)\n\n\/\/ This only holds for proper affine points\naffine_decompress_correct : AffinePoint p -> Bit\naffine_decompress_correct R = ~err \/\\ R == R'\n  where\n    (R',err) = ec_decompress (ec_compress`{width p+2} R)\n\n\/\/ Use the generator G to produce random affine points and test\n\/\/ the compression\/decompression algorithm\ndecompress_correct : Z p -> Bit\nproperty decompress_correct k = affine_decompress_correct (ec_affinify (ec_mult k G))\n\nparameter\n\n  type p : #\n  type constraint Constraints p\n\n  b : Z p\n\n  G : ProjectivePoint p\n\n  type q : #\n  type constraint Constraints q\n\n  mp_mod_sqrt : Z p -> Z p\n\nprivate\n\n  type constraint Constraints a = (fin a, isOdd a, a >= 4)\n\n  type AffinePoint a = {x : Z a, y : Z a}\n  type ProjectivePoint a = {x : Z a, y : Z a, z : Z a}\n\n  ec_projectify : {a} (Constraints a) => AffinePoint a -> ProjectivePoint a\n  ec_projectify S = {x = S.x, y = S.y, z = 1}\n\n  ec_affinify : {a} (Constraints a) => ProjectivePoint a -> AffinePoint a\n  ec_affinify S = if S.z == 0 then error \"Cannot affinify the point at infinity\"\n                  else {x = lambda^^2 * S.x, y =  lambda^^3 * S.y}\n    where\n      lambda = mp_mod_inv S.z\n\n  ec_compress : {r} (fin r, r >= width p + 2) => AffinePoint p -> [r]\n  ec_compress S = (2 + (Sy % 2)) # Sx\n    where Sx = ZtoBV S.x : [width p]\n          Sy = ZtoBV S.y : [r - width p]\n\n  ec_decompress : {a} (fin a, a >= width p + 2) => [a] -> (AffinePoint p, Bit)\n  ec_decompress S = ({x = Rx, y = Ry}, err)\n    where c  = toInteger (take S : [2])\n          Rx = BVtoZ (drop S : [a-2])\n          t0 = Rx ^^ 3 - (mul3 Rx) + b\n          t1 = mp_mod_sqrt t0\n          err = t1 ^^ 2 != t0\n          Ry = if (fromZ t1)%2 == c%2 then t1 else -t1\n\n  ec_is_point_affine : AffinePoint p -> Bit\n  ec_is_point_affine S = S.y ^^ 2 == t\n    where t = S.x ^^ 3 - (mul3 S.x) + b\n\n  ec_double : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a\n  ec_double S =\n    if S.z == 0 then\n      {x = 1, y = 1, z = 0}             \/* 5: r <- (1,1,0) and return *\/\n    else\n      {x = r18, y = r23, z = r13}\n    where r7  = S.z ^^ 2                \/*  7: t4 <- (t3)^2 *\/\n          r8  = S.x - r7                \/*  8: t5 <- t1 - t4 *\/\n          r9  = S.x + r7                \/*  9: t4 <- t1 + t4 *\/\n          r10 = r9 * r8                 \/* 10: t5 <- t4 * t5 *\/\n          r11 = mul3 r10                \/* 11: t4 <- 3 * t5 *\/\n          r12 = S.z * S.y               \/* 12: t3 <- t3 * t2 *\/\n          r13 = mul2 r12                \/* 13: t3 <- 2 * t3 *\/\n          r14 = S.y ^^ 2                \/* 14: t2 <- (t2)^2 *\/\n          r15 = S.x * r14               \/* 15: t5 <- t1 * t2 *\/\n          r16 = mul4 r15                \/* 16: t5 <- 4 * t5 *\/\n          r17 = r11 ^^ 2                \/* 17: t1 <- (t4)^2 *\/\n          r18 = r17 - (mul2 r16)        \/* 18: t1 <- t1 - 2 * t5 *\/\n          r19 = r14 ^^ 2                \/* 19: t2 <- (t2)^2 *\/\n          r20 = mul8 r19                          r21 = r16 - r18                         r22 = r11 * r21                         r23 = r22 - r20                 ec_add : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a -> ProjectivePoint a\n  ec_add S T =\n    if r13 == 0 then\n      if r14 == 0 then\n        {x = 0, y = 0, z = 0}            else\n        {x = 1, y = 1, z = 0}          else\n      {x = r32, y = r37, z = r27}\n    where r9  = S.z ^^ 2           \/*  9: t7 <- (t3)^2 *\/\n          r10 = T.x * r9           \/* 10: t4 <- t4 * t7 *\/\n          r11 = S.z * r9           \/* 11: t7 <- t3 * t7 *\/\n          r12 = T.y * r11                    r13 = S.x - r10                    r14 = S.y - r12                    r22 = mul2 S.x - r13               r23 = mul2 S.y - r14               r27 = S.z * r13                    r28 = r13 ^^ 2                     r29 = r13 * r28          \/* 29: t4 <- t4 * t7 *\/\n          r30 = r22 * r28          \/* 30: t7 <- t1 * t7 *\/\n          r31 = r14 ^^ 2           \/* 31: t1 <- (t5)^2 *\/\n          r32 = r31 - r30          \/* 32: t1 <- t1 - t7 *\/\n          r33 = r30 - (mul2 r32)   \/* 33: t7 <- t7 - 2*t1 *\/\n          r34 = r14 * r33          \/* 34: t5 <- t5 * t7 *\/\n          r35 = r23 * r29          \/* 35: t4 <- t2 * t4 *\/\n          r36 = r34 - r35          \/* 36: t2 <- t5 - t4 *\/\n          r37 = half r36             ec_full_add : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a -> ProjectivePoint a\n  ec_full_add S T = \n    if S.z == 0 then T\n     | T.z == 0 then S\n     | R == {x = 0, y = 0, z = 0} then ec_double S\n     else R\n    where R = ec_add S T\n\n  ec_full_sub : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a -> ProjectivePoint a\n  ec_full_sub S T = R\n    where U = {x = T.x, y = -T.y, z = T.z}\n          R = ec_full_add S U\n\n  ec_mult : {a} (Constraints a) => Z a -> ProjectivePoint a -> ProjectivePoint a\n  ec_mult d S = if d == 0 then {x = 1, y = 1, z = 0}\n                 | d == 1 then S\n                 | S.z == 0 then {x = 1, y = 1, z = 0}\n                 else Rs!1\n    where S' = if S.z != 1 then ec_projectify (ec_affinify S) else S\n          k = ZtoBV d : [width a + 2]\n          h = k + k + k\n          Rs = [{x = 1, y = 1, z = 0}] # \/\/Here we start with 1 instead of S because we don't really know where the high-bit is\n               [ if hi && ~ki then ec_full_add RiDouble S\n                  | ~hi && ki then ec_full_sub RiDouble S\n                  else RiDouble\n                 where RiDouble = ec_double Ri\n               | ki <- k | hi <- h | Ri <- Rs ]\n\n  F : [5] -> [5]\n  F t = if (18 <= t) && (t < 22) then 9\n         | (14 <= t) && (t < 18) then 10\n         | (22 <= t) && (t < 24) then 11\n         | (4 <= t)  && (t < 12) then 14\n         else 12\n\n  ec_twin_mult : {a} (Constraints a) => Z a -> ProjectivePoint a -> Z a -> ProjectivePoint a -> ProjectivePoint a\n  ec_twin_mult d0 S d1 T = (states!0).0\n    where Sp = if S.z != 1 then ec_projectify (ec_affinify S) else S\n          Tp = if T.z != 1 then ec_projectify (ec_affinify T) else T\n          SpT = ec_full_add Sp Tp\n          SpTp = if SpT.z != 1 then ec_projectify (ec_affinify SpT) else SpT\n          SmT = ec_full_sub Sp Tp\n          SmTp = if SmT.z != 1 then ec_projectify (ec_affinify SmT) else SmT\n          e0  = ZtoBV d0 : [max 4 (width a)]\n          e1  = ZtoBV d1 : [max 4 (width a)]\n          c   = [[False, False] # take e0,\n                 [False, False] # take e1] : [2][6]\n          states = [({x = 1, y = 1, z = 0}, c)] #\n                   [ (Rk', [c0', c1'])\n                     where h0 = if c0@0 then 31 - tail c0 else tail c0\n                           h1 = if c1@0 then 31 - tail c1 else tail c1\n                           u0 = if h0 < (F h1) then 0 else if c0@0 then -1 else 1 : [2]\n                           u1 = if h1 < (F h0) then 0 else if c1@0 then -1 else 1 : [2]\n                           c0' = [(u0!=0) ^ c0@1] # drop c0 # [e0k]\n                           c1' = [(u1!=0) ^ c1@1] # drop c1 # [e1k]\n                           Rk' = if (u0 == -1) && (u1 == -1) then ec_full_sub RkDouble SpTp\n                                  | (u0 == -1) && (u1 ==  0) then ec_full_sub RkDouble Sp\n                                  | (u0 == -1) && (u1 ==  1) then ec_full_sub RkDouble SmTp\n                                  | (u0 ==  0) && (u1 == -1) then ec_full_sub RkDouble Tp\n                                  | (u0 ==  0) && (u1 ==  1) then ec_full_add RkDouble Tp\n                                  | (u0 ==  1) && (u1 == -1) then ec_full_add RkDouble SmTp\n                                  | (u0 ==  1) && (u1 ==  0) then ec_full_add RkDouble Sp\n                                  | (u0 ==  1) && (u1 ==  1) then ec_full_add RkDouble SpTp\n                                  else RkDouble\n                           RkDouble = ec_double Rk\n                   | (Rk, [c0, c1]) <- states\n                   | e0k <- drop`{4} e0 # (zero : [5])\n                   | e1k <- drop`{4} e1 # (zero : [5]) ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p256.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::p256 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\ntype p = 115792089210356248762697446949407573530086143415290314195533631308867097853951\n\nb = 41058363725152142129326129780047268409114441015993725554835256314039467401291\n\nG = {x = 48439561293906451759052585252797914202762949526041747995844080717082404635286,\n     y = 36134250956749795798585127919587881956611106672985015071877198253568414405109,\n     z = 1}\n\ntype q = 115792089210356248762697446949407573529996955224135760342422259061068512044369\n\nmp_mod_sqrt : Z p -> Z p\nmp_mod_sqrt c = r'' ^^ (2 ^^ 94)\n  where t1  = (c ^^ 2) * c\n        t2  = (t1 ^^ (2 ^^ 2)) * t1\n        t3  = (t2 ^^ (2 ^^ 4)) * t2\n        t4  = (t3 ^^ (2 ^^ 8)) * t3\n        r   = (t4 ^^ (2 ^^ 16)) * t4\n        r'  = (r ^^ (2 ^^ 32)) * c\n        r'' = (r' ^^ (2 ^^ 96)) * c\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA_tests.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::ECDSA_tests where\n\nimport Common::utils\n\nimport Primitive::Asymmetric::Signature::ECDSA::p192 as p192\nimport Primitive::Asymmetric::Signature::ECDSA::p224 as p224\nimport Primitive::Asymmetric::Signature::ECDSA::p256 as p256\nimport Primitive::Asymmetric::Signature::ECDSA::p384 as p384\nimport Primitive::Asymmetric::Signature::ECDSA::p521 as p521\n\n\n\/\/p192 tests\n\nproperty p192_G_compress = p192::G_compress 0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\n\np192_S = {x = BVtoZ 0xd458e7d127ae671b0c330266d246769353a012073e97acf8,\n          y = BVtoZ 0x325930500d851f336bddc050cf7fb11b5673a1645086df3b}\n\np192_T = {x = BVtoZ 0xf22c4395213e9ebe67ddecdd87fdbd01be16fb059b9753a4,\n          y = BVtoZ 0x264424096af2b3597796db48f8dfb41fa9cecc97691a9c79}\n\nproperty p192_decompress_S = p192::affine_decompress_correct p192_S\nproperty p192_decompress_T = p192::affine_decompress_correct p192_T\n\nproperty p192_full_add_example =\n  p192::full_add_example R p192_S p192_T\n  where R = {x = BVtoZ 0x48e1e4096b9b8e5ca9d0f1f077b8abf58e843894de4d0290,\n             y = BVtoZ 0x408fa77c797cd7dbfb16aa48a3648d3d63c94117d7b6aa4b}\n\nproperty p192_full_subtract_example =\n  p192::full_subtract_example R p192_S p192_T\n  where R = {x = BVtoZ 0xfc9683cc5abfb4fe0cc8cc3bc9f61eabc4688f11e9f64a2e,\n             y = BVtoZ 0x093e31d00fb78269732b1bd2a73c23cdd31745d0523d816b}\n\nproperty p192_double_example =\n  p192::double_example R p192_S\n  where R = {x = BVtoZ 0x30c5bc6b8c7da25354b373dc14dd8a0eba42d25a3f6e6962,\n             y = BVtoZ 0x0dde14bc4249a721c407aedbf011e2ddbbcb2968c9d889cf}\n\nproperty p192_scalar_multiply_example0 =\n  p192::scalar_multiply_example R p192_S d\n  where d = BVtoZ 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        R = {x = BVtoZ 0x1faee4205a4f669d2d0a8f25e3bcec9a62a6952965bf6d31,\n             y = BVtoZ 0x5ff2cdfa508a2581892367087c696f179e7a4d7e8260fb06}\n\np192_S' = {x = BVtoZ 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012,\n           y = BVtoZ 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811}\n\nproperty p192_scalar_multiply_example1=\n    p192::scalar_multiply_example R p192_S' d\n    where d = BVtoZ 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3\n          R = {x = BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6,\n               y = BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477}\n\nproperty p192_joint_scalar_multiply_example =\n  p192::joint_scalar_multiply_example R p192_S p192_T d e\n  where d = BVtoZ 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        e = BVtoZ 0xc4be3d53ec3089e71e4de8ceab7cce889bc393cd85b972bc\n        R = {x = BVtoZ 0x019f64eed8fa9b72b7dfea82c17c9bfa60ecb9e1778b5bde,\n             y = BVtoZ 0x16590c5fcd8655fa4ced33fb800e2a7e3c61f35d83503644}\n\nproperty mp_mod_sqrt_192_correct = p192::mp_mod_sqrt_correct\n\n\n\/\/p224 tests\n\nproperty p224_G_compress = p224::G_compress 0x00000002b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\n\np224_S = {x = BVtoZ 0x6eca814ba59a930843dc814edd6c97da95518df3c6fdf16e9a10bb5b,\n          y = BVtoZ 0xef4b497f0963bc8b6aec0ca0f259b89cd80994147e05dc6b64d7bf22}\n\np224_T = {x = BVtoZ 0xb72b25aea5cb03fb88d7e842002969648e6ef23c5d39ac903826bd6d,\n          y = BVtoZ 0xc42a8a4d34984f0b71b5b4091af7dceb33ea729c1a2dc8b434f10c34}\n\nproperty p224_full_add_example =\n  p224::full_add_example R p224_S p224_T\n  where R = {x = BVtoZ 0x236f26d9e84c2f7d776b107bd478ee0a6d2bcfcaa2162afae8d2fd15,\n             y = BVtoZ 0xe53cc0a7904ce6c3746f6a97471297a0b7d5cdf8d536ae25bb0fda70}\n\nproperty p224_full_subtract_example =\n  p224::full_subtract_example R p224_S p224_T\n  where R = {x = BVtoZ 0xdb4112bcc8f34d4f0b36047bca1054f3615413852a7931335210b332,\n             y = BVtoZ 0x90c6e8304da4813878c1540b2396f411facf787a520a0ffb55a8d961}\n\nproperty p224_double_example =\n  p224::double_example R p224_S\n  where R = {x = BVtoZ 0xa9c96f2117dee0f27ca56850ebb46efad8ee26852f165e29cb5cdfc7,\n             y = BVtoZ 0xadf18c84cf77ced4d76d4930417d9579207840bf49bfbf5837dfdd7d}\n\nproperty p224_scalar_multiply_example =\n  p224::scalar_multiply_example R p224_S d\n  where d = BVtoZ 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        R = {x = BVtoZ 0x96a7625e92a8d72bff1113abdb95777e736a14c6fdaacc392702bca4,\n             y = BVtoZ 0x0f8e5702942a3c5e13cd2fd5801915258b43dfadc70d15dbada3ed10}\n\nproperty p224_joint_scalar_multiply_example =\n  p224::joint_scalar_multiply_example R p224_S p224_T d e\n  where d = BVtoZ 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        e = BVtoZ 0x54d549ffc08c96592519d73e71e8e0703fc8177fa88aa77a6ed35736\n        R = {x = BVtoZ 0xdbfe2958c7b2cda1302a67ea3ffd94c918c5b350ab838d52e288c83e,\n             y = BVtoZ 0x2f521b83ac3b0549ff4895abcc7f0c5a861aacb87acbc5b8147bb18b}\n\nproperty mp_mod_sqrt_224_correct = p224::mp_mod_sqrt_correct\n\n\n\/\/p256 tests\n\nproperty p256_G_compress = p256::G_compress 0x000000036b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\n\np256_S = {x = BVtoZ 0xde2444bebc8d36e682edd27e0f271508617519b3221a8fa0b77cab3989da97c9,\n          y = BVtoZ 0xc093ae7ff36e5380fc01a5aad1e66659702de80f53cec576b6350b243042a256}\n\np256_T = {x = BVtoZ 0x55a8b00f8da1d44e62f6b3b25316212e39540dc861c89575bb8cf92e35e0986b,\n          y = BVtoZ 0x5421c3209c2d6c704835d82ac4c3dd90f61a8a52598b9e7ab656e9d8c8b24316}\n\nproperty p256_full_add_example =\n  p256::full_add_example R p256_S p256_T\n  where R = {x = BVtoZ 0x72b13dd4354b6b81745195e98cc5ba6970349191ac476bd4553cf35a545a067e,\n             y = BVtoZ 0x8d585cbb2e1327d75241a8a122d7620dc33b13315aa5c9d46d013011744ac264}\n\nproperty p256_full_subtract_example =\n  p256::full_subtract_example R p256_S p256_T\n  where R = {x = BVtoZ 0xc09ce680b251bb1d2aad1dbf6129deab837419f8f1c73ea13e7dc64ad6be6021,\n             y = BVtoZ 0x1a815bf700bd88336b2f9bad4edab1723414a022fdf6c3f4ce30675fb1975ef3}\n\nproperty p256_double_example =\n  p256::double_example R p256_S\n  where R = {x = BVtoZ 0x7669e6901606ee3ba1a8eef1e0024c33df6c22f3b17481b82a860ffcdb6127b0,\n             y = BVtoZ 0xfa878162187a54f6c39f6ee0072f33de389ef3eecd03023de10ca2c1db61d0c7}\n\nproperty p256_scalar_multiply_example =\n  p256::scalar_multiply_example R p256_S d\n  where d = BVtoZ 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        R = {x = BVtoZ 0x51d08d5f2d4278882946d88d83c97d11e62becc3cfc18bedacc89ba34eeca03f,\n             y = BVtoZ 0x75ee68eb8bf626aa5b673ab51f6e744e06f8fcf8a6c0cf3035beca956a7b41d5}\n\nproperty p256_joint_scalar_multiply_example =\n  p256::joint_scalar_multiply_example R p256_S p256_T d e\n  where d = BVtoZ 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        e = BVtoZ 0xd37f628ece72a462f0145cbefe3f0b355ee8332d37acdd83a358016aea029db7\n        R = {x = BVtoZ 0xd867b4679221009234939221b8046245efcf58413daacbeff857b8588341f6b8,\n             y = BVtoZ 0xf2504055c03cede12d22720dad69c745106b6607ec7e50dd35d54bd80f615275}\n\nproperty mp_mod_sqrt_256_correct = p256::mp_mod_sqrt_correct\n\n\n\/\/p384 tests\n\nproperty p384_G_compress = p384::G_compress 0x00000003aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\n\np384_S = {x = BVtoZ 0xfba203b81bbd23f2b3be971cc23997e1ae4d89e69cb6f92385dda82768ada415ebab4167459da98e62b1332d1e73cb0e,\n          y = BVtoZ 0x5ffedbaefdeba603e7923e06cdb5d0c65b22301429293376d5c6944e3fa6259f162b4788de6987fd59aed5e4b5285e45}\n\np384_T = {x = BVtoZ 0xaacc05202e7fda6fc73d82f0a66220527da8117ee8f8330ead7d20ee6f255f582d8bd38c5a7f2b40bcdb68ba13d81051,\n          y = BVtoZ 0x84009a263fefba7c2c57cffa5db3634d286131afc0fca8d25afa22a7b5dce0d9470da89233cee178592f49b6fecb5092}\n\nproperty p384_full_add_example =\n  p384::full_add_example R p384_S p384_T\n  where R = {x = BVtoZ 0x12dc5ce7acdfc5844d939f40b4df012e68f865b89c3213ba97090a247a2fc009075cf471cd2e85c489979b65ee0b5eed,\n             y = BVtoZ 0x167312e58fe0c0afa248f2854e3cddcb557f983b3189b67f21eee01341e7e9fe67f6ee81b36988efa406945c8804a4b0}\n\nproperty p384_full_subtract_example =\n  p384::full_subtract_example R p384_S p384_T\n  where R = {x = BVtoZ 0x6afdaf8da8b11c984cf177e551cee542cda4ac2f25cd522d0cd710f88059c6565aef78f6b5ed6cc05a6666def2a2fb59,\n             y = BVtoZ 0x7bed0e158ae8cc70e847a60347ca1548c348decc6309f48b59bd5afc9a9b804e7f7876178cb5a7eb4f6940a9c73e8e5e}\n\nproperty p384_double_example =\n  p384::double_example R p384_S\n  where R = {x = BVtoZ 0x2a2111b1e0aa8b2fc5a1975516bc4d58017ff96b25e1bdff3c229d5fac3bacc319dcbec29f9478f42dee597b4641504c,\n             y = BVtoZ 0xfa2e3d9dc84db8954ce8085ef28d7184fddfd1344b4d4797343af9b5f9d837520b450f726443e4114bd4e5bdb2f65ddd}\n\nproperty p384_scalar_multiply_example =\n  p384::scalar_multiply_example R p384_S d\n  where d = BVtoZ 0xa4ebcae5a665983493ab3e626085a24c104311a761b5a8fdac052ed1f111a5c44f76f45659d2d111a61b5fdd97583480\n        R = {x = BVtoZ 0xe4f77e7ffeb7f0958910e3a680d677a477191df166160ff7ef6bb5261f791aa7b45e3e653d151b95dad3d93ca0290ef2,\n             y = BVtoZ 0xac7dee41d8c5f4a7d5836960a773cfc1376289d3373f8cf7417b0c6207ac32e913856612fc9ff2e357eb2ee05cf9667f}\n\nproperty p384_joint_scalar_multiply_example =\n  p384::joint_scalar_multiply_example R p384_S p384_T d e\n  where d = BVtoZ 0xa4ebcae5a665983493ab3e626085a24c104311a761b5a8fdac052ed1f111a5c44f76f45659d2d111a61b5fdd97583480\n        e = BVtoZ 0xafcf88119a3a76c87acbd6008e1349b29f4ba9aa0e12ce89bcfcae2180b38d81ab8cf15095301a182afbc6893e75385d\n        R = {x = BVtoZ 0x917ea28bcd641741ae5d18c2f1bd917ba68d34f0f0577387dc81260462aea60e2417b8bdc5d954fc729d211db23a02dc,\n             y = BVtoZ 0x1a29f7ce6d074654d77b40888c73e92546c8f16a5ff6bcbd307f758d4aee684beff26f6742f597e2585c86da908f7186}\n\nproperty mp_mod_sqrt_384_correct = p384::mp_mod_sqrt_correct\n\n\n\/\/p521 tests\n\nproperty p521_G_compress = p521::G_compress 0x04c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\n\np521_S = {x = BVtoZ 0x000001d5c693f66c08ed03ad0f031f937443458f601fd098d3d0227b4bf62873af50740b0bb84aa157fc847bcf8dc16a8b2b8bfd8e2d0a7d39af04b089930ef6dad5c1b4,\n          y = BVtoZ 0x00000144b7770963c63a39248865ff36b074151eac33549b224af5c8664c54012b818ed037b2b7c1a63ac89ebaa11e07db89fcee5b556e49764ee3fa66ea7ae61ac01823}\n\np521_T = {x = BVtoZ 0x000000f411f2ac2eb971a267b80297ba67c322dba4bb21cec8b70073bf88fc1ca5fde3ba09e5df6d39acb2c0762c03d7bc224a3e197feaf760d6324006fe3be9a548c7d5,\n          y = BVtoZ 0x000001fdf842769c707c93c630df6d02eff399a06f1b36fb9684f0b373ed064889629abb92b1ae328fdb45534268384943f0e9222afe03259b32274d35d1b9584c65e305}\n\nproperty p521_full_add_example =\n  p521::full_add_example R p521_S p521_T\n  where R = {x = BVtoZ 0x000001264ae115ba9cbc2ee56e6f0059e24b52c8046321602c59a339cfb757c89a59c358a9a8e1f86d384b3f3b255ea3f73670c6dc9f45d46b6a196dc37bbe0f6b2dd9e9,\n             y = BVtoZ 0x00000062a9c72b8f9f88a271690bfa017a6466c31b9cadc2fc544744aeb817072349cfddc5ad0e81b03f1897bd9c8c6efbdf68237dc3bb00445979fb373b20c9a967ac55}\n\nproperty p521_full_subtract_example =\n  p521::full_subtract_example R p521_S p521_T\n  where R = {x = BVtoZ 0x000001292cb58b1795ba477063fef7cd22e42c20f57ae94ceaad86e0d21ff22918b0dd3b076d63be253de24bc20c6da290fa54d83771a225deecf9149f79a8e614c3c4cd,\n             y = BVtoZ 0x000001695e3821e72c7cacaadcf62909cd83463a21c6d03393c527c643b36239c46af117ab7c7ad19a4c8cf0ae95ed51729885461aa2ce2700a6365bca3733d2920b2267}\n\nproperty p521_double_example =\n  p521::double_example R p521_S\n  where R = {x = BVtoZ 0x0000012879442f2450c119e7119a5f738be1f1eba9e9d7c6cf41b325d9ce6d643106e9d61124a91a96bcf201305a9dee55fa79136dc700831e54c3ca4ff2646bd3c36bc6,\n             y = BVtoZ 0x0000019864a8b8855c2479cbefe375ae553e2393271ed36fadfc4494fc0583f6bd03598896f39854abeae5f9a6515a021e2c0eef139e71de610143f53382f4104dccb543}\n\nproperty p521_scalar_multiply_example =\n  p521::scalar_multiply_example R p521_S d\n  where d = BVtoZ 0x000001eb7f81785c9629f136a7e8f8c674957109735554111a2a866fa5a166699419bfa9936c78b62653964df0d6da940a695c7294d41b2d6600de6dfcf0edcfc89fdcb1\n        R = {x = BVtoZ 0x00000091b15d09d0ca0353f8f96b93cdb13497b0a4bb582ae9ebefa35eee61bf7b7d041b8ec34c6c00c0c0671c4ae063318fb75be87af4fe859608c95f0ab4774f8c95bb,\n             y = BVtoZ 0x00000130f8f8b5e1abb4dd94f6baaf654a2d5810411e77b7423965e0c7fd79ec1ae563c207bd255ee9828eb7a03fed565240d2cc80ddd2cecbb2eb50f0951f75ad87977f}\n\nproperty p521_joint_scalar_multiply_example =\n  p521::joint_scalar_multiply_example R p521_S p521_T d e\n  where d = BVtoZ 0x000001eb7f81785c9629f136a7e8f8c674957109735554111a2a866fa5a166699419bfa9936c78b62653964df0d6da940a695c7294d41b2d6600de6dfcf0edcfc89fdcb1\n        e = BVtoZ 0x00000137e6b73d38f153c3a7575615812608f2bab3229c92e21c0d1c83cfad9261dbb17bb77a63682000031b9122c2f0cdab2af72314be95254de4291a8f85f7c70412e3\n        R = {x = BVtoZ 0x0000009d3802642b3bea152beb9e05fba247790f7fc168072d363340133402f2585588dc1385d40ebcb8552f8db02b23d687cae46185b27528adb1bf9729716e4eba653d,\n             y = BVtoZ 0x0000000fe44344e79da6f49d87c1063744e5957d9ac0a505bafa8281c9ce9ff25ad53f8da084a2deb0923e46501de5797850c61b229023dd9cf7fc7f04cd35ebb026d89d}\n\nproperty mp_mod_sqrt_521_correct = p521::mp_mod_sqrt_correct\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA_sign_tests.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::ECDSA_sign_tests where\nimport Common::utils\nimport Primitive::Asymmetric::Signature::ECDSA::p192\n\n\n\/\/p192 SHA1 signing tests\n\ntestCase0 = {\nMsg = BVtoZ 0x608079423f12421de616b7493ebe551cf4d65b92, \/\/ Message digest\nd = BVtoZ 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3,\nk = BVtoZ 0xcb0abc7043a10783684556fb12c4154d57bc31a289685f25,\nQx = BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6,\nQy = BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477,\nR = BVtoZ 0x6994d962bdd0d793ffddf855ec5bf2f91a9698b46258a63e,\nS = BVtoZ 0x02ba6465a234903744ab02bc8521405b73cf5fc00e1a9f41 }\n\ntestCase1 = {\nMsg = BVtoZ 0x98cff299c35616bfd081543998a5a367b43214e1,\nd = BVtoZ 0x7a0235bea3d70445f14d56f9b7fb80ec8ff4eb2f76865244,\nQx = BVtoZ 0x0ea3c1fa1f124f26530cbfddeb831eecc67df31e08889d1d,\nQy = BVtoZ 0x7215a0cce0501b47903bd8fe1179c2dfe07bd076f89f5225,\nk = BVtoZ 0x3c646b0f03f5575e5fd463d4319817ce8bd3022eaf551cef,\nR = BVtoZ 0xa3ba51c39c43991d87dff0f34d0bec7c883299e04f60f95e,\nS = BVtoZ 0x8a7f9c59c6d65ad390e4c19636ba92b53be5d0f848b4e1f7 }\n\nproperty test192 = and [((i.R, i.S) == (sign i.d i.Msg i.k)) | i <- [ testCase0, testCase1] ]\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p384.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::p384 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\ntype p = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\n\nb = 27580193559959705877849011840389048093056905856361568521428707301988689241309860865136260764883745107765439761230575\n\nG = {x = 26247035095799689268623156744566981891852923491109213387815615900925518854738050089022388053975719786650872476732087,\n     y = 8325710961489029985546751289520108179287853048861315594709205902480503199884419224438643760392947333078086511627871,\n     z = 1}\n\ntype q = 39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643\n\nmp_mod_sqrt : Z p -> Z p\nmp_mod_sqrt c = r''' ^^ (2 ^^ 30)\n  where t1    = (c ^^ 2) * c\n        t2    = (t1 ^^ (2 ^^ 2)) * t1\n        t2'   = (t2 ^^ 2) * c\n        t3    = (t2' ^^ (2 ^^ 5)) * t2'\n        t4    = (t3 ^^ (2 ^^ 5)) * t2'\n        t2''  = (t4 ^^ (2 ^^ 15)) * t4\n        t3'   = t2'' ^^ (2 ^^ 2)\n        t1'   = t3' * t1\n        t3''  = t3' ^^ (2 ^^ 28)\n        t2''' = t2'' * t3''\n        t3''' = (t2''' ^^ (2 ^^ 60)) * t2'''\n        r     = (t3''' ^^ (2 ^^ 120)) * t3'''\n        r'    = (r ^^ (2 ^^ 15)) * t4\n        r''   = (r' ^^ (2 ^^ 33)) * t1'\n        r'''  = (r'' ^^ (2 ^^ 64)) * c\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p192.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::p192 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\ntype p = 6277101735386680763835789423207666416083908700390324961279\n\nb = 2455155546008943817740293915197451784769108058161191238065\n\nG = {x = 602046282375688656758213480587526111916698976636884684818,\n     y = 174050332293622031404857552280219410364023488927386650641,\n     z = 1}\n\ntype q = 6277101735386680763835789423176059013767194773182842284081\n\nmp_mod_sqrt c = r''\n  where t1 = c ^^ 2         ; t1' = t1 * c\n        t2 = t1' ^^ (2^^2)  ; t2' = t2 * t1'\n        t3 = t2' ^^ (2^^4)  ; t3' = t3 * t2'\n        t4 = t3' ^^ (2^^8)  ; t4' = t4 * t3'\n        t5 = t4' ^^ (2^^16) ; t5' = t5 * t4'\n        t6 = t5' ^^ (2^^32) ; t6' = t6 * t5'\n        r  = t6' ^^ (2^^64) ; r'  = r * t6'\n        r'' = r' ^^ (2^^62)\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p224.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::ECDSA::p224 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\nimport Common::utils\n\ntype p = 26959946667150639794667015087019630673557916260026308143510066298881\n\nb = 18958286285566608000408668544493926415504680968679321075787234672564\n\nG = {x = 19277929113566293071110308034699488026831934219452440156649784352033,\n     y = 19926808758034470970197974370888749184205991990603949537637343198772,\n     z = 1}\n\ntype q = 26959946667150639794667015087019625940457807714424391721682722368061\n\nmp_mod_sqrt : Z p -> Z p\nmp_mod_sqrt c = r\n  where s = random (ZtoBV c)\n        (d0, e0, f0) = RP c s\n        (d1, e1, f1) = RS d0 e0 f0\n        state = [(d1, e1, f1)] #\n                [ if d1' == 0 then (d, e, f) else (d1', e1', f1')\n                  where (d1', e1', f1') = RS d e f\n                | (d, e, f) <- state ]\n        (d0', e0', _) = state@95\n        r = d0' * (mp_mod_inv e0')\n\nprivate\n\n  RS : Z p -> Z p -> Z p -> (Z p, Z p, Z p)\n  RS d0 e0 f0 = (d1, e1', f1'')\n    where t    = d0 ^^ 2\n          e1   = d0 * e0\n          d1   = t + f0\n          e1'  = e1 + e1\n          f1   = t * f0\n          f1'  = f1 + f1\n          f1'' = f1' + f1'\n\n  RSS : Z p -> Z p -> Z p -> [7] -> (Z p, Z p, Z p)\n  RSS d0 e0 f0 j = (d1, e1, f1)\n    where (d1, e1, f1) = state@j\n          state = [(d0, e0, f0)] # [ RS d e f | (d, e, f) <- state ]\n\n  RM : Z p -> Z p -> Z p -> Z p -> Z p -> (Z p, Z p, Z p)\n  RM c d0 e0 d1 e1 = (d2, e2', f2'')\n    where t1    = e0 * e1\n          t1'   = t1 * c\n          t1''  = -t1'\n          t2    = d0 * d1\n          t2'   = t2 + t1''\n          t1''' = d0 * e1\n          e2    = d1 * e0\n          e2'   = e2 + t1'''\n          f2    = e2' ^^ 2\n          f2'   = f2 * c\n          f2''  = -f2'\n          d2    = t2'\n\n  RP : Z p -> Z p -> (Z p, Z p, Z p)\n  RP c r = (d1, e1, f1)\n    where (d1, e1, f1) = state!0\n          state = [(r, 1, -c)] # [ body d e f i | (d, e, f) <- state | i <- [0..6] ]\n          body d0 e0 f0 i = (d1'', e1'', f1'')\n            where (d1', e1', _) = RSS d0 e0 f0 (2^^i)\n                  (d1'', e1'', f1'') = RM c d1' e1' d0 e0\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DSA\/DSA.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::DSA::DSA where\nimport Common::mod_arith\nimport Common::utils\n\n\nsign : Z q -> Z q -> Z q -> (Z q, Z q)\nsign x k z = (r, s)\n    where r =  ZtoZ (BVtoZ `{p=p}(mod_pow (pv, g', k')))\n          pv = ZtoBV `{1+p,L} `p\n          g' = ZtoBV `{a=L} g\n          k' = ZtoBV `{a=L} (ZtoZ `{q=q} k)\n          s = BVtoZ `{p=q}  (mod_mul (q', (ZtoBV `{a=N} kinv), zpxr))\n          kinv = mp_mod_inv k\n          xr = mod_mul(q', x', r')\n          zpxr = mod_add(q', xr, z')\n          r' = ZtoBV `{a=N} r\n          x' = ZtoBV `{a=N} x\n          z' = ZtoBV `{a=N} z\n          q' = ZtoBV `{1+q,N} `q\n\n\nverify : Z p -> Z q -> (Z q, Z q) -> Bit\nverify y z (r, s) = ((BVtoZ `{p=q} v) == r)\n   where w = (mp_mod_inv s)\n         u1 = (zero#mod_mul (q', (ZtoBV z), (ZtoBV w))) :[L]\n         u2 = (zero#mod_mul (q', (ZtoBV r), (ZtoBV w))) :[L]\n         v = mod_mul (pv, gu1, yu2)\n         gu1 =  mod_pow(pv, g', u1)\n         yu2 =  mod_pow(pv, y', u2)\n         pv = ZtoBV `{1+p,L} `p\n         g' = ZtoBV `{a=L} g\n         y' = ZtoBV `{a=L} y\n         q' = ZtoBV `{1+q,N} `q\n\n\nparameter\n\n    type p : #\n    type constraint Constraints p\n\n    g : Z p\n\n    type q : #\n\n    type constraint (fin q, isOdd q, q >= 4)\n\n\/\/ NIST recommended bit lengths of p and q\n\/\/L: the size of p, N: the size of q\n\n    type L : #\n\n    type N : #\n\/\/Comment\/uncomment according to the instantiated parameters\n    \/\/type constraint (L==1024,N==160)\n    type constraint (L==2048,N==224)\n    \/\/type constraint (L==2048,N==256)\n    \/\/type constraint (L==3072,N==256)\n\n\n\n\n\nprivate\n\n    type constraint Constraints a = (fin a, isOdd a, a >= 4)\n    \/\/type constraint validPsize L x = (L==1024*x, 2>=x)\n    \/\/type constraint validQsize N = (N==160) \/\/N==224, N==256\n\n\nproperty signDsaCorrect x k z = (verify (BVtoZ `{p=p} (mod_pow ((ZtoBV `{1+p,L} `p), ZtoBV `{a=L} g, (zero#(ZtoBV`{p=q}x):[L])))) z (sign x k z) ) == True\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/trash\/DilithiumBv.cry","filetype":"cry","content":"module Primitive::Asymmetric::Signature::DilithiumBV where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Common::mod_arith\nimport Primitive::Asymmetric::Cipher::RSA\nimport Primitive::Asymmetric::Signature::testDilithium\n\n\n\/\/ DilithiumII parameters\n\/\/ Security level - Medium\ntype qbits = 23\ntype uint32_t = 32\ntype q = 0x7fe001 type n = 0x100 d = 0xe\nwc= 0x3c gamma1 = ((`q) - 1) \/ 16:[_]\ngamma2 = (gamma1\/2):[_]\nalpha = (2*gamma2):[_]\n\n\/\/ Parameters for Number Theoretic Transform (NTT)\nrootOfUnity    = 1753 :[_]\nrootOfUnityInv = 731434 : [_]\nninv           = 8347681 : [_]\n\n\/\/Parameterize\nparameter\n    type k : #\n    type constraint (fin k, k>=3, k <=6)\n    type l : #\n    type constraint (fin l, l>=2, l<=5)\n    eta : [4]\n    beta : [12]\n    omega : [8]\n\n\/\/ Integer polynomials; a superset of ring R referenced in specification\ntype intPoly        = [n][uint32_t]\ntype intPolyVec dim = [dim]intPoly\n\n\/\/ Polynomials; a superset of ring R_q referenced in specification\ntype poly        = [n][qbits] \/\/ This is R_q, actually defines a super set of R_q\ntype polyVec dim = [dim]poly\n\n\/\/ Polynomials in NTT representation\ntype nttPoly          = [n][qbits]\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k}\ntype SecretKey = {rho : [256]\n                    , K  : [256]\n                    , tr : [384]\n                    , s1 : polyVec l\n                    , s2 : polyVec k\n                    , t0 : intPolyVec k}\ntype SEEDBYTES = 32\n\n\/* Generate public and private keys *\/\n\/\/Gen : [SEEDBYTES*8] -> (PublicKey,SecretKey)\nGen seed = A\n    where\n      randoms = split`{3} (join (SHA3::toBytes (take`{768} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))\n      (rho, rho', K) = (randoms@0, randoms@1, randoms@2)\n      A       = ExpandA rho\n      s1      = PolyUniformEtaV`{dim=l} rho' zero\n\nprivate\n    pack_w : intPolyVec k -> [4*n*k]\n    pack_w w = join [pack_poly p | p <- wBV ]\n        where\n        wBV = map (\\p -> map (\\x -> drop`{24} x:[8]) p) w\n\n        pack2 : [2][8] -> [8]\n        pack2 xs = xs@0 || (xs@1 << 4)\n\n        pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\n\/\/ Only works when n=256\nPolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [8] -> polyVec dim\nPolyUniformEtaV rho nonce = [PolyUniformEta rho (nonce + j) | j <- [0..(dim-1)]:[dim][8]]\n\nPolyUniformEta : [SEEDBYTES*8] -> [8] -> poly\nPolyUniformEta rho nonce = map (\\x -> (zero#eta:[23]) - x) (map (\\x-> (zero#x):[23]) (take`{n} withinEta))\n    where\n    seed = rho#nonce\n    randoms = ((join (SHA3::toBytes (take`{2*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))#zero)\n    withinEta = randomsInRangeDouble genS (2*eta) randoms\n\ngenS : [8] -> [2][4]\ngenS byte = [t0, t1]\n    where\n    t0 = drop`{4} (byte && 0x0F)\n    t1 = drop`{4} (byte >> 4)\n\n\n\nH : ([384],intPolyVec k) -> poly\nH (mu,w) = map fromInteger (SampleInBall ss samples)\n    where\n    w_packed = pack_w w\n    randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n    ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n    extByte : [8] -> [8]\n    extByte x = x\n\n    samples : [60][8]\n    samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\n\nSampleInBall : [60] -> [60][8] -> [256]Integer\nSampleInBall signs jsamples = ys ! 0\n    where\n    ys = [ zero:[256]Integer ]\n        #    [ if i==j then update y i ((-1:Integer)^^(toInteger [s]))\n            else updates y [j,i] [(-1:Integer)^^(toInteger [s]),y@j] | i <- [196..255]\n        | j <- jsamples\n        | s <- signs\n        | y <- ys\n        ]\n\n\nExpandMask : ([SEEDBYTES*8], [384], Integer) -> polyVec l\nExpandMask  (K, mu, kappa) = [samplePoly K mu kappa i `l | i <- [0..(l-1)] ]\n\n\nsamplePoly : [256] -> [384] -> Integer -> Integer -> Integer -> poly\nsamplePoly K mu kappa i dim = [ (`q + (zero#gamma1:[23]) - (zero#1:[23]) - (zero#vj:[23])) | vj <- coeffs]\n    where\n    (upper:[20])      =  drop`{3}(2*gamma1-2):[20]\n    kappaBytes = join (reverse (split (fromInteger (dim*kappa+i):[16]):[2][8])) \/\/ LEB order\n    s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes (K#mu#kappaBytes)))))) \/\/ checked\n    (coeffs:[n][20])   = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\n\nextractPolyElt : [40] -> [2][20]\nextractPolyElt bits = [zero#int1, zero#int2]\n    where\n    [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n    int1 = b2'*2^^16 + b1*2^^8 +  b0\n    int2 = b4*2^^12 + b3*2^^4 +  b2''\n    b2'  = b2 && 15\n    \/\/b2'' = b2\/(16:[20])\n    b2'' = b2\/16\n\n\/\/ seed should be in little endian byte order\nCRH : {b} (fin b, b>=1) => [b*8] -> [384]\nCRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\n\nExpandA : [SEEDBYTES*8] -> [k][l]nttPoly\nExpandA rho = [ [elt i j | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n    where\n    elt i j = matrixPoly rho i j\n\n\nmatrixPoly : [SEEDBYTES*8] -> [width k] -> [width l] -> nttPoly\nmatrixPoly rho i j = take`{n} [ drop`{1} elt | elt <- randomElts ]\n    where\n    randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n    s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n    b          = 2^^4*(zero#j:[8])+(zero#i:[8])\n\n\nextractMatElt : [24] -> [24]\nextractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n    where\n    [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n    b2' = (2^^23-1) && b2 \/\/ Typo in paper; following C implementation\n\n\nrandomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\nrandomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                             then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                             else randomsInRange createElt upperCrit randomTail\n                    where\n                    elt        = createElt (take`{a} randoms)\n                    randomTail = drop`{a} randoms\n\nrandomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\nrandomsInRanges createElt uppers randoms =\n                                            if elt <= head uppers\n                                            then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                                            else randomsInRanges createElt uppers randomTail\n                                where\n                                elt          = createElt (take`{a} randoms)\n                                randomTail   = drop`{a} randoms\n                                uppersRotate = uppers <<< 1\n\n\nrandomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\n\/*randomsInRangeDouble createElt upper randoms =\nif (elts@0 <= upper) \/\\ (elts@1 <= upper)\nthen  elts#(randomsInRangeDouble createElt upper randomTail)\nelse\nif (elts@0 <= upper)\nthen [ elts@0 ]#(randomsInRangeDouble createElt upper randomTail)\nelse\nif (elts@1 <= upper)\nthen [ elts@1 ]#(randomsInRangeDouble createElt upper randomTail)\nelse randomsInRangeDouble createElt upper randomTail\nwhere\nelts       = createElt (take`{2*a} randoms)\nrandomTail = drop`{2*a} randoms*\/\n\/\/ Correction and checked with the C code\nrandomsInRangeDouble createElt upper randoms =\n                                    if (elts@1 <= upper) then [elts@1, elts@1] # (randomsInRangeDouble createElt upper randomTail)\n                                    else (randomsInRangeDouble createElt upper randomTail)\n            where\n            elts       = createElt (take`{2*a} randoms)\n            randomTail = drop`{2*a} randoms\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/ref_ec_mul.cry","filetype":"cry","content":"module Common::EC::ref_ec_mul where\n\nimport Common::EC::ec_point_ops\n\n\/* Multiplies a large word scalar by the an affine point. *\/\nec_mul : {fv, gv}  (fin gv) => (PointOps fv [gv], [gv], AffinePoint fv) -> JacobianPoint fv\nec_mul (m, d, s) = res!0\n  where\n    k = [False, False] # d\n    h = k + (k + k)\n    res : [gv+2](JacobianPoint fv)\n    res = [(ec_zero_point(m.field))]\n          #  [ if hi && ~ki then\n                 m.add(m.double(r), s)\n               else if ~hi && ki then\n                 m.sub(m.double(r), s)\n               else\n                 m.double(r)\n             | hi <- take`{back=1} h\n             | ki <- take`{back=1} k\n             | r  <- res\n             ]\n\nec_twin_mul_aux1 : {fv, gv} (fin gv, gv >= 4) =>\n  (PointOps fv [gv], JacobianPoint fv, [32], [32],\n   AffinePoint fv, AffinePoint fv, AffinePoint fv, AffinePoint fv)\n  -> (JacobianPoint fv)\nec_twin_mul_aux1(m,rP,u0,u1,sPt,s,sMt,t) = r\n  where\n   f = m.field\n   r = if u0 == -1 then\n         (if      u1 == -1 then m.sub(r2, sPt)\n          else if u1 ==  0 then m.sub(r2, s)\n          else                  m.sub(r2, sMt))\n       else if u0 == 0 then\n         (if      u1 == -1 then m.sub(r2, t)\n          else if u1 ==  1 then m.add(r2, t)\n          else                  r2)\n       else\n         (if      u1 == -1 then m.add(r2, sMt)\n          else if u1 ==  0 then m.add(r2, s)\n          else                  m.add(r2, sPt))\n   r2 = m.double(rP)\n\nF : {a} (fin a, a>=5) => [a] -> [a]\nF(t) = if (18 <= t) && (t < 22) then\n          9\n       else if (14 <= t) && (t < 18) then\n         10\n       else if (22 <= t) && (t < 24) then\n         11\n       else if (4 <= t) && (t < 12) then\n         14\n       else\n         12\n\n\/* Return d0 * S + d1 * T. All points projective, 0 <= d0, d1 < p. *\/\nec_twin_mul : {fv, gv} (fin gv)\n            => (PointOps fv [gv+4], [gv+4], AffinePoint fv, [gv+4], AffinePoint fv)\n            -> (JacobianPoint fv)\nec_twin_mul(m, d0, s, d1, t) =\n  if ec_is_zero_point(f, sPtP) then \/* s + t = 0 *\/\n    ec_mul(m, g.sub(d0, d1), s)\n  else if ec_is_zero_point(f, sMtP) then \/* s = t *\/\n    ec_mul(m, g.add(d0, d1), s)\n  else\n    drop`{gv+4}(r)@0\n where\n   f    = m.field\n   g    = m.group_field\n   sP   = ec_projectify(f, s)\n   sPtP = m.add(sP, t) \/* 1: ec_full_add (SpT, S, T) *\/\n   sMtP = m.sub(sP, t) \/* 2: ec_full_sub (SmT, S, T) *\/\n   sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z))\n   sPt  = { x = f.mul(g2, sPtP.x)\n          , y = f.mul(f.mul(gd, g2), sPtP.y)\n          }\n     where gd = f.mul(sMtP.z, sDiv)\n           g2 = f.sq(gd)\n   sMt  = { x = f.mul(g2, sMtP.x)\n          , y = f.mul(f.mul(gd, g2), sMtP.y)\n          }\n     where gd  = f.mul(sPtP.z, sDiv)\n           g2 = f.sq(gd)\n   init_c : [2][6]\n   init_c = [zero # (take(d0) : [4]), zero # (take(d1) : [4])]\n   c : [inf]_\n   c = [init_c]\n     # [ [[abs(u0) ^ c01, c02, c03, c04, c05, e0N],\n          [abs(u1) ^ c11, c12, c13, c14, c15, e1N]]\n          where\n            abs : {a} (fin a) => [a] -> Bit\n            abs(x) = x != zero\n       | [[c00, c01, c02, c03, c04, c05], [c10, c11, c12, c13, c14, c15]] <- c\n       | [u0, u1] <- u\n       | e0N <- (drop`{4}(d0)) # (zero : [inf])\n       | e1N <- (drop`{4}(d1)) # (zero : [inf])\n       ]\n   u : [inf]_\n   u = [ [u0, u1]\n            where\n              h0' = [c05, c04, c03, c02, c01]\n              h0 = if c00 then 31 - h0' else h0'\n              h1' = [c15, c14, c13, c12, c11]\n              h1 = if c10 then 31 - h1' else h1'\n              u0 : [32]\n              u0 = if h0 < F(h1) then 0 else if c00 then -1 else 1\n              u1 : [32]\n              u1 = if h1 < F(h0) then 0 else if c10 then -1 else 1\n       | [[c00, c01, c02, c03, c04, c05], [c10, c11, c12, c13, c14, c15]] <- c\n       ]\n   r : [inf]_\n   r = [(ec_zero_point f)]\n     # [ ec_twin_mul_aux1(m, rP, u0, u1, sPt, s, sMt, t)\n       | rP      <- r\n       | [u0, u1] <- u\n       ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/p384_ec_point_ops.cry","filetype":"cry","content":"module Common::EC::p384_ec_point_ops where\n\nimport Common::EC::ec_point_ops\nimport Common::EC::p384_field\n\np384_point_ops : PointOps [384] [384]\np384_point_ops = {\n    field  = p384_field\n  , double = p384_ec_double\n  , add    = p384_ec_full_add\n  , sub    = p384_ec_full_sub\n  , group_field = p384_group_field\n  }\n\np384_ec_double : JacobianPoint [384] -> JacobianPoint [384]\np384_ec_double(p) = ec_double(p384_field, p)\n\np384_ec_full_add : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384]\np384_ec_full_add(p,q) = ec_full_add(p384_point_ops, p, q)\n\np384_ec_full_sub : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384]\np384_ec_full_sub(p,q) = ec_full_sub(p384_point_ops, p, q)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/EC_P384.cry","filetype":"cry","content":"module Common::EC::EC_P384 where\n\nimport Common::ModDivZ\n\n\ntype w = 384\n\n\/\/ Prime modulus\ntype p = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\n\ntype FieldElement = Integer\n\n\/\/ Curve coefficients\na : FieldElement\na = -3\nb : FieldElement\nb = `0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\n\n\/\/ Curve generator point\nG : AffinePoint\nG =\n  { x = `0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\n  , y = `0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\n  }\n\n\/\/ Prime order of generator G\ntype n = 39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643\n\ntype Scalar = Integer\n\n\nR_p : FieldElement\nR_p = 340282367000166625977638945021017194497\nR_p_inv : FieldElement\nR_p_inv = 183479889321925461653251752109332205360611897149516305954304919627392402791260477631193651879713439593005062\n\nR_n : Scalar\nR_n = 1388124618062372383947042015309946732620727252194336364173\nR_n_inv : Scalar\nR_n_inv = 8213155180316830564023772752902517460134849974600554980379995049303147060140144611822562736815346652390458105321745\n\n\nfieldElementToBV : FieldElement -> [w]\nfieldElementToBV x = fromInteger x\n\nfieldElementFromBV : [w] -> FieldElement\nfieldElementFromBV x = toInteger x\n\nscalarToBV : Scalar -> [w]\nscalarToBV x = fromInteger x\n\nscalarFromBV : [w] -> Scalar\nscalarFromBV x = toInteger x\n\ninv0 : Scalar -> Scalar\ninv0 = undefined\n\ntype AffinePoint = { x : FieldElement, y : FieldElement }\n\nec_point_affine_add : AffinePoint -> AffinePoint -> AffinePoint\nec_point_affine_add = undefined\n\nec_point_affine_scalar_mul : Scalar -> AffinePoint -> AffinePoint\nec_point_affine_scalar_mul = undefined\n\n\nEC_keyPrivateToPublic : Integer -> AffinePoint\nEC_keyPrivateToPublic d = ec_point_affine_scalar_mul (d % `n) G\n\n\ntype ECDSA_Signature = { r : Scalar, s : Scalar }\n\nECDSA_sign : Scalar -> Integer -> Scalar -> ECDSA_Signature\nECDSA_sign d z k = { r = r, s = s }\n  where\n    { x = x1, y = _ } = ec_point_affine_scalar_mul k G\n    r =  x1 % `n\n    s = ((inv0 k) * (z + r * d)) % `n\n\nECDSA_verify : AffinePoint -> Integer -> ECDSA_Signature -> Bit\nECDSA_verify Q z { r = r, s = s } = r != 0 \/\\ r < `n \/\\ s != 0 \/\\ s < `n \/\\ r == x1 % `n\n  where\n    u1 = z * (inv0 s) % `n\n    u2 = r * (inv0 s) % `n\n    { x = x1, y = _ } = ec_point_affine_add (ec_point_affine_scalar_mul u1 G) (ec_point_affine_scalar_mul u2 Q)\n\n\nECDH_derive : Scalar -> AffinePoint -> FieldElement\nECDH_derive d Q = x % `p\n  where\n    { x = x, y = _ } = ec_point_affine_scalar_mul d Q\n\n\ntype JacobianPoint = { x : FieldElement, y : FieldElement, z : FieldElement }\n\ntoJacobian : AffinePoint -> JacobianPoint\ntoJacobian p = { x = p.x, y = p.y, z = 1 }\nfromJacobian : JacobianPoint -> AffinePoint\nfromJacobian p = undefined\n\n\nec_point_jacobian_add : JacobianPoint -> JacobianPoint -> JacobianPoint\nec_point_jacobian_add = undefined\n\nec_point_jacobian_scalar_mul : Scalar -> JacobianPoint -> JacobianPoint\nec_point_jacobian_scalar_mul = undefined\n\n\ntype JacobianBVPoint = { X : [w], Y : [w], Z : [w] }\n\njacobianToBV : JacobianPoint -> JacobianBVPoint\njacobianToBV p =\n  { X = fieldElementToBV p.x\n  , Y = fieldElementToBV p.y\n  , Z = fieldElementToBV p.z\n  }\n\njacobianFromBV : JacobianBVPoint -> JacobianPoint\njacobianFromBV p =\n  { x = fieldElementFromBV p.X\n  , y = fieldElementFromBV p.Y\n  , z = fieldElementFromBV p.Z\n  }\n\njacobianToMont : JacobianPoint -> JacobianPoint\njacobianToMont p =\n  { x = (p.x * P384_R_p) % `p\n  , y = (p.y * P384_R_p) % `p\n  , z = (p.z * P384_R_p) % `p\n  }\n\njacobianFromMont : JacobianPoint -> JacobianPoint\njacobianFromMont p =\n  { x = (p.x * P384_R_p_inv) % `p\n  , y = (p.y * P384_R_p_inv) % `p\n  , z = (p.z * P384_R_p_inv) % `p\n  }\n\njacobianToMontBV : JacobianPoint -> JacobianBVPoint\njacobianToMontBV p = jacobianToBV (jacobianToMont p)\n\njacobianFromMontBV : JacobianBVPoint -> JacobianPoint\njacobianFromMontBV p = jacobianFromMont (jacobianFromBV p)\n\n\nmont_R : {m} (fin m, m >= 3) => Integer\nmont_R = 2 ^^ `(width m) % `m\n\nmont_R_inv : {m} (fin m, m >= 3) => Integer\nmont_R_inv = fromZ (moddiv`{m} 1 (fromInteger (mont_R`{m})))\n\nbn_mont_n0 : {m} (fin m, m >= 3) => [64]\nbn_mont_n0 = fromInteger (((2 ^^ `(width m)) * mont_R_inv`{m} - 1) \/ `m)\n\n\ntype P384_w = w\ntype P384_p = p\nP384_a = a\nP384_b = b\nP384_G = G\nP384_G_Jacobian = toJacobian G\ntype P384_n = n\n\nP384_R_p = R_p\nP384_R_p_inv = R_p_inv\nP384_R_n = R_n\nP384_R_n_inv = R_n_inv\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/p384_ec_mul.cry","filetype":"cry","content":"module Common::EC::p384_ec_mul where\n\nimport Common::bv\nimport Common::mul_java\nimport Common::EC::ec_point_ops\nimport Common::EC::p384_field\nimport Common::EC::p384_ec_point_ops\nimport Common::EC::ref_ec_mul\n\n\/* Promote a finite sequence to an infinite sequence *\/\nmk_strm : {a, b} fin a => [a][b] -> [inf][b]\nmk_strm x = x # zero\n\n\/* Adds two n*m bit numbers split into m-bit segments and returns carry. *\/\nripple_adc : {m, n} (m >= 1, fin m, fin n) => ([n][m],[n][m]) -> ([n][m],Bit)\nripple_adc(xx,yy) = (values, carry_strm!0)\n  where\n    adc' : ([m],[m],Bit) -> (Bit,[m])\n    adc'(x,y,c) = (sum3@0, drop(sum3))\n      where sum3 = safe_add(x,y) + zext([c])\n    list = [ adc'(a,b,c)\n           | a <- xx\n           | b <- yy\n           | c <- carry_strm\n           ]\n    values = [ v | (_,v) <- list ]\n    carry_strm : [n+1]\n    carry_strm  = [False] # [ c | (c,_) <- list ]\n\nproperty ripple_adc_toJavaArray x y =\n  ripple_adc (toJavaArray x, toJavaArray y) == (toJavaArray (x + y), carry x y)\n\n\/* Returns (xl # c) >> 1. *\/\nripple_shr : {m, n} (m >= 1, fin m, n >= 1, fin n) => ([n][m],Bit) -> ([n][m])\nripple_shr(xl,c) = [ (x' << (length(x) - 1:[width m])) || (x >> 1)\n                   | x <- xl\n                   | x' <- drop`{1}(xl) # [(zext([c]))]\n                   ]\n\nproperty ripple_shr_toJavaArray x c =\n  ripple_shr (toJavaArray x, c) == toJavaArray (take`{back=1} ([c] # x))\n\np384_ec_zero_point : JacobianPoint [384]\np384_ec_zero_point = ec_zero_point(p384_field)\n\n\/* Matches Java implementation *\/\np384_ec_mul : ([384], AffinePoint [384]) -> JacobianPoint [384]\np384_ec_mul (d, s) = res!0\n  where\n    d' : [12][32]\n    d' = toJavaArray d\n    ini =  p384_ec_mul_init(d, s)\n    h : [12][32]\n    h = toJavaArray (ini.h)\n    r0 = ini.r\n    f (j, r) = p384_ec_mul_aux(r, s, j, h@i, c, d'@i, d_at_ip1)\n      where\n        i        = j >> 5\n        c        = i < 11\n        d_at_ip1 = if c then d'@(i+1) else 0\n                   \/* NB: We guard indexing here to avoid bounds VCs;\n                      p384_ec_mul_aux's use of d_at_ip1 is likewise\n                      guarded. *\/\n    res : [385]_\n    res = [r0] #\n          [ f(j, r)\n          | j <- reverse [0..383]\n          | r <- res\n          ]\n\n\/* Matches Java implementation *\/\np384_ec_mul_aux : ( JacobianPoint [384]\n                   , AffinePoint [384]\n                   , [32], [32], Bit, [32], [32] ) -> JacobianPoint [384]\np384_ec_mul_aux (r, s, j, hi, i_lt_11, d_at_i, d_at_ip1) = r'\n  where\n    m = 1 << (j && 31)\n    ki  = d_at_i >> 1\n    ki' = if i_lt_11 then\n            ((d_at_ip1 && 1) << 31) || ki\n          else\n            ki\n    r2 = p384_ec_double(r)\n    r'  = if ((hi && m) != 0) && ((ki' && m) == 0) then\n            p384_ec_full_add(r2, s)\n          else if ((hi && m) == 0) && ((ki' && m) != 0) then\n            p384_ec_full_sub(r2, s)\n          else\n            r2\n\np384_ec_mul_init : ([384], AffinePoint [384]) ->\n                   { h: [384], r: JacobianPoint [384] }\np384_ec_mul_init (d, s) = { h = fromJavaArray h0, r = r0 }\n  where\n    d' : [12][32]\n    d' = toJavaArray d\n    (h0, c) = ripple_adc(d', ripple_shr(d', False))\n    r0 = if c then ec_projectify(p384_field, s)\n              else p384_ec_zero_point\n\np384_ec_twin_mul_init :\n  ([384], AffinePoint [384], [384], AffinePoint [384]) ->\n  { r : JacobianPoint [384]\n  , sMt : AffinePoint [384]\n  , sPt : AffinePoint [384]\n  }\np384_ec_twin_mul_init(d0, s, d1, t) =\n  { r = r0\n  , sPt = if s.x == t.x then azero else sPt0\n  , sMt = if s.x == t.x then azero else sMt0\n  }\n  where\n    azero = { x = 0:[384], y = 0:[384] }\n    r0 =\n      if s.x == t.x then\n        if s.y == t.y then\n          p384_ec_mul(g.add(d0, d1), s)\n        else\n          p384_ec_mul(g.sub(d0, d1), s)\n      else\n        ec_zero_point f\n    m    = p384_point_ops\n    f    = m.field\n    g    = m.group_field\n    sP   = ec_projectify(f, s)\n    sPtP = m.add(sP, t) \/* 1: ec_full_add (SpT, S, T) *\/\n    sMtP = m.sub(sP, t) \/* 2: ec_full_sub (SmT, S, T) *\/\n    sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z))\n    sPt0 = { x = f.mul(sPtP.x, g2), y = f.mul(f.mul(sPtP.y, g1), g2) }\n           where g1 = f.mul(sMtP.z, sDiv)\n                 g2 = f.sq(g1)\n    sMt0 = { x = f.mul(sMtP.x, g2), y = f.mul(f.mul(sMtP.y, g1), g2) }\n           where g1 = f.mul(sPtP.z, sDiv)\n                 g2 = f.sq(g1)\n\np384_ec_twin_mul_aux1 :\n  (JacobianPoint [384], [32], [32], AffinePoint [384], AffinePoint [384], AffinePoint [384], AffinePoint [384])\n  -> JacobianPoint [384]\np384_ec_twin_mul_aux1(rP, u0_32, u1_32, sPt, s, sMt, t) =\n  ec_twin_mul_aux1(p384_point_ops, rP, u0_32, u1_32, sPt, s, sMt, t)\n\np384_ec_twin_mul_aux2 : ([32],[32],[32],[32],[32],[32],[32],Bit,Bit) ->\n  { tma2_u0:[32]\n  , tma2_u1:[32]\n  , tma2_c0':[32]\n  , tma2_c1':[32]\n  , tma2_e0':[32]\n  , tma2_e1':[32]\n  , tma2_sh':[32]\n  }\np384_ec_twin_mul_aux2 (c0, c1, e0, e1, sh, d0i, d1i, dv1, dv2) =\n  { tma2_u0  = u0\n  , tma2_u1  = u1\n  , tma2_c0' = c0'\n  , tma2_c1' = c1'\n  , tma2_e0' = e0'\n  , tma2_e1' = e1'\n  , tma2_sh' = sh'\n  }\n  where\n    c0'           = ((if h0Less then 0 else `0x20) ^ (c0 << 1)) || ((e0 >> (sh && 31)) && `0x1)\n    c1'           = ((if h1Less then 0 else `0x20) ^ (c1 << 1)) || ((e1 >> (sh && 31)) && `0x1)\n    u0            = if h0Less then 0 else (if (c0 && `0x20) != 0 then (-1) else 1)\n    u1            = if h1Less then 0 else (if (c1 && `0x20) != 0 then (-1) else 1)\n\n    h0            = if (c0 && `0x20) != 0 then 31 - h0' else h0'\n      where h0' = c0 && `0x1F\n\n    h1            = if (c1 && `0x20) != 0 then 31 - h1' else h1'\n      where h1' = c1 && `0x1F\n\n    h0Less        = h0 < F(h1)\n    h1Less        = h1 < F(h0)\n    (e0',e1',sh') = if dv1 then\n                      if dv2 then (d0i, d1i, 31) else (0, 0, 31)\n                    else (e0, e1, sh-1)\n\n\/\/ F : [5] -> [5] via original impl\n\/\/ F : [32] -> [32] via fused impl\np384_ec_twin_mul_aux_F32 : [32] -> [32]\np384_ec_twin_mul_aux_F32 = F\n\n\/* Matches Java implementation *\/\np384_ec_twin_mul : ([384],AffinePoint[384], [384], AffinePoint [384]) -> JacobianPoint [384]\np384_ec_twin_mul(d0, s, d1, t) =\n  if s.x == t.x then i.r else jj_r\n  where\n   m     = p384_point_ops\n   f     = m.field\n   g     = m.group_field\n   i     = p384_ec_twin_mul_init(d0, s, d1, t)\n   d0'   = toJavaArray d0\n   d1'   = toJavaArray d1\n   d0_11 = d0'!0\n   d1_11 = d1'!0\n   (jj_r, _, _, _, _, _) = jj!0\n   jj : [386](JacobianPoint [384], _,_,_,_,_)\n   jj    = [ ( i.r             \/\/ initial point\n             , d0_11 >> 28     \/\/ c0 initial value\n             , d1_11 >> 28     \/\/ c1 initial value\n             , d0_11           \/\/ e0 initial value\n             , d1_11           \/\/ e1 initial value\n             , 27:[32]         \/\/ shift initial value\n             )\n           ]\n         # [ (r', c0', c1', e0', e1', sh')\n             where\n                k = (k0-5):[32]\n                r'         = p384_ec_twin_mul_aux1(r, u0, u1, i.sPt, s, i.sMt, t)\n                aux2       = p384_ec_twin_mul_aux2(c0, c1, e0, e1, sh, d0i, d1i, dv1, dv2)\n                (u0, u1)   = (aux2.tma2_u0, aux2.tma2_u1)\n                (c0', c1') = (aux2.tma2_c0', aux2.tma2_c1')\n                (e0', e1') = (aux2.tma2_e0', aux2.tma2_e1')\n                sh'        = aux2.tma2_sh'\n                (d0i, d1i,\n                 dv1, dv2) = if dv1i && dv2i then\n                               (d0'@ii, d1'@ii, dv1i, dv2i)\n                             else\n                               (zero, zero, dv1i, dv2i)\n                             where\n                               ii    = (k >> 5) - 1\n                               dv1i  = (k && `0x1F) == 0\n                               dv2i  = ~(ii@0)\n           | (r, c0, c1, e0, e1, sh) <- jj\n           | k0 <- reverse [0 .. 384]\n           ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/PrimeField\/PFEC.cry","filetype":"cry","content":"\/\/ NIST Prime Field Elliptic Curves defined in FIPS-186-4\n\nmodule Common::EC::PrimeField::PFEC where\n\nimport Common::ModDivZ\n\nparameter\n    type P : #     \/\/  The prime modulus\n    type constraint (fin P, P >= 5)\n    n  : Integer   \/\/  Prime order of generator G\n    b  : Z P       \/\/  Curve coefficient\n    Gx : Z P       \/\/  Curve coordinates\n    Gy : Z P       \/\/    of generator point\n\ntype Point = (Z P, Z P)\nG = (Gx, Gy) : Point\na = -3 : Z P       \/\/  Curve coefficient\np = toInteger`{width P} `P\n\n\/\/ A convenient representation of the point-at-infinity identity element\noo = (0, 0) : Point\n\n\/\/ Check that a given point is on the curve\nvalid_point : Point -> Bit\nvalid_point (x, y) =\n    ((x, y) == oo) \\\/ (y ^^ 2 == x ^^ 3 + a * x + b)\n\n\/\/ (From http:\/\/www.secg.org\/sec1-v2.pdf, section 2.2.1)\n\/\/ Addition of two elliptic curve points in E(F_p) (p an odd prime)\n\/\/ on a curve with coefficient 'a'. Note 'b' is unused.\nec_add : Point -> Point -> Point\nec_add (x1, y1) (x2, y2) =\n    if (x1, y1) ==    oo     then  (x2, y2)  \/\/  Rules 1, 2\n     | (x2, y2) ==    oo     then  (x1, y1)  \/\/  Rules 1, 2\n     | (x1, y1) == (x2, -y1) then     oo     \/\/  Rule 3\n                             else   (x, y)   \/\/  Rules 4, 5\n    where  \/\/ all arithmetic operations are mod p\n    x = L ^^ 2 - x1 - x2\n    y = L * (x1 - x) - y1\n    L = if x1 == x2 then (3 * x1 ^^ 2 + a) %\/ (2 * y1)\n                    else (y2 - y1) %\/ (x2 - x1)\n\n\/\/ Scalar multiplication of a curve point using double-and-add\nscmul : Integer -> Point -> Point\nscmul m xy =\n    if m == 0 then oo\n     | m == 1 then xy\n     | even m then scmul (m \/ 2) (ec_add xy xy)\n              else ec_add xy (scmul (m - 1) xy)\n\n(~*) = scmul  \/\/ infix form of operator\n\n\/\/ TODO: needs a primality checker!\n\/\/ property p_prime = prime p\n\/\/ property n_prime = prime n\nproperty valid_n = (n + 1) ~* G == G\nproperty valid_scmul m = valid_point (m ~* G)\nproperty scmul_commutes m m' = m ~* (m' ~* G) == m' ~* (m ~* G)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/gf.cry","filetype":"cry","content":"module GF where\n\nimport Types\n\n\ngf_iszero : base_t  -> base_t\ngf_iszero a = t_3 where\n    (t_1 : uint32t ) = cvt_16_to_32 a\n    (t_2 : uint32t ) = (t_1-1)>> 19\n    (t_3 : base_t) = cvt_32_to_16 t_2\n\ngf_add : base_t -> base_t -> base_t\ngf_add a b = a^b\n\ngf_mul : gf_t  -> gf_t  -> gf_t\ngf_mul a b = rtn  where\n    (t0:base_64t) = cvt_16_to_64 a\n    (t1:base_64t) = cvt_16_to_64 b\n    loop_i i tmp =\n        if (i>= GFBITS) then tmp\n        else loop_i (i+1) tmp' where\n            tmp' = t0 * (t1 && (1 << i))\n    (tmp_0 : base_64t) = t0 * (t1 && 1)\n    (tmp_1 : base_64t) = loop_i 0 tmp_0\n        (k_0: base_64t) =  cvt_20_to_64 0x1FF0000\n    (k_1: base_64t) =  cvt_20_to_64 0x000E000\n    (t_0: base_64t) = tmp_1 && k_0\n    (t_1: base_64t) = tmp_2 && k_1\n    (tmp_2 : base_64t) = tmp_1 ^ ((t_0 >> 9) ^ (t_0 >> 10) ^ (t_0 >> 12) ^ (t_0 >> 13))\n    (tmp_3 : base_64t) = tmp_2 ^ ((t_1 >> 9) ^ (t_1 >> 10) ^ (t_1 >> 12) ^ (t_1 >> 13))\n    (rtn : gf_t ) = cvt_64_to_16 (tmp_3 && GFMASK)\n\nloop_i i x limit M =\n    if(i<limit) then loop_i i' x' limit M where\n        t = x && (M@i)\n        x'= x^ (t >> 9) ^ (t >> 10) ^ (t >> 12) ^ (t >> 13)\n        i' = i+1\n    else  cvt_64_to_16 (x&& GFMASK)\n\ngf_sqmul : gf_t -> gf_t -> gf_t\ngf_sqmul a b = rtn where\n    M = [0x0000001FF0000000, 0x000000000FF80000, 0x000000000007E000]\n    (t0:uint64t) = cvt_16_to_64  a\n    (t1:uint64t) = cvt_16_to_64  b\n    (x1:uint64t) = (t1 << 6) * (t0 && (1 << 6))\n    (t2:uint64t) = t0^(t0 << 7)\n    (x2:uint64t) = x1^ (t1 * (t2 && (cvt_20_to_64 0x04001)))\n    (x3:uint64t) = x2^ (t1 * (t2 && (cvt_20_to_64 0x08002))) << 1\n    (x4:uint64t) = x3^ (t1 * (t2 && (cvt_20_to_64 0x10004))) << 2\n    (x5:uint64t) = x4^ (t1 * (t2 && (cvt_20_to_64 0x20008))) << 3\n    (x6:uint64t) = x5^ (t1 * (t2 && (cvt_20_to_64 0x40010))) << 4\n    (x7:uint64t) = x6^ (t1 * (t2 && (cvt_20_to_64 0x80020))) << 5\n    rtn = loop_i 0 x7 3 M\n\ngf_sq2mul : gf_t -> gf_t -> gf_t\ngf_sq2mul a b = rtn where\n    (M:[6][64]) = [0x1FF0000000000000,\n        0x000FF80000000000,\n        0x000007FC00000000,\n        0x00000003FE000000,\n        0x0000000001FE0000,\n        0x000000000001E000]\n    (t0:uint64t) = cvt_16_to_64 a\n    (t1:uint64t) = cvt_16_to_64 b\n    (x_1:uint64t) = (t1 << 18) * (t0 && (1 << 6))\n    t2 = t0^(t0 << 21)\n    (x_2:uint64t) = x_1^(t1 * (t0 && (cvt_36_to_64 0x010000001)))\n    (x_3:uint64t) = x_2^(t1 * (t0 && (cvt_36_to_64 0x020000002))) << 3\n    (x_4:uint64t) = x_3^(t1 * (t0 && (cvt_36_to_64 0x040000004))) << 6\n    (x_5:uint64t) = x_4^(t1 * (t0 && (cvt_36_to_64 0x080000008))) << 9\n    (x_6:uint64t) = x_5^(t1 * (t0 && (cvt_36_to_64 0x100000010))) << 12\n    (x_7:uint64t) = x_6^(t1 * (t0 && (cvt_36_to_64 0x200000020))) << 15\n    rtn = loop_i 0 x_7 6 M\n\ngf_sq2 : gf_t -> gf_t\ngf_sq2 in = rtn where\n    (B:[4][64]) = [0x1111111111111111,\n        0x0303030303030303,\n        0x000F000F000F000F,\n        0x000000FF000000FF]\n    (M:[4][64]) = [0x0001FF0000000000,\n        0x000000FF80000000,\n        0x000000007FC00000,\n        0x00000000003FE000]\n    (x_1:uint64t) = cvt_16_to_64 in\n    (x_2:uint64t) = (x_1 || (x_1 << 24)) && (B@3)\n    (x_3:uint64t) = (x_2 || (x_2 << 12)) && (B@2)\n    (x_4:uint64t) = (x_3 || (x_3 << 6)) && (B@1)\n    (x_5:uint64t) = (x_4 || (x_3 << 3)) && (B@0)\n    rtn = loop_i 0 x_5 4 M\n\ngf_frac : gf_t -> gf_t -> gf_t\ngf_frac d n = t7 where\n    t1 = gf_sqmul d d\n    t2 = gf_sq2mul t1 t1\n    t3 = gf_sq2 t2\n    t4 = gf_sq2mul t3 t2\n    t5 = gf_sq2 t4\n    t6 = gf_sq2mul t5 t2\n    t7 = gf_sqmul t7 n\n\ngf_inv : gf_t -> gf_t\ngf_inv d = gf_frac d 1\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/operations.cry","filetype":"cry","content":"module Operations where\n\n\nimport Types\nimport Encrypt\nimport Decrypt\n\ncompute_hash_2e : SYS_N8_plus1_t -> [32]base_t\ncompute_hash_2e in = undefined\ncompute_hash_1e : pm_t -> [32]base_t\ncompute_hash_1e in = undefined\n\ncrypto_hash_32b_1 : SYS_N8_plus1_t -> [32]base_t\ncrypto_hash_32b_1 in = undefined\n\ncrypto_hash_32b_2 : pm_t -> g_key_t\ncrypto_hash_32b_2 in = undefined\n\n\/\/defined externally\n\/\/ KeccakWidth1600_Sponge\n\n(two_e : SYS_N8_plus1_t) = [ 2 | x <- [0..870]]\n\n\/\/ encapsulation\ncrypto_kem_enc : g_ct_t -> g_key_t -> g_pk_t -> SYS_N8_plus2_t\n    -> (g_ct_t, g_key_t)\ncrypto_kem_enc c0 key pk e =  (c2, key2) where\n    \/\/ step 1. uniform random vector e (given as input)\n    (e :  SYS_N8_plus2_t) = zero\n    \/\/ step 2. use encoding subroutine on e and public key T to compute Co\n    (c1 : g_ct_t) = encrypt c0 pk e\n        (c2 : g_ct_t) = (take `{194} c1 ) # (compute_hash_2e two_e)\n    (one_ec : pm_t) = ([1])#(take `{870} e)#c2\n    (key2 : g_key_t) = compute_hash_1e one_ec\n\n\ncrypto_kem_dec : g_ct_t -> g_sk_t -> g_key_t\ncrypto_kem_dec c sk = key where\n    \/\/ calls decoding subroutine\n    (e : SYS_N8_t, ret_decrypt : gf_t) = decrypt sk c\n    \/\/ calls KeccakWidth1\n    (conf : [32]base_t) = crypto_hash_32b_1 two_e\n    loop_i i rc =\n        if (i<32)\n        then loop_i i' rc' where\n            i' = i+1\n            rc' = rc || ((conf@i) ^ c@(SYND_BYTES + i))\n        else rc\n    (ret_confirm : base_16t) = loop_i 0 0\n    (m_0 : base_16t) = ret_decrypt || ret_confirm\n    (m_1 : base_16t) = m_0 - 1\n    (m : base_16t) = m_1 >> 8\n    x_1 = [(~m && 0) || (m && 1)]\n    x_2 = [(~m && (sk@i)) || (m && (e@i)) | i <- [0..(870-1)]]\n    x_3 = [(c@i) | i <- [0..(194-1+32)]]\n    (preimage: pm_t) = x_1 # x_2 # x_3\n    \/\/ 1 + SYS_N\/8 + (SYND_BYTES + 32)\n    (key : g_key_t) = crypto_hash_32b_2 preimage\n","variant":"hybrid","set":"supervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/benes.cry","filetype":"cry","content":"module Benes where\n\nimport Types\nimport GF\nimport Util\n\n\ntype La_t = [32]\ntype Lb_t = [j_size_t][32]\ntype Lc_t = [GFBITS_t][j_size_t][32]\n\napply_benes r bits rev = zero\n\/* where\n    (bits_ptr, inc) =\n        if rev\n        then (bits_ptr, inc) where\n            bits_ptr = bits + 12288\n            inc = -1024\n        else (bits_ptr, inc) where\n            bits_ptr = bits\n            inc = 0\n\n    (r_int_v_0:[64][64]) = [ load8 (r + i*16 + 0) | i<- [0..63]]\n    (r_int_v_1:[64][64]) = [ load8 (r + i*16 + 8) | i<- [0..63]]\n    (r_int_v:[2][64][64]) = [r_int_v_0, r_int_v_1]\n\n    r_int_h_0 = transpose_64x64 r_int_v_0\n    r_int_h_1 = transpose_64x64 r_int_v_1\n\n    \/\/\/\/--- fixme\n    r_int_v_0 = transpose_64x64 r_int_h_0\n    r_int_v_1 = transpose_64x64 r_int_h_1\n*\/\n\nsupport_gen : g_sk_t  -> L_t\nsupport_gen c  = s where\n    k_size = (1:La_t) << GFBITS\n    loop_i : La_t -> Lc_t -> Lc_t\n    loop_i ix L =\n        if(ix<k_size)\n        then  loop_i ix' L' where\n            (_, a) = bitrev ix\n            loop_j : La_t -> Lc_t -> Lc_t\n            loop_j jx M =\n                if (jx < GFBITS)\n                then loop_j jx' M' where\n                    (kx:La_t) = ix\/8\n                    (val_jx:Lb_t) = M@jx\n                    (val_kx:La_t) = val_jx@kx\n                    (c:La_t) = (ix%8:La_t)\n                    (d:La_t)  = (((a >> jx) && (1:La_t)) << c)\n                    (val_0:La_t) =  val_kx || d\n                    (val_1:Lb_t) = (update val_jx kx val_0)\n                    (M':Lc_t) = update M jx val_1\n                    (jx':La_t) = jx+1\n                else M\n            L' = loop_j 0 L\n            ix' = ix+1\n        else L\n    (L_0:Lc_t) = zero\n    (L_1:Lc_t) = loop_i 0 L_0\n    (L_2:Lc_t) =[(apply_benes l c 0) | l <- L_1]\n    loop_ix : La_t -> L_t -> L_t\n    loop_ix ix s =\n        if (ix<SYS_N)\n        then loop_ix (ix+1) s_2  where\n            loop_jx : La_t -> L_t -> L_t\n            loop_jx jx s =\n                if(jx>=0)\n                then loop_jx jx' s' where\n                    (x : La_t) = (L_2@jx)@(ix\/8)\n                    (y : La_t) = (x >> (ix%8)) && 1\n                    (z : base_t) = (s@ix << (1:base_t)) || ( cvt_32_to_16 y)\n                    (jx': La_t) = jx-1\n                    s' = update s ix z\n                else s\n\n                        s_1 = update s ix 0\n            s_2 = loop_jx (GFBITS-1) s_1\n        else s\n    (s:L_t) = loop_ix 0 zero\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/decrypt.cry","filetype":"cry","content":"module Decrypt where\n\nimport Benes\nimport Types\nimport Decrypt_helpers\nimport GF\nimport Util\n\n\/\/decrypt\n\/\/[13908] base_t -> [226] base_t  \ndecrypt : g_sk_t -> g_ct_t -> (f_t, gf_t)\ndecrypt sk c = (e, check) where\n    (r : r_t) = (take `{194} c)#zero\n    loop_1 g i sk_index =\n        if i < SYS_T\n        then loop_1 g' (i+1) (sk_index+2) where\n            (a : gf_t)= load2 sk sk_index\n            (b : gf_t) = a && GFMASK\n            g'= update g i b\n        else g\n    (g_0 : g_t) = zero\n    (g_1 : g_t) = loop_1 g_0 0 0\n    (L : L_t) = support_gen sk\n    (s : s_t) = synd g_1 L r\n    (locator : g_t) = bm s\n    (images : SYS_N_t) = root locator L\n    loop_2 : [32] -> f_t -> gf_t -> (f_t, gf_t)\n    loop_2 i e w =\n        if (i<SYS_N)\n        then loop_2 (i+1) e' w' where\n            (t : gf_t) = (gf_iszero (images @i)) && (1:[16])\n            jx = i\/8\n            val = (e@jx) || t << (i%8)\n            (e' : f_t) = update e jx val\n            (w' : gf_t) = w+t\n        else (e, w)\n    (e : f_t, w : gf_t) = loop_2 0 zero 0\n    (s_cmp : s_t) = synd g_1 L e\n    loop_3 i check =\n        if (i<SYS_T*2)\n        then  loop_3 (i+1) check' where\n            check' = check || ((s@i) ^ (s_cmp@i))\n        else check\n    (check_0 : gf_t) = w ^ SYS_T\n    (check_1 : gf_t) = loop_3 0 check_0\n    (check_2 : gf_t) = (check_1 -1)>> 15\n    (check : gf_t) = check_2 ^ 1\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/decrypt_helpers.cry","filetype":"cry","content":"module Decrypt_helpers where\n\nimport Types\nimport GF\nimport Util\n\neval f a = out where\n    loop_i i r =\n        if (i<0) then r\n        else loop_i i' r' where\n            r' = gf_add (gf_mul r a) (f@i)\n            i' = i-1\n    r_init = f@SYS_T\n    i_init = SYS_T-1\n    out = loop_i i_init r_init\n\nroot : g_t ->  SYS_N_t -> SYS_N_t\nroot f L = out where\n    out = [ eval f l | l <- L]\n\nsynd : g_t -> L_t -> r_t -> s_t\nsynd f L r = out' where\n    loop_j i j out e_inv c =\n        if (j<SYS_T_double)\n        then (loop_j i j' out' e_inv' c) where\n            j' = j+1\n            x = gf_mul e_inv c\n            y = gf_add (out@j) x\n            out' = update out j y\n            e_inv' = gf_mul e_inv (L@i)\n        else (out, e_inv)\n\n    loop_i i out e_inv c =\n        if (i<SYS_N)\n        then loop_i i' out' e_inv' c where\n            c = (r@(i\/8) >> (i%8)) && (1:[16])\n            e = eval f (L@i)\n            e_inv = gf_inv (gf_mul e e)\n            (out', e_inv') = loop_j i 0 out e_inv c\n            i' = i+1\n        else out\n    out' = loop_i 0 zero 0 0\n\nbm : s_t-> g_t\nbm s = out where\n    N_limit =  2 * SYS_T\n    outer_loop N B C T L b =\n        if (N<N_limit) then (outer_loop N_2 B_3 C_2 T_2 L_2 b_2) where\n            (d_0 : gf_t) = zero\n            limit = min N SYS_T\n            loop_1 i d  =\n                if(i < limit)\n                then loop_1 i' d' where\n                    d' = d ^ (gf_mul (C@i) (s@(N-i)))\n                    i' = i+1\n                else d\n            (d_1 : gf_t) = loop_1 0 d_0\n            (mne: uint16t) = ((d_1 - (1:[16]))>> 15) - (1:[16])\n            (mle_0: uint16t)= ((N - (2:[16])*L) >> 15) - (1:[16])\n            (mle_1: uint16t) = mle_0 && mne\n            (T_2 : SYS_T_plus1) = C\n            (f: gf_t) = gf_frac b d_1\n            (C_2: SYS_T_plus1) =\n                [c ^ ((gf_mul f (B@i)) && mne)\n                | i <- [0.. 120]\n                | c <- C]\n            (L_2: uint16t) = (L && ~mle_1) || ((N+1-L) && mle_1)\n            (B_2: SYS_T_plus1) =\n                [((b && ~mle_1) || (t && mle_1)) | b <- B | t <- T]\n            b_2 = (b && ~mle_1) || (d_1 && mle_1)\n            (B_3: SYS_T_plus1) = zero # (take `{119} B_2)\n            N_2 = N+1\n        else C\n    (N : uint16t) = 0\n    (L : uint16t) = 0\n    (B_0 : SYS_T_plus1) = zero\n    (B_1 : SYS_T_plus1) = update B_0 1 1\n    (C_0 : SYS_T_plus1) = zero\n    (C_1 : SYS_T_plus1) = update C_0 0 1\n    (T : SYS_T_plus1) = zero\n    (b : gf_t) = 1\n    (C_2 : SYS_T_plus1)= outer_loop N B_1 C_1 T L b\n    out = reverse C_2\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/types.cry","filetype":"cry","content":"module Types where\n\n\n\/\/ Values\nSYS_T = 119\nSYS_N = 6960\nSYS_Nd8 = SYS_N\/8 GFBITS =  13\ntype GFBITS_t =  13\nCOND_BYTES  = (((1:[32]) << (GFBITS-(4:[32])))*(2*GFBITS - (1:[32])))\nIRR_BYTES = (SYS_T * 2)\nPK_NROWS  =  (SYS_T*GFBITS)\nPK_NCOLS  =  (SYS_N - PK_NROWS)\nPK_ROW_BYTES  =  ((PK_NCOLS + 7)\/8)\ntype PK_ROW_BYTES_t = [677]\nSK_BYTES  =  (SYS_Nd8 + IRR_BYTES + COND_BYTES)\nSYND_BYTES  =  ((PK_NROWS + 7)\/8)\ntype SYND_BYTES_t = [194]\nGFMASK  =  (((1:[32]) << GFBITS) - 1)\ntype j_size_t =  1024 \/\/ Base Types\ntype base_16t = [16]\ntype base_32t = [32]\ntype base_64t = [64]\ntype uint16t = [16]\ntype uint64t = [64]\ntype uint32t = [32]\ntype base_t = base_16t\ntype gf_t = base_t\n\n\/\/parameter Types\ntype ciphertext_t = [226] base_t    \/\/ crypto_kem_CIPHERTEXTBYTES\ntype keybytes_t = [32] base_t \/\/ crypto_kem_BYTES\ntype publickey_t = [1047319]base_t \/\/ crypto_kem_PUBLICKEYBYTES\ntype secretkey_t = [13908] base_t type g_s_t =   ciphertext_t\ntype g_ct_t =  ciphertext_t\ntype g_key_t = keybytes_t\ntype g_pk_t =  publickey_t\ntype g_sk_t = secretkey_t\n\ntype SYS_N8_t = [870] base_t\ntype SYS_N8_plus1_t = [871] base_t\ntype SYS_N8_plus2_t = [872]base_t\n\nSYS_T_double = 238type SYS_T_double_t = [238]base_t\ntype SYS_N_t = [6960]base_t\ntype SYS_T_plus1 = [120]base_t\n\n\/\/decrypt specific types\ntype L_t = SYS_N_t type f_t = SYS_N8_t\ntype r_t = SYS_N8_t\ntype g_t = SYS_T_plus1\ntype s_t = SYS_T_double_t \/\/encap specific types\ntype e_t = SYS_N8_plus2_t\ntype ind_t = SYS_T_double_t\ntype e_int_t = [109]base_t\ntype val_t = [119] base_t\ntype e_pieces_t = [109][8]base_t\n\n\n\/\/ used in operations module\ntype pm_t =  [1097]base_t cvt_16 e = fromInteger `{[16]} (toInteger e)\ncvt_32 e = fromInteger `{[32]} (toInteger e)\ncvt_64 e = fromInteger `{[64]} (toInteger e)\ncvt_32_to_16 e = cvt_16 e\ncvt_64_to_16 e = cvt_16 e\ncvt_16_to_32 e = cvt_32 e\ncvt_20_to_64 e = cvt_64 e\ncvt_16_to_64 e = cvt_64 e\ncvt_36_to_64 e = cvt_64 e\n\n","variant":"hybrid","set":"supervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/encrypt.cry","filetype":"cry","content":"module Encrypt where\n\nimport Types\nimport Util\n\nmov_forward : ind_t -> (ind_t, Bool)\nmov_forward ind_0 = outer_loop 0 ind_0 False where\n    inner_loop : _ -> _ -> ind_t -> Bool -> (ind_t, Bool)\n    inner_loop j i ind found =\n        if (j < (SYS_T* 2))\n        then if(jval<SYS_N)\n            then inner_loop (j+1) i ind' found'\n            else inner_loop (j+1) i ind found\n        else (ind, found)\n        where\n            (jval : base_t) = ind@j\n            (ind' : ind_t) = update (update ind j (ind@i)) i jval\n            found' = True\n    outer_loop : _ -> ind_t -> Bool -> (ind_t, Bool)\n    outer_loop i ind found =\n        if (i < SYS_T)\n        then if(found')\n            then outer_loop (i+1) ind' found'\n            else (ind', found')\n            where\n                (ind', found') = inner_loop i i ind found\n        else (ind, found)\n\nloop_x i ind = if (i<SYS_T*2) then loop_x (i+1) ind' else ind\n    where\n    ind' = update ind i ((ind@i) && GFMASK)\n\n\/\/ when find equal value returns true\nloop_findEq : ind_t  -> _ -> Bool -> Bool\nloop_findEq ind i rtn = if (i<SYS_T) then rtn' else rtn\n    where\n        loop_z : ind_t -> _ -> _ -> Bool\n        loop_z ind i j =\n            if(j<i)\n            then\n                if((ind@i) == (ind@j))\n                then True\n                else loop_z ind i (j+1)\n            else False\n        rtn' = if(loop_z ind i 0)\n            then True\n            else loop_findEq ind (i+1) rtn\n\n\/\/ While_loop : Might consider adding a limit to the counter here\nwhile_loop : ind_t -> ind_t\nwhile_loop ind =\n    if(loop_findEq ind_2 1 False) then ind_2 else while_loop ind_2\n    where ind_2 = loop_x 0 ind\n\n\n\/\/ --------------------------------------------- gen_e for loops\n\/\/ implements val[j] = one << (ind[j] & 63)\nloop_a : base_t -> val_t ->ind_t -> val_t\nloop_a j val ind =\n    if (j<SYS_T) then loop_a (j+1) val' ind else val\n    where\n        x = 1 << ((ind@j) && 63)\n        val' = update val j x\n\nloop_c : base_t ->  val_t -> ind_t -> e_int_t -> e_int_t\nloop_c i val ind e_int  =\n    if(i < (SYS_N+63)\/64) then e_int' else e_int\n    where\n    (e_int' : e_int_t) = loop_b 0 i val ind e_int\n    loop_b : base_t -> base_t -> val_t -> ind_t -> e_int_t -> e_int_t\n    loop_b j i val ind e_int =\n        if (j<SYS_T) then loop_b (j+1) i val ind e_int' else e_int\n        where\n            (mask_0 : base_t) =cvt_16 (ind@j)\n            (mask_1 : base_t) = i^(mask_0 >> 6)\n            (mask_2 : base_t) = mask_1-1\n            (mask_3 : base_t) = mask_2 >> 63\n            (mask : base_t) = -1* mask_2\n            (m : base_t) = e_int@i\n            (n : base_t) = (val@j) && mask\n            (o : base_t) = m ||  n\n            (e_int' : e_int_t) = update e_int i o\n\n\/\/ store in groups of 8\nloop_d : _ ->  e_int_t -> e_pieces_t ->  e_t\nloop_d i e_int e_pieces =\n    if (i < (SYS_N+63)\/64 - 1)\n    then loop_d (i+1) e_int e_pieces'\n    else join e_pieces\n    where\n        (x : [8]base_t) = store8 (e_pieces@i) (e_int@i)\n        (e_pieces' : e_pieces_t) = update e_pieces i x\n\n\/\/shift each value by j and && with 0xFF\nloop_e : _ -> _ -> e_int_t -> e_t -> e_t\nloop_e j i e_int e =\n    if (j<(SYS_N % 64)) then loop_e (j+8) i e_int e' else e\n    where\n        (w : base_t) = (e_int@i) >> j\n        (x : base_t) = w && (cvt_16 0xFF)\n        (e' : [872]base_t) = update e (j\/8) x\n\ngen_e : e_t -> e_t\ngen_e e = undefined where\n    (val_1 : val_t) = zero\n    (ind_1 : ind_t) = zero\n    (e_int_1 : e_int_t) = zero\n    (ind_2 : ind_t)  = while_loop ind_1\n    (val_2 : val_t) = loop_a 0 val_1 ind_2\n    (e_int_2 : e_int_t) = loop_c 0 val_2 ind_2 e_int_1\n    (e_pieces_1 : e_pieces_t) = groupBy `{8} e\n    (e_2 : e_t) = loop_d 0 e_int_2 e_pieces_1\n    (i : [16]) = (SYS_N+63)\/64 - 1 \/\/max at previous loop\n    (e_3 : e_t) = loop_e 0 i e_int_2 e_2\n\nsyndrome : g_pk_t -> e_t -> g_s_t -> g_s_t\nsyndrome pk e s_in = s_out where\n    tail = PK_NROWS % 8\n    \/\/ PK_ROW_BYTES = 677\n    \/\/ PK_NROWS = 1547\n    pk_short = take `{1047319} pk \/\/ PK_ROW_BYTES * PK_NROWS (right size)\n    pk_ptr = groupBy `{677} pk_short\n    loop_c : _ -> SYS_N8_t -> SYS_N8_t\n    loop_c j row =\n        if (j >= SYS_N\/8 - PK_ROW_BYTES)\n        then loop_c (j-1) row'\n        else row\n        where\n            a = (row @ j) << tail\n            b = (row @ (j-1)) >> (8-tail)\n            c = a||b\n            row' = update row j c\n    loop_d : _ -> base_t -> SYS_N8_t -> base_t\n    loop_d j b row =\n        if (j < (SYS_N\/8))\n        then loop_d (j+1) ((row@j) && (e@j)) row\n        else b\n    second_loop : _ -> g_s_t -> g_s_t\n    second_loop i s =\n        if (i < PK_NROWS)\n        then second_loop (i+1) s_out\n        else s\n        where\n            (row_1 : SYS_N8_t) =  zero # (pk_ptr@i)\n            (row_2 : SYS_N8_t) = loop_c (SYS_N\/8-1) row_1\n            (d : base_t) =  (row_2@(i\/8))|| (1 << (i%8))\n            (row_3 : SYS_N8_t) =  update row_2 (i\/8) d\n            (b_0 : base_t) = loop_d 0 0 row_3\n            (b_1 : base_t) = b_0 ^ (b_0>>4)\n            (b_2 : base_t) = b_1 ^ (b_1>>2)\n            (b_3 : base_t) = b_2 ^ (b_2>>1)\n            (b_4 : base_t) = b_3 && 1\n            (sval : base_t) =  (s@(i\/8)) || (b_4 << (i%8))\n            (s_out : g_s_t) =  update s (i\/8) sval\n    (s : g_s_t) = zero # (drop `{194} s_in)\n    s_out = second_loop 0 s\n\nencrypt : g_s_t -> g_pk_t -> e_t -> g_s_t\nencrypt s pk e = s where\n    (e' : e_t) = gen_e e\n    (s : g_s_t) = syndrome pk e' s\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/CM_Parameters.cry","filetype":"cry","content":"module CM_Parameters where\n\ntype a_ty = [32]\n\ntype CM =\n    { m : a_ty  \/\/log2q\n    , q : a_ty  \/\/ The size of the field used\n    , n : a_ty  \/\/ The code length\n    , t : a_ty  \/\/ The guaranteed error-correction capability\n    , k : a_ty  \/\/ The code dimension\n    , d : a_ty \/\/ ` Length of hash disgest\n    }\n\ntype byte_rep n = [n\/8][8] Bit\n\n\n\/\/ -- 2.8 representation of objects as byte strings\n\/\/ -- 3.1  list of paramter set\n\n\/\/ Initiate CM parameter\nmake_mk : a_ty -> a_ty -> a_ty -> a_ty -> CM \nmake_mk m n t d =\n    { m = m : a_ty\n    , q = (2^m) : a_ty\n    , n = n : a_ty\n    , t = t : a_ty\n    , k = (n-m*t) : a_ty\n    , d = d : a_ty\n    }\n\n\/\/ Check if CM parameters are OK\nmk_ok : CM -> Bool\nmk_ok cm =\n    ((is_pos m) \/\\ (n_ok) \/\\ (t_ok) \/\\ (is_pos cm.d))\n    where\n        m = cm.m\n        n = cm.n\n        t = cm.t\n        is_pos e = e>0\n        n_ok = ((is_pos n) \/\\ (n <= cm.q))\n        t_ok = (t>=2) \/\\ (m*t <n)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/CM_696.cry","filetype":"cry","content":"module CM_696 where\n\nimport CM_Parameters\n\ncm696  =\n    { m = 13 : a_ty\n    , q = (2^13) : a_ty\n    , n = 6960 : a_ty\n    , t = 119 : a_ty\n    , k = 5413 : a_ty\n    , d = 256 : a_ty\n    } : CM\n","variant":"hybrid","set":"supervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Encapsulation.cry","filetype":"cry","content":"module Encapsulation where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\n\/\/ in order of general algorithm spec\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T  \/\/ also n-k\ntype H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                \/\/ [13]Bit\n    , a : alphas_T              \/\/ [6960][13]Bit  \/\/[n][m]Bit\n    }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                   \/\/ [870][8]Bit\n    , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\n\n\/\/ a bit string of length and Hamming weight T\ntype weighted_T = n_T\n\n\n\/\/--------------------------------------------------\n\/\/ Define H = (I_n-k |T )\nstep_1 : mt_T -> public_key_T -> H_T\nstep_1 I A = zero\n\/\/ get inverse A|I\n\n\/\/ reduce matrix I|B\n\/\/ Co = He\nstep_2 : H_T -> weighted_T -> C0_T\nstep_2 H e = zero\n\n\/\/\n\/\/ encoding subroutine\nencoding_subroutine : weighted_T -> public_key_T -> C0_T\nencoding_subroutine e T = C0 where\n    (I: mt_T) = zero\n    (H:H_T) = step_1 I T         (C0:C0_T) = step_2 H e\n\n\ntype session_key_t = [32] \/\/?\n\/\/ 2.6.3\ncompute_hash_2e e = undefined\n\/\/ 2.6.4\ncompute_hash_1e e C = undefined\n\n\/\/ step 1.) uniform random vector e\nencapsulation\n    : public_key_T ->  weighted_T\n    -> (session_key_t, cipher_text_T)\nencapsulation T e =  (K, C) where\n    \/\/ step 1. uniform random vector e (given as input)\n    \/\/ step 2. use encoding subroutine on e and public key T to compute Co\n    (C0 : C0_T) = encoding_subroutine e T\n        (C1: C1_T) = compute_hash_2e e\n    (C: cipher_text_T) = {C0 = C0, C1 = C1}\n    (K: session_key_t) = compute_hash_1e e C\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/CM_819.cry","filetype":"cry","content":"module CM_819 where\n\nimport CM_Parameters\n\nCM_819 =\n    { m = 13 : a_ty\n    , q = (2^13) : a_ty\n    , n = 8192 : a_ty\n    , t = 128 : a_ty\n    , k = (8192-(13*128)) : a_ty\n    , d = 256 : a_ty\n    } : CM\n","variant":"hybrid","set":"supervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Key_Generation.cry","filetype":"cry","content":"module Key_Generation where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\n\/\/ in order of general algorithm spec\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T\ntype H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                \/\/ [13]Bit\n    , a : alphas_T              \/\/ [6960][13]Bit  \/\/[n][m]Bit\n    }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                   \/\/ [870][8]Bit\n    , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\ntype e_T =\n    { length : n_T\n    , hammington_weight : t_T\n    }\n\n\nrandom_element : field_element_T\nrandom_element = ([True | i <- [1..m]])\nrandom_elements : {t0}(fin t0, t0>=1) => [t0]field_element_T\nrandom_elements = ([random_element | i <- [1..t0]])\n\nstep_1 = random_elements `{ t0 = t-1}#[1]\n\nstep_3 : (t * n == min t n) =>  poly_T -> alphas_T -> H_T\nstep_3 g alphas = [[ f i j | j <- [1..n]] | i <- [1..t]]\n    where f i j = aj \/ (g @ aj)\n            where aj = alphas@j\n\nstep_5 : H_T -> (Bool, public_key_T)\nstep_5 H_tilde = undefined\n\nmk_gamma : Integer -> (gamma_T,public_key_T)\nmk_gamma counter =\n    if(flag) then ({p=g, a=alphas}, public_key)\n    else if (counter < 100)\n        then mk_gamma (counter+1)\n    else undefined\n    where\n                (g: poly_T) = step_1\n        (alphas: alphas_T) =  random_elements `{ t0 = n}\n        (H_tilde: H_T) = step_3 g alphas\n        (flag, public_key) = step_5 H_tilde\n\nkey_generation : [n]Bit -> (public_key_T, private_key_T)\nkey_generation s = (public_key, private_key) where\n    (gamma: gamma_T, public_key: public_key_T) = mk_gamma 0\n    (private_key: private_key_T) = {s=s, g=gamma}\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Types.cry","filetype":"cry","content":"module Types where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\n\/\/ in order of general algorithm spec\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T  \/\/ also n-k\ntype H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                \/\/ [13]Bit\n    , a : alphas_T              \/\/ [6960][13]Bit  \/\/[n][m]Bit\n    }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                   \/\/ [870][8]Bit\n    , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\n\n\/\/ a bit string of length and Hamming weight T\ntype weighted_T = n_T\n\n\n-------------\n\/\/\/\/type crypto_kem_CIPHERTEXTBYTES = [226] -> 1808\n\/\/vs. {mt_T, d_T}  (1547, 256) -> 1803\n\n\n\/\/type crypto_kem_PUBLICKEYBYTES = [1047319]\n\/\/ [1547][5413]   ->8373911\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/keccak.cry","filetype":"cry","content":"\/\/ Specification of the Keccak (SHA-3) hash function\n\/\/ Author: David Lazar\n\nmodule Keccak where\n\nSHA_3_224 M = take`{224} (Keccak `{r = 1152, c =  448} (M # 0b01))\nSHA_3_256 M = take`{256} (Keccak `{r = 1088, c =  512} (M # 0b01))\nSHA_3_384 M = take`{384} (Keccak `{r =  832, c =  768} (M # 0b01))\nSHA_3_512 M = take`{512} (Keccak `{r =  576, c = 1024} (M # 0b01))\nSHAKE128 M = Keccak`{r = 1344, c = 256} (M # 0b1111)\nSHAKE256 M = Keccak`{r = 1088, c = 512} (M # 0b1111)\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Specification of the cSHAKE (customizable SHAKE) function\n\n\/\/ cshake_128 : {m, n, s} \n\/\/     ( fin m\n\/\/     , fin n\n\/\/     , fin s\n\/\/    \/\/ , m >= 192\n\/\/     \/\/, m <=320\n\/\/     , (2^^2040-1) >= (n*8)\n\/\/     , (2^^2040-1) >= (n*s)\n\/\/     ) => [m] -> [n][8] -> [s][8]-> [inf]\nCSHAKE128 M s1 s2 = if (s1 == \"\" \/\\ s2 == \"\") then (SHAKE128 M)\n                                               else (Keccak`{r = 1344, c = 256} (join(s1)#join(s2)#M#0b00))\n\n\/\/ NOTE: We are unsure if (join(s1)#join(s2)#M#0b00)) is the correct value\n\n\n\/\/ cshake_256 : {m, n, s} \n\/\/     ( fin m\n\/\/     , fin n \n\/\/     , fin s\n\/\/    \/\/ , m >= 192\n\/\/    \/\/ , m <=320\n\/\/     , (2^^2040-1) >= (n*8)\n\/\/     , (2^^2040-1) >= (n*s)\n\/\/     ) => [m] -> [n][8] -> [s][8]-> [inf]\nCSHAKE256 M s1 s2 = if (s1 == \"\" \/\\ s2 == \"\") then (SHAKE256 M)\n                                               else (Keccak`{r = 1088, c = 512} (join(s1)#join(s2)#M#0b00))\n\n\/\/ NOTE: We are unsure if (join(s1)#join(s2)#M#0b00)) is the correct value\n\n\nKeccak : {r, c, m}\n  ( fin r, fin c, fin m\n  , r >= 1\n  , (r + c) % 25 == 0\n  , 64 >= (r + c) \/ 25\n  ) => [m] -> [inf]\nKeccak M = squeeze `{r = r} (absorb `{w = (r + c) \/ 25} Ps)\n  where Ps = pad `{r = r} M\n\nsqueeze : {r, w} (fin r, fin w, 64 >= w, r >= 0, 25 * w >= r) => [5][5][w] -> [inf]\nsqueeze A = take`{r} (flatten A) # squeeze`{r = r} (Keccak_f A)\n\nabsorb : {r, w, n} (fin r, fin w, fin n, 64 >= w, 25 * w >= r) => [n][r] -> [5][5][w]\nabsorb Ps = as ! 0\n  where\n    as = [zero] # [ Keccak_f `{w = w} (s ^ (unflatten p)) | s <- as | p <- Ps ]\n\npad : {r, m}\n  ( fin r, fin m\n  , r >= 1\n  ) => [m] -> [(m + 2) \/^ r][r]\n  \npad M = split (M # [True] # zero # [True])\n\nKeccak_f : {w} (fin w, 64 >= w) => [5][5][w] -> [5][5][w]\nKeccak_f A0 = rounds ! 0\n  where\n    rounds = [A0] # [ Round RC A | RC <- RCs`{w = w} | A <- rounds ]\n\nRound : {w} (fin w) => [5][5][w] -> [5][5][w] -> [5][5][w]\nRound RC A = \u03b9 RC (\u03c7 (\u03c0 (\u03c1 (\u03b8 A))))\n\n\u03b8 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03b8 A = A'\n  where\n    C = [ xor a | a <- A ]\n    D = [ C @ x ^ (C @ y <<< 1)\n        | (x:[8]) <- [4,0,1,2,3]\n        | (y:[8]) <- [1,2,3,4,0]\n        ]\n    A' = [ [ a ^ (D @ x) | a <- A @ x ] | (x:[8]) <- [0 .. 4] ]\n\n\u03c1 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03c1 A = groupBy`{5} [ a <<< r | a <- join A | (r:[8]) <- R ]\n  where R = [00, 36, 03, 41, 18,\n             01, 44, 10, 45, 02,\n             62, 06, 43, 15, 61,\n             28, 55, 25, 21, 56,\n             27, 20, 39, 08, 14]\n\n\u03c0 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03c0 A = groupBy`{5} [ A @ ((x + 3*y) % 5) @ x\n                  | (x:[8]) <- [0..4], (y:[8]) <- [0..4]\n                  ]\n\n\u03c7 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03c7 A = groupBy`{5} [ (A @ x @ y) ^ (~ A @ ((x + 1) % 5) @ y\n                                  && A @ ((x + 2) % 5) @ y)\n                  | (x:[8]) <- [0..4], (y:[8]) <- [0..4]\n                  ]\n\n\u03b9 : {w} (fin w) => [5][5][w] -> [5][5][w] -> [5][5][w]\n\u03b9 RC A = A ^ RC\n\nRCs : {w, n} (fin w, fin n, 24 >= n, n == 12 + 2 * (lg2 w)) => [n][5][5][w]\nRCs = take`{n} [ [[take`{w} RC] # zero] # zero | RC <- RCs64 ]\n\nRCs64 : [24][64]\nRCs64 = join (transpose [\n    [0x0000000000000001, 0x000000008000808B],\n    [0x0000000000008082, 0x800000000000008B],\n    [0x800000000000808A, 0x8000000000008089],\n    [0x8000000080008000, 0x8000000000008003],\n    [0x000000000000808B, 0x8000000000008002],\n    [0x0000000080000001, 0x8000000000000080],\n    [0x8000000080008081, 0x000000000000800A],\n    [0x8000000000008009, 0x800000008000000A],\n    [0x000000000000008A, 0x8000000080008081],\n    [0x0000000000000088, 0x8000000000008080],\n    [0x0000000080008009, 0x0000000080000001],\n    [0x000000008000000A, 0x8000000080008008]\n])\n\nunflatten : {r, w} (fin w, 25*w >= r) => [r] -> [5][5][w]\nunflatten p = transpose (groupBy`{5} (reverse (groupBy`{w} (reverse (p # zero)))))\n\nflatten : {w} (fin w) => [5][5][w] -> [5 * 5 * w]\nflatten A = reverse (join (reverse (join (transpose A))))\n\nxor : {a, b} (fin a) => [a][b] -> [b]\nxor xs = xors ! 0\n  where xors = [zero] # [ x ^ z | x <- xs | z <- xors ]\n\nproperty RC_correct i j =\n  (i:[8]) < 24 ==> (j:[8]) < 7 ==> RCs64@i!(2^^j - 1) == lfsr@(j + 7*i)\n\nlfsr : [inf]\nlfsr = [ p!0 | p <- ps ]\n  where\n    \/* powers of x modulo m *\/\n    ps = [0x01] # [ pmod (pmult p 0b10) m | p <- ps ]\n    m = <| x^^8 + x^^6 + x^^5 + x^^4 + 1 |>\n\n\/* See https:\/\/keccak.team\/files\/Keccak-reference-3.0.pdf, Section 1.2 *\/\nproperty unflatten_correct x y z p =\n  x < 5 ==> y < 5 ==> z < (64:[12]) ==>\n  p@((5*y + x)*64 + z) == unflatten`{1600,64} p @ x @ y ! z\n\nproperty flatten_correct s =\n  unflatten`{1600,64} (flatten`{64} s) == s\n\n\/** Splits a list of bits into bytes, using little-endian bit order. **\/\ntoBytes : {n} (fin n) => [8*n] -> [n][8]\ntoBytes s = reverse (split (reverse s))\n\n\/** Joins a list of bytes into a list of bits, using little-endian bit order. **\/\nfromBytes : {n} (fin n) => [n][8] -> [8*n]\nfromBytes bs = reverse (join (reverse bs))\n\n\/*\nTest vectors from\nhttps:\/\/csrc.nist.gov\/projects\/cryptographic-standards-and-guidelines\/example-values#aHashing\n*\/\n\nproperty t1 = join (toBytes (SHA_3_224 [])) ==\n  0x6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7\nproperty t2 = join (toBytes (SHA_3_256 [])) ==\n  0xa7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a\nproperty t3 = join (toBytes (SHA_3_384 [])) ==\n  0x0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004\nproperty t4 = join (toBytes (SHA_3_512 [])) ==\n  0xa69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26\n\nproperty u1 = join (toBytes (SHA_3_224 0b11001)) ==\n  0xffbad5da96bad71789330206dc6768ecaeb1b32dca6b3301489674ab\nproperty u2 = join (toBytes (SHA_3_256 0b11001)) ==\n  0x7b0047cf5a456882363cbf0fb05322cf65f4b7059a46365e830132e3b5d957af\nproperty u3 = join (toBytes (SHA_3_384 0b11001)) ==\n  0x737c9b491885e9bf7428e792741a7bf8dca9653471c3e148473f2c236b6a0a6455eb1dce9f779b4b6b237fef171b1c64\nproperty u4 = join (toBytes (SHA_3_512 0b11001)) ==\n  0xa13e01494114c09800622a70288c432121ce70039d753cadd2e006e4d961cb27544c1481e5814bdceb53be6733d5e099795e5e81918addb058e22a9f24883f37\n\nmsg1600 : [1600]\nmsg1600 = join [ 0b11000101 | _ <- zero : [200] ]\n\nproperty v1 = join (toBytes (SHA_3_224 msg1600)) ==\n  0x9376816aba503f72f96ce7eb65ac095deee3be4bf9bbc2a1cb7e11e0\n\nproperty w1 = join (toBytes (SHA_3_224 (msg1600 # 0b11000))) ==\n  0x22d2f7bb0b173fd8c19686f9173166e3ee62738047d7eadd69efb228\n\n\/\/SHAKE -- Test Vectors\n\/\/Author: Ajay Kumar Eeralla\n\/\/source:https:\/\/github.com\/XKCP\/XKCP\/tree\/master\/tests\/TestVectors\n\nproperty k1 = join (toBytes (take`{512} (SHAKE128 []))) == 0x7f9c2ba4e88f827d616045507605853ed73b8093f6efbc88eb1a6eacfa66ef263cb1eea988004b93103cfb0aeefd2a686e01fa4a58e8a3639ca8a1e3f9ae57e2\n\nproperty k2 = join (toBytes (take`{512} (SHAKE128 0b0))) == 0xe78b86559a9ccdc72288bf7bcf8e11d574543a2922978913a02be149e89d03cae63d2c36e2cf6906791b187d7e371d4f21ebe59dcfc249a510b82255a18250dd\n\nproperty k3 = join (toBytes (take`{512} (SHAKE128 0b11))) == 0xf6b6c4093f0a2ceba61b9f2c2fea2ca238ce9005edcd588c380405070532ddd00cbd3a3a7448017d874c52c9e383fa3db1c184e023181fcc8550f53ac92feca5\n\nproperty k4 = join (toBytes (take`{512} (SHAKE256 []))) == 0x46b9dd2b0ba88d13233b3feb743eeb243fcd52ea62b81b82b50c27646ed5762fd75dc4ddd8c0f200cb05019d67b592f6fc821c49479ab48640292eacb3b7c4be\n\nproperty k5 = join (toBytes (take`{512} (SHAKE256 0b0))) == 0x1e20b13f3bdb730d286913335c092bcec0eb1aff2798c05736faa93bd665807a48ed7652aefd600427e9f797d647b9b355d30410d71b8e275a676545600f1c35\n\nproperty k6 = join (toBytes (take`{512} (SHAKE256 0b11))) == 0x4f86b0eb85f7a9f6dc38b622706948adb2beb6dd6911b5e9d865fd1f9667b5c02a0dbb39c488b040a18ff3885f04ef957c98f3948e6b7959a9b8950ffd6345d5\n\n","variant":"hybrid","set":"supervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Shared.cry","filetype":"cry","content":"module Shared where\n\nimport Types\nimport Keccak\n\ncvt_bit_int b = if(b) then 1 else 0\ncvt_int_bit i = if(i==1) then True else False\n\n\/\/ matrix multiplication\ncompute_He : H_T -> e_T -> C0_T\n\/\/ also [n-k][n]f2_T -> [n]f2_T -> [n-k]f2_T\ncompute_He H e =\n    [ cvt_int_bit (sum (f hi)) | hi <- H ]\n        where f hi = [ (cvt_bit_int hij) * (cvt_bit_int ej)\n            |  ej <- e | hij <- hi]\n\n\/\/ Define H = (I_n-k |T )\n\/\/[n-k][n][2]   = [n-k][n-k][2] :: [n-k][k][2]\ncompute_H : public_key_T -> H_T\ncompute_H T =\n    [ (I i) # T@i | i <- [0..(n-k-1)]]\n    where I i = (update zero i True)\n\ncompute_hash_e : Integer -> e_T -> C1_T\ncompute_hash_e  i e = out where\n    (a: [8]) = fromInteger `{[8]} i\n    (x:[inf]) = SHAKE256 ((fromInteger `{[8]} i) # e)\n    (out: C1_T) = take `{256} x\n\ncompute_hash_eC\n    : Integer -> e_T -> cipher_text_T -> session_key_T\ncompute_hash_eC  i e C = out where\n    (a: [8]) = fromInteger `{[8]} i\n    (x:[inf]) = SHAKE256 (a # e # C.C0 # C.C1)\n    (out: session_key_T) = take `{32} x\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Decapsulation.cry","filetype":"cry","content":"module Decapsulation where\n\nimport Types\nimport Shared\n\n\/\/ Hamming weight. Number of ones\nget_weight : n_T  -> Integer\nget_weight e = sum ([cvt_bit_int i | i <- e])\n\ncheck_e : e_T -> public_key_T -> C0_T -> (e_T, Bool)\ncheck_e e public_key C0 =\n    if((get_weight e == glob_t) && (C0 == C0'))\n    then (e, True)\n    else (zero, False)\n    where\n        \/\/ checks that \"C0 = He\"\n        (H: H_T) = compute_H public_key\n        (C0':C0_T) = compute_He H e\n\n\/\/[mt]-> {[n],{[t],[n]}} -> [mt][k] \ndecrypt\n    : C0_T -> private_key_T -> public_key_T -> fn_get_goppa_T\n    -> (e_T, Bool)\ndecrypt C0 private_key public_key get_goppa = (e, dec_pass) where\n    (failure : (e_T, Bool)) = (zero, False)\n    (s : n_T) = private_key.s\n    (gamma : gamma_T) = private_key.g\n    \/\/ step 1 : extend C0 to v\n    (v:n_T) = C0#zero\n    \/\/step2 : find unique codeword in the Goppa code\n    (c:n_T, goppa_pass) = get_goppa gamma\n    (e, dec_pass) =\n        if(~ goppa_pass)\n        then failure\n        else (check_e e public_key C0)             where\n            \/\/step 3 : set e to v plus c\n            (e :e_T) = v+c\n\n\/* Note without get_goppa function can use decrypt_1()\n    but it hase different type spec\n    decrypt_1 : ciphertext_t ->  secretkey_t -> (SYS_N8_t, gf_t)\n    It was written based on the reference spec\n*\/\ndecapsulation\n    : cipher_text_T -> private_key_T -> public_key_T -> fn_get_goppa_T\n    -> session_key_T\ndecapsulation C private_key public_key get_goppa =  K where\n    \/\/step 1 :split ciphertext\n    C0 = C.C0\n    C1 = C.C1\n    s = private_key.s\n    gamma = private_key.g\n    \/\/step 2 : set b to 1\n    b_1 = 1\n    \/\/step 3 : use decoding subroutine\n    (e_1:e_T, dec_pass) = decrypt C0 private_key public_key get_goppa\n    (e_2:e_T, b_2) =\n        if(dec_pass)\n        then (e_1, b_1)\n        else (s, 0) \/\/ case of failure\n    \/\/step 4 : compute C1 for H input encoding\n    (C1': C1_T) = compute_hash_e 2 e_2\n    \/\/step 5 : Compare C1\n    (e_3:e_T, b_3) =\n        if(C1==C1')\n        then (e_2, b_2)\n        else (s, 0)\n    \/\/step 6 : H input encodings\n    (K: session_key_T) = compute_hash_eC b_2 e_3 C\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Encapsulation.cry","filetype":"cry","content":"module Encapsulation where\n\nimport Types\nimport Shared \n\n\/\/ encoding subroutine\nencoding_subroutine : e_T -> public_key_T -> C0_T\nencoding_subroutine e T = C0 where\n    (H:H_T) = compute_H T\n    (C0:C0_T) = compute_He H e\n\nencapsulation\n    : public_key_T ->  e_T\n    -> (session_key_T, cipher_text_T)\nencapsulation T e =  (K, C) where\n    \/\/ step 1. uniform random vector e (given as input)\n    \/\/ step 2. use encoding subroutine on e and public key T to compute Co\n    (C0 : C0_T) = encoding_subroutine e T\n        (C1: C1_T) = compute_hash_e 2 e\n    (C: cipher_text_T) = {C0 = C0, C1 = C1}\n    (K: session_key_T) = compute_hash_eC 1 e C\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/decrypt.cry","filetype":"cry","content":"module Decrypt where\n\n\nimport Types\nimport Shared\nimport Benes\nimport Decrypt_helpers\nimport GF\nimport Util\n\ndecrypt_1\n    : ciphertext_t ->  secretkey_t\n    -> (SYS_N8_t, gf_t)\ndecrypt_1 c sk = (e, check) where\n    (r : SYS_N8_t) = (take `{194} c)#zero\n    loop_1 g i sk_index =\n        if i < glob_t\n        then loop_1 g' (i+1) (sk_index+2) where\n            (a : gf_t)= load2 sk sk_index\n            (b : gf_t) = a && cvt_16 GFMASK\n            g'= update g i b\n        else g\n    (g_0 : SYS_T_plus1) = zero\n    (g_1 : SYS_T_plus1) = loop_1 g_0 0 0\n    (L : SYS_N_t) = support_gen sk\n    (s : SYS_T_double_t) = synd g_1 L r\n    (locator : SYS_T_plus1) = bm s\n    (images : SYS_N_t) = root locator L\n    loop_2 : [32] -> SYS_N8_t -> gf_t -> (SYS_N8_t, gf_t)\n    loop_2 i e w =\n        if (i<glob_n)\n        then loop_2 (i+1) e' w' where\n            (t : gf_t) = (gf_iszero (images @i)) && (1:[16])\n            jx = i\/8\n            val = (e@jx) || t << (i%8)\n            (e' :SYS_N8_t) = update e jx val\n            (w' : gf_t) = w+t\n        else (e, w)\n    (e :SYS_N8_t, w : gf_t) = loop_2 0 zero 0\n    (s_cmp : SYS_T_double_t) = synd g_1 L e\n    loop_3 i check =\n        if (i<glob_t*2)\n        then  loop_3 (i+1) check' where\n            check' = check || ((s@i) ^ (s_cmp@i))\n        else check\n    (check_0 : gf_t) = w ^ glob_t\n    (check_1 : gf_t) = loop_3 0 check_0\n    (check_2 : gf_t) = (check_1 -1)>> 15\n    (check : gf_t) = check_2 ^ 1\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Gauss.cry","filetype":"cry","content":"module Gauss where\n\nimport Types\nimport Keccak\nimport Shared\n\ntype M_len1 = n-k\nglob_M_len1 = glob_n-glob_k\ntype b_len2 = k\nglob_b_len2 = glob_k\ntype a_in_T = [M_len1][M_len1]\ntype b_in_T = [M_len1][b_len2]\n\n\/\/ ----------------------- Gaussian Elimination -----------------------\n\/\/ reference https:\/\/rosettacode.org\/wiki\/Gaussian_elimination\n\/\/index Matrix a\nindex M i j = cvt_bit_int ((M@i)@j)\n\nupdate_M M i j v =\n    update M i val' where\n    N =  index M i j\n    val = cvt_int_bit v\n    val' = update N j val\n\nloop_3\n    : a_in_T -> b_in_T -> [32]\n    -> (a_in_T, b_in_T)\nloop_3 a_in b_in i =\n    inner (i+1) a_in b_in where\n    inner j A B =\n        if(j < glob_M_len1)\n        then\n            (A_1, B_1) where\n            tmp = (index A j i)\/ (index A i i)\n            i' = i+1\n                        \/* one way we want to write it\n            A_1 = [(index A j k)- (tmp *(index A i k))\n                    | j <- [i'..(M_len1-1)]\n                    | k <- [i'..(M_len1-1)]]\n            B_1 = [(index B j k)- (tmp *(index B i k))\n                    | j <- [i'..(M_len1-1)]\n                    | k <- [i'..(b_len2-1)]]\n            *\/\n            loop_j1 k k_limit M  =\n                if (k<k_limit)\n                then loop_j2 k' k_limit M' where\n                    k' = k+1\n                    val = (index M j k) - ((index M i k) * tmp)\n                    M' = update_M M j k val\n                else M\n            loop_j2 k k_limit M  =\n                if (k<k_limit)\n                then loop_j2 k' k_limit M' where\n                    k' = k+1\n                    val = (index M j k) - ((index M i k) * tmp)\n                    M' = update_M M j k val\n                else M\n            A_1 = loop_j1 (i+1) glob_M_len1 A\n            B_1 = B         else (A ,B)\n\nbig_loop_1\n    : [32] -> a_in_T -> b_in_T -> [32]\n     -> (a_in_T, b_in_T, [32])\nbig_loop_1 i A B det =\n    if (i< (glob_M_len1-1))\n    then big_loop_1 (i+1) A_2 B_2 det_1 where\n        inner_1 : [32] -> [32] -> [32]\n        inner_1 j k =\n            if(j<glob_M_len1)\n            then\n                if((abs_index A j i) > (abs_index A k i))\n                then j\n                else inner_1 (j+1) k\n            else i         inner_2 k = (A_1, B_1, det_1) where\n                \/\/swap values a[i]=a[k], a[k]=a[i]\n                v1 = index A i k\n                v2 = index A k i\n                A_1 = update_M (update_M A i k v2) k i v1\n                u1 = index B i k\n                u2 = index B k i\n                B_1 = update_M (update_M B i k u2) k i u1\n                det_1 = -1 * det\n                abs_index M i j  = if (val<0)then -1* val else val\n            where val = index M i j\n        k = inner_1 (i+1) i\n        (A_1, B_1, det_1) =\n            if (k!=i) then inner_2 det else (A, B, det)\n        (A_2, B_2) = loop_3 A_1 B_1 i\n    else (A, B, det)\n\nbig_loop_2\n    : [32] -> a_in_T -> b_in_T -> [32]\n    -> b_in_T\nbig_loop_2 i A B_in det =\n    if(i>=0)\n    then big_loop_2 (i+1) A B_3 det_1 where\n        loop_j : [32] -> b_in_T -> b_in_T\n        loop_j j B =\n            if (j<glob_M_len1)\n            then loop_j j' B_1 where\n                tmp = index A i j\n                loop_k k B =\n                    if (k<glob_b_len2)\n                    then loop_k k' B_1 where\n                        k' = k+1\n                        val = (index B i k) - (tmp* (index B j k))\n                        B_1 = update_M  B i k val\n                    else B\n                B_1 = loop_k 0 B\n                j' = j+1\n            else B\n        B_1 = loop_j (i+1) B_in\n        val = index A i i\n        t = 1\/val\n        det_1 = det * val\n        loop_j2 j B_2 =\n            if (j<glob_b_len2)\n            then loop_j2 j' B_3 where\n                j' = j+1\n                val = ((index B_2 i j) * t)\n                B_3 = update_M B_2 i j val\n            else B_2\n        B_3 = loop_j2 0 B_1\n    else B_in\n\n\/\/guassian : H_tilde_T -> (Bool, public_key_T)\n\/\/ H_tilde_T    =   [t][n][m]f2_T\n\/\/ public_key_T = [n-k][k]f2_T\nguassian : a_in_T ->  (Bool, b_in_T)\nguassian a  = (True, B_2) where\n    det = 1\n    (b : b_in_T) = zero\n    (A_1, B_1, det_1) = big_loop_1 0 a b det\n    (B_2) = (big_loop_2 0 A_1 B_1 det_1)\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Key_Generation.cry","filetype":"cry","content":"module Key_Generation where\n\nimport Types\nimport Shared\n\n\n\/\/h_ij  = a_j ^(i-1) \/ g(alpha_j)\ncompute_H_tilde : poly_T -> alphas_T -> [t][n][m]Bit\ncompute_H_tilde g alphas =\n    [[ f i j | j <- [1..n]] | i <- [1..t]]\n            where f i j = aj \/ (g @ aj)\n                    where aj = alphas@j\n\nmk_gamma \n\t: [32]->[32] ->[inf]poly_T -> [inf]alphas_T -> fn_gauss_T\n\t-> (Bool, gamma_T, public_key_T)\nmk_gamma counter counter_limit gs alphas fn_gauss =\n\tif(counter<counter_limit) then \n\t\tif(flag) \n\t\t\tthen (True, current_gamma, public_key)\n\t\t\telse mk_gamma (counter+1) counter_limit gs alphas fn_gauss\n\t\twhere\n\t\t\tg = gs@counter\n\t\t\talpha = alphas@counter\n            \/\/ current gamma selection if successful \n\t\t\tcurrent_gamma = { p = g, a = alpha }\n            \t\t\t(H_tilde: H_tilde_T) = compute_H_tilde g alpha\n            \t\t\t(flag, public_key) = fn_gauss H_tilde\n\telse \n\t\t(False, zero, zero)\n\n\n\/\/ g: uniform random monic irreducible polynomial \n\/\/ alpha :uniform random sequence\n\/\/ counter_limit : how many times should to go back to step 1 if H can be transformed to systematic form\n\/\/ fn_gauss_T : function to apply Gaussian elimination\n\/\/            see also Gauss.cry for example\n\/\/ failed state in this case is zero\nkey_generation\n\t : [n]Bit -> [inf]poly_T -> [inf]alphas_T -> [32] -> fn_gauss_T\n\t-> (public_key_T, private_key_T)\nkey_generation s gs alphas counter_limit fn_gauss = (public_key, private_key) where\n    (rtn, gamma: gamma_T, public_key: public_key_T) = mk_gamma 0 counter_limit gs alphas fn_gauss\n    (private_key: private_key_T) = if rtn then  {s=s, g=gamma} else zero\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Types.cry","filetype":"cry","content":"module Types where\n\n\nglob_t = 119\ntype t = 119\nglob_n = 6960\ntype n = 6960\nglob_m = 13\ntype m = 13\ntype d = 256\ntype mt = m*t \/\/1547\n\/\/--------------------------------------------\n\/\/ Structure Defined by spec\n\/\/--------------------------------------------\nglob_k = (glob_n-glob_m*glob_t) type k = (n-m*t) \/\/ 5413\n\/\/ in order of general algorithm spec\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [k]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [mt]f2_T  \/\/ also n-k\ntype public_key_T = [mt][k]f2_T\ntype H_T = [n-k][n]f2_T \ntype H_tilde_T = [t][n][m]f2_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                \/\/ [13]Bit\n    , a : alphas_T              \/\/ [6960][13]Bit  \/\/[n][m]Bit\n    }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                   \/\/ [870][8]Bit\n    , g : gamma_T\n    }\n\ntype C0_T = mt_T \/\/ also n-k \/\/1547\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\n\n\/\/ a bit string of length and Hamming weight T\ntype weighted_T = n_T\ntype e_T = n_T\n\ntype session_key_T = [32]\n\ntype fn_get_goppa_T = gamma_T -> (n_T, Bool)\ntype fn_gauss_T = H_tilde_T -> (Bool, public_key_T)\n\n\n\/\/--------------------------------------------\n\/\/ Structure Defined by reference implementation\n\/\/--------------------------------------------\n\/\/ Base Types\ntype base_16t = [16]\ntype base_32t = [32]\ntype base_64t = [64]\ntype uint16t = [16]\ntype uint64t = [64]\ntype uint32t = [32]\ntype gf_t = base_t\n\/\/conversions\ncvt_16 e = fromInteger `{[16]} (toInteger e)\ncvt_32 e = fromInteger `{[32]} (toInteger e)\ncvt_64 e = fromInteger `{[64]} (toInteger e)\n\n\n\/\/specific to low level implementation of goppa code\nGFBITS =  13\ntype GFBITS_t =  13\ntype base_t = base_16t\ntype secretkey_t = [13908] base_t\ntype ciphertext_t = [226] base_t  \/\/ crypto_kem_CIPHERTEXTBYTES\n\ntype SYS_N_t = [n]base_t\ntype SYS_N8_t = [n\/8] base_t\ntype SYS_T_double_t = [t*2]base_t\ntype SYS_T_plus1 = [t+1]base_t\nSYS_T_double =  glob_t*2 \/\/ support_gen in benes\nGFMASK  =  cvt_64 (((1:[32]) << GFBITS) - 1)\ntype j_size_t =  1024 \/\/((1:[32]) << GFBITS)\/8\ntype La_t = [32]\ntype Lb_t = [j_size_t][32]\ntype Lc_t = [GFBITS_t][j_size_t][32]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/util.cry","filetype":"cry","content":"module Util where\n\nimport Types\n\nload2 : secretkey_t -> [32] -> gf_t\nload2 src sk_index = (a && (cvt_16 GFMASK)) where\n    (a: base_16t) = src@(1+sk_index)\n    b = a << 8\n    c = b || src@(0+sk_index)\n\n\n\nbitrev : [32] -> ([32],  [32])\nbitrev a = (cvt_32 a_4, cvt_32(a_4>>3)) where\n    a_0 = cvt_16 a\n    a_1 = ((a_0 && 0x00FF) << 8) || ((a_0 && 0xFF00) >> 8)\n    a_2 = ((a_1 && 0x0F0F) << 4) || ((a_1 && 0xF0F0) >> 4)\n    a_3 = ((a_2 && 0x3333) << 2) || ((a_2 && 0xCCCC) >> 2)\n    a_4 = ((a_3 && 0x5555) << 1) || ((a_3 && 0xAAAA) >> 1)\n\n\nstore8 out in = out\nload8 in = zero\ntranspose_64x64 in = zero\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/SAW\/spec\/AES\/AES-GCM-implementation.cry","filetype":"cry","content":"module AES_GCM_Implementation where\n\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM\nimport AES_GCM\n\n\n\/*\n * GCM polyval mul\/red implementations\n *\/\ngcm_polyval_mul_pmult3 : {n} (fin n) => [2 * (1 + n)] -> [2 * (1 + n)] -> [4 * (1 + n)]\ngcm_polyval_mul_pmult3 X Y = r3 # (r2 ^ r1 ^ r3 ^ m1) # (r1 ^ r0 ^ r2 ^ m0) # r0\n  where\n    [X_hi, X_lo] = split X\n    [Y_hi, Y_lo] = split Y\n    [r1, r0] = split ((0 : [1]) # (pmult X_lo Y_lo))\n    [r3, r2] = split ((0 : [1]) # (pmult X_hi Y_hi))\n    [m1, m0] = split ((0 : [1]) # (pmult (X_lo ^ X_hi) (Y_hi ^ Y_lo)))\n\ngcm_polyval_mul_pmult4 : {n} (fin n) => [2 * (1 + n)] -> [2 * (1 + n)] -> [4 * (1 + n)]\ngcm_polyval_mul_pmult4 X Y = (hi ^ (0 : [1 + n]) # (hi_bits (m0 ^ m1))) # (lo ^ ((lo_bits (m0 ^ m1)) # (0 : [1 + n])))\n  where\n    [X_hi, X_lo] = split X\n    [Y_hi, Y_lo] = split Y\n    lo = (0 : [1]) # (pmult X_lo Y_lo)\n    hi = (0 : [1]) # (pmult X_hi Y_hi)\n    m0 = (0 : [1]) # (pmult X_lo Y_hi)\n    m1 = (0 : [1]) # (pmult X_hi Y_lo)\n\ngcm_polyval_red_pmult : [256] -> [128]\ngcm_polyval_red_pmult X = (d1 ^ x3) # (d0 ^ x2)\n  where\n    [x3, x2, x1, x0] = split X\n    [a1, a0] = split ((0 : [1]) # (pmult <| x^^63 + x^^62 + x^^57 |> x0))\n    b1 = x0 ^ a1\n    b0 = x1 ^ a0\n    [c1, c0] = split ((0 : [1]) # (pmult <| x^^63 + x^^62 + x^^57 |> b0))\n    d1 = b0 ^ c1\n    d0 = b1 ^ c0\n\ngcm_polyval_avx : [128] -> [128] -> [128]\ngcm_polyval_avx H X = x30\n  where\n    [H_hi, H_lo] = split H\n    [X_hi, X_lo] = split X\n    x17 = (0 : [1]) # (pmult H_lo X_lo)\n    x18 = ((0 : [1]) # (pmult H_hi X_hi)) ^ x17\n    x19 = x18 ^ ((0 : [1]) # (pmult (H_lo ^ H_hi) (X_lo ^ X_hi)))\n    x20 = (lo_bits x19) # (0 : [64])\n    x21 = x17 ^ x20\n    x22 = hi_bits x21\n    x23 = lo_bits x21\n    x25 = (take`{8} ((x23 << 57) ^ (x23 << 62) ^ (x23 << 63))) # (0 : [120])\n    x26 = x21 ^ x25\n    x27 = (hi_bits x26) >> 1\n    x28 = (lo_bits x26) >> 1\n    x29 = (x26 ^ (x27 # x28)) ^ ((x27 >> 5) # (x28 >> 5))\n    x30 = ((((x18 ^ x20) ^ ((0 : [64]) # (hi_bits x19))) ^ x25) ^ ((0 : [64]) # (take`{8} ((x22 << 57) ^ (x22 << 62) ^ (x22 << 63))) # (0 : [56]))) ^ (((hi_bits x29) >> 1) # ((lo_bits x29) >> 1))\n\n\n\/*\n * aesni_gcm_cipher Cryptol implementation\n *\/\naesni_gcm_cipher : {n} (fin n) => [32] -> AES_GCM_Ctx -> [(1 + n) * 6 * 16][8] -> [16][8]\naesni_gcm_cipher enc ctx in = ctx''.Xi\n  where\n    enc_blks = if enc ! 0\n      then split (aesni_gcm_ctr32_encrypt_block ctx in)\n      else split (map join (split in))\n    ctx' = aesni_gcm_cipher_block6 enc False ctx (enc_blks @ 0)\n    ctx'' = foldl (aesni_gcm_cipher_block6 enc (enc ! 0)) ctx' (drop`{1} enc_blks)\n\naesni_gcm_ctr32_encrypt_block : {n} (fin n) => AES_GCM_Ctx -> [n * 16][8] -> [n][16 * 8]\naesni_gcm_ctr32_encrypt_block ctx in = out\n  where\n    ctr = drop ((ctx.len \/ 16) + 1)\n    in' = split in\n    out = [ swap8 ((join (reverse blk)) ^ (join (reverse (EKi ctx (ctr + i))))) | blk <- in' | i <- [0 ...] ]\n\naesni_gcm_cipher_block6 : [32] -> Bit -> AES_GCM_Ctx -> [6][128] -> AES_GCM_Ctx\naesni_gcm_cipher_block6 enc karatsuba ctx blks = ctx'\n  where\n    gcm_polyval_mul_fun = if karatsuba\n      then gcm_polyval_mul_pmult3\n      else gcm_polyval_mul_pmult4\n    Htable = get_Htable ctx\n    Xi = join ctx.Xi\n    Xi_0 = gcm_polyval_mul_fun (Htable @ 0) (blks @ 5)\n    Xi_1 = gcm_polyval_mul_fun (Htable @ 1) (blks @ 4)\n    Xi_2 = gcm_polyval_mul_fun (Htable @ 3) (blks @ 3)\n    Xi_3 = gcm_polyval_mul_fun (Htable @ 4) (blks @ 2)\n    Xi_4 = gcm_polyval_mul_fun (Htable @ 6) (blks @ 1)\n    Xi_5 = gcm_polyval_mul_fun (Htable @ 7) (Xi ^ (blks @ 0))\n    Xi_6 = gcm_polyval_red_pmult (Xi_0 ^ Xi_1 ^ Xi_2 ^ Xi_3 ^ Xi_4 ^ Xi_5)\n    Xi' = split Xi_6\n    ctx' =\n      { key = ctx.key\n      , iv = ctx.iv\n      , Xi = Xi'\n      , len = ctx.len + 6 * 16\n      }\n\ngcm_ghash_avx : {n, m} (fin n, 1 <= m, m <= 8) => [128] -> [16][8] -> [(n * 8 + m) * 16][8] -> [16][8]\ngcm_ghash_avx H Xi in = Xi''\n  where\n    bulk # tl = in\n    Xi' = foldl (gcm_ghash_avx_8`{8} H) Xi (split`{n} bulk)\n    Xi'' = gcm_ghash_avx_8`{m} H Xi' tl\n\ngcm_ghash_avx_8 : {n} (1 <= n, n <= 8) => [128] -> [16][8] -> [n * 16][8] -> [16][8]\ngcm_ghash_avx_8 H Xi in = Xi''\n  where\n    [H0, H1, _, H2, H3, _, H4, H5, _, H6, H7, _] = gcm_init_Htable H\n    Htable = [H0, H1, H2, H3, H4, H5, H6, H7]\n    Xi' = join Xi\n    blks = map join (split in)\n    Xi_0 = gcm_polyval_mul_pmult3 (Htable @ (`n - 1)) (Xi' ^ (blks @ 0))\n    Xi_1 = gcm_polyval_mul_pmult3 (Htable @ (`n - 2)) (blks @ 1)\n    Xi_2 = gcm_polyval_mul_pmult3 (Htable @ (`n - 3)) (blks @ 2)\n    Xi_3 = gcm_polyval_mul_pmult3 (Htable @ (`n - 4)) (blks @ 3)\n    Xi_4 = gcm_polyval_mul_pmult3 (Htable @ (`n - 5)) (blks @ 4)\n    Xi_5 = gcm_polyval_mul_pmult3 (Htable @ (`n - 6)) (blks @ 5)\n    Xi_6 = gcm_polyval_mul_pmult3 (Htable @ (`n - 7)) (blks @ 6)\n    Xi_7 = gcm_polyval_mul_pmult3 (Htable @ (`n - 8)) (blks @ 7)\n    T1 = if `n == 8\n      then Xi_7 ^ Xi_6 ^ Xi_5 ^ Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n      else if `n == 7\n        then Xi_6 ^ Xi_5 ^ Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n        else if `n == 6\n          then Xi_5 ^ Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n          else if `n == 5\n            then Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n            else if `n == 4\n              then Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n              else if `n == 3\n                then Xi_2 ^ Xi_1 ^ Xi_0\n                else if `n == 2\n                  then Xi_1 ^ Xi_0\n                  else Xi_0\n    Xi_n = gcm_polyval_red_pmult T1\n    Xi'' = split Xi_n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/SAW\/spec\/AES\/X86.cry","filetype":"cry","content":"module X86 where\n\nimport Primitive::Symmetric::Cipher::Block::AES\n\n\nclmul : [64] -> [64] -> [128]\nclmul x y = 0b0 # pmult x y\n\naesenc : [128] -> [128] -> [128]\naesenc pt key =\n  stateToMsg_x86 (AESRound (msgToState_x86 key, msgToState_x86 pt))\n\naesenclast : [128] -> [128] -> [128]\naesenclast pt key =\n  stateToMsg_x86 (AESFinalRound (msgToState_x86 key, msgToState_x86 pt))\n\naesdec : [128] -> [128] -> [128]\naesdec pt key =\n  stateToMsg_x86 (AESInvRound (msgToState_x86 key, msgToState_x86 pt))\n\naesdeclast : [128] -> [128] -> [128]\naesdeclast pt key =\n  stateToMsg_x86 (AESFinalInvRound (msgToState_x86 key, msgToState_x86 pt))\n\naeskeygenassist : [128] -> [8] -> [128]\naeskeygenassist src imm = join\n  ( (RotWord_x86 (SubWord x3) ^ rcon)\n  # SubWord x3\n  # (RotWord_x86 (SubWord x1) ^ rcon)\n  # SubWord x1\n  )\n  where\n    [x3, x2, x1, x0] = [split x | x <- split src]\n    rcon = [0, 0, 0, imm]\n\n\nRotWord_x86 : [4]GF28 -> [4]GF28\nRotWord_x86 x = reverse (RotWord (reverse x))\n\nmsgToState_x86 : [128] -> State\nmsgToState_x86 msg = transpose (split (reverse (split msg)))\n\nstateToMsg_x86 : State -> [128]\nstateToMsg_x86 st = join (reverse (join (transpose st)))\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"aws-lc-verification\/SAW\/spec\/AES\/AES-GCM.cry","filetype":"cry","content":"module AES_GCM where\n\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM\nimport X86\n\n\nswap8 : {parts, a} (fin parts) => [parts * 8]a -> [parts * 8]a\nswap8 x = join`{each=8} (reverse (split`{each=8} x))\n\nswap128 : {parts, a} (fin parts) => [parts * 128]a -> [parts * 128]a\nswap128 x = join`{each=128} (reverse (split`{each=128} x))\n\nhi_bits : {n} (fin n) => [2 * n] -> [n]\nhi_bits = take\n\nlo_bits : {n} (fin n) => [2 * n] -> [n]\nlo_bits = drop\n\n\naes_key_to_schedule : [Nr + 1][128] -> KeySchedule\naes_key_to_schedule key = (key' @ 0, key' @@ [1 .. (Nr - 1)], key' @ `Nr)\n  where\n    key' = map msgToState_x86 key\n\naes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]\naes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (key' @@ [2 .. Nr])))\n  where\n    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])\n\ninv_aes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]\ninv_aes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (reverse (key' @@ [2 .. Nr]))))\n  where\n    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])\n\naes_hw_decrypt : [16][8] -> [32][8] -> [16][8]\naes_hw_decrypt in key = split (aesDecrypt ((join in), (join key)))\n\naes_hw_ctr32_encrypt_blocks : {n} (fin n) => [16*n][8] -> [32][8] -> [16][8] -> [16*n][8]\naes_hw_ctr32_encrypt_blocks in key (iv # ctr) =\n  join [ blk ^ (aes_hw_encrypt (iv # (split ((join ctr) + i))) key) | blk <- split in | i <- [(0 : [32]) ...]]\n\ngcm_init : [2][64] -> [12][128]\ngcm_init Xi = gcm_init_Htable (gcm_init_H (join Xi))\n\ngcm_init_Htable : [128] -> [12][128]\ngcm_init_Htable h0 = [h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11]\n  where\n    h1 = gcm_polyval h0 h0\n    h2 = ((hi_bits h1) ^ (lo_bits h1)) # ((hi_bits h0) ^ (lo_bits h0))\n    h3 = gcm_polyval h0 h1\n    h4 = gcm_polyval h0 h3\n    h5 = ((hi_bits h4) ^ (lo_bits h4)) # ((hi_bits h3) ^ (lo_bits h3))\n    h6 = gcm_polyval h0 h4\n    h7 = gcm_polyval h0 h6\n    h8 = ((hi_bits h7) ^ (lo_bits h7)) # ((hi_bits h6) ^ (lo_bits h6))\n    h9 = gcm_polyval h0 h7\n    h10 = gcm_polyval h0 h9\n    h11 = ((hi_bits h9) ^ (lo_bits h9)) # ((hi_bits h10) ^ (lo_bits h10))\n\ngcm_gmult : [128] -> [16][8] -> [16][8]\ngcm_gmult H Xi = split (gcm_polyval H (join Xi))\n\ngcm_ghash : {n} (fin n) => [128] -> [16][8] -> [n * 16][8] -> [16][8]\ngcm_ghash H Xi inp = foldl (gcm_ghash_block H) Xi (split inp)\n\ngcm_ghash_block : [128] -> [16][8] -> [16][8] -> [16][8]\ngcm_ghash_block H Xi inp = split (gcm_polyval H ((join Xi) ^ (join inp)))\n\n\nget_Htable : AES_GCM_Ctx -> [12][128]\nget_Htable ctx = gcm_init (get_H ctx)\n\nget_i : AES_GCM_Ctx -> [32]\nget_i ctx = drop ((ctx.len + 15) \/ 16)\n\nget_Yi : AES_GCM_Ctx -> [16][8]\nget_Yi ctx = ctx.iv # (split ((get_i ctx) + 2))\n\nget_EKi : AES_GCM_Ctx -> [16][8]\nget_EKi ctx = EKi ctx (get_i ctx)\n\nget_EK0 : AES_GCM_Ctx -> [16][8]\nget_EK0 ctx = EKi ctx 0\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/tests\/Fp12_tests.cry","filetype":"cry","content":"\/\/ Tests of the definitions in implementation::Fp12\n\nimport implementation::Fp12\nimport Parameters (Fp_12, t_Fp_12, p, u, u_plus_1, v, w)\nimport FieldExtras\nimport Frobenius (fp12_conjugate)\n\n\/\/ relationship between Fp_12 and Fp_12_alt (all can be proved)\n\nproperty fp12_alt_round_trip_1 x =\n    Fp_12_alt_to_Fp_12 (Fp_12_to_Fp_12_alt x) == x\n\nproperty fp12_alt_round_trip_2 x =\n    Fp_12_to_Fp_12_alt (Fp_12_alt_to_Fp_12 x) == x\n\nproperty fp12_alt_add x y =\n    Fp_12_alt_to_Fp_12 (Fp_12_alt.add (x, y)) == Fp_12.add (Fp_12_alt_to_Fp_12 x, Fp_12_alt_to_Fp_12 y)\n\nproperty fp12_alt_mul_w x =\n    Fp_12_alt_to_Fp_12 (Fp_12_alt.mul (Fp_12_to_Fp_12_alt w, x)) == Fp_12.mul (w, Fp_12_alt_to_Fp_12 x)\n\n\/\/ cyclotomic squaring.  We need values in the cyclotomic subgroup, which are the values x in Fp_12\n\/\/ satisfying x^(p^4-p^2+1) == 1.  These can be found by raising ANY nonzero element to the power\n\/\/   (p^8 + p^6 - p^2 - 1) = (p^6 - 1)(p^2 + 1) = (p^3 + 1)(p^3 - 1)(p^2 + 1),\n\/\/ since all nonzero elements satisfy x^(p^12-1) = 1.\n\n\/*\n\/\/ slow...\nto_cyclotomic x = F_expt Fp_12 (F_expt Fp_12 (F_expt Fp_12 x e1) e2) e3 where\n    e1 = `(p*p+1):[768]\n    e2 = `(p*p*p + 1):[3*384]\n    e3 = e2 - 2\n*\/\n\n\/\/ to_cyclotomic: t_Fp_12 -> t_Fp_12\nto_cyclotomic_fp12 x = k_expt`{4} Fp_12 x1 e where\n    x1 = Fp_12.div (fp12_conjugate x, x) \/\/ = x^(p^6 - 1)\n    e = `(p*p+1):[2*382] \/\/ p^2 + 1\n\nis_cyclotomic_fp12 x = (Fp_12.mul(x4, x) == x2) where \/\/ x^(p^4+1) == x^(p_2), so x^(p^4-p^2+1) == 1\n    x2 = fp12_frobenius2 x \/\/ x^(p^2)\n    x4 = fp12_frobenius2 x2 \/\/ x^(p^4)\n\ncyclotomic_sqr_fp12_ok x =\n    cyclotomic_sqr_fp12 x' == Fp_12.sq x' where x' = to_cyclotomic_fp12 x\n\ntest_a = [[[1,2],[3,4],[5,6]],[[7,8],[9,10],[11,12]]]: t_Fp_12\ntest_b = [[[0,9],[1,8],[2,7]],[[3,6],[4,5],[5,4]]]: t_Fp_12\n\nproperty cyclotomic_sqr_fp12_test_a = cyclotomic_sqr_fp12_ok test_a\nproperty cyclotomic_sqr_fp12_test_b = cyclotomic_sqr_fp12_ok test_b\n\n\/\/ _imp matches the spec version\n\nproperty cyclotomic_sqr_fp12_imp_ok x =\n    cyclotomic_sqr_fp12 x == cyclotomic_sqr_fp12_imp x\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/tests\/ParameterTests.cry","filetype":"cry","content":"import Parameters\nimport ShortWeierstrassCurve\n\n\/\/ representation of field elements:\n\nproperty Fp_to_octets_to_Fp x =\n  Fp.is_val x ==> octets_to_Fp (Fp_to_octets x) == x\n\nproperty Fp_12_to_octets_to_Fp_12 x =\n  Fp_12.is_val x ==> octets_to_Fp_12 (Fp_12_to_octets x) == x\n\n\/\/ Sanity checks on the curve parameters\n\nproperty BP_on_E =\n    is_point_affine E BP \/\/ BP is on curve E\n\nproperty BP'_on_E' =\n    is_point_affine E' BP' \/\/ BP' is on curve E'\n\nproperty BP_order =\n    is_point_O E (mult E r BP) \/\/ r*BP = O\n\nproperty BP'_order =\n    is_point_O E' (mult E' r BP') \/\/ r*BP' = O\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/tests\/G2SubGroupCheckTests.cry","filetype":"cry","content":"import Parameters (p, Fp_2, t_Fp_2, E', BP', r)\nimport Frobenius\nimport FieldExtras\nimport ShortWeierstrassCurve\nimport G2SubGroupCheck\n\nproperty test_psi_1 = is_point_affine E' (psi BP') \/\/ psi takes BP' to a point on the curve\n\/\/ and multiples of BP':\ntest_psi_2 m = is_point_affine E' (psi (mult E' m BP')) \/\/ and multiples of BP'\nproperty test_psi_2_1 = test_psi_2 0x6db7\nproperty test_psi_2_2 = test_psi_2 0xdefc\n\nproperty in_G2_1 = is_in_G2' BP'\n\nin_G2_2 m = is_in_G2' (mult E' m BP')\nproperty in_G2_2_1 = in_G2_2 0xa3e0\nproperty in_G2_2_2 = in_G2_2 0xd58f\n\n\/\/ psi has order 12, apparently\n\nproperty test_psi_order =\n  same_point_affine E' (images@12) BP' where\n  images = [BP'] # [psi P | P <- images] \/\/ so images @ i == psi^i BP'\n\ntest_psi_order_mult m =\n  same_point_affine E' (images@12) Q where\n  images = [Q] # [psi P | P <- images] \/\/ so images @ i == psi^i BP'\n  Q = mult E' m BP'\nproperty test_psi_order_mult_1 = test_psi_order_mult 0x7ecf\nproperty test_psi_order_mult_2 = test_psi_order_mult 0xe233\n\n\/\/ psi is claimed to map elements of G2 to a multiple, by p.  So\n\nproperty test_psi_is_mult = same_point_affine E' (psi BP') (mult E' (`p:[384]) BP')\n\n\/\/ or as the order of G2 is r, we can use exponent (p mod r)\n\ntest_psi_is_mult_reduced m = same_point_affine E' (psi P) (mult E' e  P)\n  where e = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfe2dfefffeffff0001\n        P = mult E' m BP'\nproperty test_psi_is_mult_reduced_1 = test_psi_is_mult_reduced 0xdefc\nproperty test_psi_is_mult_reduced_2 = test_psi_is_mult_reduced 0x7ecf\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/tests\/ShortWeierstrassCurveTests.cry","filetype":"cry","content":"\/\/ Some tests of the algebraic properties of curve operations\n\nimport PrimeField\nimport ExtensionField\nimport ShortWeierstrassCurve\n\nF7 = prime_field_bv 0b111\nC1: EllipticCurve [3]\nC1 = {base_field = F7, a = 0, b = 1}\n\nF13 = prime_field`{13}\nC2: EllipticCurve (Z 13)\nC2 = {base_field = F13, a = 3, b = 1} \/\/ 18 rational points\n\nF3 = prime_field`{3}\nF9 = extension_field F3 [0,2]\nC3: EllipticCurve _ \/\/ [2](Z 3) can be inferred\nC3 = {base_field = F9, a = [1,1], b=[1,2]}\n\ndouble_stays_on_curve C S =\n   is_point_affine C S ==> is_point_affine C (double C S)\n\nproperty double_stays_on_curve1 = double_stays_on_curve C1\nproperty double_stays_on_curve2 = double_stays_on_curve C2\nproperty double_stays_on_curve3 = double_stays_on_curve C3\n\nadd_closed C P Q =\n   is_point_affine C P \/\\ is_point_affine C Q ==>\n   is_point_affine C (add C P Q)\n\nproperty add_closed1 = add_closed C1\nproperty add_closed2 = add_closed C2\nproperty add_closed3 = add_closed C3\n\nadd_commutes C P Q =\n   is_point_affine C P \/\\ is_point_affine C Q ==>\n   same_point_affine C (add C P Q) (add C Q P)\n\nproperty add_commutes1 = add_commutes C1\nproperty add_commutes2 = add_commutes C2\nproperty add_commutes3 = add_commutes C3\n\nsubtraction_inverts_addition C P Q =\n   is_point_affine C P \/\\ is_point_affine C Q ==>\n   same_point_affine C (sub C (add C P Q) Q) P  \n\nproperty subtraction_inverts_addition1 = subtraction_inverts_addition C1\nproperty subtraction_inverts_addition2 = subtraction_inverts_addition C2\nproperty subtraction_inverts_addition3 = subtraction_inverts_addition C3\n\naddition_inverts_subtraction C P Q =\n   is_point_affine C P \/\\ is_point_affine C Q ==>\n   same_point_affine C (add C (sub C P Q) Q) P  \n\nproperty addition_inverts_subtraction1 = addition_inverts_subtraction C1\nproperty addition_inverts_subtraction2 = addition_inverts_subtraction C2\nproperty addition_inverts_subtraction3 = addition_inverts_subtraction C3\n\nmult_sum C S a b =\n    is_point_affine C S \/\\ a <= 0x3f \/\\ b <= 0x3f ==> \/\/ so a+b does not overflow\n    same_point_affine C (mult C (a+b) S) (add C (mult C a S) (mult C b S))\n\nproperty mult_sum1 = mult_sum C1\nproperty mult_sum2 = mult_sum C2\nproperty mult_sum3 = mult_sum C3\n\nmult_prod C S a b =\n    is_point_affine C S \/\\ a <= 0x0f \/\\ b <= 0x0f ==> \/\/ so a*b does not overflow\n    same_point_affine C (mult C (a*b) S) (mult C a (mult C b S))\n\nproperty mult_prod1 = mult_prod C1\nproperty mult_prod2 = mult_prod C2\nproperty mult_prod3 = mult_prod C3\n","variant":"hybrid","set":"supervised"}
{"filename":"BLST-Verification\/tests\/FrobeniusTests.cry","filetype":"cry","content":"import Parameters as P\nimport Frobenius\nimport FieldExtras\n\np: [381]\np = `P::p\n\n\/\/ It is a simple mathematical fact that the operations defined in module Frobenius are\n\/\/ in fact p^th powers.  We can run a few tests just to check against simple implementation\n\/\/ errors.\n\nproperty fp2_frobenius_prop x =\n  fp2_frobenius x' == F_expt P::Fp_2 x' p where x' = P::Fp_2.normalize x\n\nproperty f6_frobenius_prop x =\n  fp6_frobenius x' == F_expt P::Fp_6 x' p where x' = P::Fp_6.normalize x\n\nproperty f12_frobenius_prop x =\n  fp12_frobenius x' == F_expt P::Fp_12 x' p where x' = P::Fp_12.normalize x\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/tests\/ProjectiveCurveOperationsTests.cry","filetype":"cry","content":"\/\/ Tests of ProjectiveCurveOperations\n\/\/\n\/\/ Here we just check that we get results equivalent to the affine versions\n\nimport ShortWeierstrassCurve\nimport ProjectiveCurveOperations\nimport PrimeField\nimport FieldExtras\n\nF7 = prime_field`{7}\nC1: EllipticCurve _\nC1 = {base_field = F7, a = 1, b = 3}\n  \nF13 = prime_field_bv (13:[4])\nC2: EllipticCurve _\nC2 = {base_field = F13, a = 4, b = 5}\n\n\/\/ FAILS for S = (0,0), because of the special-case representation of point_O\n\/\/ Perhaps projectify should recognize this case?\n\/\/is_point_OK_1 C S =\n\/\/  is_point_affine C S == is_point_projective C (projectify C S)\n\nis_point_OK_1 C S =\n  is_point_O C S \\\/\n  is_point_affine C S == is_point_projective C (projectify C S)\n\nproperty projectify_preserves_is_point_C1 = is_point_OK_1 C1\nproperty projectify_preserves_is_point_C2 = is_point_OK_1 C2\n\n\/\/ FAILS for S = (0,0,1) because of our representation of point_O as (0,0)\n\/\/is_point_OK_2 C S =\n\/\/  (is_point_projective C S == is_point_affine C (affinify C S))\nis_point_OK_2 C S =\n  is_point_O C (affinify C S) \\\/\n  is_point_projective C S == is_point_affine C (affinify C S)\n\nproperty affinify_preserves_is_point_C1 = is_point_OK_2 C1\nproperty affinify_preserves_is_point_C2 = is_point_OK_2 C2\n\n\/\/ doubling\n\ndouble_stays_on_curve C S =\n   is_point_projective C S ==> is_point_projective C (p_double C S)\n\nproperty double_stays_on_curve_C1 = double_stays_on_curve C1\nproperty double_stays_on_curve_C2 = double_stays_on_curve C2\n\ndouble_agrees C S =\n   is_point_projective C S ==>\n   same_point_affine C (affinify C (p_double C S))\n                       (double C (affinify C S))\n\nproperty double_agrees_C1 = double_agrees C1\nproperty double_agrees_C2 = double_agrees C2\n\n\/\/ addition\n\naddition_zero C S =\n    is_point_projective C S ==> same_point C S (p_add C S (p_point_O C))\n\naddition_commutes C S T =\n    is_point_projective C S \/\\  is_point_projective C T ==>\n    same_point C (p_add C S T) (p_add C T S)\n\nproperty addition_commutes_C1 = addition_commutes C1\nproperty addition_commutes_C2 = addition_commutes C2\n\naddition_distributes C S T R =\n    is_point_projective C S \/\\ is_point_projective C T \/\\ is_point_projective C R ==>\n    same_point C (p_add C S (p_add C T R)) (p_add C (p_add C S T) R)\n\nproperty addition_distributes_C1 = addition_distributes C1\nproperty addition_distributes_C2 = addition_distributes C2\n\naddition_agrees C S T =\n    is_point_projective C S \/\\  is_point_projective C T ==>\n    same_point_affine C (add C (affinify C S) (affinify C T))\n                        (affinify C (p_add C S T))\n\nproperty addition_agrees_C1 = addition_agrees C1\nproperty addition_agrees_C2 = addition_agrees C2\n\n\/\/ subtraction\n\nsubtraction_inverts_addition C S T =\n     is_point_projective C S \/\\ is_point_projective C T ==>\n     same_point C S (p_sub C (p_add C S T) T)\n\nproperty subtraction_inverts_addition_C1 = subtraction_inverts_addition C1\nproperty subtraction_inverts_addition_C2 = subtraction_inverts_addition C2\n\nsubtraction_agrees C S T =\n     is_point_projective C S \/\\  is_point_projective C T ==>\n     same_point_affine C (sub C (affinify C S) (affinify C T))\n                         (affinify C (p_sub C S T))\n\nproperty subtraction_agrees_C1 = subtraction_agrees C1\nproperty subtraction_agrees_C2 = subtraction_agrees C2\n\np_mult_agrees: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> ProjectivePoint t -> Bool\np_mult_agrees C m S =\n    is_point_projective C S ==>\n    same_point_affine C (affinify C (p_mult`{k=k} C m S))\n                        (mult`{k=k} C m (affinify C S))\n\nproperty p_mult_agrees_C1 = p_mult_agrees`{k=4} C1\nproperty p_mult_agrees_C2 = p_mult_agrees`{k=3} C2\n\np_mult_affine_agrees: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> AffinePoint t -> Bool\np_mult_affine_agrees C m S =\n    is_point_affine C S ==>\n    same_point_affine C (p_mult_affine`{k=k} C m S)\n                        (mult`{k=k} C m S)\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/tests\/SerializationTests.cry","filetype":"cry","content":"import Serialization\nimport Parameters\nimport ShortWeierstrassCurve as EC\nimport Maybe\n\nproperty ser_des_E1 (m:[16]) =\n  deserialize_E1 ((serialize_E1 Q) # zero) == just Q where Q = EC::mult E m BP\n\nproperty ser_des_E2 (m:[16]) =\n  deserialize_E2 (serialize_E2 Q) == just Q where Q = EC::mult E' m BP'\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/tests\/PolynomialTest.cry","filetype":"cry","content":"\/\/ tests for the Polynomial module\n\nimport Common::Field\nimport Polynomial\nimport PrimeField\n\n\/\/ check that all coefficients are in their field\nis_OK: {t,k} (fin k) => FieldRep t -> [k]t ->Bool\nis_OK F p = all F.is_val p\n\npoly_mul_0:  {t,k} (fin k, k>=1) => FieldRep t -> [k]t ->Bool\npoly_mul_0 F x = poly_equal F (poly_mul F x (poly_0 F), poly_0 F)\n\npoly_mul_1:  {t,k} (fin k, k>=1) => FieldRep t -> [k]t ->Bool\npoly_mul_1 F x =\n   is_OK F x ==> poly_equal F (poly_mul F x (poly_1 F), x)\n\npoly_mul_commutes:  {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t ->Bool\npoly_mul_commutes F x y =\n    is_OK F x \/\\ is_OK F y ==> poly_equal F (poly_mul F x y, poly_mul F y x)\n\npoly_mul_mod_commutes:  {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t ->Bool\npoly_mul_mod_commutes F x y =\n    is_OK F x \/\\ is_OK F y ==> poly_equal F (poly_mul F x y, poly_mul F y x)\n\npoly_div_mod_prop: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t ->  Bool\npoly_div_mod_prop F x y =\n    is_OK F y \/\\ is_OK F x \/\\ ~ (poly_equal F (y, poly_0 F)) ==>\n    poly_equal F (x, poly_add F (poly_mul F q y) r) where (q,r) = poly_div_mod F x y\n\npoly_inverse_mod_prop: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t -> Bool\n\/\/ only when q represents an irreducible polynomial\npoly_inverse_mod_prop F q p =\n    (is_OK F q) \/\\ is_OK F p \/\\ ~ (poly_equal F (p, poly_0 F)) ==> \n    poly_equal F (poly_mul_mod F p (poly_inverse_mod F p q) q, poly_1 F)\n\n\nF7 = prime_field`{7}\nF29 = prime_field_bv (29:[5])\n\n\/\/ Some monomorphic test cases\n\nproperty mul_0_F7 = poly_mul_0`{k=4} F7\nproperty mul_1_F7 = poly_mul_1`{k=4} F7\nproperty mul_commutes_F7 = poly_mul_commutes`{k=5} F7\nproperty mul_mod_commutes_F7 = poly_mul_mod_commutes`{k=4} F7\n\nproperty div_mod_F7 = poly_div_mod_prop`{k=3} F7\nproperty div_mod_F7' = poly_div_mod_prop`{k=8} F7\n\n\/\/ for the inverse_mod property, take care to recall the unusual representatin of the modulus.\nproperty inverse_mod_F7 = poly_inverse_mod_prop`{k=3} F7 [1,1,3] \/\/ q=x^3-x^2-x-3 is irreducible in F7\nproperty inverse_mod_F7' = poly_inverse_mod_prop`{k=4} F7 [2,0,1,1] \/\/ x^4-2*x^3-x-1 is irreducible in F7\n\nproperty mul_0_F29 = poly_mul_0`{k=4} F29\nproperty mul_1_F29 = poly_mul_1`{k=4} F29\nproperty mul_commutes_F29 = poly_mul_commutes`{k=5} F29\nproperty mul_mod_commutes_F29 = poly_mul_mod_commutes`{k=4} F29\n\nproperty div_mod_F29 = poly_div_mod_prop`{k=3} F29\n\nproperty inverse_mod_F29 = poly_inverse_mod_prop`{k=3} F29 [2,3,5] \/\/ x^3-2x^2-3y-5 is irreducible in F29\nproperty inverse_mod_F29' = poly_inverse_mod_prop`{k=4} F29 [27,1,1,6] \/\/ x^4-27x^3-x^2-x-6, also irreducible\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/tests\/ClearCofactorTests.cry","filetype":"cry","content":"import HashToCurveE2\nimport HashToCurveE2Aux\nimport Parameters\nimport Serialization\nimport ShortWeierstrassCurve\n\nimport implementation::HashToG2\n\n\/\/ Check that the two clear_cofactor specifications agree\nspec_eq : AffinePoint t_Fp_2 -> Bit\nspec_eq P = (clear_cofactor_bls12381_g2 P) == (clear_cofactor P)\n\nto_Fp2: ([384], [384]) -> t_Fp_2\nto_Fp2 (a,b) = [to_Fp b, to_Fp a] \/\/ a+b*I\n\n\/\/ Get a point on the curve through deserialization\npoint = deserialize_E2 (serialize_E2 (to_Fp2 (0, 1), to_Fp2 (0, 1)))\n\n\/\/ Generate a few more points on the curve from `point`\npoints = [mult E' x (point.1) | x <- [0x1, 0x2 .. 0x5 : [4]]]\n\n\/\/ Check that the implementation function agrees with clear_cofactor\nimpl_eq P = (clear_cofactor P) == (affinify E' (clear_cofactor_E2_impl (projectify E' P)))\n\n\/\/ Since changing `mult` to `scalar_mult` in clear_cofactor_bls12381_g2,\n\/\/ running this check is too slow.  It can be uncommented if\n\/\/ clear_cofactor_bls12381_g2 is ever changed back to use `mult`.\n\/\/property spec_eq_many = all spec_eq points\n\nproperty impl_eq_many = all impl_eq points\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/tests\/HashToG2Tests.cry","filetype":"cry","content":"import HashToCurveE2\nimport HashToCurveE2Aux\nimport Serialization\nimport ShortWeierstrassCurve\nimport implementation::HashToG2\n\ntest u = (affinify C (map_to_curve_E2_prime_impl u)) == map_to_curve_simple_swu u\n\nus = [zero, [324,33], [1,0],[`p-1,7]]\n\nproperty prop = all test us\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/tests\/HashToCurveE1Tests.cry","filetype":"cry","content":"\/\/ Tests for hashing to curve E1, from draft-irtf-cfrg-hash-to-curve-09\n\nimport ExpandMessage\nimport HashToCurveE1\nimport ShortWeierstrassCurve as EC\nimport Parameters as P\n\n\/\/ Appendix I.1  tests expand_message\n\ndst_1 = \"QUUX-V01-CS02-with-expander\"\n\nproperty expand_test_1 =\n    expand_message \"\" dst_1 ==\n    split 0xf659819a6473c1835b25ea59e3d38914c98b374f0970b7e4c92181df928fca88\n\nproperty expand_test_2 =\n    expand_message  \"abc\" dst_1 ==\n    split 0x1c38f7c211ef233367b2420d04798fa4698080a8901021a795a1151775fe4da7\n\nproperty expand_test_3 =\n    expand_message \"abcdef0123456789\" dst_1 ==\n    split 0x8f7e7b66791f0da0dbb5ec7c22ec637f79758c0a48170bfb7c4611bd304ece89\n\nmsg_q128 = \"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\" #\n           \"qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\" #\n           \"qqqqqqqqqqqqqqqqqqqqqqqqq\"\n\nproperty expand_test_4 =\n    expand_message msg_q128 dst_1 ==\n    split 0x72d5aa5ec810370d1f0013c0df2f1d65699494ee2a39f72e1716b1b964e1c642\n\n\nmsg_a512 = \"a512_\"  # ['a' | _ <- [0..511]]\n\nproperty expand_test_5 =\n    expand_message msg_a512 dst_1 ==\n    split 0x3b8e704fc48336aca4c2a12195b720882f2162a4b7b13a9c350db46f429b771b\n\n\/\/ From Section H.9.1, BLS12381G1_XMD:SHA-256_SSWU_RO_\n\nto_Fp = P::to_Fp dst = \"QUUX-V01-CS02-with-BLS12381G1_XMD:SHA-256_SSWU_RO_\"\n\nex1_msg = \"\"\n\nex1_us = hash_to_field`{count=2} ex1_msg dst\n\nex1_expected_us =\n   [ to_Fp 0x0ba14bd907ad64a016293ee7c2d276b8eae71f25a4b941eece7b0d89f17f75cb3ae5438a614fb61d6835ad59f29c564f\n   , to_Fp 0x019b9bd7979f12657976de2884c7cce192b82c177c80e0ec604436a7f538d231552f0d96d9f7babe5fa3b19b3ff25ac9\n   ]\n\nproperty hash_to_field_test_1 =\n    ex1_us == ex1_expected_us\n\n\/\/ .. the first step works (map_to_curve, going to Isogenous_Curve)\n\nproperty map_to_curve_test_1_1_a =\n    EC::is_point_affine Isogenous_Curve (map_to_curve_simple_swu (ex1_us@0))\n\nproperty map_to_curve_test_1_1_b =\n    EC::is_point_affine Isogenous_Curve (map_to_curve_simple_swu (ex1_us@1))\n\n\/\/ ... and the isogeny gets us to the curve C\n\nproperty map_to_curve_test_1_2_a =\n    EC::is_point_affine P::E (map_to_curve_simple_swu_AB0 (ex1_us@0))\n\nproperty map_to_curve_test_1_2_b =\n    EC::is_point_affine P::E (map_to_curve_simple_swu_AB0 (ex1_us@1))\n\n\/\/ .. and indeed to the correct points on that curve\n\nproperty map_to_curve_test_1_3_a =\n    EC::same_point_affine P::E (map_to_curve_simple_swu_AB0 (ex1_us@0))\n    (to_Fp 0x11a3cce7e1d90975990066b2f2643b9540fa40d6137780df4e753a8054d07580db3b7f1f03396333d4a359d1fe3766fe,\n     to_Fp 0x0eeaf6d794e479e270da10fdaf768db4c96b650a74518fc67b04b03927754bac66f3ac720404f339ecdcc028afa091b7)\n\nproperty map_to_curve_test_1_3_b =\n    EC::same_point_affine P::E (map_to_curve_simple_swu_AB0 (ex1_us@1))\n    (to_Fp 0x160003aaf1632b13396dbad518effa00fff532f604de1a7fc2082ff4cb0afa2d63b2c32da1bef2bf6c5ca62dc6b72f9c,\n     to_Fp 0x0d8bb2d14e20cf9f6036152ed386d79189415b6d015a20133acb4e019139b94e9c146aaad5817f866c95d609a361735e)\n\n\/\/ ... finally, the overall mapping gets us the correct result.\n\nproperty hash_to_curve_test_1 =\n    EC::same_point_affine P::E (hash_to_curve (\"\", dst))\n    (to_Fp 0x052926add2207b76ca4fa57a8734416c8dc95e24501772c814278700eed6d1e4e8cf62d9c09db0fac349612b759e79a1,\n     to_Fp 0x08ba738453bfed09cb546dbb0783dbb3a5f1f566ed67bb6be0e8c67e2e81a4cc68ee29813bb7994998f3eae0c9c6a265)\n\n\/\/ Example 2\n\nex2_msg = \"abc\"\nex2_us = hash_to_field`{count=2} ex2_msg dst\n\nex2_expected_us =\n [ to_Fp 0x0d921c33f2bad966478a03ca35d05719bdf92d347557ea166e5bba579eea9b83e9afa5c088573c2281410369fbd32951\n , to_Fp 0x003574a00b109ada2f26a37a91f9d1e740dffd8d69ec0c35e1e9f4652c7dba61123e9dd2e76c655d956e2b3462611139\n ]\n\nproperty hash_to_field_test_2 =\n  ex2_us == ex2_expected_us\n\nproperty hash_to_curve_test_2 =\n    EC::same_point_affine P::E (hash_to_curve (\"abc\", dst))\n    (to_Fp 0x03567bc5ef9c690c2ab2ecdf6a96ef1c139cc0b2f284dca0a9a7943388a49a3aee664ba5379a7655d3c68900be2f6903,\n     to_Fp 0x0b9c15f3fe6e5cf4211f346271d7b01c8f3b28be689c8429c85b67af215533311f0b8dfaaa154fa6b88176c229f2885d)\n\n\/\/ Examples 3 .. \n\nproperty hash_to_curve_test_3 =\n    EC::same_point_affine P::E (hash_to_curve (\"abcdef0123456789\", dst))\n    (to_Fp 0x11e0b079dea29a68f0383ee94fed1b940995272407e3bb916bbf268c263ddd57a6a27200a784cbc248e84f357ce82d98,\n     to_Fp 0x03a87ae2caf14e8ee52e51fa2ed8eefe80f02457004ba4d486d6aa1f517c0889501dc7413753f9599b099ebcbbd2d709)\n\nproperty hash_to_curve_test_4 =\n    EC::same_point_affine P::E (hash_to_curve (msg_q128, dst))\n    (to_Fp 0x15f68eaa693b95ccb85215dc65fa81038d69629f70aeee0d0f677cf22285e7bf58d7cb86eefe8f2e9bc3f8cb84fac488,\n     to_Fp 0x1807a1d50c29f430b8cafc4f8638dfeeadf51211e1602a5f184443076715f91bb90a48ba1e370edce6ae1062f5e6dd38)\n\nproperty hash_to_curve_test_5 =\n    EC::same_point_affine P::E (hash_to_curve (msg_a512, dst))\n    (to_Fp 0x082aabae8b7dedb0e78aeb619ad3bfd9277a2f77ba7fad20ef6aabdc6c31d19ba5a6d12283553294c1825c4b3ca2dcfe,\n     to_Fp 0x05b84ae5a942248eea39e1d91030458c40153f3b654ab7872d779ad1e942856a20c438e8d99bc8abfbf74729ce1f7ac8)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/ProjectiveCurveOperationsA0.cry","filetype":"cry","content":"\/\/ Optimized algorithms for curves in Weierstrass short form with a = 0,\n\/\/ over an arbitrary field.  That is, with equation y^2 = x^3 + b\n\/\/\n\/\/ These algorithms work in Jacobian projective coordinates.\n\/\/\n\/\/ Formulas come from https:\/\/hyperelliptic.org\/EFD\/g1p\/auto-shortw-jacobian-0.html\n\nmodule ProjectiveCurveOperationsA0  where\n\nimport Common::Field\nimport ShortWeierstrassCurve\nimport FieldExtras\n\nprivate\n\n  two: {t} FieldRep t -> t\n  two F = F.add (F.field_unit, F.field_unit)   three: {t} FieldRep t -> t\n  three F = F.add (two F, F.field_unit)\n\n  F_double: {t} FieldRep t -> t -> t\n  F_double F x = F.add (x, x)\n\n  cubed: {t} FieldRep t -> t -> t\n  cubed F x = F.mul(x, F.sq x)\n\np_point_O: {t} EllipticCurve t -> ProjectivePoint t\np_point_O C = (F.field_unit, F.field_unit, F.field_zero) where F = C.base_field\n\n\/**\n * p_double P is the sum P+P for P a point on the elliptic curve.\n *\/\np_double: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t\np_double C (X1,Y1,Z1) =\n    \/\/ Using the \"dbl-2009-alnr\" doubling formulas, three-operand code version\n    if F_is_zero F Z1 then p_point_O C else (X3, Y3, Z3) where \n        F = C.base_field\n        A = F.sq X1 \/\/ A = X1^2\n        B = F.sq Y1 \/\/ B = Y1^2\n        ZZ = F.sq Z1 \/\/ ZZ = Z1^2\n        C' = F.sq B    \/\/ C = B^2\n        t0 = F.add (X1, B) \/\/t0 = X1+B\n        t1 = F.sq t0         t2 = F.sub (t1, A)         t3 = F.sub (t2, C')         D = F.mul (two F, t3)         E = F.mul (three F, A)         F' = F.sq E         t4 = F_double F D         X3 = F.sub (F', t4)         t5 = F.sub (D, X3)                            t6 = F_double F (F_double F (F_double F C'))         t7 = F.mul (E, t5)         Y3 = F.sub (t7, t6)         t8 = F.add (Y1, Z1)         t9 = F.sq t8         t10 = F.sub (t9, B)         Z3 = F.sub (t10, ZZ)     \n\n\/**\n * Sum of two distinct points in projective coordinates on the elliptic curve,\n * provided neither is the zero point.\n * If the two points are the same, returns (0,0,0)\n *\/\np_add_generic: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add_generic C (X1,Y1,Z1) (X2,Y2,Z2) = (X3, Y3, Z3) where\n    F = C.base_field\n    \/\/ using the  \"add-2007-bl\" addition formula\n    Z1Z1 = F.sq Z1                         Z2Z2 = F.sq Z2                         U1 = F.mul (X1, Z2Z2)                  U2 = F.mul (X2, Z1Z1)                  S1 = F.mul (Y1, F.mul (Z2, Z2Z2))      S2 = F.mul (Y2, F.mul (Z1, Z1Z1))      H = F.sub (U2, U1)                     I = F.sq (F.mul (two F, H))        \/\/ I = (2*H)^2\n    J = F.mul (H, I)                       r = F.mul (two F, F.sub (S2, S1))      V = F.mul (U1, I)                  \/\/ V = U1*I\n    X3 = F.sub (F.sub (F.sq r, J), F.mul (two F, V))                       Y3 = F.sub (F.mul (r, F.sub (V, X3)), F.mul (F.mul(two F, S1), J))     Z3 = F.mul (F.sub (F.sub (F.sq (F.add (Z1, Z2)), Z1Z1), Z2Z2), H)  \/\/ Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2)*H\n\n\n\/*\nThe \"madd-2007-bl\" addition formulas https:\/\/hyperelliptic.org\/EFD\/g1p\/auto-shortw-jacobian-0.html\nis a simple algebraic simplification of the \"add-2007-bl\" formula when Z2 = 1.\n*\/\np_add_affine: {t} EllipticCurve t -> ProjectivePoint t -> AffinePoint t -> ProjectivePoint t\np_add_affine C (X1,Y1,Z1) (X2,Y2) = (X3, Y3, Z3) where\n    F = C.base_field\n    \/\/ using the  \"madd-2007-bl\" addition formula\n    Z1Z1 = F.sq Z1                         U2 = F.mul (X2, Z1Z1)                  S2 = F.mul (Y2, F.mul (Z1, Z1Z1))      H = F.sub (U2, X1)                 \/\/ H = U2-X1\n    HH = F.sq H                        \/\/ HH = H^2\n    I = F_double F (F_double F HH)     \/\/ I = 4*HH\n    J = F.mul (H, I)                       r = F.mul (two F, F.sub (S2, Y1))  \/\/ r = 2*(S2-Y1)\n    V = F.mul (X1, I)                      X3 = F.sub (F.sub (F.sq r, J), F.mul (two F, V))                       Y3 = F.sub (F.mul (r, F.sub (V, X3)), F.mul (F.mul(two F, Y1), J)) \/\/ Y3 = r*(V-X3)-2*Y1*J\n    Z3 = F.sub (F.sub (F.sq (F.add (Z1, H)), Z1Z1), HH)                \/\/ Z3 = (Z1+H)^2-Z1Z1-HH\n\n\/**\n * Sum of two points in projective coordinates on the elliptic curve.\n *\/\np_add: {t} EllipticCurve t ->  ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add C S T = \n    if F_is_zero F Z1 then T\n     | F_is_zero F Z2 then S\n     | all (F_is_zero F) [X3,Y3,Z3] then p_double C S      else R\n    where\n        F = C.base_field\n        (_,_,Z1) = S\n        (_,_,Z2) = T\n        R = p_add_generic C S T\n        (X3,Y3,Z3) = R\n\n\/**\n * Difference of two points in projective coordinates on the elliptic curve.\n *\/\np_sub: {t} EllipticCurve t ->  ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_sub C S (x,y,z) = p_add C S (x, C.base_field.neg y, z)\n\n\/**\n * Integer multiple of a point in projective coordinates on the elliptic curve.\n * The multiplier, a bitvector, is interpreted as a non-negative integer.\n *\/\np_mult: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> ProjectivePoint t -> ProjectivePoint t\np_mult C d S = if d == 0 then p_point_O C\n               |  d == 1 then S\n               |  F_is_zero F S.2 then p_point_O C\n               else Rs!1\n    where\n        F = C.base_field\n        k = 0b00 # d \/\/ 2 extra top bits, so that h does not overflow\n        h = k + k + k\n        Rs = [p_point_O C] # \/\/Here we start with 1 instead of S because we don't really know where the high-bit is\n             [ if hi && ~ki then p_add C RiDouble S\n                | ~hi && ki then p_sub C RiDouble S\n                else RiDouble\n               where RiDouble = p_double C Ri\n             | ki <- k | hi <- h | Ri <- Rs ]\n\n\/**\n * Integer multiple of a point in affine coordinates  on the elliptic curve.\n * The multiplier, a bitvector, is interpreted as a non-negative integer.\n * This definition uses projective operations internally, but should give\n * the same result as `mult`.\n *\/\np_mult_affine: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> AffinePoint t -> AffinePoint t\np_mult_affine C d S =\n               if d == 0 then point_O C\n               |  d == 1 then S\n               |  is_point_O C S then S\n               else affinify C (Rs!1)\n    where\n        F = C.base_field\n        negS = ( (x, F.neg y) where (x,y) = S )\n        k = 0b00 # d \/\/ 2 extra top bits, so that h does not overflow\n        h = k + k + k\n        Rs = [p_point_O C] # \/\/Here we start with 1 instead of S because we don't really know where the high-bit is\n             [ if hi && ~ki then add' RiDouble S\n                | ~hi && ki then add' RiDouble negS\n                else RiDouble\n               where RiDouble = p_double C Ri\n             | ki <- k | hi <- h | Ri <- Rs ]\n        add': ProjectivePoint t -> AffinePoint t -> ProjectivePoint t \/\/ \"full\" version of p_add_affine\n        add' U V = if F_is_zero F Z1 then projectify C V\n                  |  all (F_is_zero F) [X3,Y3,Z3] then p_double C U\n                  else R\n            where\n                (_,_,Z1) = U\n                R = p_add_affine C U V\n                (X3,Y3,Z3) = R\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/Polynomial.cry","filetype":"cry","content":"module Polynomial where\n\nimport Common::Field\n\n\/\/\/\/\/ Polynomials over a field\n\/\/\n\/\/  A value `p: [k]t` represents a polyomial with `p!0` giving the constant coefficient\n\/\/  thus for example `[1,0,2]` represents x^2 + 2, as does `[0,1,0,2]`\n\n\/**\n * Are two polynomials equal?  This uses the equality defined in the underlying field,\n * so `poly_equal p q` might not be the same as `p == q`.\n *\/\npoly_equal:  {t,k} (fin k, k>=1) => FieldRep t -> ([k]t, [k]t) -> Bool\npoly_equal F (p,q) = and (zipWith (curry F.is_equal) p q)\n\n\/**\n * 0, as a polynomial over a field\n *\/\npoly_0: {t,k} (fin k) => FieldRep t -> [k]t\npoly_0 F = repeat F.field_zero\n\n\/**\n *\n * Constant polynomial: a member of the base field viewed as a polynomial\n *\/\npoly_const: {t,k} (fin k, k >= 1) => FieldRep t -> t -> [k]t\npoly_const F c = (repeat F.field_zero) # [c]\n\n\/**\n * 1, as a polynomial over a field\n *\/\npoly_1: {t,k} (fin k, k >= 1) => FieldRep t -> [k]t\npoly_1 F = poly_const F F.field_unit\n\n\/**\n * x, as a polynomial over a field\n *\/\npoly_x: {t,k} (fin k, k >= 2) => FieldRep t -> [k]t\npoly_x F = (repeat F.field_zero) # [F.field_unit, F.field_zero]\n\n\/**\n * The degree of a polynomial.  We arbitrarily return 0 for the degree ofthe zero polynomial.\n *\/\npoly_degree: {t, k, a} (fin k, Ring a, Literal (max 1 k) a)\n             => FieldRep t -> [k+1]t -> a\npoly_degree F coeffs = (ds!0).0 where\n    ds = [(`k,True)] # [ if lz \/\\ F.is_equal(ci, F.field_zero) then (d-1,True) else (d, False)\n                       | (d,lz) <- ds\n                       | ci <- coeffs\n                       ]\n\n\/**\n * The leading coefficient of a non-zero polynomial.  This is the coefficient of the\n * largest power of x that has a non-zero coefficient.\n *\/\nleading_coefficient: {t,k} (fin k) => FieldRep t -> [k]t -> t\nleading_coefficient F p =\n    foldr (\\ c a -> if F.is_equal (c, F.field_zero) then a else c) F.field_zero p\n\n\/**\n * The sum of two polynomials over a field.\n *\/\npoly_add: {t,k} (fin k) => FieldRep t -> [k]t -> [k]t -> [k]t\npoly_add F = zipWith (curry F.add)\n\n\/**\n * The difference of two polynomials over a field.\n *\/\npoly_sub: {t,k} (fin k) => FieldRep t -> [k]t -> [k]t -> [k]t\npoly_sub F = zipWith (curry F.sub)\n\nprivate\n    shifts: {k,t} (fin k, k >= 1) => t -> [k]t -> [k][k]t\n    shifts pad seq = take seqs where\n        seqs = [seq] # [shift s | s <- seqs]\n        shift s = tail s # [pad]\n\n\/**\n * The product of two polynomials over a field, truncated at their size\n * That is, if p, q: [k]t, then all terms c*x^i for i >= k are dropped.\n *\n * Function `poly_full_mul` does not discard those terms.\n *\/\npoly_mul: {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t -> [k]t\npoly_mul F p q = foldl (poly_add`{t,k} F) (poly_0 F) rows where\n    rows: [k][k]t\n    rows = zipWith (\\ c s -> map (curry F.mul c) s) p (reverse (shifts F.field_zero q))\n\n\/**\n * The product of two polynomials over a field, with  result type\n * guaranteed to hold all the non-zero coefficients of the result.\n *\n * Compare to function `poly_mul`.\n *\/\npoly_full_mul: {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t -> [2*k-1]t\npoly_full_mul F p q = foldl (poly_add F) (poly_0 F) rows where\n    rows: [k][2*k-1]t\n    rows = zipWith (\\ c s -> map (curry F.mul c) s) p (reverse (full_shifts F.field_zero q))\n    full_shifts: t -> [k]t -> [k][2*k-1]t\n    full_shifts pad seq = take seqs where\n        seqs = [(repeat pad) # seq] # [shift s | s <- seqs]\n        shift s = tail s # [pad]\n\n\/**\n * Division with remainder for two polynomials over a field.\n * If p, q, r, d: [k]t, d is not poly_0, and (q,r) = poly_div_mod F p d,\n * then p == poly_add (poly_mul d q) r \n *\/\npoly_div_mod: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t -> ([k]t, [k]t)\npoly_div_mod F dividend divisor =(quot, rems!0) where\n    \/\/ shifted divisors, from most to least shifted\n    ds: [k][k]t\n    ds = reverse (shifts F.field_zero divisor)\n    \/\/ we only use the shifts when the leading coefficient is still in\n    use: [k]Bool\n    use = reverse us where\n      us = [True] # [u \/\\ F.is_equal (d@0, F.field_zero) | u <- us | d <- take`{k-1} (reverse ds)]\n    \/\/ index into remainder to be used\n    ix: [k+1][width k]\n    ix = [0] # [if u then i+1 else i | u <- use | i <- ix]\n    \/\/ c is the reciprocal of the leading coefficient of the divisor\n    c = F.div (F.field_unit, leading_coefficient F divisor)\n    \/\/ quot is the quotient, built from the highest degree down\n    quot: [k]t\n    quot = [ if u then F.mul (c, rem@i) else F.field_zero\n           | u <- use\n           | rem <- rems\n           | i <- ix\n           ]\n    \/\/ remainders at successive stages\n    rems: [k+1][k]t\n    rems = [dividend] # [ zipWith (curry F.sub) r (map (curry F.mul q) d)\n                        | r <- rems\n                        | q <- quot\n                        | d <- ds\n                        ]\n\n\n\/* For operations modulo some polynomial, we use a finite sequence\n * s: [k]t to represent the poynomial\n *\n *   x^k - sum [(s!i) * x^i | i <- [0 .. (`k-1)] ]      (*)\n *\n * In other words, s represents the reduction of x^k modulo the\n * polynomial.\n *\n * We refer to (*) as \"the polynomial corresponding to modulus s\"\n * in documentation below.\n *\/\n\nprivate\n    \/**\n     * (shifts_mod F p m)@i = (x^i * p) mod (Polynomial_of m)\n     *\/\n    shifts_mod: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t -> [k][k]t\n    shifts_mod F p m = take seqs where\n        seqs = [p] # [shift s | s <- seqs]\n        shift s = poly_add F (tail s # [F.field_zero]) (map (curry F.mul (s@0)) m)\n\n\/*\n * poly_mul_mod F p q m = p*q mod (Polynomial_of m), where\n * p and q are polynomials in F[x]\n *\/\npoly_mul_mod: {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t -> [k]t -> [k]t\npoly_mul_mod F p q m = foldl (poly_add`{t,k} F) (poly_0 F) rows where\n    rows: [k][k]t\n    rows = zipWith (\\ c s -> map (curry F.mul c) s) p (reverse (shifts_mod F q m))\n\n\/\/ specialized version of xgcd used for inverse_mod\n\/\/ we then do not need the \"t\" part, and can reduce mod along the way.\n\/\/ TODO: Find a citation for this algorithm\n\n\/**\n * Inverse of one polynomial modulo a second that it is relatively prime to.\n * For example, over GF(3), the inverse of `x+1` mod `x^2` is `2x+1`, since\n * `(x+1)(2x+1) = 2x^2 + 1`, which is 1 modulo `x^2`.\n *\/\npoly_inverse_mod: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t -> [k]t\npoly_inverse_mod F p q = r where\n    \/\/ if we just do xgcd p (polynomial_of q), that's in [k+1]t\n    \/\/ so instead we compute divrem (poly_of q) p\n    \/\/ drop the msb (which will be 0) and can continue in [k]t\n    poly_of_q = [F.field_unit] # (map F.neg q) \/\/ expanded modulus\n    expand_p = [F.field_zero] # p \/\/ extra bit for p\n    (q1,r1) = poly_div_mod F poly_of_q expand_p\n    \/\/ Now, continue xgcd from the second step\n    tuples = [ (tail r1, p, map F.neg (tail q1), poly_1 F) ]\n             # map (pim_step F q) tuples\n    (p1,p2,s1,s2) = tuples@(`k:Integer) \/\/ \":Integer\" eliminates a type-inference warning\n    \/\/ now p1 should be a constant polynomial, but might not be 1\n    \/\/ i.e p*s1 = p1 mod (poly_of_q)\n    \/\/ so multiply through by its inverse\n    r = map (curry F.mul (F.div (F.field_unit, p1!0))) s1\n\nprivate\n    pim_step F m (p1, p2, s1, s2) =\n        if poly_equal F (p2, poly_0 F)\n        then (p1, p2, s1, s2)\n        else ( (p2, r, s2, poly_sub F s1 (poly_mul_mod F q s2 m)) where\n               (q,r) = poly_div_mod F p1 p2\n             )\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/BLSMinimalPublicKeySize.cry","filetype":"cry","content":"module BLSMinimalPublicKeySize = BLSGeneric where\n\n\/\/ Suite BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_, as defined in\n\/\/ draft-irtf-cfrg-bls-signature-04, Secton 4.2.1 and Appendix A\n\nimport Parameters\nimport HashToCurveE2\nimport Pairing (bls_ate_pairing)\nimport Serialization\nimport ShortWeierstrassCurve as EC\n\n\/\/ a pairing-friendly elliptic curve\ntype t_F = t_Fp_2 \/\/ representation type for field of the primary curve (signature)\ntype t_F' = t_Fp \/\/ representation type for field of the secondary curve (pubkey)\ntype t_G = t_Fp_12  \/\/ representation type for field of the pairing result\nG = Fp_12\n\ntype pubkey_len = 48*8\ntype signature_len  = 96*8\n\nmain_curve = E'\nother_curve = E\n\n\/\/ hash_to_point  BLS12381G2_XMD:SHA-256_SSWU_RO_\n\/\/ type DST_len = 43\n\nDST: [43][8]\nDST = \"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\"\n\nhash_to_point hx = hash_to_curve_opt (hx, DST)\n\n\/\/ other primitives \"determined by the above parameters\"\n\nP: EC::AffinePoint t_F' \/\/ base point\nP = BP\n\n\/\/ pairing: (EC::AffinePoint t_F, EC::AffinePoint t_F') -> t_G\npairing (p,q) = bls_ate_pairing q p \/\/ Section 2.2\n\n\/\/ point_to_pubkey: EC::AffinePoint t_F' -> [pubkey_len]\n\/\/ point_to_pubkey = point_to_octets_E2 \/\/ Section 2.2 BUT\n\/\/    draft-irtf-cfrg-pairing-friendly-curves-07 does not mention\n\/\/    a function of this name.  So:\npoint_to_pubkey S = join (serialize_E1 S)\n\n\/\/ point_to_signature: EC::AffinePoint t_F -> [signature_len]\n\/\/point_to_signature = point_to_octets_E1 \/\/ Section 2.2\npoint_to_signature S = join (serialize_E2 S)\n\n\/\/ pubkey_to_point: [pubkey_len] -> Maybe (EC::AffinePoint t_F') \/\/ can fail\npubkey_to_point S = uncompress_E1 (split S)\n\n\/\/ signature_to_point: [signature_len] -> Maybe (EC::AffinePoint t_F) \/\/ can fail\n\n\/\/ signature_to_point: [signature_len] -> Maybe (EC::AffinePoint t_F) \/\/ can fail\n\/\/ signature_to_point = octets_to_point_E1\nsignature_to_point S = deserialize_E2 (split S)\n\n\/\/ Here are the unoptimized versions of the subgroup check\n\n\/\/ pubkey_subgroup_check: EC::AffinePoint t_F' -> Bool\npubkey_subgroup_check S =\n    EC::is_point_O E (EC::mult E r S)\n\n\/\/ signature_subgroup_check: EC::AffinePoint t_F -> Bool\n\/\/ ... more efficient versions are allowed.\nsignature_subgroup_check S =\n    EC::is_point_O E' (EC::mult E' r S)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/CoreVerifyPKInG1.cry","filetype":"cry","content":"module CoreVerifyPKInG1 where\n\nimport Parameters\nimport HashToCurveE2\nimport Pairing\n\ncore_verify_pk_in_g1 pk sig msg dst = Fp_12.is_equal(c1, c2) where\n    c1 = bls_ate_pairing pk (hash_to_curve_opt (msg, dst))\n    c2 = bls_ate_pairing BP sig\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/ExtensionField.cry","filetype":"cry","content":"\/\/\/\/\/\/ Field extensions\n\/\/\n\/\/ Extension fields are represented as polynomial quotient rings,\n\/\/ so the elements of an extension of degree m can be represented\n\/\/ by polynomials of degree at most m-1, with operations\n\/\/ carried out modulo some irreducible polynomial of degree m.\n\/\/\n\/\/ We use the Polynomial module, which represents polynomials by\n\/\/ their sequence of coefficients, in big-endian order, that is\n\/\/ with the constant coefficient appearing last.\n\/\/\n\/\/ The modulus is represented a bit strangely; see below.\n\nmodule ExtensionField where\n\nimport Common::Field\nimport Polynomial\n\n\/**\n * An extension field, represented as a polynomial quotient ring.\n *\n * The modulus is not represented directly as in the `Polynomial` module,\n * but instead we use a finite sequence `s: [k]t` to represent the poynomial\n *\n *     x^k - sum [(s!i) * x^i | i <- [0 .. (`k-1)] ]\n *\n * This `s` is in fact the polynomial giving the reduction of x^k modulo\n * the modulus.  So for example, the modulus\n *\n *      x^3 - x^2 - 5\n *\n * is represented as `[1,0,5]`.\n *\n * The modulus should be an irreducible polynomial; we do not check that here.\n *\/\nextension_field: {k, t} (fin k, k >= 1) => FieldRep t -> [k]t -> FieldRep ([k]t)\nextension_field F p =\n    { is_val = all F.is_val\n    , normalize = map F.normalize\n    , field_zero = poly_0 F\n    , field_unit = poly_1 F\n    , add (a,b) = poly_add F a b \/\/ uncurry\n    , sub (a,b) = poly_sub F a b\n    , neg = map  F.neg\n    , mul (a,b) = poly_mul_mod F a b p\n    , sq a = poly_mul_mod F a a p\n    , half = map F.half\n    , div (a,b) = poly_mul_mod F a bi p where bi = poly_inverse_mod F b p\n    , is_equal (a,b) = all F.is_equal (zip a b)\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/HashToCurveGeneric.cry","filetype":"cry","content":"\/\/ Hash-to-curve for BLS\n\/\/ Two variants are used:\n\/\/ BLS12381G1_XMD:SHA-256_SSWU_RO_ and  BLS12381G2_XMD:SHA-256_SSWU_RO_\n\nmodule HashToCurveGeneric where\n\nimport rfc8017 (I2OSP, OS2IP)\nimport Primitive::Keyless::Hash::SHA256 as SHA256\nimport Common::Field\nimport Parameters (t_Fp, Fp, to_Fp)\nimport FieldExtras\nimport ShortWeierstrassCurve as EC\nimport ExpandMessage\nimport Common::bv\n\n\/\/ NOTE: we use the trick described below around limitations of the Cryptol module system\n\/\/ https:\/\/github.com\/GaloisInc\/cryptol\/issues\/1092\n\nparameter\n    type _p: # \/\/ the field characteristic\n    type constraint fin _p\n    type constraint width _p <= 384 \/\/ because we have already specialized to BLS12-381 below\n\n    type _q: # \/\/ the number of elements in the field\n    type constraint fin _q\n\n    type _t_F: * \/\/ a type representing field elements in the extension\n    _F: FieldRep _t_F \/\/ the field operatons, in the extension field\n\n    type _m: # \/\/ extension degree\n    type constraint fin _m\n\n    \/\/ various constraints thrown up by the type checker\n    type constraint 8 * ((128 + lg2 p) \/^ 8) >= 384\n    type constraint 2 * m <= 127\n\n    \/\/ Convert a list of elements of F_p to an element of F_q\n    _base_to_F: [m]t_Fp -> _t_F\n\n    \/\/ The curve (will be E1 or E2)\n    _C: EC::EllipticCurve _t_F\n\n    _clear_cofactor: (_t_F, _t_F) -> (_t_F, _t_F)     \/\/ additional field operations\n    _is_square: _t_F -> Bool\n    _sqrt: _t_F -> _t_F\n    _sgn0: _t_F -> Bit     _inv0: _t_F -> _t_F\n\n    \/\/ for map_to_curve_simple_swu for AB=0\n    _Z: _t_F\n    _A': _t_F\n    _B': _t_F\n    _iso_map: (_t_F, _t_F) -> (_t_F, _t_F)\n\ntype p = _p\ntype q = _q\ntype t_F = _t_F\nF: FieldRep t_F \/\/ the field operatons, in the extension field\nF = _F\ntype m = _m \/\/ extension degree\nbase_to_F = _base_to_F\nC = _C\nclear_cofactor = _clear_cofactor\nis_square = _is_square\nsqrt = _sqrt\nsgn0 = _sgn0\ninv0 = _inv0\nZ = _Z\nA' = _A'\nB' = _B'\niso_map = _iso_map\n\n\/\/ Section 3\n\n\/\/ Note: added the dst as an extra parameter; the spec does not really fully determine it.\n\n\/\/ random oracle encoding (hash_to_curve)\nhash_to_curve: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 2 * m <= 127 \/\/ Needed for expand_message, otherwise output too large\n               \/\/ , 2 * m * ((128+lg2 p)\/^ 8) <= 255 \/\/ output length of expand_message must be low enough\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384                ) =>\n               ([msg_len][8], [DST_len][8]) -> EC::AffinePoint t_F\nhash_to_curve (msg,dst) = P where\n    u = hash_to_field`{count=2} msg dst \/\/ spec does not mention the dst here\n    Q0 = map_to_curve_simple_swu_AB0 (u@0)\n    Q1 = map_to_curve_simple_swu_AB0 (u@1)\n    R = EC::add C Q0 Q1\n    P = clear_cofactor R\n\n\/\/ ... however, there is an alternative way of doing it, described in Section 6.6.3\n\/\/ where points are added before the isogeny is applied\n\nhash_to_curve_opt: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 2 * m <= 127 \/\/ Needed for expand_message, otherwise output too large\n               \/\/ , 2 * m * ((128+lg2 p)\/^ 8) <= 255 \/\/ output length of expand_message must be low enough\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384                ) =>\n               ([msg_len][8], [DST_len][8]) -> EC::AffinePoint t_F\nhash_to_curve_opt (msg,dst) = P where\n    u = hash_to_field`{count=2} msg dst \/\/ spec does not mention the dst here\n    Q0 = map_to_curve_simple_swu (u@0)     Q1 = map_to_curve_simple_swu (u@1)     R = EC::add Isogenous_Curve Q0 Q1\n    P = clear_cofactor (iso_map R)\n\n\n\/\/ 5.2\n\nhash_to_field: {msg_len, DST_len, count}\n               (fin msg_len, fin DST_len, fin count\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , count * m <= 127 \/\/ Needed for expand_message, otherwise output too large\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384                ) =>\n               [msg_len][8] -> [DST_len][8] -> [count]t_F\n\nhash_to_field msg DST = us where\n      type k = 128 \/\/ for BLS12-381\n      type L = ((lg2 p) + k) \/^ 8 \/\/ 64 for BLS12-381\n      uniform_bytes: [count * m * L][8]\n      uniform_bytes = expand_message msg DST\n      \/\/ The double loop in the Draft just splits pseduo_random_bytes into\n      \/\/ \"count\" parts, each part consisting of m sub_parts,\n      \/\/ each sub-part consisting of L bytes.\n      parts: [count][m][L][8]\n      parts = split (split uniform_bytes)\n            us = [ make_u_i part | part <- parts ]\n      make_u_i: [m][L][8] -> t_F\n      \/\/ \"drop\" here takes the 8*L-bit (i.e. 512-bit for BLS12-381) result and drops leading zeros to get to [384]\n      make_u_i part = base_to_F [to_Fp (drop`{back=384} ((join bytes) % `p)) | bytes <- part]\n\nhash_to_field_1: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384                ) =>\n               [msg_len][8] -> [DST_len][8] -> [384]\nhash_to_field_1 msg DST = us where\n      type L = 64\n      uniform_bytes: [L][8]\n      uniform_bytes = expand_message msg DST\n      us = drop`{back=384} ((join uniform_bytes) % `p)\n\n\/\/ 6.6.2 Simplified SWU\n\nmap_to_curve_simple_swu: t_F -> (t_F, t_F)\nmap_to_curve_simple_swu u = ret where\n    \/\/1. tv1 = inv0(Z^2 * u^4 + Z * u^2)\n    tv1 = inv0 (F.add (F.mul (F.sq Z, F.sq (F.sq u)),\n                       F.mul (Z, F.sq u)))\n    \/\/2. x1 = (-B \/ A) * (1 + tv1)\n    \/\/3. If tv1 == 0, set x1 = B \/ (Z * A)\n    x1 = if F_is_zero F (tv1)\n         then F.div (B', F.mul (Z, A'))\n         else F.mul (F.div (F.neg B', A'), F.add(F.field_unit, tv1))\n    \/\/ 4. gx1 = x1^3 + A * x1 + B\n    gx1 = F.add (cube x1, F.add (F.mul (A', x1), B'))\n    \/\/ 5. x2 = Z * u^2 * x1\n    x2 = F.mul (Z, F.mul (F.sq u, x1))\n    \/\/ 6. gx2 = x2^3 + A * x2 + B\n    gx2 = F.add (cube x2, F.add (F.mul (A', x2), B'))\n    \/\/ 7. If is_square(gx1), set x = x1 and y = sqrt(gx1)\n    \/\/ 8. Else set x = x2 and y = sqrt(gx2)\n    (x,y) = if is_square(gx1) then (x1, sqrt(gx1)) else (x2, sqrt(gx2))\n    \/\/ 9. If sgn0(u) != sgn0(y), set y = -y\n    \/\/ 10. return (x, y)\n    ret = if sgn0(u) != sgn0(y) then (x, F.neg y) else (x,y)\n\n    cube z = F.mul (z, F.sq z)\n\n\/\/ 6.6.3, Simplified SWU for AB=0\n\nmap_to_curve_simple_swu_AB0(u) = (x, y) where\n    (x', y') = map_to_curve_simple_swu (u) \/\/ (x', y') is on E'\n    (x, y) = iso_map(x', y')               \/\/ (x, y) is on E\n\nIsogenous_Curve: EC::EllipticCurve t_F\nIsogenous_Curve = {base_field=F, a = A', b = B'}\n","variant":"hybrid","set":"supervised"}
{"filename":"BLST-Verification\/spec\/CoreVerifyPKInG2.cry","filetype":"cry","content":"module CoreVerifyPKInG2 where\n\nimport Parameters\nimport HashToCurveE1\nimport Pairing\n\ncore_verify_pk_in_g2 pk sig msg dst = Fp_12.is_equal(c1, c2) where\n    c1 = bls_ate_pairing (hash_to_curve_opt (msg, dst)) pk\n    c2 = bls_ate_pairing sig BP'\n","variant":"hybrid","set":"holdout"}
{"filename":"BLST-Verification\/spec\/HashToCurveE1.cry","filetype":"cry","content":"\/\/ hash_to_curve algorithm from draft-irtf-cfrg-hash-to-curve-09\n\nmodule HashToCurveE1 = HashToCurveGeneric where\n\n\/\/ NOTE: Our ExtensionField and Polynonial modules represents elements\n\/\/ of extension fields as polynomials, and those as lists of elements\n\/\/ of a base field in descending order by degree, so that [a,b,c]\n\/\/ represents ax^2 + bx+c.\n\/\/\n\/\/ Section 2.1 of the specification states that they are represented\n\/\/ \"in ascending order by degree\" so that [a,b,c] represents a+bx +\n\/\/ cx^2.  So we need reversals when transcribing the spec's defintions\n\/\/ into our Cryptol model, whenever lists of elements are used. These are\n\/\/ notes in the definitions belo0w\n\nimport Parameters as P\nimport FieldExtras\nimport ShortWeierstrassCurve as EC\nimport HashToCurveE1Aux as Aux\nimport BLSFieldExtras (sqrt_fp)\n\ntype _p = P::p type _q = P::p type _t_F = P::t_Fp _F = P::Fp type _m = 1 \/\/ extension degree\n_base_to_F [x] = x _C = P::E \/\/ {base_field = F, a = _F.field_zero, b = P::b}\n\n\/\/ dst = \"SPEC_IS_NOT_VERY_CLEAR\"\n\n\/\/ extra field operations\n\n_is_square x =  y == 0 \\\/ y == 1 where\n    y = F_expt`{n=width _q} _F x `((_q-1)\/2)\n\n_sqrt = sqrt_fp\n\n_sgn0 = Aux::sgn0\n\n_inv0 x = F_expt`{n=width _q} _F x `(_q-2) \/\/ but could be _F.div (_F.field_unit, x)\n\n\/\/ Constants from Section 8.8.1\n_Z = Aux::Z\n_A' = Aux::A'\n_B' = Aux::B'\n\n_clear_cofactor P = EC::mult _C Aux::h_eff P\n\n_iso_map: (_t_F, _t_F) -> (_t_F, _t_F)\n_iso_map (x', y') = if EC::is_point_O _C (x',y') then EC::point_O _C else (x, y) where\n    x_powers = [_F.field_unit] # [_F.mul(x', xi) | xi <- x_powers]\n    x_num = F_sum _F [_F.mul(ki, xi) | ki <- Aux::k1s | xi <- x_powers]\n    x_den = _F.add (x_powers@10, F_sum _F [_F.mul(ki, xi) | ki <- Aux::k2s | xi <- x_powers])\n    y_num = F_sum _F [_F.mul(ki, xi) | ki <- Aux::k3s | xi <- x_powers]\n    y_den = _F.add (x_powers@15, F_sum _F [_F.mul(ki, xi) | ki <- Aux::k4s | xi <- x_powers])\n    x = _F.div (x_num, x_den)\n    y = _F.mul (y', _F.div(y_num, y_den))\n","variant":"hybrid","set":"supervised"}
{"filename":"BLST-Verification\/spec\/HashToCurveE2.cry","filetype":"cry","content":"module HashToCurveE2 = HashToCurveGeneric where\n\n\/\/ NOTE: Our ExtensionField and Polynonial modules represents elements\n\/\/ of extension fields as polynomials, and those as lists of elements\n\/\/ of a base field in descending order by degree, so that [a,b,c]\n\/\/ represents ax^2 + bx+c.\n\/\/\n\/\/ Section 2.1 of the specification states that they are represented\n\/\/ \"in ascending order by degree\" so that [a,b,c] represents a+bx +\n\/\/ cx^2.  So we need reversals when transcribing the spec's defintions\n\/\/ into our Cryptol model, whenever lists of elements are used. These are\n\/\/ notes in the definitions belo0w\n\nimport Parameters as P\nimport FieldExtras\nimport ShortWeierstrassCurve as EC\nimport HashToCurveE2Aux as Aux\n\ntype _p = P::p type _q = P::p * P::p \/\/ cardinality, here p^2\ntype _t_F = P::t_Fp_2 _F = P::Fp_2 \/\/ the field structure, containing the operations\ntype _m = 2 \/\/ extension degree\n_base_to_F xs = reverse xs \/\/ Our polynomials are big-endian; the spec is little-endian\n\n_C = P::E' \/\/ {base_field = F, a = F.field_zero, b = P::b'}\n\n\/\/ From Section 4. Utility Functions\nCMOV (a,b,c) = if c==False then a else b\n\n\/\/ extra field operations\n\n_is_square x =  _F.is_equal (y, _F.field_zero) \\\/ _F.is_equal (y, _F.field_unit) where\n    y = F_expt`{n = width _q} _F x `((_q-1)\/2)\n\n\/\/ Alternative implementation from G.5\n\/\/ TODO\n\n\/\/ sqrt from Appendix G.3 (q = 9 mod 8)\n_sqrt x = z where\n    tv1 = F_expt`{n=width ((_q+7)\/16)} _F x `((_q+7)\/16)\n    tv2 = _F.mul (c1, tv1)\n    tv3 = _F.mul (c2, tv1)\n    tv4 = _F.mul (c3, tv1)\n    e1 =  _F.is_equal (_F.sq tv2, x)\n    e2 =  _F.is_equal (_F.sq tv3, x)\n\n    tv1_1 = CMOV (tv1, tv2, e1)\n    tv2_1 = CMOV (tv4, tv3, e2)\n    e3 = _F.is_equal (_F.sq tv2_1, x)\n    z = CMOV (tv1_1, tv2_1, e3)\n\n    \/\/ Need constants c1,c2,c3 with c1^2 = -1, c2^2 = c1, c3^3 = -c1\n    \/\/ As Fp_2 = Fp(u) with u^2 +1 = 0, c1 = u does the first\n    c1 = [1,0]\n    \/\/ Now pick a particular k (thanks to SageMath) so that 2 k^2 = -1 (mod p)\n    k: P::t_Fp\n    k = 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257\n    \/\/ Then (k(u+1))^2 = k^2(2u) = -u and\n    \/\/      (k(u-1))^2 = k^2(-2u) = u\n    c2 = [k, P::Fp.neg k] \/\/ k*(u-1)\n    c3 = [k, k] \/\/ k*(u+1)\n\n\/\/ sgn0 for m=2, from Section 4.1\n_sgn0 [x_1, x_0] =  sign_0 || (zero_0 && sign_1) where\n    \/\/ [x_1, x_0] because Section 2.1 asks for a little-endian order of elements\n    x_0' = P::from_Fp x_0\n    x_1' = P::from_Fp x_1\n    sign_0 = x_0'!0 \/\/ least-signifcant bit\n    zero_0 = x_0' == 0 \/\/ represent the Boolean as 0 or 1\n    sign_1 = x_1'!0\n\n_inv0 x = F_expt`{n=width (_q-2)} _F x `(_q-2) \/\/ but could be F.div (_F.field_unit, x)\n\n\/\/ Constants from Section 8.8.2\n_Z = _F.neg [1, 2] \/\/ -(2+I)\n\/\/ A' = [to_Fp 240, 0]: t_F \/\/ 240 * I\n_A' = Aux::to_Fp2 (0,240)\n\/\/B' = [to_Fp 1012, to_Fp 1012]: t_F  \/\/ 1012 * (1+I)\n_B' = Aux::to_Fp2 (1012,1012)\n\nh_eff = 0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551\n\n_clear_cofactor P = EC::mult _C h_eff P\n\n_iso_map: (_t_F, _t_F) -> (_t_F, _t_F)\n_iso_map (x', y') = if EC::is_point_O _C (x',y') then EC::point_O _C else (x, y) where\n    x_powers = [_F.field_unit] # [_F.mul(x', xi) | xi <- x_powers]\n    x_num = F_sum _F [_F.mul(ki, xi) | ki <- Aux::k1s | xi <- x_powers]\n    x_den = _F.add (x_powers@2, F_sum _F [_F.mul(ki, xi) | ki <- Aux::k2s | xi <- x_powers])\n    y_num = F_sum _F [_F.mul(ki, xi) | ki <- Aux::k3s | xi <- x_powers]\n    y_den = _F.add (x_powers@3, F_sum _F [_F.mul(ki, xi) | ki <- Aux::k4s | xi <- x_powers])\n    x = _F.div (x_num, x_den)\n    y = _F.mul (y', _F.div(y_num, y_den))\n","variant":"hybrid","set":"supervised"}
{"filename":"BLST-Verification\/spec\/ProjectiveCurveOperations.cry","filetype":"cry","content":"\/\/ Optimized algorithms for curves in Weierstrass short form\n\/\/ over an arbitrary field.\n\/\/\n\/\/ These algorithms work in Jacobian projective coordinates.\n\/\/\n\/\/ Formulas come from https:\/\/hyperelliptic.org\/EFD\/g1p\/auto-shortw-jacobian.html,\n\/\/ selected from the many choices available there to best match the blst code.\n\nmodule ProjectiveCurveOperations  where\n\nimport Common::Field\nimport ShortWeierstrassCurve\nimport FieldExtras\n\nprivate\n\n  two: {t} FieldRep t -> t\n  two F = F.add (F.field_unit, F.field_unit)   three: {t} FieldRep t -> t\n  three F = F.add (two F, F.field_unit)\n\n  F_double: {t} FieldRep t -> t -> t\n  F_double F x = F.add (x, x)\n\n  F_by4 F x = F_double F (F_double F x)\n  F_by8 F x = F_double F (F_by4 F x)\n\n  cubed: {t} FieldRep t -> t -> t\n  cubed F x = F.mul(x, F.sq x)\n\np_point_O: {t} EllipticCurve t -> ProjectivePoint t\np_point_O C = (F.field_unit, F.field_unit, F.field_zero) where F = C.base_field\n\n\/**\n * The negative of a point in projective coordinates on a curve.\n *\/\np_neg: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t\np_neg C (x,y,z) = (x, C.base_field.neg y, z)\n\n\/**\n * p_double P is the sum P+P for P a point on the elliptic curve.\n *\/\np_double: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t\np_double C (X1,Y1,Z1) =\n    \/\/ Using the \"dbl-1998-cmo-2\" doubling formulas, three-operand code version\n    \/\/    if F_is_zero F Z1 then p_point_O C else (X3, Y3, Z3) where\n    (X3, Y3, Z3) where \n        F = C.base_field\n        XX = F.sq X1                    YY = F.sq Y1                    ZZ = F.sq Z1            \/\/ ZZ = Z1^2\n        t0 = F.mul (X1, YY)             S = F_by4 F t0                  t1 = F.sq ZZ                    t2 = F.mul (C.a, t1)            t3 = F.mul(three F, XX)         M = F.add(t3, t2)               t4 = F.sq M                     t5 = F_double F S               T = F.sub (t4, t5)      \/\/ T = t4-t5\n        X3 = T                  \/\/ X3 = T\n        t6 = F.sub (S, T)       \/\/ t6 = S-T\n        t7 = F.sq YY            \/\/ t7 = YY^2\n        t8 = F_by8 F t7         \/\/ t8 = 8*t7\n        t9 = F.mul (M, t6)      \/\/ t9 = M*t6\n        Y3 = F.sub (t9, t8)     \/\/ Y3 = t9-t8\n        t10 = F.mul (Y1, Z1)    \/\/ t10 = Y1*Z1\n        Z3 = F_double F t10         \n\n\/**\n * Sum of two distinct points in projective coordinates on the elliptic curve,\n * provided neither is the zero point.\n * If the two points are the same, returns (0,0,0)\n *\/\np_add_generic: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add_generic C (X1,Y1,Z1) (X2,Y2,Z2) = (X3, Y3, Z3) where\n    F = C.base_field\n    \/\/ using the  \"add-1986-cc\" addition formula, three-operand code version\n    t0 = F.sq Z2              U1 = F.mul (X1, t0)       t1 = F.sq Z1              U2 = F.mul (X2, t1)       t2 = F.mul (Z2, t0)       S1 = F.mul (Y1, t2)       t3 = F.mul (Z1, t1)   \/\/ t3 = Z1^3\n    S2 = F.mul (Y2, t3)   \/\/ S2 = Y2*t3\n    P = F.sub (U2, U1)    \/\/ P = U2-U1\n    R = F.sub (S2, S1)    \/\/ R = S2-S1\n    t4 = F.add (U1, U2)   \/\/ t4 = U1+U2\n    t5 = F.sq R           \/\/ t5 = R^2\n    t6 = F.sq P           \/\/ t6 = P^2\n    t7 = F.mul (t4, t6)   \/\/ t7 = t4*t6\n    X3 = F.sub (t5, t7)       t8 = F.sq P           \/\/ t8 = P^2 -- redundant, t6 already holds p^2\n    t9 = F.mul (U1, t8)       t10 = F.sub (t9, X3)      t11 = F.mul (P, t8)       t12 = F.mul (S1, t11)     t13 = F.mul (R, t10)      Y3 = F.sub (t13, t12)     t14 = F.mul (Z2, P)   \/\/ t14 = Z2*P\n    Z3 = F.mul (Z1, t14)  \/\/ Z3 = Z1*t14\n\n\n\/**\n * Sum of two points in projective coordinates on the elliptic curve.\n *\/\np_add: {t} EllipticCurve t ->  ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add C S T = \n    if F_is_zero F Z1 then T\n     | F_is_zero F Z2 then S\n     | all (F_is_zero F) [X3,Y3,Z3] then p_double C S      else R\n    where\n        F = C.base_field\n        (_,_,Z1) = S\n        (_,_,Z2) = T\n        R = p_add_generic C S T\n        (X3,Y3,Z3) = R\n\n\/**\n * Difference of two points in projective coordinates on the elliptic curve.\n *\/\np_sub: {t} EllipticCurve t ->  ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_sub C S T = p_add C S (p_neg C T)\n\n\/**\n * Integer multiple of a point in projective coordinates on the elliptic curve.\n * The multiplier, a bitvector, is interpreted as a non-negative integer.\n *\/\np_mult: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> ProjectivePoint t -> ProjectivePoint t\np_mult C d S = if d == 0 then p_point_O C\n               |  d == 1 then S\n               |  F_is_zero F S.2 then p_point_O C\n               else Rs!1\n    where\n        F = C.base_field\n        k = 0b00 # d \/\/ 2 extra top bits, so that h does not overflow\n        h = k + k + k\n        Rs = [p_point_O C] # \/\/Here we start with 1 instead of S because we don't really know where the high-bit is\n             [ if hi && ~ki then p_add C RiDouble S\n                | ~hi && ki then p_sub C RiDouble S\n                else RiDouble\n               where RiDouble = p_double C Ri\n             | ki <- k | hi <- h | Ri <- Rs ]\n\n\/**\n * Integer multiple of a point in affine coordinates  on the elliptic curve.\n * The multiplier, a bitvector, is interpreted as a non-negative integer.\n * This definition uses projective operations internally, but should give\n * the same result as `mult`.\n *\/\np_mult_affine: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> AffinePoint t -> AffinePoint t\np_mult_affine C d S = affinify C (p_mult C d (projectify C S))\n","variant":"hybrid","set":"supervised"}
{"filename":"BLST-Verification\/spec\/ShortWeierstrassCurve.cry","filetype":"cry","content":"\/\/ Curves in Weierstrass short form, over an arbitrary field\n\/\/\n\/\/ That is, the curve equation is y^2 = x^3 + ax + b for some a, b in the field.\n\/\/\n\/\/ We use affine coordinates, and describe Jacobian projective coordiates.\n\/\/ Points are represented as tuples, corresponding to normal math notation.\n\/\/\n\/\/ We represent the point at infinity by the affine coordinates (0,0), which is fine so long as\n\/\/ b is not 0.  This is the case for all curves of interest in this project.\n\/\/\n\/\/ The curve operations are in no way optimized; we are only interested in getting the\n\/\/ mathematically correct answer here.\n\nmodule ShortWeierstrassCurve where\n\nimport Common::Field\n\ntype EllipticCurve t =\n  { base_field: FieldRep t\n  , a: t\n  , b: t\n  } type AffinePoint rep = (rep, rep) type ProjectivePoint rep = (rep, rep, rep) \/**\n * The \"point at infinity\" on an elliptic curve; the zero for point addition.\n * That's the letter \"O\" in the name, not the digit \"0\".\n *\/\npoint_O: {t} EllipticCurve t ->  AffinePoint t\npoint_O C = (F.field_zero, F.field_zero) where F = C.base_field\n\n\/**\n * Is a point the point at infinity for a given curve?\n *\/\nis_point_O: {t} EllipticCurve t ->  AffinePoint t -> Bool\nis_point_O C S = same_point_affine C S (point_O C)\n\n\/**\n * The Jacobian projective coordinates of a point in affine coordinates.\n *\/\nprojectify: {t} EllipticCurve t -> AffinePoint t -> ProjectivePoint t\nprojectify C (x,y) = (x, y, C.base_field.field_unit)\n\n\/**\n * The affine coordinates of a point in Jacobian projective coordinates.\n *\/\naffinify: {t} EllipticCurve t -> ProjectivePoint t -> AffinePoint t\naffinify C (x,y,z) = if is_zero F z\n                     then point_O C\n                     else (F.mul(lambda2, x), F.mul(lambda3, y))\n    where\n        F = C.base_field\n        lambda = F.div (F.field_unit, z)\n        lambda2 = F.sq lambda\n        lambda3 = F.mul(lambda, lambda2)\n\nprivate\n    cubed: {t} FieldRep t -> t -> t\n    cubed F x = F.mul (x, F.sq x)\n\n    fourth: {t} FieldRep t -> t -> t\n    fourth F x = F.sq (F.sq x)\n\n    sixth: {t} FieldRep t -> t -> t\n    sixth F x = F.sq (cubed F x)\n\n    is_zero: {t} FieldRep t -> t -> Bit\n    is_zero F x = F.is_equal (x, F.field_zero)\n\n        twice: {t} FieldRep t -> t -> t\n    twice F x = F.add (x, x)\n\n    thrice: {t} FieldRep t -> t -> t\n    thrice F x = F.add (x, twice F x)\n  \n\/**\n * Determine whether two projective points are different representations of\n * the same point on the curve.\n *\/\nsame_point: {t} EllipticCurve t -> ProjectivePoint t ->  ProjectivePoint t -> Bool\nsame_point C (x,y,z) (x',y',z')  =\n    F.is_equal (F.mul (x, F.sq z'), F.mul (x', F.sq z)) \/\\\n    F.is_equal (F.mul (y, cubed F z'), F.mul (y', cubed F z))\n    where F = C.base_field\n\n\/**\n * Are two affine points on a curve equal?\n *\/\nsame_point_affine:  {t} EllipticCurve t -> AffinePoint t ->  AffinePoint t -> Bool\nsame_point_affine C (x,y) (x',y') = F.is_equal (x, x') \/\\ F.is_equal (y, y')\n    where F = C.base_field\n\n\/**\n * Is a given point in affine coordinates on a given curve?\n *\/\nis_point_affine: {t} EllipticCurve t -> AffinePoint t -> Bit\nis_point_affine C S = is_point_O C S \\\/\n                      (F.is_val x \/\\ F.is_val y \/\\\n                       F.is_equal(F.sq y, F.add(cubed F x, F.add (F.mul (C.a, x), C.b))))\n    where F = C.base_field\n          (x,y) = S\n\n\/**\n * Is a given point in Jacobian projective coordinates on a given curve?\n *\/\nis_point_projective : {t} EllipticCurve t -> ProjectivePoint t -> Bit\nis_point_projective C (x,y,z) = F.is_val x \/\\ F.is_val y \/\\ F.is_val z \/\\ F.is_equal(F.sq y, t)\n    where t = F.add(cubed F x, F.add (F.mul (F.mul (C.a, x), fourth F z), F.mul (C.b, sixth F z)))\n          F = C.base_field\n\n\n\/\/ Group operations on the curve, using affine coordinates\n\n\/**\n * The negative of a point in affine coordinates on a curve.\n *\/\nneg: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t\nneg C (x,y) = (x, C.base_field.neg y)\n\ndouble: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t\ndouble C P = if is_point_O C P then P\n             | is_zero C.base_field P.1 then point_O C              else double_non_O C P\n\nprivate\n    double_non_O: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t\n    double_non_O C (x1,y1) = (x3,y3) where\n        F = C.base_field\n        \/\/ x3 = (3*x1^2+a)^2\/(2*y1)^2-x1-x1\n        x3 = F.sub (F.sq R0, twice F x1)\n        \/\/y3 = (2*x1+x1)*(3*x1^2+a)\/(2*y1)-(3*x1^2+a)^33\/(2*y1)^3-y1\n        \/\/ y3 = F.sub (F.sub (R1, R2), y1)\n        \/\/ alt formula (Wiki)\n        y3 = F.sub (F.mul (R0, F.sub(x1,x3)), y1)\n        R0 = F.div (F.add (thrice F (F.sq x1), C.a), twice F y1) \/\/ (3*x1^2+a)\/(2*y1)\n        R1 = F.mul (thrice F x1, R2)\n        R2 = cubed F R0\n\n\/**\n * The sum of two points in affine coordinates on a curve.\n * This can give meaningless results if the given points are not in fact\n * on the curve.\n *\/\nadd: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\nadd C P Q = if same_point_affine C P (point_O C) then Q\n            |  same_point_affine C Q (point_O C) then P\n            |  same_point_affine C P (neg C Q) then point_O C\n            |  same_point_affine C P Q then double C P\n            else raw_add C P Q \n\nprivate\n  raw_add: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\n  raw_add C (x1,y1) (x2,y2) = (x3,y3) where\n    F = C.base_field\n    \/\/ x3 = (y2-y1)^2\/(x2-x1)^2-x1-x2\n    x3 = F.sub (F.sub (F.sq R0, x1), x2)\n    \/\/ y3 = (2*x1+x2)*(y2-y1)\/(x2-x1)-(y2-y1)^3\/(x2-x1)^3-y1\n    y3 = F.sub (F.sub (R1, R2), y1)\n    R0 = F.div (F.sub (y2, y1), F.sub (x2, x1)) \/\/ (y2-y1)\/(x2-x1)\n    R1 = F.mul (F.add (twice F x1, x2), R0)\n    R2 = cubed F R0\n\n\n\/**\n * The difference of two points in affine coordinates on a curve.\n * This can give meaningless results if the given points are not in fact\n *  on the curve.\n *\/\nsub: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\nsub C P Q = add C P (neg C Q)\n\n\/**\n * Integer multiple of a point on the elliptic curve.  The multiplier,\n * a bitvector, is interpreted as a non-negative integer.\n *\/ \nmult: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> AffinePoint t -> AffinePoint t\nmult C d S = if d == 0 then point_O C\n             | d == 1 then S\n             | same_point_affine C S (point_O C) then point_O C\n             else Rs!1\n  where k = 0b00 # d \/\/ 2 extra top bits, so h does not overflow (e.g. for d=0b11)\n        h = k + k + k\n        Rs = [point_O C] # \/\/ start with 1 instead of S; we don't really know where the high-bit is\n             [ if hi && ~ki then add C RiDouble S\n                | ~hi && ki then sub C RiDouble S\n                else RiDouble\n               where RiDouble = double C Ri\n             | ki <- k\n             | hi <- h\n             | Ri <- Rs ]\n\n\/\/ Scalar multiplication with an Integer exponent\nscalar_mult: {t} EllipticCurve t -> Integer -> AffinePoint t -> AffinePoint t\nscalar_mult C k P = if k < 0 then scalar_mult C (-k) (neg C P)\n                     else if k == 0 then point_O C\n                     else add C P (scalar_mult C (k-1) P)\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/G2SubGroupCheck.cry","filetype":"cry","content":"module G2SubGroupCheck where\n\nimport Parameters (p, Fp_2, t_Fp_2, E', BP', r)\nimport Frobenius\nimport Pairing (alpha) \/\/ alpha is 1\/(u+1) = (1-u)\/2\nimport FieldExtras\nimport ShortWeierstrassCurve\n\n\n\/**\n * A \"projective_pair\" `(xn, xd, yn, yd)` represents the affine point (xn\/xd, yn\/yd)\n *\/\ntype projective_pair_fp2 = (t_Fp_2, t_Fp_2, t_Fp_2, t_Fp_2)\n\n\/**\n *  Endomorphism \"psi\" from Appendix E.4 of draft-irtf-cfrg-hash-to-curve-09\n *\/\npsi_projective: projective_pair_fp2 -> projective_pair_fp2\npsi_projective (xn, xd, yn, yd) = (qxn, qxd, qyn, qyd) where\n    qxn = Fp_2.mul (psi_c1, fp2_frobenius xn)\n    qxd = fp2_frobenius xd\n    qyn = Fp_2.mul (psi_c2, fp2_frobenius yn)\n    qyd = fp2_frobenius yd\n\npsi_c1: t_Fp_2\npsi_c1 = F_expt`{n=384} Fp_2 alpha ((`p-1)\/3)\n\/\/ == [to_Fp 0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad,\n\/\/     0], so also a multiple of u\n\npsi_c2: t_Fp_2\npsi_c2 = F_expt`{n=384} Fp_2 alpha ((`p-1)\/2)\n\/\/ AppendexE.1 describes the mapping from projective_pairs to Jacobian projective coordinate\n\nprojective_pair_to_jacobian: projective_pair_fp2 -> ProjectivePoint t_Fp_2\nprojective_pair_to_jacobian (xn, xd, yn, yd) = (X', Y', Z') where\n    X' = Fp_2.mul (xn, Fp_2.mul (xd, Fp_2.sq yd))\n    Y' = Fp_2.mul (yn, Fp_2.mul (Fp_2.sq yd, Fp_2.mul (xd, Fp_2.sq xd)))\n    Z' = Fp_2.mul (xd, yd)\n\njacobian_to_projective_pair: ProjectivePoint t_Fp_2 -> projective_pair_fp2\njacobian_to_projective_pair (X ,Y, Z) = (X, xd, Y, yd) where\n    xd = Fp_2.sq Z \/\/ Z^2\n    yd = Fp_2.mul (Z, xd) \/\/Z^3\n\n\/\/ and also the mapping to affine\n\nprojective_pair_to_affine: projective_pair_fp2 -> AffinePoint t_Fp_2\nprojective_pair_to_affine (xn, xd, yn, yd) = (X', Y') where\n    X' = Fp_2.div  (xn, xd)\n    Y' = Fp_2.div (yn, yd)\n\naffine_to_projective_pair: AffinePoint t_Fp_2 -> projective_pair_fp2\naffine_to_projective_pair (x, y) = (x,Fp_2.field_unit, y, Fp_2.field_unit)\n\n\/\/ We can derive the effect of psi in affine coordinates\n\npsi: AffinePoint t_Fp_2 -> AffinePoint t_Fp_2\npsi (x, y) = (qxn, qyn) where\n    qxn = Fp_2.mul (psi_c1, fp2_frobenius x)\n    qyn = Fp_2.mul (psi_c2, fp2_frobenius y)\n\n\/\/ The subgroup check for G2, from Bowe \"Faster Subgroup Checks for BLS12-381\"\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/ExpandMessage.cry","filetype":"cry","content":"module ExpandMessage where\n\nimport rfc8017 (I2OSP, OS2IP)\nimport Primitive::Keyless::Hash::SHA256 as SHA256\n\nprivate\n    \/\/ From Section 4. Utility Functions\n\n    \/\/ For byte strings str1 and str2, strxor(str1, str2) returns the bitwise XOR of the two strings.\n    strxor: {k} ([k][8],[k][8]) -> [k][8]\n    strxor (s1, s2) = s1^s2\n\nprivate\n    \/\/ The Draft uses hash function H taking byte strings and outputting byte strings.\n    \/\/ we therefore need some glue around SHA_256, which takes and returns bit strings.\n\n    \/\/ \"Hashable n\" holds if [n][8] is an acceptable argument for H\n    type constraint Hashable n = (61 >= width n)\n\n    H: {n} (Hashable n) => [n][8] -> [32][8]\n    H x = split (SHA256::sha (join x))\n\n\nexpand_message = expand_message_xmd \/\/ as per the chosen suites\n\/\/ Due to the internal calls to H (SHA-256), there is a length limit on the inputs\n\/\/ to this function.  In particular, for computing b_0 we give an argument of length\n\/\/ r_in_bytes + len_message + 2 + 1 + 1 + len_DST = 68 + len_message + len_DST\n\/\/\n\/\/ In Cryptol this is a type-checked condition rather than the \"abort if\" run-time check\n\/\/ in the Draft.\n\ntype constraint Expandable len_message len_DST  =  (61 >= width (69 + len_message + len_DST))\n\nexpand_message_xmd: {len_message, len_DST, len_in_bytes}\n                (fin len_message\n                , fin len_DST\n                , len_DST <= 255\n                , fin len_in_bytes\n                , len_in_bytes \/^ 32 <= 255\n                , Expandable len_message len_DST\n                ) => [len_message][8] -> [len_DST][8] -> [len_in_bytes][8]\nexpand_message_xmd msg DST = take uniform_bytes where\n    \/\/type b = 256                  \/\/ output length of SHA-256, in bits\n    \/\/type b_in_bytes = b \/^ 8      \/\/ = 32\n    type r_in_bytes = 64            \/\/ input block size of SHA-256\n    \/\/ type ell = len_in_bytes \/^ b_in_bytes\n    \/\/ abort if ell > 255           \/\/ this is computed in the type constraint\n    DST_prime = DST # (I2OSP`{xLen=1} (`len_DST))     Z_pad = I2OSP`{xLen=r_in_bytes} (0)\n    l_i_b_str = I2OSP`{xLen=2} (`len_in_bytes)\n    msg' = Z_pad # msg # l_i_b_str # (I2OSP`{1} 0) # DST_prime\n    b_0 = H (msg')\n    b_1 = H (b_0 # (I2OSP`{xLen=1} 1) # DST_prime)\n    bs = [b_1] # [H(strxor(b_0, b_prev) # (I2OSP`{xLen=1} i) # DST_prime) | b_prev <- bs | i:[8] <- [2...]]\n    uniform_bytes = join bs\n\nexpand_b0: {len_message, len_DST, len_in_bytes}\n                (fin len_message\n                , fin len_DST\n                , len_DST <= 255\n                , fin len_in_bytes\n                , len_in_bytes \/^ 32 <= 255\n                , Expandable len_message len_DST\n                ) => ([len_message][8], [len_DST][8]) -> [32][8]\nexpand_b0 (msg, DST) = b_0 where\n    type r_in_bytes = 64            \/\/ input block size of SHA-256\n    DST_prime = DST # (I2OSP`{xLen=1} (`len_DST)) # [0x80]\n    Z_pad = I2OSP`{xLen=r_in_bytes} (0)\n    l_i_b_str = I2OSP`{xLen=2} (`len_in_bytes)\n    b_0 = H (Z_pad # msg # l_i_b_str # (I2OSP`{1} 0) # DST_prime)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/Serialization.cry","filetype":"cry","content":"\/\/ Point serialization, from draft-irtf-cfrg-pairing-friendly-curves-07\n\/\/ Appendix C\n\/\/\nmodule Serialization where\n\nimport Parameters (p, E, E', t_Fp, to_Fp, t_Fp_2, Fp, Fp_2)\nimport ShortWeierstrassCurve as EC\nimport rfc8017\nimport Maybe\nimport FieldExtras (F_expt)\nimport BLSFieldExtras (sqrt_fp, is_square_fp, sqrt_fp2, is_square_fp2)\n\n\/\/\/\/ Serialization (with compression)\n\nsign_F_p: t_Fp -> Bit\nsign_F_p y = y > `((p - 1)\/2)\n\nsign_F_p_2: t_Fp_2 -> Bit\nsign_F_p_2(y') = if y'_1 == 0 then sign_F_p(y'_0) else y'_1 > `((p - 1)\/2) where\n    [y'_1, y'_0] = y'\n\nmetadata_bits_E1:  EC::AffinePoint t_Fp -> [3]\nmetadata_bits_E1 P = [C_bit, I_bit, S_bit] where\n    C_bit = True\n    I_bit = EC::is_point_O E P\n    S_bit = if I_bit then False else sign_F_p y where (_,y) = P\n\nm_byte_E1: EC::AffinePoint t_Fp -> [8]\nm_byte_E1 P = (metadata_bits_E1 P) # zero\n\nx_string_E1: EC::AffinePoint t_Fp -> [48][8]\nx_string_E1 P = if EC::is_point_O E P\n                then I2OSP(0)\n                else I2OSP(x) where (x,_) = P\n\n\/\/ See the note about the order of the x_i below, in deserialize_E2\nx_string_E2: EC::AffinePoint t_Fp_2 -> [96][8]\nx_string_E2 P = if EC::is_point_O E' P\n                then I2OSP(0)\n                else I2OSP`{xLen=48}(x_1) # I2OSP(x_0) where ([x_1, x_0],_) = P\n\nserialize_E1: EC::AffinePoint t_Fp -> [48][8]\nserialize_E1 P = x_string_E1 P || ([m_byte_E1 P]# zero)\n\nserialize_E2: EC::AffinePoint t_Fp_2 -> [96][8]\nserialize_E2 P = x_string_E2 P || ([m_byte]# zero) where\n    C_bit = True\n    I_bit = EC::is_point_O E' P\n    S_bit = if I_bit then False else sign_F_p_2 y where (_,y) = P\n    m_byte = [C_bit, I_bit, S_bit] # zero\n\n\/\/\/\/ Deserialization\n\/\/ Strictly speaking, we should be able to deserialize an uncompressed representation,\n\/\/ but the suites we look at all use compression.\n\n\/\/ TODO: we need [96][8] because if the infinity bit is set, we must check all 96 bytes (except first 3 bits) are zero. We could also have a separate uncompress function.\n\/\/ the C code can take a 96 bytes array whose last 48 are unintialized\n\/\/ we deviate from the RFC: the RFC says \"if the string has length...\", but in the C code there's no concept of length of the string\n\ndeserialize_E1: [96][8] -> Maybe (EC::AffinePoint t_Fp)\ndeserialize_E1 s_string = ret where\n    \/\/ Step 1.\n    m_byte = (s_string@0) && 0xE0 \/\/ three highest bits\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    \/\/ Step 2 deferred (we check that C_bit is 1 later)\n    \/\/ Step 3\n    s_string' = take`{front=48} ([(s_string@0) && 0x1F] # tail s_string) \/\/ the last 48 bytes may be uninitialized for a compressed point. TODO should we assume they're zero? doesn't seem to make sense (extra work for the caller)\n    \/\/ Step 6\n    x = OS2IP(s_string')\n    \/\/Step 7 (on curve E)\n    y2 = Fp.add (Fp.mul (x, Fp.sq x), 4)\n    y = sqrt_fp y2\n    Y_bit = sign_F_p y\n    \/\/ Steps 2, 4, 8\n    ret = if C_bit == False then nothing \/\/ Error, from Step 2; TODO what if I_bit is set? We could still return inf\n           | I_bit then (if s_string' == zero then just (EC::point_O E) else nothing) \/\/ Step 4\n           | ~ (is_square_fp y2) then nothing \/\/ from Step 7\n           | S_bit == Y_bit then just (x,y)\n          else just (x, Fp.neg y)\n\n\/\/ draft-irtf-cfrg-bls-signature-04 specifies that the compressed representation is used for BLST\nuncompress_E1: [48][8] -> Maybe (EC::AffinePoint t_Fp)\nuncompress_E1 s_string = ret where\n    \/\/ Step 1.\n    m_byte = (s_string@0) && 0xE0 \/\/ three highest bits\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    \/\/ Step 2 deferred (we check that C_bit is 1 later)\n    \/\/ Step 3\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    \/\/ Step 6\n    x = OS2IP(s_string')\n    \/\/ TODO here the C implementation checks that x is smaller than the modulus\n    \/\/Step 7 (on curve E)\n    y2 = Fp.add (Fp.mul (x, Fp.sq x), 4)\n    y = sqrt_fp y2\n    Y_bit = sign_F_p y\n    \/\/ Steps 2, 4, 8\n    ret = if (m_byte == 0x20 ) || (m_byte == 0x60) || (m_byte == 0xE0) then nothing\n           | C_bit == False then nothing \/\/ Error, from Step 2\n           | I_bit then (if s_string' == zero then just (EC::point_O E) else nothing) \/\/ Step 4\n           | ~ (is_square_fp y2) then nothing \/\/ from Step 7\n           | S_bit == Y_bit then just (x,y)\n          else just (x, Fp.neg y)\n\ndeserialize_E2: [96][8] -> Maybe (EC::AffinePoint t_Fp_2)\ndeserialize_E2 s_string = ret where\n    \/\/ Step 1.\n    m_byte = (s_string@0) && 0xE0\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    \/\/ Step 2 deferred (we check that C_bit is 1 later)\n    \/\/ Step 3\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    \/\/ Step 6\n    \/\/ Section 2.5 of draft-irtf-cfrg-pairing-friendly-curves-07 suggests this should be:\n    \/\/     x = map to_Fp (reverse (split`{parts=2} (OS2IP`{a=[2*384]}(s_string'))))\n    \/\/ HOWEVER, the  cited ZCash scheme, and personal communications from R Wahby disagree:\n    \/\/ we do not reverse the order of the parts.  So:\n    x = map to_Fp (split`{parts=2} (OS2IP`{a=[2*384]}(s_string')))\n    \/\/Step 7 (on curve E')\n    y2 = Fp_2.add (Fp_2.mul (x, Fp_2.sq x), [4,4])     y = sqrt_fp2 y2\n    Y_bit = sign_F_p_2 y\n    \/\/ Steps 2, 4, 8\n    ret = if m_byte == 0x20 \\\/ m_byte == 0x60 \\\/ m_byte == 0xE0 then nothing \/\/ Error, from Step 1\n           | C_bit == False then nothing \/\/ Error, from Step 2\n           | I_bit then (if s_string' == zero then just (EC::point_O E') else nothing) \/\/ Step 4\n           | ~ (is_square_fp2 y2) then nothing \/\/ from Step 7\n           | S_bit == Y_bit then just (x,y)\n          else just (x, Fp_2.neg y)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/KeyGen.cry","filetype":"cry","content":"module KeyGen where\n\n\/\/ 2.3 KeyGen\n\nimport Parameters as P\nimport Primitive::Keyless::Hash::SHA256\nimport Primitive::Symmetric::KDF::HKDF256\nimport rfc8017\n\n\/**\n * KeyGen from draft-02\n *\/\nKeyGen_r2: {IKM_len, info_len} ( IKM_len >= 32\n                               , validHMACSizes 20 (1+IKM_len)\n                               , validHMACSizes 32 (35+info_len)\n                               ) =>\n        ([IKM_len][8], [info_len][8]) -> [256]\nKeyGen_r2 (IKM, key_info) = SK where\n    type L = (3 * 256) \/^ 16 \/\/ (ceil lg2 r) = 256, so L = 3*16=48\n    PRK = HKDF_Extract \"BLS-SIG-KEYGEN-SALT-\" (IKM # [0]) \/\/ [0] is I2OSP`{xLen=1} 0)\n    OKM = HKDF_Expand`{L=L} PRK (key_info # I2OSP`{xLen=2} `L)\n    SK = drop ((OS2IP`{a=[384]} OKM) % (zext P::r))\n\n\/**\n * KeyGen from draft-04\n *\/\nKeyGen: {IKM_len, info_len} ( validHMACSizes 20 (1+IKM_len)\n                            , validHMACSizes 32 (35+info_len)\n                            ) =>\n        ([IKM_len][8], [info_len][8]) -> [256]\n\/\/ artificial cutoff at 4 iterations, to avoid an unbounded loop\nKeyGen (IKM, key_info) = (KeyGenLoop (sha (join \"BLS-SIG-KEYGEN-SALT-\")) IKM key_info) @ 4\n\nKeyGenLoop salt IKM info = keys where\n  salts = [salt] # [sha salt' | salt' <- salts]\n  keys = [zero] #\n         \/\/ hang on to a nonzero key, try again with revised salt otherwise\n         [if k == zero then key_gen_step salt' else k | k <- keys | salt' <- salts]\n  key_gen_step s = KeyGenStep s IKM info\n\nKeyGenStep:  {IKM_len, info_len} (\n                              validHMACSizes 20 (1+IKM_len)\n                            , validHMACSizes 32 (35+info_len)\n                            ) =>\n        [256] -> [IKM_len][8] ->[info_len][8] -> [256]\nKeyGenStep salt IKM key_info = SK where\n    type L = (3 * 256) \/^ 16 \/\/ (ceil lg2 r) = 256, so L = 3*16=48\n    PRK = HKDF_Extract (split salt) (IKM # [0]) \/\/ I2OSP`{xLen=1} 0)\n    OKM = HKDF_Expand`{L=L} PRK (key_info # I2OSP`{xLen=2} `L)\n    SK = drop ((OS2IP`{a=[384]} OKM) % (zext P::r))\n","variant":"hybrid","set":"supervised"}
{"filename":"BLST-Verification\/spec\/rfc8017.cry","filetype":"cry","content":"module rfc8017 where\n\/\/ Some definitions from RFC 8107 (PKCS #1), November 2016\n\/\/ \n\n\/\/ Section 4. Data Conversion Primitives\n\/\/\n\/\/ The intent is to convert to and from \"Integers\".  For Cryptol,\n\/\/ we make them work with any integer-like type.\n\n\/\/ The bytes are assembled in big-endian order.\n\n\/*\n * I2OSP`{xLen=y} x corresponds to the RFC's notation \"I2OSP(x, y)\"\n *\/\nI2OSP: {xLen, a} (fin xLen, Integral a) => a -> [xLen][8]\nI2OSP x = split (fromInteger (toInteger x))\n\n\/\/ TODO: it may be dangerous to let type \"a\" be inferred; sometimes\n\/\/ Cryptol infers [n] for n < xLen*8, which then ignores high-order bits.\n\nOS2IP: {xLen, a} (fin xLen, Ring a) => [xLen][8] -> a\nOS2IP x = fromInteger (toInteger (join x))\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/Pairing.cry","filetype":"cry","content":"\/\/ Pairing for tyhe BLS curves, from draft-irtf-cfrg-pairing-friendly-curves-07\n\nmodule Pairing where\n\nimport Parameters as P\nimport ShortWeierstrassCurve as EC\nimport FieldExtras\nimport Frobenius\n\n\/**\n * The curve E: y^2 = x^3 + 4, over F_p^12\n *\/\nc12: EC::EllipticCurve t12\nc12 = { base_field = P::Fp_12, a = P::Fp_12.field_zero, b = P::Fp_to_Fp_12 P::b }\n\n\/**\n * Take a point on E\/F_p to a point on E\/F_p^12\n * This just applies the field injection to the coordinates\n *\/\nphi_1: EC::AffinePoint t1 -> EC::AffinePoint t12\nphi_1 (x,y) = (P::Fp_to_Fp_12 x, P::Fp_to_Fp_12 y)\n\n\/\/ alpha = (1-u)\/2.  This constant is needed in the sextic twist in function `phi_2`\nalpha: t2\nalpha = f2.half (f2.sub (f2.field_unit, P::u))\n\n\/\/ Note: the layout of f12 over f2 is\n\/\/ [[a,c,e],[b,d,f]] represents a*w^5 + b*w^4 + c*w^3 + d*w^2 + e*w + f \n\n\/**\n *  w4_times x = x*w^3\n *\/\nw3_times: t2 -> t12\nw3_times x = [[z,x,z],[z,z,z]] where z = f2.field_zero\n\n\/**\n *  w4_times x = x * w^4\n *\/\nw4_times: t2 -> t12\nw4_times x = [[z,z,z],[x,z,z]] where z = f2.field_zero\n\n\/**\n * Take a point on E'\/F_p^2 to a point on E\/F_p^12\n * This applies a sextic twist\n *\/\nphi_2: EC::AffinePoint t2 -> EC::AffinePoint t12\nphi_2 (x,y) = (x',y') where\n    x' = w4_times (f2.mul (x, alpha))\n    y' = w3_times (f2.mul (y, alpha))\n\n\/\/ The line_function\n\nprivate\n    twice x = f12.add (x,x)\n    thrice x = f12.add (x, twice x)\n\n\/**\n * The \"Line_Function\" from Appendix A of draft-irtf-cfrg-pairing-friendly-curves-07\n *\/ \nline_function: (t12,t12) -> (t12,t12) -> (t12,t12) -> t12\nline_function A B P = ret where\n    (A1,A2) = A\n    (B1,B2) = B\n    (P1,P2) = P\n    ret = if A == EC::neg c12 B \/\/ if A==-B\n          then f12.sub (P1, A1) \/\/ return P1 - A1\n          else f12.sub (f12.add (f12.mul (l, f12.sub (P1, A1)), A2), P2)\n    l = if A == B\n        then f12.div (thrice (f12.sq A1), twice A2)\n        else f12.div (f12.sub (B2, A2), f12.sub (B1, A1))\n\n\n\/\/ bls_ate_pairing, Appendix A.2 of the Draft\n\/\/\n\/\/ The Draft does not make it clear that the Line Function acts on the curve\n\/\/ E(F_p^{`12}).  Optimizations are possible, as the points involved can be\n\/\/ represented by points on curves over smaller fields.  Here, we simply map\n\/\/ the points to the full curve and compute there.\n\n\/\/ t = -2^63 - 2^62 - 2^60 - 2^57 - 2^48 - 2^16\nnegative_t:[64]\nnegative_t = <| x^^63 + x^^62 + x^^60 + x^^57 + x^^48 + x^^16 |>\n\n\/**\n * The \"Optimal Ate Pairing\" for the BLS12_381 curves,\n * as defined in Appendix A.2 of  draft-irtf-cfrg-pairing-friendly-curves-07\n *\/\nbls_ate_pairing: EC::AffinePoint t1 -> EC::AffinePoint t2 -> t12\nbls_ate_pairing p q = ate_pairing (phi_1 p) (phi_2 q)\n\nate_pairing: EC::AffinePoint t12 -> EC::AffinePoint t12 -> t12\nate_pairing P Q = final_exponentiation (ate_pairing' P Q)\n\n\/\/ skipping the final exponentation\nate_pairing': EC::AffinePoint t12 -> EC::AffinePoint t12 -> t12\nate_pairing' P Q =  last_f where\n   negQ = EC::neg c12 Q\n   (last_f, _) = f_Ts ! 0\n   f_Ts = [(f12.field_unit, negQ)] #\n          [ miller_step P negQ fT ci | fT <- f_Ts | ci <- tail negative_t]\n\n\/\/ in the Miller loop, c_i is only ever 0 or -1, here represented by False and True\n\/\/ We only subtract Q, never add, so we take -Q as a parameter\nmiller_step:  EC::AffinePoint t12 -> EC::AffinePoint t12 -> (t12, EC::AffinePoint t12)\n              -> Bit -> (t12, EC::AffinePoint t12)\nmiller_step P negQ (f, T) ci = (f', T') where\n    f0 = f12.mul (f12.sq f, line_function T T P)\n    T0 = EC::double c12 T\n    (f', T') = if ci\n               then (f12.mul (f0, line_function T0 negQ P),\n                     EC::add c12 T0 negQ)\n               else (f0, T0)\n\n\ntype r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\ntype final_exponent = (P::p^^12 - 1) \/ r\ntype small_final_e =  (P::p^^4 - P::p^^2 +1)\/r\n\n\/\/ Use the Frobenius mapping to compute x^(p^6-1)*(p^2+1)\nfinal_exp_frobenius_map : t12 -> t12\nfinal_exp_frobenius_map x = x2 where\n  x1 = f12.div (fp12_conjugate x, x) \/\/ = x^(p^6 - 1)\n  x2 = f12.mul (fp12_frobenius (fp12_frobenius x1), x1) \/\/ x1^(p^2+1)\n\nfinal_exponentiation: t12 -> t12\n\/* We could most simply define\n\n  final_expt x = k_expt`{6} f12 x (`final_exponent:[4314])\n\n  but is it rather inefficient to do so.  Instead, as noted in [1] and [2]\n  we can use the factorization\n\n     p^12-1 = (p^8+p^6 - p^2-1)*(p^4-p^2+1)\n            = (p^6-1)*(p^2+1)*(p^4-p^2+1)\n\n  and r since divides p^4-p^2+1, we can first use the Frobenius mapping to\n  easily compute x^(p^6-1)*(p^2+1), then complete the calculation\n  raising this to (p^4-p^2+1)\/r.\n\n  For that last exponentiation, we use a (2^5)-ary breakdown of the exponent,\n  noting that 2^5 = 32 is pretty close the the square root of 1268, the number of\n  bits in the exponent.\n\n  [1] Beauchat et al.  \"High-Speed Software Implementation of the Optimal\n      Ate airing over Barreto-Naehrig Curves\"\n\n  [2] Scott et al. \"On the final exponentiation for calculating pairings on\n      ordinary elliptic curves.\" eprint.iacr.org\/2008\/490\n *\/\nfinal_exponentiation x = k_expt`{5} f12 (final_exp_frobenius_map x) (`small_final_e:[1268+2])\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/BLSGeneric.cry","filetype":"cry","content":"\/\/ Definitions from draft-irtf-cfrg-bls-signature-04\n\/\/\n\/\/ That specification describes a number of \"parameters\" that are used in its\n\/\/ definitions, and later defines ciphersuites that instantiate those parameters.\n\/\/\n\/\/ This module defines the specification in terms of the parameters, using a Cryptol\n\/\/ parameterized module.  The instantiations are done in separate Crytpol files,\n\/\/ as required by the language.\n\nmodule BLSGeneric where\n\nimport Common::Field (FieldRep)\nimport ShortWeierstrassCurve as EC\nimport Parameters as P\nimport Maybe\nimport Primitive::Keyless::Hash::SHA256\nimport Primitive::Symmetric::KDF::HKDF256\nimport rfc8017\n\n\/\/ Section 2.2, \"parameters\"\n\nparameter\n    \/\/ signature variant: not needed in the formalization\n\n    \/\/ a pairing-friendly elliptic curve\n    type t_F: * \/\/ representation type for field of the primary curve (signature)\n    type t_F': * \/\/ representation type for field of the secondary curve (pubkey)\n    type t_G: * \/\/ representation type for field of the pairing result\n    G: FieldRep t_G\n\n        type constraint Eq t_G\n    type constraint Zero t_G      type pubkey_len: #\n    type signature_len: #\n\n    main_curve: EC::EllipticCurve t_F\n    other_curve: EC::EllipticCurve t_F'\n\n    \/\/ H, a hash function, is always HKDF, so not listed here\n\n        DST: [43][8]\n\n    hash_to_point: {msg_len} (Hashable msg_len) =>\n               [msg_len][8] -> EC::AffinePoint t_F\n\n    \/\/ other primitives \"determined by the above parameters\"\n\n    P: EC::AffinePoint t_F' \/\/ base point\n    \/\/ r -- is fixed in both BLS variants  Should we use it here as a parameter anyway??\n\n    pairing: (EC::AffinePoint t_F, EC::AffinePoint t_F') -> t_G\n\n    point_to_pubkey: EC::AffinePoint t_F' -> [pubkey_len]\n    point_to_signature: EC::AffinePoint t_F -> [signature_len]\n\n    pubkey_to_point: [pubkey_len] -> Maybe (EC::AffinePoint t_F') \/\/ can fail\n    signature_to_point: [signature_len] -> Maybe (EC::AffinePoint t_F) \/\/ can fail\n\n    pubkey_subgroup_check: EC::AffinePoint t_F' -> Bool\n    signature_subgroup_check: EC::AffinePoint t_F -> Bool\n\n\/\/type constraint Hashable msg_len = (msg_len <= 255, 61 >= width (69 + msg_len + DST_len))\ntype constraint Hashable msg_len = (msg_len <= 255, 61 >= width (69 + msg_len + 43))\n\nreexport_DST = DST\n\nreexport_pubkey_subgroup_check = pubkey_subgroup_check\nreexport_signature_subgroup_check = signature_subgroup_check\n\n\/\/ 2.3 KeyGen\n\n\/\/ ... KeyGen has been moved to its own module, called KeyGen, as it does not depend\n\/\/     on the parameters.\n\n\n\/\/ 2.4 SkToPk\n\nsk_to_pk: [255] -> [pubkey_len]\nsk_to_pk sk = point_to_pubkey (EC::mult other_curve sk P)\n\n\n\/\/ 2.5 KeyValidate\n\n\/\/ The spec says to return VALID or INVALID; here we use True for VALID\nKeyValidate: [pubkey_len] -> Bool\nKeyValidate pk = ret where\n    xP = pubkey_to_point pk  \/\/ step 1\n    ret = maybe_cases xP\n            False \/\/ xP is None, step 2\n            (\\y ->   (~ (EC::is_point_O other_curve y)) \/\/ Step 3\n                  \/\\ reexport_pubkey_subgroup_check y) \/\/ Step 4\n\n\/\/ 2.6 CoreSign\n\n\/* CoreSign: {msg_len} (Hashable msg_len) => [255] -> [msg_len][8] -> [signature_len] *\/\nCoreSign: {msg_len} (Hashable msg_len) => ([255], [msg_len][8]) -> [signature_len]\nCoreSign (sk, message) = signature where\n    Q = hash_to_point message\n    R = EC::mult main_curve sk Q\n    signature = point_to_signature R\n\n\/\/ 2.7 CoreVerify\n\nCoreVerify: {msg_len} (Hashable msg_len) => [pubkey_len] -> [msg_len][8] -> [signature_len] -> Bool\n\/* possible alternate definition\nCoreVerify(PK, message, signature) = maybe False step3 (signature_to_point signature) where \/\/ lines 1, 2\n    step3 R = if signature_subgroup_check R == False then False \/\/ line 3\n               |  KeyValidate PK == False then False \/\/ line 4\n              else maybe False (step5 R) (pubkey_to_point PK) \/\/ line 5, but dealing with \"maybe-ness\"\n    step5 R xP = C1 == C2 where \/\/ line 9\n         Q = hash_to_point message \/\/ line 6\n         C1 = pairing (Q, xP) \/\/ line 7\n         C2 = pairing (R, P) \/\/ line 8\n*\/\nCoreVerify PK message signature =\n    maybe_cases (signature_to_point signature)\n        False         (\\ R -> if reexport_signature_subgroup_check R == False then False                  |  KeyValidate PK == False then False                 else maybe_cases (pubkey_to_point PK)\n                    False                     (\\ xP -> (C1 == C2 where                               Q = hash_to_point message                               C1 = pairing (Q, xP)                               C2 = pairing (R, P)))) aggregate_loop: {n, msg_len} (fin n, Hashable msg_len) =>\n                [n][pubkey_len] ->\n                [n][msg_len][8] ->\n                Maybe t_G\naggregate_loop PKs messages = C1s ! 0 where      C1s = [just G.field_unit] # [ aggregate_loop_body PK message C1 |\n                                  PK <- PKs |\n                                  message <- messages |\n                                  C1 <- C1s ]\n\naggregate_loop_body: {msg_len} (Hashable msg_len) =>\n                     [pubkey_len] ->\n                     [msg_len][8] ->\n                     Maybe t_G ->\n                     Maybe t_G\naggregate_loop_body PK message mC1 =\n    maybe_cases mC1 nothing (\\C1 ->\n        if KeyValidate PK == False then nothing          else maybe_cases (pubkey_to_point PK)\n            nothing              (\\ xP -> (just (G.mul (C1, (pairing (Q, xP)))) where                        Q = hash_to_point message)))  CoreAggregateVerify: {n, msg_len} (fin n, Hashable msg_len) =>\n                     [n][pubkey_len] ->\n                     [n][msg_len][8] ->\n                     [signature_len] ->\n                     Bool\nCoreAggregateVerify PKs messages signature =\n    maybe_cases (signature_to_point signature)          False                                           (\\R -> if reexport_signature_subgroup_check R == False\n               then False                 else (maybe_cases mC1 False (\\C1 -> C1 == C2) where                       mC1 = aggregate_loop PKs messages                      C2 = pairing (R, P)))  ","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/FieldExtras.cry","filetype":"cry","content":"module FieldExtras where\n\nimport Common::Field\n\n\/**\n * Sum of a list of field elements\n *\/\nF_sum: {t, n} (fin n) => FieldRep t -> [n]t -> t\nF_sum F vs = sums!0 where\n    sums = [F.field_zero] # [F.add (s, v) | s <- sums | v <- vs]\n\n\/**\n * Product of a list of field elements\n *\/\nF_prod: {t, n} (fin n) => FieldRep t -> [n]t -> t\nF_prod F vs = prods!0 where\n    prods = [F.field_unit] # [F.mul (s, v) | s <- prods | v <- vs]\n\n\/**\n * F_expt F x e = x^e, computed in field F.\n *\/\nF_expt: {t, n} (fin n) => FieldRep t -> t -> Integer -> t\nF_expt F x e = powers ! 0 where\n    powers = [F.field_unit] #\n             [if b then F.mul (x, F.sq p) else F.sq p | p <- powers | b <- ((fromInteger e):[n])]\n\n\/**\n * Is a field element zero?\n *\/\nF_is_zero: {t} FieldRep t -> t -> Bit\nF_is_zero F x = F.is_equal (x, F.field_zero)\n\nprivate\n    kth_square: {k, t} (fin k, k>=1) => FieldRep t -> t -> t\n    kth_square F x = squares@(`k) where\n        squares = [x] # [F.sq y | y <- squares]\n\n\/**\n * k_expt`{k} F b e computes b^e in field f, using `k` bits of the exponent at a time.\n * This is not exactly Brauer's \"2^k-ary\" method, but is close.\n * This can be more efficient than the formal `F_expt` function that uses the convential\n * \"square-and-multiply\" algorithm.\n *\/\nk_expt: {k, n, t} (fin k, fin n, k>=1, n>=1) => FieldRep t -> t -> [n*k] -> t\nk_expt F b e = acc!0 where\n    digits: [n][k]\n    digits = split e\n    small_powers = [F.field_unit] # [F.mul(b, sp) | sp <- small_powers] \/\/ 1, b, b^2, ...\n    acc = [small_powers@(digits@0)] # [F.mul(small_powers@d, kth_square`{k} F a) | a <- acc | d <- tail digits]\n\n\/\/ Multiplication by small constants\n\nmul_by_2: {t} FieldRep t -> t -> t\nmul_by_2 F x = F.add (x,x)\n\nmul_by_3: {t} FieldRep t -> t -> t\nmul_by_3 F x = F.add (x, F.add (x, x))\n\nmul_by_4: {t} FieldRep t -> t -> t\nmul_by_4 F x = mul_by_2 F (mul_by_2 F x)\n\nmul_by_6: {t} FieldRep t -> t -> t\n\/\/ mul_by_6 F x = F.add (y, F.add (y, y)) where y = mul_by_2 F x\nmul_by_6 F x = mul_by_3 F (mul_by_2 F x)\n\nmul_by_8: {t} FieldRep t -> t -> t\nmul_by_8 F x = x8 where\n  x2 = F.add (x, x)\n  x4 = F.add (x2, x2)\n  x8 = F.add (x4, x4)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/PrimeField.cry","filetype":"cry","content":"\/\/ Three representation of a finite field with p elements, where p is prime.\n\/\/\n\/\/ The first uses Integers, the second the modular type `Z n`, and \n\/\/ the third uses bit vectors.\n\/\/\n\/\/ In the second, then, \"p\" is a type parameter, while in the other two it\n\/\/ is a value parameter.\n\nmodule PrimeField where\n\nimport Common::Field\nimport Common::ModDivZ\nimport Common::mod_arith\n\n\/**\n * A finite field with a prime number of elements, represented\n * using Integers\n *\n * The constructor does not check that `p` is prime, so the caller should.\n *\/\nprime_field_integer: Integer -> FieldRep Integer\nprime_field_integer p =\n    { is_val x = 0 <= x \/\\ x < p\n    , normalize x = x % p\n    , add (x, y) =  mod_add_Z (p,x,y)\n    , sub (x, y) = mod_sub_Z (p,x,y)\n    , neg x = mod_neg_Z (p,x)\n    , mul (x,y) = mod_mul_Z (p,x,y)\n    , sq x = mod_sq_Z (p, x)\n    , half x = mod_half_Z (p,x)\n    , div (x,y) = mod_div_Z (p,x,y)\n    , field_zero = 0\n    , field_unit = 1\n    , is_equal (x, y) = x==y\n    }\n\nmod_add_Z: (Integer,Integer,Integer) -> Integer\nmod_add_Z (p,x,y) = (x + y) % p\n\nmod_sub_Z: (Integer,Integer,Integer) -> Integer\nmod_sub_Z (p,x,y) = (x - y) % p\n\nmod_mul_Z: (Integer,Integer,Integer) -> Integer\nmod_mul_Z (p,x,y) = (x * y) % p\n\nmod_neg_Z: (Integer,Integer) -> Integer\nmod_neg_Z (p, x) = (-x)%p\n\nmod_sq_Z: (Integer,Integer) -> Integer\nmod_sq_Z (p,x) = mod_mul_Z (p, x, x)\n\nmod_half_Z: (Integer,Integer)-> Integer\nmod_half_Z (p, x) = if (x%2==0) then x\/2 else (x+p)\/2\n\n\/* Returns x\/y in F_p using Euler's binary gcd algorithm. *\/\n\/* Taken from [HMV] *\/\nmod_div_Z : (Integer,Integer,Integer) -> Integer\nmod_div_Z (p,x,y) = egcd(p,0,y%p,x%p)\n  where\n    \/* In code below, a is always odd. *\/\n    egcd(a,ra,b,rb) =\n      if b == 0 then\n        ra\n      else if (b % 2) == 0 then \/* b is even. *\/\n        egcd(a, ra, b \/ 2, mod_half_Z(p, rb))\n      else if a < b then\n        egcd(a, ra, (b - a) \/ 2, mod_half_Z (p, (rb-ra)%p))\n      else\n        egcd(b, rb, (a - b) \/ 2, mod_half_Z (p, (ra-rb)%p))\n\n\n\/**\n * A finite field with a prime number of elements, represented\n * using modular types: `prime_field`k is represented with type `Z k`.\n *\n * The constructor does not check that `k` is prime, so the caller should.\n *\/\nprime_field: {k} (fin k, k >= 3, k > 2*(k\/2)) =>  FieldRep (Z k)\nprime_field =\n    { is_val x = True\n    , normalize x = x\n    , add (x, y) = x + y\n    , sub (x, y) = x - y\n    , neg x = -x\n    , mul (x,y) = x*y\n    , sq x = x*x\n    , half x = moddiv x 2\n    , div (x,y) = moddiv x y\n    , field_zero = 0\n    , field_unit = 1\n    , is_equal (x, y) = x==y\n    }\n\n\n\/**\n * A finite field with a prime number of elements, represented using\n * bit-vector types: `prime_field (k:[n])` is represented with type `[n]`.\n *\n * The constructor does not check that `m` is prime, so the caller should.\n *\/\nprime_field_bv: {n} (fin n, n >= 1) => [n] -> FieldRep [n]\nprime_field_bv m =\n    { is_val x = x < m\n    , normalize x = (x % m)\n    , add (x, y) = mod_add (m,x,y)\n    , sub (x, y) = mod_sub (m,x,y)\n    , neg x = mod_neg (m, x)\n    , mul (x,y) = mod_mul (m, x, y)\n    , sq x = mod_mul (m, x, x)\n    , half x = mod_half (m, x)\n    , div (x,y) = mod_div (m, x, y)\n    , field_zero = 0\n    , field_unit = 1\n    , is_equal (x, y) = x==y \/\/ does this need to handle unnormalized values?\n    }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/BLSFieldExtras.cry","filetype":"cry","content":"module BLSFieldExtras where\n\nimport Parameters (p, Fp, t_Fp, Fp_2, t_Fp_2, u)\nimport FieldExtras\n\nis_square_fp x =  y == 0 \\\/ y == 1 where\n    y = F_expt`{n=width p} Fp x `((p-1)\/2)\n\nsqrt_fp x = F_expt`{n=width p} Fp x `((p+1)\/4) \/\/ the =3 (mod 4) variant\n\ninverse_fp x = F_expt`{n=width p} Fp x `(p-2) \/\/ but also could be F.div (F.field_unit, x)\n\ntype q = p*p\n\n\/\/ sqrt in Fp2 from Appendix G.3 (q = 9 mod 8)\nsqrt_fp2 x = z where\n    tv1 = F_expt`{n=(width q) - 3} Fp_2 x `((q+7)\/16)\n    tv2 = Fp_2.mul (c1, tv1)\n    tv3 = Fp_2.mul (c2, tv1)\n    tv4 = Fp_2.mul (c3, tv1)\n    e1 =  Fp_2.is_equal (Fp_2.sq tv2, x)\n    e2 =  Fp_2.is_equal (Fp_2.sq tv3, x)\n\n    tv1_1 = CMOV (tv1, tv2, e1)\n    tv2_1 = CMOV (tv4, tv3, e2)\n    e3 = Fp_2.is_equal (Fp_2.sq tv2_1, x)\n    z = CMOV (tv1_1, tv2_1, e3)\n\n    \/\/ From Section 4. Utility Functions\n    CMOV (a,b,c) = if c==False then a else b\n\n    \/\/ Need constants c1,c2,c3 with c1^2 = -1, c2^2 = c1, c3^3 = -c1\n    \/\/ As Fp_2 = Fp(u) with u^2 +1 = 0, c1 = u does the first\n    c1 = [1,0]\n    c2 = sqrt_fp2_c2\n    c3 = sqrt_fp2_c3\n\n\/\/ Appendix G.3 asks for `c2` so that `c2^2 == u`, without saying how to get it.  If we find a\n\/\/ constant `k` in Fp with `k^^2 == -1\/2, then\n\/\/  (k*(u+1))^2 == k^2 * (u-1)^2 == (-1\/2) * (u^2 - 2*u + 1) = (-1\/2) * (-2*u) == u\n\/\/ and\n\/\/  (k*(u-1))^2 = (-1\/2)*(u^2 + 2*u + 1) == -u\n\/\/ We found this k (thanks to SageMath):\nsqrt_fp2_k: t_Fp\nsqrt_fp2_k = 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257\n\nsqrt_fp2_c2: t_Fp_2\nsqrt_fp2_c2 = [sqrt_fp2_k, Fp.neg sqrt_fp2_k]\n\nsqrt_fp2_c3: t_Fp_2\nsqrt_fp2_c3 = [sqrt_fp2_k, sqrt_fp2_k]\n\n\/\/ the C implementation of sqrt deviates from the above and uses the following defintion\nsqrt_align_fp2_coeff: t_Fp_2 -> t_Fp_2 -> t_Fp_2\nsqrt_align_fp2_coeff s inp =\n  if Fp_2.sq (Fp_2.mul(sqrt_fp2_c3, s)) == inp then sqrt_fp2_c3\n   | Fp_2.sq (Fp_2.mul(sqrt_fp2_c2, s)) == inp then sqrt_fp2_c2\n   | Fp_2.sq (Fp_2.mul(          u, s)) == inp then u\n  else Fp_2.field_unit\n\n\/\/ (a*u + b) inverse is (-a*u + b)\/(a^2+b^2), as can be checked by multiplying out\ninverse_fp2: t_Fp_2 -> t_Fp_2\ninverse_fp2 [a,b] = [Fp.div(Fp.neg a, c), Fp.div(b, c)] where\n    c = Fp.add (Fp.sq a, Fp.sq b)\n\n\/\/ Two ways to implement `is_square` for Fp_2 are offered\n\n\/\/is_square x =  F.is_equal (y, F.field_zero) \\\/ F.is_equal (y, F.field_unit) where\n\/\/    y = F_expt`{n = width q} F x `((q-1)\/2)\n\n\/\/ ... and Appendix G.5 of draft-irtf-cfrg-hash-to-curve\n\nis_square_fp2: t_Fp_2 -> Bool\nis_square_fp2 [x_2, x_1] = (tv1' != Fp_2.neg Fp_2.field_unit) where\n    \/\/ NB our representation of polynomnials is big-endian unlike the spec\n    tv1 = Fp.sq x_1\n    tv2 = Fp_2.sq [x_2, Fp.field_zero] \/\/ = Fp2_sq (Fp_2.mul (u, const_poly x_2))\n    tv1' = F_expt`{n=381} Fp_2 (Fp_2.sub ([Fp.field_zero, tv1], tv2)) ((`p-1)\/2)\n\nfp_exp: t_Fp -> Integer -> t_Fp\nfp_exp x e = if e < 0 then Fp.div (Fp.field_unit, fp_exp x (-e))\n              | e == 0 \/\\ x == Fp.field_zero then Fp.field_zero \/\/ needed for the alg. rules\n              | e == 0 then Fp.field_unit\n              else Fp.mul (x, fp_exp x (e-1))\n\nfp2_exp: t_Fp_2 -> Integer -> t_Fp_2\nfp2_exp x e = if e < 0 then Fp_2.div (Fp_2.field_unit, fp2_exp x (-e))\n              | e == 0 \/\\ x == Fp_2.field_zero then Fp_2.field_zero \/\/ needed for the alg. rules\n              | e == 0 then Fp_2.field_unit\n              else Fp_2.mul (x, fp2_exp x (e-1))\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/Parameters.cry","filetype":"cry","content":"\/\/ Parameters for the BLS12_381 signature, from draft-irtf-cfrg-pairing-friendly-curves-07\n\nmodule Parameters where\n\nimport Polynomial\nimport PrimeField\nimport ExtensionField\nimport ShortWeierstrassCurve\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Pairing-friendly curves, Section 4.2.2\n\/\/\n\n\/\/ t = -2^63 - 2^62 - 2^60 - 2^57 - 2^48 - 2^16\nt_signed_form: [64][2] \/\/ list of {-1,0,1}, used in ate pairing\n\/\/ here, just {-1, 0} used\nt_signed_form = [ [bit,bit] | bit <-  <| x^^63 + x^^62 + x^^60 + x^^57 + x^^48 + x^^16 |> ]\n\ntype p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\n\n\/\/ Choice of base representation for GF(p) is made here:\n\n\/\/ For the Integer version:\nFp = prime_field_integer `p\ntype t_Fp = Integer\n\nto_Fp: {n} (fin n, n <= 384) => [n] -> t_Fp\nto_Fp bits = toInteger (zext`{m=384} bits)\n\nfrom_Fp: t_Fp -> [384]\nfrom_Fp x = fromInteger x\n\n\/*\n\/\/ For the Z p version:\nFp = prime_field`{p}\ntype t_Fp = Z p\n\nto_Fp: {n} (fin n, n <= 384) => [n] -> t_Fp\nto_Fp bits = fromInteger (toInteger (zext`{m=384} bits))\n\nfrom_Fp: t_Fp -> [384]\nfrom_Fp x = fromInteger (fromZ x)\n*\/\n\n\/*\n\/\/ For the bivector version:\nFp = prime_field_bv`{384} `p  \/\/ representation of F_p\ntype t_Fp = [384]  \/\/ ... and the underlying Cryptol type\n\nto_Fp: {n} (fin n, n <= 384) => [n] -> t_Fp\nto_Fp bits = (zext bits) \/\/ mod something?\n\nfrom_Fp: t_Fp -> [384]\nfrom_Fp x = x\n*\/\n\n\/\/ Nothing else should need to change depending on the version of base representation chosen above.\n\n\n\/\/       F_p^2 = F_p[u] \/ (u^2 + 1)\nFp_2 = extension_field Fp [Fp.field_zero, Fp.neg Fp.field_unit] \/\/ [0,-1]\ntype t_Fp_2 = [2]t_Fp\n\n\/** u is the generator for F_p^2 over F_p *\/\nu: t_Fp_2\nu = poly_x Fp\n\nu_plus_1: t_Fp_2\nu_plus_1 = Fp_2.add (u, poly_1 Fp)\n\n\/**\n * Lift a value from F_p to F_p^2\n *\/\nFp_to_Fp_2: t_Fp -> t_Fp_2\nFp_to_Fp_2 = poly_const Fp\n\n\/\/       F_p^6 = F_p^2[v] \/ (v^3 - u - 1)\nFp_6 = extension_field Fp_2 [Fp_2.field_zero, Fp_2.field_zero, u_plus_1]\ntype t_Fp_6 = [3]t_Fp_2\n\n\/** v is the generator for F_p^6 over F_p^2 *\/\nv: t_Fp_6\nv = poly_x Fp_2\n\n\/**\n * Lift a value from F_p^2 to F_p^6\n *\/\nFp_2_to_Fp_6: t_Fp_2 -> t_Fp_6\nFp_2_to_Fp_6 = poly_const Fp_2\n\n\/**\n * Lift a value from F_p to F_p^6\n *\/\nFp_to_Fp_6: t_Fp -> t_Fp_6\nFp_to_Fp_6 x = Fp_2_to_Fp_6 (Fp_to_Fp_2 x)\n\n\/\/       F_p^12 = F_p^6[w] \/ (w^2 - v).\nFp_12 = extension_field Fp_6 [Fp_6.field_zero, v]\ntype t_Fp_12 = [2]t_Fp_6\n\n\/** w is the generator for F_p^12 over F_p^6 *\/\nw: t_Fp_12\nw = poly_x Fp_6\n\n\/**\n * Lift a value from F_p^6 to F_p^12\n *\/\nFp_6_to_Fp_12: t_Fp_6 -> t_Fp_12\nFp_6_to_Fp_12 = poly_const Fp_6\n\n\/**\n * Lift a value from F_p^2 to F_p^12\n *\/\nFp_2_to_Fp_12: t_Fp_2 -> t_Fp_12\nFp_2_to_Fp_12 x = Fp_6_to_Fp_12 (Fp_2_to_Fp_6 x)\n\n\/**\n * Lift a value from F_p to F_p^12\n *\/\nFp_to_Fp_12: t_Fp -> t_Fp_12\nFp_to_Fp_12 x = Fp_2_to_Fp_12 (Fp_to_Fp_2 x)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Pairing-friendly curves, Section 2.5, representation convention\n\/\/\n\n\/\/ Given function f: t -> octets, then we just concatenate the octet streams, starting with the\n\/\/ constant coefficient\nprivate\n  poly_to_octets: {t,k,n} (fin k, fin n) => (t->[n*8]) -> [k]t -> [k*n*8]\n  poly_to_octets f p = join (map f (reverse p))\n\nFp_to_octets: t_Fp -> [48*8] \/\/ big endian\nFp_to_octets = from_Fp\n\nFp_12_to_octets: t_Fp_12 -> [12*48*8]\nFp_12_to_octets = poly_to_octets (poly_to_octets (poly_to_octets Fp_to_octets))\n\nprivate\n  octets_to_poly: {t,k,n} (fin k, fin n) => ([n*8]->t) -> [k*n*8] -> [k]t\n  octets_to_poly f octets = map f (reverse (split octets))\n\noctets_to_Fp: [48*8] -> t_Fp\noctets_to_Fp octets = to_Fp octets octets_to_Fp_2: [2*48*8] -> t_Fp_2\noctets_to_Fp_2 = (octets_to_poly`{k=2} octets_to_Fp)\n\noctets_to_Fp_12: [12*48*8] -> t_Fp_12\noctets_to_Fp_12 = octets_to_poly`{k=2} (octets_to_poly`{k=3} (octets_to_poly`{k=2} octets_to_Fp))\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ parameters for a base point on the main curve, Section 4.2.1\n\/\/\n\nr = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\n\nBP_x = octets_to_Fp 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\n\nBP_y = octets_to_Fp 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1\n\nh = 0x396c8c005555e1568c00aaab0000aaab\n\nBP = (BP_x, BP_y)\n\nb: t_Fp\nb = 4\n\nE: EllipticCurve t_Fp\nE = {base_field = Fp, a = Fp.field_zero, b = b}\n\nr' =  0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\n\nx'_0 = octets_to_Fp 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\n\nx'_1 =  octets_to_Fp 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e\n\ny'_0 = octets_to_Fp 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801\n\ny'_1 = octets_to_Fp 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be\n\nh' = 0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\n\nBP_x' = [x'_1, x'_0]\nBP_y' = [y'_1, y'_0]\n\nBP' = (BP_x', BP_y')\n\nb': t_Fp_2\nb' = [4,4]  \/\/ 4(u+1)\n\nE': EllipticCurve t_Fp_2\nE' = {base_field = Fp_2, a = Fp_2.field_zero, b = b'}\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/Maybe.cry","filetype":"cry","content":"\/*\nSimilar to Haskell's Maybe type, this gives a way to have optional values.\n\nA value of type `Maybe t` is meant to be either `nothing`, or `just x`\nfor some x:t.  There is no way to properly define this type in\nCryptol; the type definition here allows for some undesired values to\nexist in `Maybe t`.  Function `is_maybe` recognizes the proper values.\n\nFunction `maybe` allows for case analysis.\n\nFunction `maybe_map` allows a function to be applied \"inside\" the\nMaybe wrapper.\n*\/\n\nmodule Maybe where\n\ntype Maybe a = (Bool, a)\n\n\/** The `no data` value in a Maybe type. *\/\nnothing: {a} (Zero a) => Maybe a\nnothing = (False, zero)\n\n\/** Inject a value of type `a` into `Maybe a`. *\/\njust: {a} a -> Maybe a\njust x = (True, x)\n\n\/** Case analysis of a value of `Maybe` type.\n    maybe v f nothing  == v\n    maybe v f (just x) == f x\n *\/\nmaybe: {a,b} b -> (a -> b) -> Maybe a -> b\nmaybe c_nothing c_just (b, x) = if b then c_just x else c_nothing\n\n\/** Case analysis of a value of `Maybe` type, alternative order of arguments.\n    maybe_cases nothing  v f  == v\n    maybe_cases (just x) v f  == f x\n *\/\nmaybe_cases: {a,b} Maybe a -> b -> (a -> b) -> b\nmaybe_cases (b, x) c_nothing c_just = if b then c_just x else c_nothing\n\n\/** Apply a function to the contained value if present, in a `Maybe` type.\n    maybe_map f nothing == nothing\n    maybe_map f (just x) == just (f x)\n*\/\nmaybe_map: {a,b} (Zero b) => (a -> b) -> Maybe a -> Maybe b\nmaybe_map f = maybe nothing (\\v -> just (f v))\n\n\/** Recognizer for proper `Maybe` values *\/\nis_maybe: {a} (Cmp a, Zero a) => Maybe a -> Bool\nis_maybe (b,x) = (b \\\/ x==zero) \/\/ b==False ==> x==zero\n\nprivate\n        property distinct (x:[2]) = nothing != just x\n    property injective (x:[2]) y = (just x == just y) == (x == y)\n\n    property recognize_nothing = is_maybe`{[5]} nothing\n    property recognize_just x = is_maybe`{([2],[2])} (just x)\n\n    property no_junk x = is_maybe`{[3]} x ==> x == (maybe nothing just) x\n    property no_junk' x = is_maybe`{[3]} x ==> x == maybe_cases x nothing just\n\n    property map_id x = is_maybe`{([2],Bit)} x ==> x == maybe_map (\\y->y) x\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/BLSMinimalSignatureSize.cry","filetype":"cry","content":"module BLSMinimalSignatureSize = BLSGeneric where\n\n\/\/ Suite BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_, as defined in\n\/\/ draft-irtf-cfrg-bls-signature-04, Secton 4.2.1 and Appendix A\n\nimport Parameters\nimport HashToCurveE1\nimport Pairing (bls_ate_pairing)\nimport Serialization\nimport ShortWeierstrassCurve as EC\n\n\/\/ a pairing-friendly elliptic curve\ntype t_F = t_Fp \/\/ representation type for field of the primary curve (signature)\ntype t_F' = t_Fp_2 \/\/ representation type for field of the secondary curve (pubkey)\ntype t_G = t_Fp_12  \/\/ representation type for field of the pairing result\nG = Fp_12\n\ntype pubkey_len = 96*8\ntype signature_len  = 48*8\n\nmain_curve = E\nother_curve = E'\n\n\/\/ hash_to_point  BLS12381G1_XMD:SHA-256_SSWU_RO_\n\/\/ type DST_len = 43\n\nDST: [43][8]\nDST = \"BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_\"\n\nhash_to_point hx = hash_to_curve_opt (hx, DST)\n\n\/\/ other primitives \"determined by the above parameters\"\n\nP: EC::AffinePoint t_F' \/\/ base point\nP = BP'\n\n\/\/ pairing: (EC::AffinePoint t_F, EC::AffinePoint t_F') -> t_G\npairing (p,q) = bls_ate_pairing p q \/\/ Section 2.2\n\n\/\/ point_to_pubkey: EC::AffinePoint t_F' -> [pubkey_len]\n\/\/ point_to_pubkey = point_to_octets_E2 \/\/ Section 2.2 BUT\n\/\/    draft-irtf-cfrg-pairing-friendly-curves-07 does not mention\n\/\/    a function of this name.  So:\npoint_to_pubkey S = join (serialize_E2 S)\n\n\/\/ point_to_signature: EC::AffinePoint t_F -> [signature_len]\n\/\/point_to_signature = point_to_octets_E1 \/\/ Section 2.2\npoint_to_signature S = join (serialize_E1 S)\n\n\/\/ pubkey_to_point: [pubkey_len] -> Maybe (EC::AffinePoint t_F') \/\/ can fail\n\/\/ pubkey_len = 768\n\/\/ deserialize_E2: [96][8] -> Maybe (EC::AffinePoint t_Fp_2)\npubkey_to_point S = deserialize_E2 (split S)\n\n\/\/ signature_to_point: [signature_len] -> Maybe (EC::AffinePoint t_F) \/\/ can fail\n\/\/ signature_to_point = octets_to_point_E1\n\/\/ TODO: Was deserialize_E1, but types didn't line up with the expected\n\/\/ signature length\nsignature_to_point S = uncompress_E1 (split S)\n\n\/\/ Here are the unoptimized versions of the subgroup check\n\n\/\/ pubkey_subgroup_check: EC::AffinePoint t_F' -> Bool\npubkey_subgroup_check S =\n    EC::is_point_O E' (EC::mult E' r S)\n\n\/\/ signature_subgroup_check: EC::AffinePoint t_F -> Bool\n\/\/ ... more efficient versions are allowed.\nsignature_subgroup_check S =\n    EC::is_point_O E (EC::mult E r S)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/BulkAddition.cry","filetype":"cry","content":"import Common::Field\nimport FieldExtras\nimport ShortWeierstrassCurve\nimport PrimeField import implementation::CurveOperation\n\n\/\/ Test setup\n\nF37 = prime_field`{37}\nC1: EllipticCurve (Z 37)\nC1 = { base_field= F37, a = 0, b = 4 }\n\n\/\/ C1, like the BLS curves E and E', has no rational points with y==0.\n\np1: AffinePoint (Z 37)\np1 = (2,7) \/\/ was (1,6), for F31\n\/\/ p1 generates the 39-element group of rational points\n\np2: AffinePoint (Z 37)\np2 = (16,20) \/\/ was (5,6)\n\/\/ p2 = 10*p1\n\nq1: AffinePoint (Z 37)\nq1 = (24, 29) \/\/ q1 generates a group of 13 elements, not including (0,2)\n\n\/\/ ... also with a representation with junk elements\nF37' = prime_field_bv`{6} 37\nC1': EllipticCurve [6]\nC1' = { base_field= F37', a = 0, b = 4 }\n\np1': AffinePoint [6]\np1' = (2,7)\n\np2': AffinePoint [6]\np2' = (16,20)\n\nq1': AffinePoint [6]\nq1' = (24,29)\n\n\/\/ end test setup\n\n\/* Montgomery's trick allows the calculation of the inverses of several\n   field values while only computing one inverse.\n\n   The basic idea, for two values a and b, is to compute (ab)^(-1), then we get\n   a^(-1) = b*(ab)^{-1}   and   b^(-1) = a*(ab)^{-1}\n\n  for 4 values, it works like this.\n  1. From [a,b,c,d], we form the products [a, ab, abc, abcd]\n  2. Compute (abcd)^(-1)\n  3. Get [a^(-1), (ab)^(-1), (abc)^(-1), (abcd)^(-1)] by starting with the last\n     value, and getting each earlier value by a multiplication\n  4. Get [a^(-1),  b^(-1), c^(-1), d^(-1)] by multiplication with the\n     appropriate products, e.g. c^(-1) = (ab) * (abc)^(-1)\n\n If any of the input values is 0, the whole thing fails.\n*\/\n\ninverses: {n, t} (fin n, n >= 1) => FieldRep t -> [n]t -> [n]t\ninverses F xs = results where\n  products = [xs@0] # [F.mul (p, x) | p <- products | x <- tail xs ]\n  \/\/ products@i == product (take`{i} xs)\n  iprods = [F.mul (x, i) | i <- tail`{n-1} iprods | x <- tail xs]\n           # [F.div(F.field_unit, products!0) ]\n  \/\/ iprods@i == xs@(i+1) * iprods@(i+1) == inverse (products@i)\n  results = [iprods@0] # [F.mul(p, i) | p <- products | i <- tail iprods]\n  \/\/ results@i == products@(i-1) * iprods@i == inverse (xs@i)\n\n\/\/ correctness property\ninverse_functionality: {n, t} (fin n, n >= 1, Eq t) => FieldRep t -> [n]t -> Bool\ninverse_functionality F xs =\n  (mem F.field_zero (map F.normalize xs)) \\\/ test_inverses F xs == map (\\ x -> F.field_unit) xs\n  where\n    mem i xs' = (map ((==) i) xs') != zero\n    test_inverses F' xs' = [F'.mul(x,i) | x <- xs' | i <- inverses F' xs']\n\neq_F : {t} (Eq t) => FieldRep t -> t -> t -> Bool\neq_F F x y = F.normalize x == F.normalize y\n\nbulk_addition_head_imp: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t) -> t -> ((t,t,t), (t,t,t))\nbulk_addition_head_imp F A B mul_acc = ((ax_1, ay_1, az_2), (bx_1, by_1, bz_2)) where\n  x1 = F.normalize A.0\n  y1 = F.normalize A.1\n  x2 = F.normalize B.0\n  y2 = F.normalize B.1\n  inf = (eq_F F x1 F.field_zero \/\\ eq_F F y1 F.field_zero) \\\/ (eq_F F x2 F.field_zero \/\\ eq_F F y2 F.field_zero)\n  bz = F.sub (x2, x1)\n  bx = F.add (x2, x1)\n  az = F.add (y2, y1)\n  by_0 = F.sub (y2, y1)\n\n  cond = eq_F F bz F.field_zero \/\/ if test, x2 == x1\n  inf_1 = if cond then eq_F F az F.field_zero else inf\n  bx_1 = if cond then if inf_1 then az else bx else bx\n  by_1 = if cond then mul_by_3 F (F.sq x1) else by_0\n  bz_1 = if cond then az else bz\n\n  ax_1 = if inf_1 then bx_1 else x1\n  ay_1 = if inf_1 then az else y1\n  az_1 = if inf_1 then F.field_unit else bz_1\n  bz_2 = if inf_1 then F.field_zero else bz_1\n  az_2 = F.mul (az_1, mul_acc)\n\n\/\/ The HEAD function computes half of point addition, up to the point that\n\/\/ an inverse is needed.  See comments in `bulk_addition.c` for a description of the\n\/\/ 6 elements of the result.  Those comments suggest this function:\n\nbulk_addition_head: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t) -> t -> ((t,t,t), (t,t,t))\nbulk_addition_head F A B mul_acc = (bulk_addition_head_a F A B mul_acc,  bulk_addition_head_b F A B)\n\nbulk_addition_head_a: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t) -> t -> (t,t,t)\nbulk_addition_head_a F (x1,y1) (x2,y2) mul_acc =\n  if x1 == x2 \/\\ y1 == y2\n  then (x1, y1, mul_by_2 F (F.mul (y1, mul_acc)))\n  else if x1 == x2 \/\\ y1 == F.neg(y2)\n  then (F.field_zero, F.field_zero, mul_acc)\n  else (x1, y1, (F.mul (F.sub (x2, x1), mul_acc)))\n\nbulk_addition_head_b: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t) -> (t,t,t)\nbulk_addition_head_b F (x1,y1) (x2,y2) =\n  if x1 == x2 \/\\ y1 == y2\n  then (mul_by_2 F x1, mul_by_3 F (F.sq x1), mul_by_2 F y1)\n  else if x1 == x2 \/\\ y1 == F.neg(y2)\n  then (F.field_zero, mul_by_3 F (F.sq x1), F.field_zero)\n  else (F.add (x2, x1), F.sub(y2, y1), F.sub (x2, x1))\n\/\/ ... however, this disagrees with the code, which handles (0,0) specially (as it must)\n\n\/\/ TAIL produces two results, D and B->Z\n\nbulk_addition_tail: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t,t) -> t -> (t,t)\nbulk_addition_tail F A B lam = if eq_F F b_z F.field_zero then (a_x, a_y) else (d_x, d_y)\n  where\n    a_x = F.normalize A.0\n    a_y = F.normalize A.1\n    b_x = F.normalize B.0\n    b_y = F.normalize B.1\n    b_z = F.normalize B.2\n    lam' = F.mul(lam, b_y)\n    llam = F.sq lam'\n    d_x = F.sub (llam, b_x)\n    d_y = F.sub (F.mul(F.sub(a_x, d_x), lam'), a_y)\n\n\/\/ the B->Z result does not depend on A or lambda\nbulk_addition_tail_bz: {t} (Eq t) => FieldRep t -> t -> t\nbulk_addition_tail_bz F b_z =\n    if eq_F F b_z F.field_zero then F.field_unit else (F.normalize b_z)\n\n\/\/ TODO: semi-correctness: head, inverse, tail give the correct addition formula.\n\n\/\/ NOTE: in the A==B case, must know that y != 0, i.e., there are no\n\/\/ points (x,0) on the curve.  given the equation y^2 = x^3 + 4 for E,\n\/\/ that's saying that -4 is not a cube (which is true); given the\n\/\/ equation y^2 = x^3+4(u+1) for E', it says that -4(u+1) is not a\n\/\/ cube.  This is also true.  Both assertions are easily checked; when q-1 is divisible by 3,\n\/\/ then if x is a cube modulo q we have  x^((q-1)\/\/3) = 1.  Both p and p^2\n\/\/ are 1 more than a multiple of 3.\n\n\/\/ Now if (ax,ay,az), (bx,by_0,bz) = bulk_addition_head F a b m\n\/\/ and lam = inverse F bz\n\/\/ and c = bulk_addition_tail F (ax,ay) (bx,by_0,bz) lam\n\/\/ then c == add C a b\n\nhead_inverse_tail: {t} (Eq t) => EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\nhead_inverse_tail C a b = c where\n          F = C.base_field\n          ((ax,ay,az), (bx,by_0,bz)) = bulk_addition_head F a b F.field_unit\n          lam = F.div (F.field_unit, az)\n          c = bulk_addition_tail F (ax,ay) (bx,by_0,bz) lam\n\n\/\/ corrected version:\nhead_inverse_tail': {t} (Eq t) => EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\nhead_inverse_tail' C a b = c where\n          F = C.base_field\n          ((ax,ay,az), (bx,by_0,bz)) = bulk_addition_head_imp F a b F.field_unit\n          lam = if az == F.field_zero then F.field_unit else F.div (F.field_unit, az)\n          c = bulk_addition_tail F (ax,ay) (bx,by_0,bz) lam\n\ntype BulkAdditionStuff t =\n  { field : FieldRep t\n  , bulk_addition_head_fn : (t,t) -> (t,t) -> t -> ((t,t,t), (t,t,t))\n  , bulk_addition_tail_fn : (t,t) -> (t,t,t) -> t -> (t,t)\n  , bulk_addition_tail_bz_fn : t -> t\n  , point_dadd_affine_fn : ProjectivePoint t -> AffinePoint t  -> ProjectivePoint t\n  }\n\n\/\/ The accumulate function starts with while loop that halves the length\n\/\/ of the array at each iteration.  Inside that loop are  two other loops, first\n\/\/ calling HEAD on pairs of points, the second calling TAIL, and with some plumbing\n\/\/ for the Montgomery trick.\n\/\/\n\/\/ Following that is a simple loop for fewer than 16 points, that just adds them.\n\n\ncoerceSize : {m,n,a} (fin n, fin m) => [m]a -> [n]a\ncoerceSize xs = assert (`m == `n) \"coerceSize: size mismatch\" [ xs@i | i <- [0..<n] ]\n\natLeastOne: {n,a} [n]a -> [max 1 n]a\natLeastOne xs = (drop`{min 1 n} ([undefined] # xs))\n\n\/*\nbulk_accumulate_0: {n, t} (fin n) => EllipticCurve t -> (t,t) -> [n] (t,t)  -> (t,t)\nbulk_accumulate_0 C sum' points =\n  if `n < 16\n  then bulk_accumulate_small C sum' points\n  else if (`n%2) == 1\n  \/\/ then bulk_accumulate_even`{n\/2} C (add C sum' (points@0)) (take (tail (points # junk)))\n  then bulk_accumulate_even_0`{n\/2} C (add C sum' (points@0)) (tail (coerceSize points))\n  \/\/ else bulk_accumulate_even`{n\/2} C sum' (take points)\n  else bulk_accumulate_even_0`{n\/2} C sum' (coerceSize points)\n  \/\/ where junk = [ point_O C ] # junk\n*\/\n\nbulk_accumulate: {n, t} (fin n, Eq t) => BulkAdditionStuff t -> (t,t,t) -> [n] (t,t)  -> (t,t,t)\nbulk_accumulate C sum' points =\n  if `n < 16\n  then bulk_accumulate_small C sum' points\n  else if (`n%2) == 1\n  then bulk_accumulate`{n\/2} C (C.point_dadd_affine_fn sum' (points@0)) (bulk_accumulate_even`{n\/2} C (tail (coerceSize points)))\n  else bulk_accumulate`{n\/2} C sum' (bulk_accumulate_even`{n\/2} C (coerceSize points))\n\nbulk_accumulate_small: {n, t} (fin n) => BulkAdditionStuff t -> (t,t,t) -> [n] (t,t)  -> (t,t,t)\nbulk_accumulate_small C sum' points = sums!0 where\n  sums = [sum'] # [C.point_dadd_affine_fn x p | x <- sums | p <- points]\n\nbulk_accumulate_even_0: {n, t} (fin n) => EllipticCurve t -> (t,t) -> [2*n] (t,t)  -> (t,t)\nbulk_accumulate_even_0 C sum' points = undefined\n\nbulk_accumulate_even: {n, t} (fin n, Eq t) => BulkAdditionStuff t -> [2*n] (t,t)  -> [n](t,t)\nbulk_accumulate_even C points = dst where\n  points':  [n] ((t,t,t), (t,t,t))\n  points' = bulk_accumulate_loop_1 C points\n  \/\/ the Montgomery trick part\n  last_pair: ((t,t,t), (t,t,t))\n  \/\/last_pair = ([(z,z)] # points')!0 \/\/ type checker does not know n >= 1\n  \/\/z = (z0,z0,z0) \/\/ : (t,t,t)\n  \/\/z0 = C.base_field.field_zero \/\/ : t\n  last_pair = points'!0\n  last_inv = C.field.div (C.field.field_unit, last_pair.0.2)\n  dst = bulk_accumulate_loop_2 C points' last_inv\n\n\/\/ First loop: run adjacent pairs through the HEAD function\n\/\/ this results in an accumulated product in the .Z fields of the even-numbered points\n\/\/ (The \"a\"s in the a\/b splitting), and individual denominator values in the Z fields\n\/\/ of the odd-numbered points.\n\/\/ The c code modifies the points array in place, effectively resulting in a [2*n] (t,t,t)\nbulk_accumulate_loop_1: {n, t} (fin n, Eq t) => BulkAdditionStuff t -> [2*n] (t,t)  -> [n] ((t,t,t), (t,t,t))\nbulk_accumulate_loop_1 C points = points' where\n  points' = [C.bulk_addition_head_fn a b mul_ac | [a,b] <- split points | mul_ac <- mul_acs]\n  mul_acs = [C.field.field_unit] # [ma | ((_,_,ma), _) <- points' ]\n\n\/\/ second loop ` for (dst = points, i = n; --i;) ...`\n\/\/  runs reversed through the points array.  There are two effects:\n\/\/ one is the Montgomery inverse calculation, using the z fields of the\n\/\/ \"b\" points, the other using these inverses in the TAIL part of the\n\/\/ point addition. We use \n\nbulk_accumulate_loop_2: {n, t} (fin n, Eq t) => BulkAdditionStuff t -> [n] ((t,t,t),(t,t,t))  -> t -> [n](t,t)\nbulk_accumulate_loop_2 C point_pairs last_inv = dst where\n    dst = [C.bulk_addition_tail_fn (ax,ay) b i | ((ax,ay,az),b) <- point_pairs | i <- inverses']\n  inverses': [max 1 n] t\n    products = [az | ((_,_,az),_) <- point_pairs]\n  xs = [bz | (_,(_,_,bz)) <- point_pairs]\n  iprods: [max 1 n] t\n  iprods = [C.field.mul (i, C.bulk_addition_tail_bz_fn x) | i <- tail iprods | x <- tail (atLeastOne xs)]\n           # [C.field.div(C.field.field_unit, products!0) ]\n  \/\/ iprods@i == xs@(i+1) * iprods@(i+1) == inverse (products@i)\n  inverses' = [iprods@0] # [C.field.mul(i, p) | i <- tail iprods | p <- products]\n  \/\/ inverses'@i == products@(i-1) * iprods@i == inverse (xs@i)\n\nbulk_accumulate_inverses: {n, t} (fin n, Eq t) => FieldRep t -> [n] ((t,t,t),(t,t,t))  -> t -> [_]t\nbulk_accumulate_inverses F point_pairs last_inv = inverses' where\n  inverses': [max 1 n] t\n    products = [az | ((_,_,az),_) <- point_pairs]\n  xs = [bz | (_,(_,_,bz)) <- point_pairs]\n  iprods: [max 1 n] t\n  iprods = [F.mul (x, i) | i <- tail iprods | x <- tail (atLeastOne xs)]\n           # [F.div(F.field_unit, products!0) ]\n  \/\/ iprods@i == xs@(i+1) * iprods@(i+1) == inverse (products@i)\n  inverses' = [iprods@0] # [F.mul(p, i) | p <- products | i <- tail iprods]\n  \/\/ inverses'@i == products@(i-1) * iprods@i == inverse (xs@i)\n\nbulk_add : {m, n, t} (fin m, fin n, Eq t) => BulkAdditionStuff t -> (t, t, t) -> [n](t, t) -> (t, t, t)\nbulk_add C sum_acc points = if `n == 0\n  then sum_acc\n  else bulk_add`{m} C (bulk_accumulate C sum_acc (take`{min m n} points)) (drop`{min m n} points)\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/Frobenius.cry","filetype":"cry","content":"\/* Frobenius and related functions on the BLS fields. *\/\n\nmodule Frobenius where\n\nimport Parameters as P\nimport FieldExtras\n\ntype t1 = P::t_Fp\ntype t2 = P::t_Fp_2\ntype t6 = P::t_Fp_6\ntype t12 = P::t_Fp_12 \n\nf1 = P::Fp\nf2 = P::Fp_2\nf6 = P::Fp_6\nf12 = P::Fp_12\n\n\/\/ F_p2\n\nfp2_conjugate: t2 -> t2\nfp2_conjugate [a,b] = [f1.neg a, b] \/\/ a*u + b -> -a*u + b\n\nfp2_frobenius: t2  -> t2\nfp2_frobenius x = fp2_conjugate x\n\n\/\/ F_p6\n\n\/\/ We have f6 = f2(v) where v^3 = (u+1).\n\/\/ Then v^p = v^(3 ((p-1)\/3)) * v = (u+1)^((p-1)\/3) * v\n\nv_frobenius_constant: t2\nv_frobenius_constant = F_expt`{n=381} f2 P::u_plus_1 `((P::p-1)\/3)\n\nv_frobenius_constant_sq: t2\nv_frobenius_constant_sq = f2.sq v_frobenius_constant\n\n\/\/ Now (av^2+bv+c)^p = a^p k^2 v^2 + b^p k v + c^p\n\nfp6_frobenius: t6 -> t6\nfp6_frobenius [a,b,c] = [a',b',c'] where\n    a' = f2.mul (v_frobenius_constant_sq, fp2_frobenius a)\n    b' = f2.mul (v_frobenius_constant, fp2_frobenius b)\n    c' = fp2_frobenius c\n\n\/\/ F_p12\n\n\/\/ We have f12 = f6(w) where w^2 = v so w^6 = (u+1)\n\/\/ thus w^p = w^(6 ((p-1)\/6)) * w = (u+1)^((p-1)\/6) * w\n\nw_frobenius_constant: t6\nw_frobenius_constant = P::Fp_2_to_Fp_6 (F_expt`{n=381} f2 P::u_plus_1 `((P::p-1)\/6))\n\nfp12_frobenius: t12 -> t12\nfp12_frobenius [a,b] = [a', b'] where\n    a' = f6.mul (w_frobenius_constant, fp6_frobenius a)\n    b' = fp6_frobenius b\n\n\/\/ The conjugate in F_p12 also gives x^(p^6), the six-fold Frobenius\n\nfp12_conjugate: t12 -> t12\nfp12_conjugate [a,b] = [f6.neg a, b] \/\/ a*w + b -> -a*w + b\n","variant":"hybrid","set":"supervised"}
{"filename":"BLST-Verification\/spec\/implementation\/CoreVerifyPKInG1.cry","filetype":"cry","content":"module implementation::CoreVerifyPKInG1 where\n\nimport Parameters (Fp_12, t_Fp, t_Fp_2, BP, E')\nimport ShortWeierstrassCurve (AffinePoint, affinify)\nimport implementation::PairingImpl (miller_loop_opt)\nimport implementation::HashToG2 (hash_to_curve_E2_opt_impl)\nimport implementation::FinalExp (final_exponentiation_impl)\nimport implementation::PairingImpl (miller_loop_opt_checked)\nimport ExpandMessage\nimport Frobenius (fp12_conjugate)\nimport HashToCurveE2\n\ncore_verify_pk_in_g1_impl : {msg_len,dst_len,aug_len}\n  (fin msg_len, fin dst_len, fin aug_len\n  , Expandable (msg_len+aug_len) dst_len\n  , dst_len <= 255) =>\n  AffinePoint t_Fp -> AffinePoint t_Fp_2 -> [msg_len][8] -> [dst_len][8] -> [aug_len][8] -> Bool\n\ncore_verify_pk_in_g1_impl pk sig msg dst aug = Fp_12.is_equal(gt, Fp_12.field_unit) where\n    Q = affinify E' (hash_to_curve_E2_opt_impl (aug#msg, dst))\n    gtPQ = miller_loop_opt_checked pk Q\n    gtSig = fp12_conjugate (miller_loop_opt_checked BP sig)\n    gt = final_exponentiation_impl (Fp_12.mul (gtSig, gtPQ))\n\n\/* core_verify_pk_in_g1 : {msg_len,dst_len,aug_len} *\/\n  \/* (fin msg_len, fin dst_len, fin aug_len *\/\n  \/* , Expandable (msg_len+aug_len) dst_len *\/\n  \/* , dst_len <= 255) => *\/\n  \/* AffinePoint t_Fp -> AffinePoint t_Fp_2 -> [msg_len][8] -> [dst_len][8] -> [aug_len][8] -> Bool *\/\n\n\/* core_verify_pk_in_g1 pk sig msg dst aug = Fp_12.is_equal(c1, c2) where *\/\n    \/* c1 = bls_ate_pairing pk (hash_to_curve (aug#msg, dst)) *\/\n    \/* c2 = bls_ate_pairing BP sig *\/\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/SerializationP2.cry","filetype":"cry","content":"module implementation::SerializationP2 where\n\nimport Parameters (p, E, E', t_Fp, to_Fp, t_Fp_2, Fp, Fp_2)\nimport ShortWeierstrassCurve as EC\nimport rfc8017\nimport Maybe\nimport FieldExtras (F_expt)\nimport BLSFieldExtras\nimport Serialization\nimport implementation::Types\nimport implementation::Field\n\n\/\/ deserialization of compressed representations for curve E2 (aka E').\n\/\/ From draft-irtf-cfrg-pairing-friendly-curves-07, Appendix C.2\n\nuncompress_E2_x: [96][8] -> [2][384]\nuncompress_E2_x s_string = x where\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    \/\/ Step 6 - but not clearly described in the IETF specification\n    \/\/ AND - some uncertainty about the order of the parts\n    \/\/ x = reverse (split`{parts=2} (join s_string'))\n    \/\/ NOTE: this order, used in ZCash and the code, disagrees with the spec.\n    x = split`{parts=2} (join s_string')\n\nuncompress_E2_x_fp: [96][8] -> t_Fp_2\nuncompress_E2_x_fp s_string = [f x0, f x1] where\n    [x0, x1] = uncompress_E2_x s_string\n    f x = Fp.mul (fp_abs (vec384_rep x), montgomery_factor_p) \/\/ Montgomery-encode using multiplication\n\nnot_too_big_E2: [2][384] -> Bool\nnot_too_big_E2 x = (x@0 < `p) \/\\ (x@1 < `p)\n\nuncompress_E2_y2: [96][8] -> t_Fp_2\nuncompress_E2_y2 s_string = y2 where\n    x = uncompress_E2_x_fp s_string\n    y2 = Fp_2.add (Fp_2.mul (Fp_2.sq x, x), [4,4]) \/\/ Note [4,4] = 4*u\n\nuncompress_E2_y: [96][8] -> t_Fp_2\nuncompress_E2_y s_string = sqrt_fp2 (uncompress_E2_y2 s_string)\n\nuncompress_E2_imp: [96][8] -> Maybe (EC::AffinePoint t_Fp_2)\nuncompress_E2_imp s_string = ret where\n    \/\/ Step 1.\n    m_byte = (s_string@0) && 0xE0 \/\/ three highest bits\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    x = uncompress_E2_x_fp s_string\n    y2 = uncompress_E2_y2 s_string\n    y = sqrt_fp2 y2\n    Y_bit = sign_F_p_2 y\n    ret = if C_bit == False then nothing \/\/ Error, from Step 2\n           | I_bit then (if ~S_bit \/\\ s_string' == zero then just (EC::point_O E') else nothing)\n           | ~ (not_too_big_E2 (uncompress_E2_x s_string)) then nothing \/\/ extra checks in the C code\n           | ~ (is_square_fp2 y2) then nothing \/\/ from Step 7\n           | S_bit == Y_bit then just (x,y)\n          else just (x, Fp_2.neg y)\n\n\nuncompress_E2_OK: [96][8] -> EC::AffinePoint t_Fp_2\nuncompress_E2_OK s_string = if S_bit == Y_bit then (x,y) else (x, Fp_2.neg y) where\n    x = uncompress_E2_x_fp s_string\n    y = uncompress_E2_y s_string\n    S_bit = (s_string@0)@2\n    Y_bit = sign_F_p_2 y\n\n\/\/ deserialization of uncompressed representations\n\ndeserialize_E2_x: [2*96][8] -> [2][384]\ndeserialize_E2_x s_string = x where\n    s_string' = take`{96} ([(s_string@0) && 0x1F] # tail s_string)\n    x = reverse (split`{parts=2} (join s_string'))\n\n\/\/deserialize_E2_x_fp: [96][8] -> t_Fp_2\n\/\/deserialize_E2_x_fp s_string =\n\/\/    Fp.mul (fp_abs (vec384_rep (deserialize_E2_x s_string)), montgomery_factor_p)\n\ndeserialize_E2_y: [2*96][8] -> [2][384]\ndeserialize_E2_y s_string = reverse (split (join (drop`{96} s_string)))\n\n\/\/deserialize_E2_y_fp: [96][8] -> t_Fp_2\n\/\/deserialize_E2_y_fp s_string =\n\/\/    Fp.mul (fp_abs (vec384_rep (deserialize_E2_y s_string)), montgomery_factor_p)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/Fp12.cry","filetype":"cry","content":"\/\/\n\/\/ Definitions for fp12_tower.c and the proofs in fp12.saw\n\/\/\n\nmodule implementation::Fp12 where\n\nimport Common::Field\nimport FieldExtras\nimport ExtensionField\nimport implementation::Types\nimport implementation::Field\nimport Parameters (p, Fp, t_Fp, to_Fp, from_Fp, t_Fp_2, Fp_2, t_Fp_6, Fp_6, t_Fp_12, Fp_12,\n                   u_plus_1, Fp_2_to_Fp_6)\nimport Frobenius\nimport PrimeField import ExtensionField\nimport Polynomial\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Frobenius_map\n\n\/\/ \"nest\" is just used to simplify the writing of the postcondition for the\n\/\/ frobenius_map functions.  However, there is a simpler way, which is used for\n\/\/ frobenius_map_fp12.\nnest f x (n:[64]) =\n    if n==0 then x\n     | n == 1 then f x\n     | n == 2 then f (f x)\n    else f (f (f x))\n\n\n\/\/ constants for the various Frobenius maps\nrep_v_frobenius_constant = \/\/ fp2_rep v_frobenius_constant\n    [[0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000],\n     [0xcd03c9e48671f071, 0x5dab22461fcda5d2, 0x587042afd3851b95,\n      0x8eb60ebe01bacb9e, 0x03f97d6e83d050d2, 0x18f0206554638741]]\n\nrep_v_frobenius_constant_sq =  \/\/ fp2_rep v_frobenius_constant_sq\n    [[0x890dc9e4867545c3, 0x2af322533285a5d5, 0x50880866309b7e2c,\n      0xa20d1b8c7e881024, 0x14e4f04fe2db9068, 0x14e56d3f1564853a],\n     [0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000]]\n\nrep_v_frobenius_constant_sq_const_part =  \/\/ fp_rep (v_frobenius_constant!0)\n    [0x890dc9e4867545c3, 0x2af322533285a5d5, 0x50880866309b7e2c,\n     0xa20d1b8c7e881024, 0x14e4f04fe2db9068, 0x14e56d3f1564853a]\n\n\/\/ w_frobenius_constant has the form [0,0,c], so we can multiply easily using fp2_mul,\n\/\/ and do not need to store all the zeros\nrep_w_frobenius_constant_const_part = \/\/ fp2_rep (w_frobenius_constant!0)\n    [[0x07089552b319d465, 0xc6695f92b50a8313, 0x97e83cccd117228f,\n      0xa35baecab2dc29ee, 0x1ce393ea5daace4d, 0x08f2220fb0fb66eb],\n     [0xb2f66aad4ce5d646, 0x5842a06bfc497cec, 0xcf4895d42599d394,\n      0xc11b9cba40a8e8d0, 0x2e3813cbe5a0de89, 0x110eefda88847faf]]\n\n\/\/ The double Frobenius for fp6 and fp12 have similar formulas to the single\nv_frobenius_constant_2 = F_expt`{n=762} f2 u_plus_1 `((p*p-1)\/3)\nv_frobenius_constant_2_sq = Fp_2.sq v_frobenius_constant_2\n\nw_frobenius_constant_2_part = F_expt`{n=762} f2 u_plus_1 `((p*p-1)\/6)\n\nrep_v_frobenius_constant_2 =\n    [[0x30f1361b798a64e8, 0xf3b8ddab7ece5a2a, 0x16a8ca3ac61577f7,\n      0xc26a2ff874fd029b, 0x3636b76660701c6e, 0x051ba4ab241b6160],\n     [0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000]]\n\nrep_v_frobenius_constant_2_sq_const_part =\n    [0xcd03c9e48671f071, 0x5dab22461fcda5d2, 0x587042afd3851b95,\n     0x8eb60ebe01bacb9e, 0x03f97d6e83d050d2, 0x18f0206554638741]\n\nrep_w_frobenius_constant_2_const_part =\n    [[0xecfb361b798dba3a, 0xc100ddb891865a2c, 0x0ec08ff1232bda8e,\n      0xd5c13cc6f1ca4721, 0x47222a47bf7b5c04, 0x0110f184e51c5f59],\n     [0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000]]\n\nfp6_frobenius2 [a,b,c] = [a',b',c'] where\n    a' = f2.mul (v_frobenius_constant_2_sq, fp2_frobenius (fp2_frobenius a))\n    b' = f2.mul (v_frobenius_constant_2, fp2_frobenius (fp2_frobenius b))\n    c' = fp2_frobenius (fp2_frobenius c)\n\nfp12_frobenius2 [a,b] = [a',b'] where\n    a' = Fp_6.mul (Fp_2_to_Fp_6 w_frobenius_constant_2_part,\n                   fp6_frobenius (fp6_frobenius a))\n    b' = fp6_frobenius (fp6_frobenius b)\n\n\/\/ for triple Frobenius\nv_frobenius_constant_3 = F_expt`{n=1143} f2 u_plus_1 `((p*p*p-1)\/3)\nv_frobenius_constant_3_sq = Fp_2.sq v_frobenius_constant_3\n\nw_frobenius_constant_3_part = F_expt`{n=1143} f2 u_plus_1 `((p*p*p-1)\/6)\n\nrep_v_frobenius_constant_3 =\n    [[0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000],\n     [0x760900000002fffd, 0xebf4000bc40c0002, 0x5f48985753c758ba,\n      0x77ce585370525745, 0x5c071a97a256ec6d, 0x15f65ec3fa80e493]]\n\nrep_v_frobenius_constant_3_sq_const_part =\n    [0x43f5fffffffcaaae, 0x32b7fff2ed47fffd, 0x07e83a49a2e99d69,\n     0xeca8f3318332bb7a, 0xef148d1ea0f4c069, 0x040ab3263eff0206]\n\nrep_w_frobenius_constant_3_const_part =\n    [[0x3e2f585da55c9ad1, 0x4294213d86c18183, 0x382844c88b623732,\n      0x92ad2afd19103e18, 0x1d794e4fac7cf0b9, 0x0bd592fc7d825ec8],\n     [0x7bcfa7a25aa30fda, 0xdc17dec12a927e7c, 0x2f088dd86b4ebef1,\n      0xd1ca2087da74d4a7, 0x2da2596696cebc1d, 0x0e2b7eedbbfd87d2]]\n\nfp6_frobenius3 [a,b,c] = [a',b',c'] where\n    a' = f2.mul (v_frobenius_constant_3_sq, fp2_frobenius a)\n    b' = f2.mul (v_frobenius_constant_3, fp2_frobenius b)\n    c' = fp2_frobenius c\n\nfp12_frobenius3 [a,b] = [a',b'] where\n    a' = Fp_6.mul (Fp_2_to_Fp_6 w_frobenius_constant_3_part,\n                   fp6_frobenius (fp6_frobenius (fp6_frobenius a)))\n    b' = fp6_frobenius (fp6_frobenius (fp6_frobenius b))\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Cyclotomic squaring\n\n\/* The \"cyclotomic squaring\" operation is described in\n   Robert Granger amd Michael Scott,\n   \"Faster Squaring in the Cyclotomic Subgroup of Sixth Degree Extensions\"\n   eprint.iacr.org\/2009\/565\n\n  This expresses a value in Fp_12 as a cubic expension of a quadratic extension,\n  whereas in most of blst we consider it as a quadratic extension of a cubic extension of Fp_2.\n  The Fp_4 we use here is used only for the purposes of this cyclotomic squaring operation.\n\n  Fp_4 = Fp_2[y]\/(y^2 - u - 1)\n  Fp_12 is isomorphic to Fp_4[x]\/(x^3 - y)\n\n  Noting that in the regular Fp_12 construction of the Parameters module, we have\n  v^3 = u+1 and w^2 = v, we have w^6 = u+1 and so (w^3)^2 = u+1.  So for the alternative\n  construction we have y = w^3 and x = w.\n*\/\n\ntype t_Fp_4 = [2]t_Fp_2\nFp_4 = extension_field Fp_2 [Fp_2.field_zero, u_plus_1]\ny_fp4: t_Fp_4\ny_fp4 = [Fp_2.field_unit, Fp_2.field_zero] \/\/ = poly_x Fp_4\n\nfp4_abs [x, y] = [fp2_abs y, fp2_abs x]\nfp4_rep [x, y] = [fp2_rep y, fp2_rep x]\n\ntype t_Fp_12_alt = [3]t_Fp_4\nFp_12_alt = extension_field Fp_4 [Fp_4.field_zero, Fp_4.field_zero, y_fp4]\n\n\/* In the standard tower, [[a,b,c],[d,e,f]] means\n  (av^2+bv+c)w + (dv^2+ev+f), which, given v = w^2, equals aw^5 + dw^4 + bw^3 + ew^2 + cw + f\n\n  In the alternative tower , [[A,B], [C,D], [E,F]] means\n  (Ay + B)x^2 + (Cy + D)x + (Ey + F),\n  and given y = w^3 and x = w, equals Aw^5 + Cw^4 + Ew^3 + Bw^2 + Dw + F\n\n  These two are equal iff A=a, B=e, C=d, D=c, E=b, and F=f\n*\/\n\nFp_12_to_Fp_12_alt: t_Fp_12 -> t_Fp_12_alt\nFp_12_to_Fp_12_alt [[a,b,c],[d,e,f]] = [[a,e], [d,c], [b,f]]\n\nFp_12_alt_to_Fp_12: t_Fp_12_alt -> t_Fp_12\nFp_12_alt_to_Fp_12 [[A,B], [C,D], [E,F]] = [[A,E,D], [C,B,F]]\n\nconjugate_fp4: t_Fp_4 -> t_Fp_4\nconjugate_fp4 [x,y] = [Fp_2.neg x, y]\n\n\/\/ definition from the paper\n\ncyclotomic_sqr_alt: t_Fp_12_alt -> t_Fp_12_alt\ncyclotomic_sqr_alt [c,b,a] = [C,B,A] where \/\/ paper has a+b+cx^2 and A + Bx + Cx^2\n    A = Fp_4.sub (x3 (Fp_4.sq a), x2 (conjugate_fp4 a))\n    B = Fp_4.add (x3 (Fp_4.mul (y_fp4, Fp_4.sq c)), x2 (conjugate_fp4 b))\n    C = Fp_4.sub (x3 (Fp_4.sq b), x2 (conjugate_fp4 c))\n    x2 x = Fp_4.add (x, x) \/\/ x+x = 2*x\n    x3 x = Fp_4.add (x, x2 x) \/\/ x + 2*x = 3*x\n\ncyclotomic_sqr_fp12: t_Fp_12 -> t_Fp_12\ncyclotomic_sqr_fp12 x =\n    Fp_12_alt_to_Fp_12 (cyclotomic_sqr_alt (Fp_12_to_Fp_12_alt x))\n\n\/\/ .. and as-implemented (in abstract space)\n\ncyclotomic_sqr_fp12_imp: t_Fp_12 -> t_Fp_12\ncyclotomic_sqr_fp12_imp [[a12, a11, a10], [a02, a01, a00]] = r where\n    \/\/ aij, tij, and rij names correspond to the indices of the implementation,\n    \/\/ i.e., reversed from abstract\n    [t01, t00] = Fp_4.sq [a11, a00]\n    [t11, t10] = Fp_4.sq [a02, a10]\n    [t21, t20] = Fp_4.sq [a12, a01]\n    r00 = f_sub t00 a00\n    r01 = f_sub t10 a01\n    r02 = f_sub t20 a02\n\n    r10 = f_add (Fp_2.mul (u_plus_1, t21)) a10\n    r11 = f_add t01 a11\n    r12 = f_add t11 a12\n\n    r = [[r12, r11, r10], [r02, r01, r00]]\n    f_sub x y = Fp_2.add (s, Fp_2.add (s, x)) where s = Fp_2.sub (x, y)\n    f_add x y = Fp_2.add (s, Fp_2.add (s, x)) where s = Fp_2.add (x, y)\n\nsqr_fp4_imp a0 a1 = [ret1, ret0] where\n    t0 = Fp_2x2.sq a0 \/\/ sqr_fp2x2(t0, a0);\n    t1 = Fp_2x2.sq a1 \/\/ sqr_fp2x2(t1, a1);\n    t3 = Fp_2.add (a0, a1)     t2 = Fp_2x2.mul (t1, u_plus_1x2)     ret0 = Fp_2x2.add (t2, t0)     t2_b = Fp_2x2.sq t3     ret1 = Fp_2x2.sub (Fp_2x2.sub (t2_b, t0), t1) \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ mul_fp6, mul_fp12, and friends\n\/\/\n\/\/ Some of the action takes place in rings:\n\/\/ Fpx2: Integers mod 2^384 * p\n\/\/ Fp2x2: Fpx2[x] \/ (x^2+1), a quotient ring.\n\/\/ etc.\n\/\/\n\/\/ We fake the rings by using the field constructors, and taking care never to call `half` or `div`\n\/\/\n\/\/ It would be a big rewrite to introduce a Ring structure (like Field), define polynomials over rings,\n\/\/ and have the projection for fields to rings where needed, but in the end it would be a bit neater.\n\nFpx2 = prime_field_integer (`p * 2^^384 )\n\nFp_2x2 = extension_field Fpx2 [Fpx2.field_zero, Fpx2.neg Fpx2.field_unit] \/\/ [0,-1]\nu_plus_1x2: t_Fp_2x2\nu_plus_1x2 = Fp_2x2.add (poly_x Fpx2, poly_1 Fpx2)\n\nFp_6x2 = extension_field Fp_2x2 [Fp_2x2.field_zero, Fp_2x2.field_zero, u_plus_1x2]\n\n\/\/ \"optimised\" form for a1 b2 + a2 b1\n\/\/ (a1+a2)(b1 + b2) - a1 b1 - a2 b2\nfp6x2_tmp a1 a2 b1 b2 = Fp_2x2.sub (Fp_2x2.sub (t, Fp_2x2.mul (a1, b1)), Fp_2x2.mul (a2, b2)) where\n  t = Fp_2x2.mul (Fp_2.add (a1,a2), Fp_2.add (b1, b2))\n\nfp6x2_mul: [3][2]Integer -> [3][2]Integer -> [3][2]Integer\nfp6x2_mul [a2, a1, a0] [b2, b1, b0] = [r2, r1, r0] where\n  r0 = Fp_2x2.add (Fp_2x2.mul (fp6x2_tmp a1 a2 b1 b2, u_plus_1x2), Fp_2x2.mul (a0, b0))\n  r1 = Fp_2x2.add (fp6x2_tmp a0 a1 b0 b1, Fp_2x2.mul (Fp_2x2.mul (a2, b2), u_plus_1x2))\n  r2 = Fp_2x2.add (fp6x2_tmp a0 a2 b0 b2, Fp_2x2.mul (a1, b1))\n\n\/\/ mul_fp12 \"as implemented\", but without the final \"redc\"\n\/\/ ...  but in the abstract space, so all our indexing is backwards\n\n\/\/ \"optimised\" form for a0 b1 + a1 b0\n\/\/ (a0+a1)(b0 + b1) - a0 b0 - a1 b1\n\nfp12_mul_1 a0 a1 b0 b1 = Fp_6x2.sub (Fp_6x2.sub (t, fp6x2_mul a0  b0), fp6x2_mul a1 b1) where\n  t = fp6x2_mul (Fp_6.add (b0,b1)) (Fp_6.add (a0, a1))\n\n\/* original definition:\nfp12_mul_0 a0 a1 b0 b1 = [rx2, rx1, rx0] where\n  t0 = Fp_6x2.mul (a0, b0)\n  t1 = Fp_6x2.mul (a1, b1)\n  rx2 = Fp_2x2.add (t0!2, t1!1)\n  rx1 = Fp_2x2.add (t0!1, t1!0)\n  rx0 = Fp_2x2.add (t0!0, Fp_2x2.mul (t1!2, u_plus_1x2))\n*\/\n\/\/ better SAWcore terms result if we use destructuring binds rather than indexing:\nfp12_mul_0 a0 a1 b0 b1 = [rx2, rx1, rx0] where\n  [t0_2, t0_1, t0_0] = fp6x2_mul a0 b0\n  [t1_2, t1_1, t1_0] = fp6x2_mul a1 b1\n  rx2 = Fp_2x2.add (t0_2, t1_1)\n  rx1 = Fp_2x2.add (t0_1, t1_0)\n  rx0 = Fp_2x2.add (t0_0, Fp_2x2.mul (t1_2, u_plus_1x2))\n\nfp12_mul: [2][3][2]Integer -> [2][3][2]Integer -> [2][3][2]Integer\nfp12_mul [a1, a0] [b1, b0] = [r1, r0] where\n  r0 = fp12_mul_0 a0 a1 b0 b1\n  r1 = fp12_mul_1 a0 a1 b0 b1\n\n\/\/ The as-implemented sqr_fp12 algorithm, in our abstractspace and so wih indexing\n\/\/ reversed from the code:\n\nfp12_sqr: t_Fp_12 -> t_Fp_12\nfp12_sqr a = ret where\n    [a1, a0] = a\n    [a12, a11, a10] = a1\n    [a02, a01, a00] = a0\n\n    t0 = Fp_6.add (a0, a1)                   t12 = Fp_2.mul (u_plus_1, a12)       \/\/ mul_by_u_plus_1_fp2(t1[2], a[1][2]);\n    t1 = [ Fp_2.add (a02, a11)           \/\/  \/- add_fp2(t1[0], a[0][0], t1[2]);\n         , Fp_2.add (a01, a10)           \/\/ <|-  add_fp2(t1[1], a[0][1], a[1][0]);\n         , Fp_2.add (a00, t12)]          \/\/  \\- add_fp2(t1[2], a[0][2], a[1][1]);\n    t0_a = Fp_6.mul (t0, t1)             \/\/ mul_fp6(t0, t0, t1);\n    t1_a = Fp_6.mul (a0, a1)             \/\/ mul_fp6(t1, a[0], a[1]);\n    [t12_a, t11_a, t10_a] = t1_a\n\n    r1 = Fp_6.add (t1_a, t1_a)           \/\/ add_fp6(ret[1], t1, t1);\n    [r02, r01, r00] = Fp_6.sub (t0_a, t1_a) \/\/ sub_fp6(ret[0], t0, t1);\n\n    t12_b = Fp_2.mul (u_plus_1, t12_a)   \/\/ mul_by_u_plus_1_fp2(t1[2], t1[2]);\n\n    r00_a = Fp_2.sub (r00, t12_b)            r01_a = Fp_2.sub (r01, t10_a)            r02_a = Fp_2.sub (r02, t11_a)            ret = [r1, [r02_a, r01_a, r00_a]]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ mul_by_xy00z0\n\/\/\n\nxy00z0_expander: Fp_6_rep_t -> Fp_12_rep_t\nxy00z0_expander [x,y,z] = [[x, y, zero], [zero, z, zero]] \/\/ in rep space\n\nfp6_to_fp12_xy00z0: t_Fp_6 -> t_Fp_12\nfp6_to_fp12_xy00z0 [z,y,x] = [[zero, z, zero], [zero, y, x]] \/\/ in abs space, reversed.\n\n\nmul_by_0y0_fp6x2: t_Fp_6 -> t_Fp_2 -> t_Fp_6\nmul_by_0y0_fp6x2 a b = [r2, r1, r0] where\n    [a2,a1,a0] = a\n    t = Fp_2x2.mul (a2, b)\n    r0 = Fp_2x2.mul (t, u_plus_1x2)\n    r1 = Fp_2x2.mul (a0, b)\n    r2 = Fp_2x2.mul (a1, b)\n\nmul_by_xy0_fp6x2: t_Fp_6 -> t_Fp_2 -> t_Fp_2 -> t_Fp_6\nmul_by_xy0_fp6x2 a b1 b0 = [r2_a, r1_b, r0_a] where\n    [a2, a1, a0] = a\n    t0 = Fp_2x2.mul (a0, b0)         t1 = Fp_2x2.mul (a1, b1)     \/\/ mul_fp2x2(t1, a[1], b[1]);\n\n    t2 = Fp_2x2.mul (a2, b1)     \/\/ mul_fp2x2(ret[1], a[2], b[1]);  (renaming to t2 here)\n    r0 = Fp_2x2.mul (t2, u_plus_1x2) \/\/ mul_by_u_plus_1_fp2x2(ret[0], ret[1]);\n    r0_a = Fp_2x2.add (r0, t0)   \/\/ add_fp2x2(ret[0], ret[0], t0);\n\n    aa = Fp_2.add (a0, a1)       \/\/ add_fp2(aa, a[0], a[1]);\n    bb = Fp_2.add (b0, b1)       \/\/ add_fp2(bb, b[0], b[1]);\n    r1 = Fp_2x2.mul (aa, bb)     \/\/ mul_fp2x2(ret[1], aa, bb);\n    r1_a = Fp_2x2.sub (r1, t0)   \/\/ sub_fp2x2(ret[1], ret[1], t0);\n    r1_b = Fp_2x2.sub (r1_a, t1) \/\/ sub_fp2x2(ret[1], ret[1], t1);\n\n    r2 = Fp_2x2.mul (a2, b0)     \/\/ mul_fp2x2(ret[2], a[2], b[0]);\n    r2_a = Fp_2x2.add (r2, t1)   \/\/ add_fp2x2(ret[2], ret[2], t1);\n\nmul_by_xy00z0_fp12: t_Fp_12 -> t_Fp_6 -> t_Fp_12\nmul_by_xy00z0_fp12 a xy00z0 = [r1_a, r0] where\n    [a1, a0] = a\n    [b2, b1, b0] = xy00z0\n    t0 =  mul_by_xy0_fp6x2 a0 b1 b0     \/\/ mul_by_xy0_fp6x2(t0, a[0], xy00z0);\n    t1 = mul_by_0y0_fp6x2 a1 b2         \/\/ mul_by_0y0_fp6x2(t1, a[1], xy00z0[2]);\n\n    t2_0 = b0                           \/\/ vec_copy(t2[0], xy00z0[0], sizeof(t2[0]));\n    t2_1 = Fp_2.add (b1, b2)            \/\/ add_fp2(t2[1], xy00z0[1], xy00z0[2]);\n    r1 = Fp_6.add (a0, a1)              \/\/ add_fp6(ret[1], a[0], a[1]);\n    rr = mul_by_xy0_fp6x2 r1 t2_1 t2_0      rr_a = Fp_6x2.sub (rr, t0)              rr_b = Fp_6x2.sub (rr_a, t1)            r1_a = rr_b                             [t0_2, t0_1, t0_0] = t0\n    [t1_2, t1_1, t1_0] = t1\n    rr0 = Fp_2x2.mul (t1_2, u_plus_1x2)     rr0_a = Fp_2x2.add (t0_0, rr0)          rr1 = Fp_2x2.add (t0_1, t1_0)           rr2 = Fp_2x2.add (t0_2, t1_1)           r0 = [rr2, rr1, rr0_a]              \/\/ redc_fp6x2(ret[0], rr);\n\ninverse_fp2_imp: t_Fp_2 -> t_Fp_2\ninverse_fp2_imp [a1,a0] = [r1,r0] where\n    t = Fp.div(Fp.field_unit, Fp.add (Fp.sq a0, Fp.sq a1))\n    r0 = Fp.mul (a0,t)\n    r1 = Fp.neg (Fp.mul (a1,t))\n\ninverse_fp6_imp: t_Fp_6 -> t_Fp_6\ninverse_fp6_imp [a2,a1,a0] = [r2,r1,r0] where \n    c0 = Fp_2.sub (Fp_2.sq a0, Fp_2.mul (u_plus_1,Fp_2.mul (a1,a2)))\n    c1 = Fp_2.sub (Fp_2.mul (u_plus_1, Fp_2.sq a2), Fp_2.mul(a0,a1))\n    c2 = Fp_2.sub (Fp_2.sq a1, Fp_2.mul (a0, a2))\n    t0 = Fp_2.add (Fp_2.mul (c1, a2), Fp_2.mul (c2, a1))\n    t1 = Fp_2.add (Fp_2.mul (u_plus_1, t0), Fp_2.mul (c0, a0))\n    t  = inverse_fp2_imp t1 \/\/ or  Fp_2.div(Fp_2.field_unit, t1)\n    r2 = Fp_2.mul(c2, t)\n    r1 = Fp_2.mul(c1, t)\n    r0 = Fp_2.mul(c0, t)\n\ninverse_fp12_imp: t_Fp_12 -> t_Fp_12\ninverse_fp12_imp [a1,a0] = [r1,r0] where\n    [t0_2, t0_1, t0_0]  = Fp_6.sq a0 \/\/ sqr_fp6(t0, a[0]);\n    [t1_2, t1_1, t1_0] = Fp_6.sq a1  \/\/ sqr_fp6(t1, a[1]);\n    t1_2a = Fp_2.mul (t1_2, u_plus_1) \/\/ mul_by_u_plus_1_fp2(t1[2], t1[2]);\n    t0_0a = Fp_2.sub (t0_0, t1_2a)      t0_1a = Fp_2.sub (t0_1, t1_0)       t0_2a = Fp_2.sub (t0_2, t1_1)       t1_a = inverse_fp6_imp [t0_2a, t0_1a, t0_0a]     r0 = Fp_6.mul (a0, t1_a)            r1 = Fp_6.neg (Fp_6.mul (a1, t1_a)) sqr_fp6_imp: t_Fp_6 -> t_Fp_6\nsqr_fp6_imp a = ret where\n    [a2, a1, a0] = a\n    s0 = Fp_2x2.mul (a0, a0)     m01 = Fp_2x2.mul (a0, a1)     m01_a = Fp_2x2.add (m01, m01)     m12 = Fp_2x2.mul (a1, a2)     m12_a = Fp_2x2.add (m12, m12)     s2 = Fp_2x2.mul (a2,a2)     \/* ret[2] = (a0 + a1 + a2)^2 - a0^2 - a2^2 - 2*(a0*a1) - 2*(a1*a2)\n              = a1^2 + 2*(a0*a2) *\/\n    ret2 = Fp_2.add (a2, a1)     ret2_a = Fp_2.add (ret2, a0)     rx = Fp_2x2.mul (ret2_a, ret2_a)     rx_a = Fp_2x2.sub (rx, s0)     rx_b = Fp_2x2.sub (rx_a, s2)     rx_c = Fp_2x2.sub (rx_b, m01_a)     rx_d = Fp_2x2.sub (rx_c, m12_a)     ret2_b = rx_d \/\/ we apply redc outside this Cryptol function \/\/  redc_fp2x2(ret[2], rx);\n\n    \/* ret[0] = a0^2 + 2*(a1*a2)*(u+1) *\/\n    rx_e = Fp_2x2.mul (m12_a, u_plus_1x2) \/\/  mul_by_u_plus_1_fp2x2(rx, m12);\n    rx_f = Fp_2x2.add (rx_e, s0)     ret0 = rx_f     \/* ret[1] = a2^2*(u+1) + 2*(a0*a1) *\/\n    rx_g = Fp_2x2.mul (s2, u_plus_1x2)     rx_h = Fp_2x2.add (rx_g, m01_a)     ret1 = rx_h     ret = [ret2_b, ret1, ret0]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/CoreVerifyPKInG2.cry","filetype":"cry","content":"module implementation::CoreVerifyPKInG2 where\n\nimport Parameters (Fp_12, t_Fp, t_Fp_2, BP', E)\nimport ShortWeierstrassCurve (AffinePoint, affinify)\nimport implementation::PairingImpl (miller_loop_opt)\nimport implementation::HashToG1 (hash_to_curve_opt_impl)\nimport implementation::FinalExp (final_exponentiation_impl)\nimport implementation::PairingImpl (miller_loop_opt_checked)\nimport ExpandMessage\nimport Frobenius (fp12_conjugate)\nimport HashToCurveE1\n\ncore_verify_pk_in_g2_impl : {msg_len,dst_len,aug_len}\n  (fin msg_len, fin dst_len, fin aug_len\n  , Expandable (msg_len+aug_len) dst_len\n  , dst_len <= 255) =>\n  AffinePoint t_Fp_2 -> AffinePoint t_Fp -> [msg_len][8] -> [dst_len][8] -> [aug_len][8] -> Bool\n\ncore_verify_pk_in_g2_impl pk sig msg dst aug = Fp_12.is_equal(gt, Fp_12.field_unit) where\n    Q = affinify E (hash_to_curve_opt_impl (aug#msg, dst))\n    gtPQ = miller_loop_opt_checked Q pk\n    gtSig = fp12_conjugate (miller_loop_opt_checked sig BP')\n    gt = final_exponentiation_impl (Fp_12.mul (gtSig, gtPQ))\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/SerializationP1.cry","filetype":"cry","content":"module implementation::serialization where\n\nimport Parameters (p, E, E', t_Fp, to_Fp, t_Fp_2, Fp, Fp_2)\nimport ShortWeierstrassCurve as EC\nimport rfc8017\nimport Maybe\nimport FieldExtras (F_expt)\nimport BLSFieldExtras\nimport Serialization\nimport implementation::Types\nimport implementation::Field\n\n\/\/ deserialization of compressed representations\n\nuncompress_E1_x: [48][8] -> [384]\nuncompress_E1_x s_string = x where\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    \/\/ Step 6\n    x = join s_string' \/\/ OS2IP(s_string')\n\nuncompress_E1_x_fp: [48][8] -> t_Fp\nuncompress_E1_x_fp s_string =\n    Fp.mul (fp_abs (vec384_rep (uncompress_E1_x s_string)), montgomery_factor_p)\n\nuncompress_E1_y2: [48][8] -> t_Fp\nuncompress_E1_y2 s_string = y2 where\n    \/\/ x = to_Fp (uncompress_E1_x s_string)\n    x = Fp.mul ( fp_abs (vec384_rep (uncompress_E1_x s_string))\n               , montgomery_factor_p) \/\/ we will prove this = to_Fp ...\n    y2 = Fp.add (Fp.mul (Fp.sq x, x), 4)\n\nuncompress_E1_y: [48][8] -> t_Fp\nuncompress_E1_y s_string = sqrt_fp (uncompress_E1_y2 s_string)\n\nuncompress_E1_imp: [48][8] -> Maybe (EC::AffinePoint t_Fp)\nuncompress_E1_imp s_string = ret where\n    \/\/ Step 1.\n    m_byte = (s_string@0) && 0xE0 \/\/ three highest bits\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    x = uncompress_E1_x_fp s_string\n    y2 = uncompress_E1_y2 s_string\n    y = sqrt_fp y2\n    Y_bit = sign_F_p y\n    ret = if C_bit == False then nothing \/\/ Error, from Step 2\n           | I_bit then (if ~S_bit \/\\ s_string' == zero then just (EC::point_O E) else nothing)\n           | uncompress_E1_x s_string >= `p then nothing \/\/ extra check in the C code\n           | ~ (is_square_fp y2) then nothing \/\/ from Step 7\n           | S_bit == Y_bit then just (x,y)\n          else just (x, Fp.neg y)\n\n\nuncompress_E1_OK: [48][8] -> EC::AffinePoint t_Fp\nuncompress_E1_OK s_string = if S_bit == Y_bit then (x,y) else (x, Fp.neg y) where\n    x = uncompress_E1_x_fp s_string\n    y = uncompress_E1_y s_string\n    S_bit = (s_string@0)@2\n    Y_bit = sign_F_p y\n\n\/\/ deserialization of uncompressed representations\n\ndeserialize_E1_x: [96][8] -> [384]\ndeserialize_E1_x s_string = x where\n    s_string' = take`{48} ([(s_string@0) && 0x1F] # tail s_string)\n    x = join s_string'\n\ndeserialize_E1_x_fp: [96][8] -> t_Fp\ndeserialize_E1_x_fp s_string =\n    Fp.mul (fp_abs (vec384_rep (deserialize_E1_x s_string)), montgomery_factor_p)\n\ndeserialize_E1_y: [96][8] -> [384]\ndeserialize_E1_y s_string = join (drop`{48} s_string)\n\ndeserialize_E1_y_fp: [96][8] -> t_Fp\ndeserialize_E1_y_fp s_string =\n    Fp.mul (fp_abs (vec384_rep (deserialize_E1_y s_string)), montgomery_factor_p)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/HashToG1.cry","filetype":"cry","content":"module implementation::HashToG1 where\n\nimport Parameters (Fp, t_Fp)\nimport ShortWeierstrassCurve (ProjectivePoint)\nimport BLSFieldExtras (sqrt_fp)\nimport ExpandMessage (Expandable)\nimport implementation::CurveOperation (point_dadd, point_add, point_double)\nimport HashToCurveE1\nimport HashToCurveE1Aux as Aux\n\n\/\/ the SWU map\n\n\/\/ This is what the implementation does:\nmap_to_curve_simple_swu_impl : t_Fp -> ProjectivePoint t_Fp\nmap_to_curve_simple_swu_impl u = res where\n  c2 = sqrt (Fp.neg (Fp.mul (Fp.sq Z, Z))) \/\/ sqrt(-Z^3)\n\n  \/\/ x numerator\n  tv1 = Fp.sq u\n  tv3 = Fp.mul (Z, tv1)\n  tv2 = Fp.add (Fp.sq tv3, tv3)\n  x1n = Fp.mul (Fp.add (tv2, Fp.field_unit), B')\n  x2n = Fp.mul(tv3, x1n)\n\n  \/\/ x denumerator\n  xd = Fp.mul(Fp.neg A', tv2)\n  e1 = Fp.is_equal(xd, Fp.field_zero)\n  xd_b = if e1 then Fp.mul(Z, A') else xd\n\n  \/\/ y numerator\n  tv2_a = Fp.sq xd_b\n  gxd = Fp.mul(xd_b, tv2_a)\n  tv2_b = Fp.mul(A',  tv2_a)\n  gx1 = Fp.sq x1n\n  gx1_a = Fp.add(gx1, tv2_b)\n  gx1_b = Fp.mul(gx1_a,  x1n)\n  tv2_c = Fp.mul(B', gxd)\n  gx1_c = Fp.add(gx1_b, tv2_c)\n  tv4 = Fp.sq gxd\n  tv2_d = Fp.mul (gx1_c, gxd)\n  tv4_b = Fp.mul (tv4, tv2_d)\n  y1 = Fp.div (Fp.field_unit, sqrt_fp tv4_b) \/\/ note this is an exponentiation in the spec\n  e2 = Fp.is_equal (Fp.sq (Fp.mul (y1, tv4_b)), tv4_b) \/\/ this appears in the body of recip_sqrt\n  y1_b = Fp.mul(y1, tv2_d)\n\n  y2 = Fp.mul(y1_b, c2)\n  y2_b = Fp.mul(y2, tv1)\n  y2_c = Fp.mul(y2_b, u)\n\n  xn = if e2 then  x1n else x2n\n  y = if e2 then y1_b else y2_c\n\n  y_a = if sgn0(u) != sgn0(y) then Fp.neg y else y\n\n  \/\/ convert to Jacobian coordinates:\n  res = (Fp.mul (xn, xd_b), Fp.mul (y_a, gxd), xd_b)\n\n\/\/ isogeny_map_to_E1\n\nisogeny_map_to_E1_impl: ProjectivePoint t_Fp -> ProjectivePoint t_Fp\nisogeny_map_to_E1_impl (X, Y, Z) = to_jacobian xn xd yn yd where\n  zzs = Zz_powers Z\n  xn = map_fp (kzzs#[last Aux::k1s]) X where\n    kzzs = map_fp_times_Zz`{n=11} Aux::k1s zzs\n  xd = Fp.mul (xs, last zzs) where\n    xs = map_fp ((take`{front=9}kzzs)#[xkzz9]) X\n    xkzz9 = Fp.add (X, last kzzs)\n    kzzs = map_fp_times_Zz`{n=10} Aux::k2s zzs\n  yn = Fp.mul (map_fp (kzzs#[last Aux::k3s]) X, Y) where\n    kzzs = map_fp_times_Zz`{n=15} Aux::k3s zzs\n  yd = Fp.mul (Fp.mul (xs, Z), last zzs) where\n    xs = map_fp ((take`{front=14}kzzs)#[xkzz14]) X\n    xkzz14 = Fp.add (X, last kzzs)\n    kzzs = map_fp_times_Zz`{n=15} Aux::k4s zzs\n\nZz_powers : t_Fp -> [15]t_Fp \/\/ powers of ZZ in descending order\nZz_powers Z = reverse (take`{front=15} zzs) where\n    zzs = [Fp.sq Z, Fp.sq (Fp.sq Z)]\n      # (join`{parts=inf} [[Fp.mul (zi0, zi1), Fp.sq zi1] | zi0 <- zzs | zi1 <- tail zzs]) map_fp_times_Zz : {m1,m2,n} (fin n, fin m2, m1 >= n, m2 >= n) => [m1]t_Fp -> [m2]t_Fp -> [n]t_Fp\nmap_fp_times_Zz ks zzs = zipWith (curry Fp.mul) (take`{front=n}ks) (drop`{back=n}zzs)\n\nmap_fp kzzs x = last rs where\n  rs = [last kzzs] # [Fp.add (Fp.mul (ri, x), kzzi) | kzzi <- tail (reverse kzzs) | ri <- rs]\n\n\/\/ NOTE: this does not follow jacobian_to_projective_pair in G2SubGroupCheck.cry\nto_jacobian xn xd yn yd = (X, Y, Z) where\n  Z = Fp.mul (xd, yd)\n  X = Fp.mul (Fp.mul (xn, yd) , Z)\n  Y = Fp.mul (Fp.mul (Fp.sq Z, xd) , yn)\n\ndbl_n_add: ProjectivePoint t_Fp -> Integer -> ProjectivePoint t_Fp -> ProjectivePoint t_Fp\ndbl_n_add out n p = point_dadd Fp (db n out) p Fp.field_zero True where\n  db: Integer -> ProjectivePoint t_Fp -> ProjectivePoint t_Fp\n  db k x =\n    if k == 1 then point_double Fp x\n    else point_double Fp (db (k-1) x)\n\nclear_cofactor_impl: ProjectivePoint t_Fp -> ProjectivePoint t_Fp\nclear_cofactor_impl p = out where\n  out1 = point_double Fp p\n  out2 = point_add Fp out1 p \/\/ NOTE: this is okay because (point_double p) != p or both are point_O\n  out3 = dbl_n_add out2 2 p\n  out4 = dbl_n_add out3 3 p\n  out5 = dbl_n_add out4 9 p\n  out6 = dbl_n_add out5 32 p\n  out = dbl_n_add out6 16 p\n\nhash_to_curve_opt_impl: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384\n               ) =>\n               ([msg_len][8], [DST_len][8]) -> ProjectivePoint t_Fp\nhash_to_curve_opt_impl (msg,dst) = map_to_g1_impl u where\n    u = hash_to_field`{count=2} msg dst\n\nmap_to_g1_impl: [2]t_Fp -> ProjectivePoint t_Fp\nmap_to_g1_impl uv = P where\n    Q0 = map_to_curve_simple_swu_impl (uv@0)\n    Q1 = map_to_curve_simple_swu_impl (uv@1)\n    R = point_dadd Fp Q0 Q1 A' False \/\/ This is addition on the isogenous curve E'\n    S = isogeny_map_to_E1_impl R\n    P = clear_cofactor_impl S\n","variant":"hybrid","set":"supervised"}
{"filename":"BLST-Verification\/spec\/implementation\/FinalExp.cry","filetype":"cry","content":"module implementation::FinalExp where\n\nimport FieldExtras\nimport Frobenius\nimport HashToCurveE2Aux\nimport Pairing\nimport Parameters as P\n\nimport implementation::Fp12\n\n\/\/ If x is in the cyclotomic subgroup, then x^(cyclotomic_exponent_modulus) = 1\ntype cyclotomic_exponent_modulus = P::p^^4 - P::p^^2 + 1\n\n\/\/ An integer representation of the constant `z`\nint_z = -pos_c1\n\n\/\/ Small final exponent from the implementation\nsmall_final_e_imp : Integer\nsmall_final_e_imp = `P::p^^27 +\n                    2*`P::p^^21*int_z +\n                    `P::p^^19 +\n                    `P::p^^18*int_z +\n                    `P::p^^15*int_z^^2 +\n                    `P::p^^14*int_z +\n                    `P::p^^13*int_z^^2 +\n                    2*`P::p^^13*int_z +\n                    `P::p^^12*int_z^^3 +\n                    2*`P::p^^12*int_z^^2 +\n                    2*`P::p^^8*int_z^^2 +\n                    2*`P::p^^7*int_z^^3 +\n                    `P::p^^7*int_z^^2 +\n                    2*`P::p^^6*int_z^^4 +\n                    `P::p^^6*int_z^^3 +\n                    `P::p^^2*int_z^^3 +\n                    `P::p*int_z^^4 +\n                    int_z^^5 +\n                    3\n\n\/\/ An exponential function that supports negative exponents.  Uses\n\/\/ fp12_conjugate to compute the inverse of x, so x must be in the cyclotomic\n\/\/ subgroup if e is negative.\nC_expt: P::t_Fp_12 -> Integer -> P::t_Fp_12\nC_expt b e = if e >= 0 then x else fp12_conjugate x where\n  \/\/ Use 16384 bits because thats the smallest \"round\" number that fits\n  \/\/ small_final_e_imp.\n  x = F_expt`{P::t_Fp_12, 16384} P::Fp_12 b (abs e)\n\nfinal_exponentiation_impl: P::t_Fp_12 -> P::t_Fp_12\nfinal_exponentiation_impl x = C_expt (final_exp_frobenius_map x) small_final_e_imp\n\n\/\/ Repeatedly square `x`.  `x` must be in the cyclotomic subgroup.\nchain_cyclotomic_sqr_fp12: {n} (fin n, n >= 1) => P::t_Fp_12 -> P::t_Fp_12\nchain_cyclotomic_sqr_fp12 x = acc ! 0 where\n  acc = [x] # [ cyclotomic_sqr_fp12 y | y <- acc | z <- [1..n]]\n\n\/\/ Multiply `ret` by `a`, then square the result `n` times.  `ret * a` must be\n\/\/ in the cyclotomic subgroup.\nmul_n_sqr: {n} (fin n, n >= 1) => P::t_Fp_12 -> P::t_Fp_12 -> P::t_Fp_12\nmul_n_sqr ret a = chain_cyclotomic_sqr_fp12`{n} (P::Fp_12.mul (ret, a))\n\n\/\/ Compute x^(z\/2).\nraise_to_z_div_by_2: P::t_Fp_12 -> P::t_Fp_12\nraise_to_z_div_by_2 x = C_expt x (int_z \/ 2)\n\n\/\/ True iff `x` is in the cyclotomic subgroup.\nis_cyclotomic: P::t_Fp_12 -> Bit\nis_cyclotomic x = C_expt x `cyclotomic_exponent_modulus == P::Fp_12.field_unit\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/HashToG2.cry","filetype":"cry","content":"module implementation::HashToG2 where\n\nimport FieldExtras (F_is_zero, F_sum, F_prod, F_expt)\nimport BLSFieldExtras (sqrt_align_fp2_coeff)\nimport Parameters (Fp_2, t_Fp_2, u)\nimport ShortWeierstrassCurve (ProjectivePoint, point_O, projectify)\nimport ExpandMessage (Expandable)\nimport implementation::CurveOperation (point_dadd, point_add, point_double, point_neg)\nimport HashToCurveE2\nimport HashToCurveE2Aux as Aux\nimport implementation::Psi\n\nmap_to_isogenous_E2_impl : t_Fp_2 -> ProjectivePoint t_Fp_2\nmap_to_isogenous_E2_impl u = res where\n  \/\/ x1n, x2n, and xd:\n  Zuu = Fp_2.mul (Z, Fp_2.sq u)\n  tv2 = Fp_2.add (Fp_2.sq Zuu, Zuu)\n  x1n = Fp_2.mul (Fp_2.add (tv2, Fp_2.field_unit), B')\n  x2n = Fp_2.mul (Zuu, x1n)\n  xd' = Fp_2.mul (Fp_2.neg A', tv2)\n  xd = if F_is_zero Fp_2 xd' then Fp_2.mul(Z,A') else xd'\n    gxd = Fp_2.mul(xd, Fp_2.sq xd) \/\/ xd^3\n  gx1 = F_sum Fp_2 [Fp_2.mul(x1n, Fp_2.sq x1n), F_prod Fp_2 [A', x1n, Fp_2.sq xd], Fp_2.mul(B', gxd)]\n  tv4 = F_prod Fp_2 [gx1, gxd, Fp_2.sq gxd] \/\/ gx1 gxd^3\n  e2 = is_square tv4\n  y1' = if e2 then Fp_2.div (sqrt tv4, tv4) else (F_expt`{n=758} Fp_2 tv4 `((p^^2-9)\/16))\n  y1 = F_prod Fp_2 [gx1, gxd, y1']\n  \/\/ y2:\n  tv4_recip_ZZZ = (Fp_2.mul (tv4, recip_ZZZ))\n  y1'_sqrt_ZZZ = Fp_2.mul (y1', F_expt`{n=758} Fp_2 ZZZ `((p^^2+7)\/16))\n  y2' = Fp_2.mul (y1'_sqrt_ZZZ, sqrt_align_fp2_coeff (Fp_2.mul (y1'_sqrt_ZZZ, tv4_recip_ZZZ)) tv4_recip_ZZZ)\n  y2 = F_prod Fp_2 [y2', gx1, gxd, Fp_2.sq u, u]\n  \/\/ xn and y:\n  (xn,y') = if e2 then (x1n,y1) else (x2n,y2)\n  y = if sgn0(u) == sgn0(y') then y' else Fp_2.neg y'\n  \/\/ convert to Jacobian coordinates\n  res = (Fp_2.mul (xn, xd), Fp_2.mul (y, gxd), xd)\n\nrecip_ZZZ = Fp_2.div(Fp_2.field_unit, ZZZ)\nZZZ = Fp_2.mul(Z, Fp_2.sq Z)\n\nmap_to_g2_impl: [2]t_Fp_2 -> ProjectivePoint t_Fp_2\nmap_to_g2_impl uv = P where\n    Q0 = map_to_isogenous_E2_impl (uv@0)\n    Q2 = map_to_isogenous_E2_impl (uv@1)\n    R = point_dadd Fp_2 Q0 Q2 A' False \/\/ This is addition on the isogenous curve E'\n    S = isogeny_map_to_E2_impl R\n    P = clear_cofactor_E2_impl S\n\nhash_to_curve_E2_opt_impl: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384\n               ) =>\n               ([msg_len][8], [DST_len][8]) -> ProjectivePoint t_Fp_2\nhash_to_curve_E2_opt_impl (msg,dst) = map_to_g2_impl u where\n    u = hash_to_field`{count=2} msg dst\n\nisogeny_map_to_E2_impl: ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\nisogeny_map_to_E2_impl (X, Y, Z) = to_jacobian xn xd yn yd where\n  zzs = Zz_powers Z\n  xn = map_fp2 (kzzs#[last Aux::k1s]) X where\n    kzzs = map_fp2_times_Zz`{n=3} Aux::k1s zzs\n  xd = Fp_2.mul (xs, last zzs) where \/\/ multiply by Z^2\n    xs = map_fp2 ((take`{front=1}kzzs)#[xkzz1]) X\n    xkzz1 = Fp_2.add (X, last kzzs)\n    kzzs = map_fp2_times_Zz`{n=2} Aux::k2s zzs\n  yn = Fp_2.mul (map_fp2 (kzzs#[last Aux::k3s]) X, Y) where\n    kzzs = map_fp2_times_Zz`{n=3} Aux::k3s zzs\n  yd = Fp_2.mul (Fp_2.mul (xs, Z), last zzs) where \/\/ multiply by Z^3\n    xs = map_fp2 ((take`{front=2}kzzs)#[xkzz2]) X\n    xkzz2 = Fp_2.add (X, last kzzs)\n    kzzs = map_fp2_times_Zz`{n=3} Aux::k4s zzs\n\n\/\/ NOTE: below there's some duplication with HashToG1, but it would be cumbersome to factor this out due to the peculiarities of the current Cryptol module system\nto_jacobian xn xd yn yd = (X, Y, Z) where\n  Z = Fp_2.mul (xd, yd)\n  X = Fp_2.mul (Fp_2.mul (xn, yd) , Z)\n  Y = Fp_2.mul (Fp_2.mul (Fp_2.sq Z, xd) , yn)\n\nmap_fp2_times_Zz : {m1,m2,n} (fin n, fin m2, m1 >= n, m2 >= n) => [m1]t_Fp_2 -> [m2]t_Fp_2 -> [n]t_Fp_2\nmap_fp2_times_Zz ks zzs = zipWith (curry Fp_2.mul) (take`{front=n}ks) (drop`{back=n}zzs)\n\nmap_fp2 kzzs x = last rs where\n  rs = [last kzzs] # [F.add (F.mul (ri, x), kzzi) | kzzi <- tail (reverse kzzs) | ri <- rs]\n\nZz_powers : t_Fp_2 -> [3]t_Fp_2\nZz_powers Z = reverse [Fp_2.sq Z, Fp_2.sq (Fp_2.sq Z), Fp_2.mul (Fp_2.sq (Fp_2.sq Z), Fp_2.sq Z)]\n\nadd_n_dbl : {n} (fin n, n >= 1) =>\n            ProjectivePoint t_Fp_2 ->\n            ProjectivePoint t_Fp_2 ->\n            ProjectivePoint t_Fp_2\nadd_n_dbl out p = doublings ! 0 where\n  outp = point_dadd Fp_2 out p Fp_2.field_zero True\n  doublings = [outp] # [point_double Fp_2 d | d <- doublings | i <- [1 .. n]]\n\ntimes_minus_z : ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\ntimes_minus_z P = out6 where\n  out1 = point_double Fp_2 P\n  out2 = add_n_dbl`{2} out1 P\n  out3 = add_n_dbl`{3} out2 P\n  out4 = add_n_dbl`{9} out3 P\n  out5 = add_n_dbl`{32} out4 P\n  out6 = add_n_dbl`{16} out5 P\n\npsi_psi_double_impl: ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\npsi_psi_double_impl P = psi_imp (psi_imp (point_double Fp_2 P))\n\nclear_cofactor_E2_impl:  ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\nclear_cofactor_E2_impl P = out4 where\n  out1 = psi_psi_double_impl P\n  t0_1 = point_neg Fp_2 P\n  t1   = psi_imp t0_1\n  out2 = point_dadd Fp_2 out1 t0_1 Fp_2.field_zero True\n  out3 = point_dadd Fp_2 out2 t1 Fp_2.field_zero True\n  t0_2 = point_dadd Fp_2 (times_minus_z P) P Fp_2.field_zero True\n  t0_3 = point_dadd Fp_2 t0_2 t1 Fp_2.field_zero True\n  t1'  = times_minus_z t0_3\n  out4 = point_dadd Fp_2 out3 t1' Fp_2.field_zero True\n\n\/\/ A slightly simplified version that we could use in a proof that the implementation corresponds to the specification:\n_map_to_isogenous_E2_impl : t_Fp_2 -> ProjectivePoint t_Fp_2\n_map_to_isogenous_E2_impl u = res where\n  \/\/ x1n, x2n, and xd:\n  Zuu = Fp_2.mul (Z, Fp_2.sq u)\n  tv2 = Fp_2.add (Fp_2.sq Zuu, Zuu)\n  x1n = Fp_2.mul (Fp_2.add (tv2, Fp_2.field_unit), B')\n  x2n = Fp_2.mul (Zuu, x1n)\n  xd' = Fp_2.mul (Fp_2.neg A', tv2)\n  xd = if F_is_zero Fp_2 xd' then Fp_2.mul(Z,A') else xd'\n    gxd = Fp_2.mul(xd, Fp_2.sq xd) \/\/ xd^3\n  gx1 = F_sum Fp_2 [Fp_2.mul(x1n, Fp_2.sq x1n), F_prod Fp_2 [A', x1n, Fp_2.sq xd], Fp_2.mul(B', gxd)]\n  tv4 = F_prod Fp_2 [gx1, gxd, Fp_2.sq gxd] \/\/ gx1 gxd^3\n  e2 = is_square tv4\n  xn = if e2 then x1n else x2n\n  y' = if e2\n        then F_prod Fp_2 [gx1, gxd, Fp_2.div (sqrt tv4, tv4)]\n        else F_prod Fp_2 [sqrt (Fp_2.div(ZZZ, tv4)), gx1, gxd, Fp_2.sq u, u]\n  y = if sgn0(u) == sgn0(y') then y' else Fp_2.neg y'\n  \/\/ convert to Jacobian coordinates\n  res = (Fp_2.mul (xn, xd), Fp_2.mul (y, gxd), xd)\n\n\/\/ other facts we would need for the proof\n\n_one_of_is_square u = Fp_2.is_val u \/\\ ~(is_square x) ==> is_square b where\n  b = Fp_2.mul (x, recip_ZZZ)\n  x = F_prod Fp_2 [gx1, gxd, Fp_2.sq gxd]\n  gxd = Fp_2.mul(xd, Fp_2.sq xd) \/\/ xd^3\n  gx1 = F_sum Fp_2 [Fp_2.mul(x1n, Fp_2.sq x1n), F_prod Fp_2 [A', x1n, Fp_2.sq xd], Fp_2.mul(B', gxd)]\n  Zuu = Fp_2.mul (Z, Fp_2.sq u)\n  tv2 = Fp_2.add (Fp_2.sq Zuu, Zuu)\n  x1n = Fp_2.mul (Fp_2.add (tv2, Fp_2.field_unit), B')\n  xd' = Fp_2.mul (Fp_2.neg A', tv2)\n  xd = if F_is_zero Fp_2 xd' then Fp_2.mul(Z,A') else xd'\n\n\/\/ It may be possible to use this instead of the above:\n\/\/ Fp_2.is_val x \/\\ ~(is_square x) ==> is_square (Fp_2.mul (x, recip_ZZZ))\n\/\/ Should be true because ZZZ is not a square, so dividing by it turns squares into nonsquares and vice versa\n\n_sqrt_align_prop x' = Fp_2.is_val x \/\\ is_square b ==>\n  Fp_2.sq (sqrt_align a ab b) == Fp_2.sq (Fp_2.div (sqrt b, b)) where\n    a = Fp_2.mul (F_expt`{n=758} Fp_2 x `((p^^2-9)\/16), F_expt`{n=758} Fp_2 ZZZ `((p^^2+7)\/16))\n    b = Fp_2.mul (x, recip_ZZZ)\n    ab = Fp_2.mul (a,b)\n    sqrt_align x y z = Fp_2.mul (x, sqrt_align_fp2_coeff y z)\n    recip_ZZZ = Fp_2.div (Fp_2.field_unit, ZZZ)\n    x = Fp_2.normalize x'\n\n_square_same_sign_prop x y u = Fp_2.sq x == Fp_2.sq y ==>\n  (if sgn0(x) == sgn0(u) then x else Fp_2.neg x) == (if sgn0(y) == sgn0(u) then y else Fp_2.neg y)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/Field.cry","filetype":"cry","content":"\/\/\n\/\/ Finite field representations in blst\n\/\/\n\nmodule implementation::Field where\n\nimport Common::Field\nimport implementation::Types\nimport Parameters ( p, Fp, t_Fp, to_Fp, from_Fp, t_Fp_2, Fp_2, t_Fp_6, Fp_6, t_Fp_12, Fp_12)\n\nmontgomery_factor_p: t_Fp\n\/\/ montgomery_factor_p = (2^^384) \/\/ NOT portable between Fp implementations.\nmontgomery_factor_p = Fp.mul (2^^4, 2^^380) \/\/ but this *is* portable\n\nmontgomery_factor_inverse_p: t_Fp\nmontgomery_factor_inverse_p = Fp.div(Fp.field_unit, montgomery_factor_p)\n\nfrom_mont: t_Fp -> t_Fp\nfrom_mont x = Fp.mul (x, montgomery_factor_inverse_p)\n\nto_mont: t_Fp -> t_Fp\nto_mont x = Fp.mul(x, montgomery_factor_p)\n\ntype Fp_rep_t = Vec384\n\nfp_abs: Fp_rep_t -> t_Fp\nfp_abs v = from_mont (to_Fp (vec384_abs v))\n\nfp_rep: t_Fp -> Fp_rep_t\nfp_rep x = vec384_rep (from_Fp (to_mont x))\n\nfp_invariant: Fp_rep_t -> Bool\nfp_invariant v = vec384_abs v < `p fp_normalize: Fp_rep_t -> Fp_rep_t\nfp_normalize x = vec384_rep (from_Fp (Fp.normalize (to_Fp (vec384_abs x))))\n\ntype Fp_2_rep_t = [2]Fp_rep_t\n\nfp2_abs: Fp_2_rep_t -> t_Fp_2\nfp2_abs [a,b] = [fp_abs b, fp_abs a]\n\nfp2_rep: t_Fp_2 -> Fp_2_rep_t\nfp2_rep [a,b] = [fp_rep b, fp_rep a]\n\nfp2_invariant: Fp_2_rep_t -> Bool\nfp2_invariant v = all fp_invariant v\n\nfp2_normalize: Fp_2_rep_t -> Fp_2_rep_t\nfp2_normalize [x,y] = [fp_normalize x, fp_normalize y]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Fpx2 is used in the implementation of the fp_12 tower.  Here, the results of a\n\/\/ multiplication are manipulated at their double width size (768 bits), before the\n\/\/ \"redc\" operation has been applied.  Addition and subtraction work modulo 2^384 p,\n\/\/ so we are no longer working in a field, but a ring.\n\n\/\/ Fp_2x2 is then built from Fp2x in the same way (a polynomial quotient ring) as Fp_2 is\n\/\/ built from Fp. Fp6x2 is similar, built from Fp2x2.\n\ntype Fpx2_rep_t = Vec768\ntype shifted_p = p * 2^^384\n\ntype t_Fpx2 = Integer\n\nfpx2_abs: Fpx2_rep_t -> t_Fpx2\nfpx2_abs x = toInteger (vec768_abs x)\n\nfpx2_rep: t_Fpx2 -> Fpx2_rep_t\nfpx2_rep x = vec768_rep (fromInteger x)\n\nfpx2_invariant v = (vec768_abs v) < `shifted_p\n\n\ntype Fp_2x2_rep_t = [2]Vec768\ntype t_Fp_2x2 = [2]t_Fpx2\n\nfp2x2_abs: Fp_2x2_rep_t -> t_Fp_2x2\nfp2x2_abs [x, y] = [fpx2_abs y, fpx2_abs x]\n\nfp2x2_rep: t_Fp_2x2 -> Fp_2x2_rep_t\nfp2x2_rep [x, y] = [fpx2_rep y, fpx2_rep x]\n\nfp2x2_invariant [x, y] = fpx2_invariant x \/\\ fpx2_invariant y\n\ntype Fp_6_rep_t = [3]Fp_2_rep_t\n\nfp6_abs [x,y,z] = [fp2_abs z, fp2_abs y, fp2_abs x]\nfp6_rep [x,y,z] = [fp2_rep z, fp2_rep y, fp2_rep x]\nfp6_invariant [x,y,z] = fp2_invariant x \/\\ fp2_invariant y \/\\ fp2_invariant z\nfp6_normalize [x,y,z] = [fp2_normalize x, fp2_normalize y, fp2_normalize z]\n\ntype t_Fp_6x2 = [3]t_Fp_2x2\nfp6x2_abs [x,y,z] = [fp2x2_abs z, fp2x2_abs y, fp2x2_abs x]\nfp6x2_rep [x,y,z] = [fp2x2_rep z, fp2x2_rep y, fp2x2_rep x]\nfp6x2_invariant [x,y,z] = fp2x2_invariant x \/\\ fp2x2_invariant y \/\\ fp2x2_invariant z\n\n\ntype Fp_12_rep_t = [2]Fp_6_rep_t\n\nfp12_abs: Fp_12_rep_t -> t_Fp_12\nfp12_abs [a,b] = [fp6_abs b, fp6_abs a]\n\nfp12_rep: t_Fp_12 -> Fp_12_rep_t\nfp12_rep [a,b] = [fp6_rep b, fp6_rep a]\n\nfp12_invariant: Fp_12_rep_t -> Bool\nfp12_invariant [x,y] = fp6_invariant x \/\\ fp6_invariant y\n\nfp12_normalize: Fp_12_rep_t -> Fp_12_rep_t\nfp12_normalize [x,y] = [fp6_normalize x, fp6_normalize y]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/CryptolHelpers.cry","filetype":"cry","content":"\/\/\n\/\/ A few extra useful functions for Cryptol\n\/\/\n\nmodule implementation::CryptolHelpers where\n\n\/\/ The low-precedence, right-associating \"$\" operator can make expressions\n\/\/ more readable by eliminating a lot of parentheses\n\/\/ Compare `f (f (g x))` and `f $ f $ g x`\n\ninfixr 1 $\n\n($): {s, t} (s->t) -> s -> t\nf $ x = f x\n\n\/\/ 'apply' is the same function: 'apply f x == f x'.  We sometimes use this to\n\/\/ make comnditional rewrite rules that do not loop infinitely\napply: {s, t} (s->t) -> s -> t\napply f x = f x\n","variant":"hybrid","set":"holdout"}
{"filename":"BLST-Verification\/spec\/implementation\/x86.cry","filetype":"cry","content":"module implementation::x86 where\n\nimport implementation::Types\nimport implementation::x86::helpers\n\nmulx_mont_384x\n  : Vec768   -> Vec768   -> Vec384    -> [64]   -> Vec768 mulx_mont_384x a b m n0 = result\n  where\n    t0 = __mulx_384 (take a) (take b)\n    t1 = __mulx_384 (drop a) (drop b)\n    t2 = __mulx_384 (__add_mod_384 (take b) (drop b) m) (__add_mod_384 (take a) (drop a) m)\n    t2' = __sub_mod_384x384 (__sub_mod_384x384 t2 t0 m) t1 m\n    t0' = __sub_mod_384x384 t0 t1 m\n    ret_re = redcx_mont_384 t0' m n0\n    ret_im = redcx_mont_384 t2' m n0\n    result = ret_re # ret_im\n\nsqrx_mont_384x\n  : Vec768   -> Vec384    -> [64]   -> Vec768 sqrx_mont_384x a m n0 = result\n  where\n    t0 = __add_mod_384 (take a) (drop a) m\n    t1 = __sub_mod_384 (take a) (drop a) m\n    tmp = mulx_mont_384 (take a) (drop a) m n0\n    ret_im = __add_mod_384 tmp tmp m\n    ret_re = mulx_mont_384 t0 t1 m n0\n    result = ret_re # ret_im\n\nmulx_382x\n  : Vec768   -> Vec768   -> Vec384    -> [2]Vec768 mulx_382x a b m = result\n  where\n    a_re = take a\n    a_im = drop a\n    (t0_cf_0, t0_0) = add (a_re @ 0) (a_im @ 0)\n    (t0_cf_1, t0_1) = adc (a_re @ 1) (a_im @ 1) t0_cf_0\n    (t0_cf_2, t0_2) = adc (a_re @ 2) (a_im @ 2) t0_cf_1\n    (t0_cf_3, t0_3) = adc (a_re @ 3) (a_im @ 3) t0_cf_2\n    (t0_cf_4, t0_4) = adc (a_re @ 4) (a_im @ 4) t0_cf_3\n    (_, t0_5) = adc (a_re @ 5) (a_im @ 5) t0_cf_4\n    b_re = take b\n    b_im = drop b\n    (t1_cf_0, t1_0) = add (b_re @ 0) (b_im @ 0)\n    (t1_cf_1, t1_1) = adc (b_re @ 1) (b_im @ 1) t1_cf_0\n    (t1_cf_2, t1_2) = adc (b_re @ 2) (b_im @ 2) t1_cf_1\n    (t1_cf_3, t1_3) = adc (b_re @ 3) (b_im @ 3) t1_cf_2\n    (t1_cf_4, t1_4) = adc (b_re @ 4) (b_im @ 4) t1_cf_3\n    (_, t1_5) = adc (b_re @ 5) (b_im @ 5) t1_cf_4\n    tmp_im_0 = __mulx_384 [t0_0, t0_1, t0_2, t0_3, t0_4, t0_5] [t1_0, t1_1, t1_2, t1_3, t1_4, t1_5]\n    tmp_re = __mulx_384 a_re b_re\n    tx = __mulx_384 a_im b_im\n    tmp_im_1 = __sub_mod_384x384 tmp_im_0 tx m\n    ret_im = __sub_mod_384x384 tmp_im_1 tmp_re m\n    ret_re = __sub_mod_384x384 tmp_re tx m\n    result = [ret_re, ret_im]\n\nsqrx_382x\n  : Vec768   -> Vec384    -> [2]Vec768 sqrx_382x a m = result\n  where\n    a_re = take a\n    a_im = drop a\n    (t0_cf_0, t0_0) = add (a_re @ 0) (a_im @ 0)\n    (t0_cf_1, t0_1) = adc (a_re @ 1) (a_im @ 1) t0_cf_0\n    (t0_cf_2, t0_2) = adc (a_re @ 2) (a_im @ 2) t0_cf_1\n    (t0_cf_3, t0_3) = adc (a_re @ 3) (a_im @ 3) t0_cf_2\n    (t0_cf_4, t0_4) = adc (a_re @ 4) (a_im @ 4) t0_cf_3\n    (_, t0_5) = adc (a_re @ 5) (a_im @ 5) t0_cf_4\n    t1 = __sub_mod_384 a_re a_im m\n    ret_re = __mulx_384 t1 [t0_0, t0_1, t0_2, t0_3, t0_4, t0_5]\n    tmp_im = __mulx_384 a_re a_im\n    (ret_im_cf_0, ret_im_0) = add (tmp_im @ 0) (tmp_im @ 0)\n    (ret_im_cf_1, ret_im_1) = adc (tmp_im @ 1) (tmp_im @ 1) ret_im_cf_0\n    (ret_im_cf_2, ret_im_2) = adc (tmp_im @ 2) (tmp_im @ 2) ret_im_cf_1\n    (ret_im_cf_3, ret_im_3) = adc (tmp_im @ 3) (tmp_im @ 3) ret_im_cf_2\n    (ret_im_cf_4, ret_im_4) = adc (tmp_im @ 4) (tmp_im @ 4) ret_im_cf_3\n    (ret_im_cf_5, ret_im_5) = adc (tmp_im @ 5) (tmp_im @ 5) ret_im_cf_4\n    (ret_im_cf_6, ret_im_6) = adc (tmp_im @ 6) (tmp_im @ 6) ret_im_cf_5\n    (ret_im_cf_7, ret_im_7) = adc (tmp_im @ 7) (tmp_im @ 7) ret_im_cf_6\n    (ret_im_cf_8, ret_im_8) = adc (tmp_im @ 8) (tmp_im @ 8) ret_im_cf_7\n    (ret_im_cf_9, ret_im_9) = adc (tmp_im @ 9) (tmp_im @ 9) ret_im_cf_8\n    (ret_im_cf_10, ret_im_10) = adc (tmp_im @ 10) (tmp_im @ 10) ret_im_cf_9\n    (_, ret_im_11) = adc (tmp_im @ 11) (tmp_im @ 11) ret_im_cf_10\n    ret_im = [ret_im_0, ret_im_1, ret_im_2, ret_im_3, ret_im_4, ret_im_5, ret_im_6, ret_im_7, ret_im_8, ret_im_9, ret_im_10, ret_im_11]\n    result = [ret_re, ret_im]\n\nredcx_mont_384\n  : Vec768 \/\/ a; pointer in rsi\n  -> Vec384 \/\/ m; pointer in rdx\n  -> [64] \/\/ n0; passed in rcx\n  -> Vec384 redcx_mont_384 a m n0 = result\n  where\n    acc = __mulx_by_1_mont_384 (take a) m n0\n    result = __redc_tail_mont_384 acc a m\nfromx_mont_384\n  : Vec384 \/\/ a; pointer in rsi\n  -> Vec384 \/\/ m; pointer in rdx\n  -> [64] \/\/ n0; passed in rcx\n  -> Vec384 fromx_mont_384 a m n0 = result\n  where\n    \n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0, r14_0, r15_0] = __mulx_by_1_mont_384 a m n0\n    rax_1 = r14_0\n    rcx_1 = r15_0\n    rdx_1 = r8_0\n    rbp_1 = r9_0\n    (cf_2, r14_2) = sub r14_0 (m @ 0)\n    (cf_3, r15_3) = sbb r15_0 (m @ 1) cf_2\n    r13_4 = r10_0\n    (cf_5, r8_5) = sbb r8_0 (m @ 2) cf_3\n    (cf_6, r9_6) = sbb r9_0 (m @ 3) cf_5\n    (cf_7, r10_7) = sbb r10_0 (m @ 4) cf_6\n    rsi_8 = r11_0\n    (cf_9, r11_9) = sbb r11_0 (m @ 5) cf_7\n    r14_10 = cmovb r14_2 rax_1 cf_9\n    r15_10 = cmovb r15_3 rcx_1 cf_9\n    r8_10 = cmovb r8_5 rdx_1 cf_9\n    r9_10 = cmovb r9_6 rbp_1 cf_9\n    r10_10 = cmovb r10_7 r13_4 cf_9\n    r11_10 = cmovb r11_9 rsi_8 cf_9\n    result = [r14_10, r15_10, r8_10, r9_10, r10_10, r11_10]\n\nsgn0x_pty_mont_384\n  : Vec384 \/\/ a; passed in rdi\n  -> Vec384 \/\/ p; passed in rsi\n  -> [64] \/\/ n0; passed in rdx\n  -> [64]\nsgn0x_pty_mont_384 a p n0 = result\n  where\n    \n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0, r14_0, r15_0] = __mulx_by_1_mont_384 a p n0\n    rax_1 = 0\n    r13_2 = r14_0\n    (cf_3, r14_3) = adcx r14_0 r14_0 False\n    (cf_4, r15_4) = adcx r15_0 r15_0 cf_3\n    (cf_5, r8_5) = adcx r8_0 r8_0 cf_4\n    (cf_6, r9_6) = adcx r9_0 r9_0 cf_5\n    (cf_7, r10_7) = adcx r10_0 r10_0 cf_6\n    (cf_8, r11_8) = adcx r11_0 r11_0 cf_7\n    (_, rax_9) = adcx rax_1 0 cf_8\n    (cf_10, r14_10) = sub r14_3 (p @ 0)\n    (cf_11, r15_11) = sbb r15_4 (p @ 1) cf_10\n    (cf_12, r8_12) = sbb r8_5 (p @ 2) cf_11\n    (cf_13, r9_13) = sbb r9_6 (p @ 3) cf_12\n    (cf_14, r10_14) = sbb r10_7 (p @ 4) cf_13\n    (cf_15, r11_15) = sbb r11_8 (p @ 5) cf_14\n    (_, rax_16) = sbb rax_9 0 cf_15\n    rax_17 = ~rax_16\n    r13_18 = r13_2 && (zext 0x1 : [64])\n    rax_18 = rax_17 && (zext 0x2 : [64])\n    result = rax_18 || r13_18\n\nsgn0x_pty_mont_384x\n  : Vec768 \/\/ a; passed in rdi\n  -> Vec384 \/\/ m; passed in rsi\n  -> [64] \/\/ n0; passed in rdx\n  -> [64]\nsgn0x_pty_mont_384x a m n0 = result\n  where\n    [r8_4, r9_4, r10_4, r11_4, r12_4, r13_4, r14_4, r15_4] = __mulx_by_1_mont_384 (drop a) m n0\n    r12_5 = r14_4\n    r14_6 = r14_4 || r15_4\n    r14_7 = r14_6 || r8_4\n    r14_8 = r14_7 || r9_4\n    r14_9 = r14_8 || r10_4\n    r14_10 = r14_9 || r11_4\n    rdi_12 = 0\n    r13_13 = r12_5\n    (cf_14, r12_14) = add r12_5 r12_5\n    (cf_15, r15_15) = adc r15_4 r15_4 cf_14\n    (cf_16, r8_16) = adc r8_4 r8_4 cf_15\n    (cf_17, r9_17) = adc r9_4 r9_4 cf_16\n    (cf_18, r10_18) = adc r10_4 r10_4 cf_17\n    (cf_19, r11_19) = adc r11_4 r11_4 cf_18\n    (cf_20, rdi_20) = adc rdi_12 0 cf_19\n    (cf_21, r12_21) = sub r12_14 (m @ 0)\n    (cf_22, r15_22) = sbb r15_15 (m @ 1) cf_21\n    (cf_23, r8_23) = sbb r8_16 (m @ 2) cf_22\n    (cf_24, r9_24) = sbb r9_17 (m @ 3) cf_23\n    (cf_25, r10_25) = sbb r10_18 (m @ 4) cf_24\n    (cf_26, r11_26) = sbb r11_19 (m @ 5) cf_25\n    (cf_27, rdi_27) = sbb rdi_20 0 cf_26\n    stack0 = r14_10\n    rdi_29 = ~rdi_27\n    r13_30 = r13_13 && zext 0x1\n    rdi_31 = rdi_29 && zext 0x2\n    rdi_32 = rdi_31 || r13_30\n    [r8_33, r9_33, r10_33, r11_33, r12_33, r13_33, r14_33, r15_33] = __mulx_by_1_mont_384 (take a) m n0\n    r12_34 = r14_33\n    r14_35 = r14_33 || r15_33\n    r14_36 = r14_35 || r8_33\n    r14_37 = r14_36 || r9_33\n    r14_38 = r14_37 || r10_33\n    r14_39 = r14_38 || r11_33\n    rax_40 = 0\n    r13_41 = r12_34\n    (cf_42, r12_42) = add r12_34 r12_34\n    (cf_43, r15_43) = adc r15_33 r15_33 cf_42\n    (cf_44, r8_44) = adc r8_33 r8_33 cf_43\n    (cf_45, r9_45) = adc r9_33 r9_33 cf_44\n    (cf_46, r10_46) = adc r10_33 r10_33 cf_45\n    (cf_47, r11_47) = adc r11_33 r11_33 cf_46\n    (cf_48, rax_48) = adc rax_40 0 cf_47\n    (cf_49, r12_49) = sub r12_42 (m @ 0)\n    (cf_50, r15_50) = sbb r15_43 (m @ 1) cf_49\n    (cf_51, r8_51) = sbb r8_44 (m @ 2) cf_50\n    (cf_52, r9_52) = sbb r9_45 (m @ 3) cf_51\n    (cf_53, r10_53) = sbb r10_46 (m @ 4) cf_52\n    (cf_54, r11_54) = sbb r11_47 (m @ 5) cf_53\n    (cf_55, rax_55) = sbb rax_48 0 cf_54\n    r12_56 = stack0\n    rax_57 = ~rax_55\n    zf_58 = r14_39 == 0\n    r13_59 = cmove r13_41 rdi_32 zf_58\n    zf_60 = r12_56 == 0\n    rax_61 = cmovne rax_57 rdi_32 zf_60\n    r13_62 = r13_59 && zext 0x1\n    rax_63 = rax_61 && zext 0x2\n    rax_64 = rax_63 || r13_62\n    result = rax_64\n\nmulx_mont_384\n  : Vec384 \/\/ a; passed in rsi\n  -> Vec384 \/\/ b; passed in rdx\n  -> Vec384 \/\/ m; passed in rcx\n  -> [64] \/\/ n0; passed in r8\n  -> Vec384 mulx_mont_384 a b m n0 = result\n  where\n    (r9, r8) = mulx (a @ 0) (b @ 0)\n    acc =\n      [ r8       , r9       , undefined       , undefined       , a @ 3       , undefined       , a @ 0       , a @ 1       , a @ 2 \/\/ rax\n      ]\n    lo = a @ 4\n    hi = a @ 5\n    result = __mulx_mont_384 acc (b @ 0) n0 lo hi a b m\n\nsqrx_n_mul_mont_383\n  : Vec384   -> Integer    -> Vec384   -> [64]   -> Vec384   -> Vec384 sqrx_n_mul_mont_383 a count m n0 b = result\n  where\n    mulx_mont_383_nonred x y = __mulx_mont_383_nonred [r8, r9, undefined, undefined, x @ 3, undefined, x @ 0, x @ 1, x @ 2] (y @ 0) n0 (x @ 4) (x @ 5) x y m\n      where (r9, r8) = mulx (x @ 0) (y @ 0)\n    loop counter acc =\n      if counter == 0\n      then acc\n      else loop (counter - 1) (mulx_mont_383_nonred acc acc)\n    result = mulx_mont_384 (loop count a) b m n0\n\nsqrx_mont_382x\n  : Vec768 \/\/ a; pointer in rsi\n  -> Vec384  \/\/ m; pointer in rdx\n  -> [64] \/\/ n0; passed in rcx\n  -> Vec768 sqrx_mont_382x a m n0 = result\n  where\n    mulx_mont_383_nonred x y = __mulx_mont_383_nonred [r8, r9, undefined, undefined, x @ 3, undefined, x @ 0, x @ 1, x @ 2] (y @ 0) n0 (x @ 4) (x @ 5) x y m\n      where (r9, r8) = mulx (x @ 0) (y @ 0)\n    a_re = take a\n    a_im = drop a\n    (t0_cf_0, t0_0) = add (a_re @ 0) (a_im @ 0)\n    (t0_cf_1, t0_1) = adc (a_re @ 1) (a_im @ 1) t0_cf_0\n    (t0_cf_2, t0_2) = adc (a_re @ 2) (a_im @ 2) t0_cf_1\n    (t0_cf_3, t0_3) = adc (a_re @ 3) (a_im @ 3) t0_cf_2\n    (t0_cf_4, t0_4) = adc (a_re @ 4) (a_im @ 4) t0_cf_3\n    (_, t0_5) = adc (a_re @ 5) (a_im @ 5) t0_cf_4\n    t0 = [t0_0, t0_1, t0_2, t0_3, t0_4, t0_5]\n    (t1_cf_0, t1_0) = sub (a_re @ 0) (a_im @ 0)\n    (t1_cf_1, t1_1) = sbb (a_re @ 1) (a_im @ 1) t1_cf_0\n    (t1_cf_2, t1_2) = sbb (a_re @ 2) (a_im @ 2) t1_cf_1\n    (t1_cf_3, t1_3) = sbb (a_re @ 3) (a_im @ 3) t1_cf_2\n    (t1_cf_4, t1_4) = sbb (a_re @ 4) (a_im @ 4) t1_cf_3\n    (gt, t1_5) = sbb (a_re @ 5) (a_im @ 5) t1_cf_4\n    t1 = [t1_0, t1_1, t1_2, t1_3, t1_4, t1_5]\n    tmp_im = mulx_mont_383_nonred a_re a_im\n    (ret_im_cf_0, ret_im_0) = add (tmp_im @ 0) (tmp_im @ 0)\n    (ret_im_cf_1, ret_im_1) = adc (tmp_im @ 1) (tmp_im @ 1) ret_im_cf_0\n    (ret_im_cf_2, ret_im_2) = adc (tmp_im @ 2) (tmp_im @ 2) ret_im_cf_1\n    (ret_im_cf_3, ret_im_3) = adc (tmp_im @ 3) (tmp_im @ 3) ret_im_cf_2\n    (ret_im_cf_4, ret_im_4) = adc (tmp_im @ 4) (tmp_im @ 4) ret_im_cf_3\n    (_, ret_im_5) = adc (tmp_im @ 5) (tmp_im @ 5) ret_im_cf_4\n    ret_im = [ret_im_0, ret_im_1, ret_im_2, ret_im_3, ret_im_4, ret_im_5]\n    tmp_re = mulx_mont_383_nonred t0 t1\n    mask = if gt then -1 else 0\n    t0_mask = [mask && (t0 @ 0), mask && (t0 @ 1), mask && (t0 @ 2), mask && (t0 @ 3), mask && (t0 @ 4), mask && (t0 @ 5)]\n    ret_re = __sub_mod_384 tmp_re t0_mask m\n    result = ret_re # ret_im\n\nmulx_mont_sparse_256\n  : Vec256 \/\/ a; passed in rsi\n  -> Vec256 \/\/ b; passed in rdx\n  -> Vec256 \/\/ m; passed in rcx\n  -> [64] \/\/ n0; passed in r8\n  -> Vec256 mulx_mont_sparse_256 a b m n0 = result\n  where\n    (r11, rax) = mulx (a @ 0) (b @ 0)\n    acc =\n      [ undefined       , r11       , undefined       , undefined       , a @ 0       , a @ 1       , rax \/\/ rax\n      ]\n    lo = a @ 2\n    hi = a @ 3\n    result = __mulx_mont_sparse_256 acc (b @ 0) n0 lo hi a b m\n\nredcx_mont_256\n  : Vec512 \/\/ a; pointer in rsi\n  -> Vec256 \/\/ m; pointer in rdx\n  -> [64] \/\/ n0; passed in rcx\n  -> Vec256 redcx_mont_256 a m n0 = result\n  where\n    [r10_0, r11_0, r12_0, r13_0, r14_0, r15_0] = __mulx_by_1_mont_256 (take a) m n0\n    (high_cf_0, high_0) = add r14_0 (a @ 4)\n    (high_cf_1, high_1) = adc r15_0 (a @ 5) high_cf_0\n    (high_cf_2, high_2) = adc r10_0 (a @ 6) high_cf_1\n    (high_cf_3, high_3) = adc r11_0 (a @ 7) high_cf_2\n    mask = if high_cf_3 then -1 else 0\n    (diff_cf_0, diff_0) = sub high_0 (m @ 0)\n    (diff_cf_1, diff_1) = sbb high_1 (m @ 1) diff_cf_0\n    (diff_cf_2, diff_2) = sbb high_2 (m @ 2) diff_cf_1\n    (diff_cf_3, diff_3) = sbb high_3 (m @ 3) diff_cf_2\n    (gt, _) = sbb mask 0 diff_cf_3\n    result0 = cmovae high_0 diff_0 gt\n    result1 = cmovae high_1 diff_1 gt\n    result2 = cmovae high_2 diff_2 gt\n    result3 = cmovae high_3 diff_3 gt\n    result = [result0, result1, result2, result3]\n\nfromx_mont_256\n  : Vec256 \/\/ a; pointer in rsi\n  -> Vec256 \/\/ m; pointer in rdx\n  -> [64] \/\/ n0; passed in rcx\n  -> Vec256 fromx_mont_256 a m n0 = result\n  where\n    [r10_0, r11_0, r12_0, r13_0, r14_0, r15_0] = __mulx_by_1_mont_256 a m n0\n    (diff_cf_0, diff_0) = sub r14_0 (m @ 0)\n    (diff_cf_1, diff_1) = sbb r15_0 (m @ 1) diff_cf_0\n    (diff_cf_2, diff_2) = sbb r10_0 (m @ 2) diff_cf_1\n    (diff_cf_3, diff_3) = sbb r11_0 (m @ 3) diff_cf_2\n    result0 = cmovae r14_0 diff_0 diff_cf_3\n    result1 = cmovae r15_0 diff_1 diff_cf_3\n    result2 = cmovae r10_0 diff_2 diff_cf_3\n    result3 = cmovae r11_0 diff_3 diff_cf_3\n    result = [result0, result1, result2, result3]","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/PairingImpl.cry","filetype":"cry","content":"\/*\n  The naive but mathematically correct definition of pairing in the Pairing module has\n  opportunities for substantial optimization.  Most of these are described, somewhat abstractly,\n  in Costello, Lange, and Naehrig \"Faster Pairing Computations on Curves with High-Degree Twists\"\n  (https:\/\/eprint.iacr.org\/2009\/615)\n\n  The reasoning behind these optimizations is too sophisticated for proof in SAW, and we will\n  instead summarize the mathematical argument here, define the resulting high-level algorithm\n  in Cryptol code, and (in a related SAW file), just assert that these two algorithms give the\n  same result.\n\n  There are several parts to the optimization:\n\n  (1) Costello, Lange, and Naehrig show in their Theorem 1 that the ate\n      pairing computation can be done by mapping to the twist E'\/Fp_12 rather\n      than to the main curve E\/Fp_12.\n\n  (2) We do not need to use a generic point_add routine because we can tell\n      exactly when we will be doubling and when we are adding to points with\n      distinct x coordinates.  That is, in the Miller loop, the values of T are\n      always smallish nonzero multiples of Q, which has order r.  So none of\n      these values are O, or Q, or -Q,\n\n  (3) Costello, Lange, and Naehrig also show that the line computation may be\n      done in Fp_2 rather than in Fp_12, as the factors of w that are\n      introduced get wiped out by the final exponentiation.\n\n  (4) We can eliminate division in computing the line function, even while using\n      projective coordinates for T.  Costello, Lange, and Naehrig explain how\n      (but in their paper using a different system of projective\n      coordinates).  Here, in the Jacobian system, we can retrace the\n      derivation; see below.  Again the key is that we can introduce factors that get\n      wiped out (mapped to 1) in the final exponentiation.\n\n  (5) A final trick used in the C code is to avoid negating Q, computing with\n      Q itself and then conjugating the final result.  This is OK, because for\n      points in Fp_12 that are in the cyclotomic subgroup, conjugation is\n      inversion, and the bilinearity of pairing shows\n\n           [-Q,P] = [Q,P]^{-1}\n\n      So computing with Q and conjugating at the end gives the correct result.\n*\/\n\nmodule implementation::PairingImpl where\n\nimport Parameters (t_Fp, t_Fp_2, t_Fp_6, t_Fp_12, Fp, Fp_2, Fp_12, Fp_to_Fp_2, E, E')\nimport Parameters as P\nimport ShortWeierstrassCurve as EC\nimport Common::Field (FieldRep)\nimport FieldExtras\nimport Frobenius (fp12_conjugate)\nimport implementation::Types (Size_t)\nimport implementation::Fp12 (fp6_to_fp12_xy00z0)\nimport implementation::CurveOperation (point_double, point_add_affine, normalize_point, normalize_affine_point)\n\n\/\/ Note: the layout of Fp_12 over Fp_2 is\n\/\/ [[a,c,e],[b,d,f]] represents a*w^5 + b*w^4 + c*w^3 + d*w^2 + e*w + f\n\n\/**\n * Take a point on E\/F_p to a point on E'\/F_p^12\n * This applies the sextic twist to the coordinates:\n * (x, y) :-> (w^2 x, w^3 y)\n *\/\nphi_3: EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_12\nphi_3 (x,y) = ([[z,z,z],[z,x',z]], [[z,y',z],[z,z,z]]) where\n   z = P::Fp_2.field_zero\n   x' = P::Fp_to_Fp_2 x    y' = P::Fp_to_Fp_2 y \/**\n * Take a point on E'\/F_p^2 to a point on E'\/F_p^12\n * This just injects the coordinates into the larger field\n *\/\nphi_4: EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp_12\nphi_4 (x,y) = (x',y') where\n    x' = P::Fp_2_to_Fp_12 x\n    y' = P::Fp_2_to_Fp_12 y\n\n\/*  For reference, computing the ate_pairing (leaving out the final exponentiation)\n    on the twist would look like this:\n\n     Here we also do the point arithmetic on E', rather than mapping up to the twist on Fp_12.\n     That's legitimate because the phi mappings are all homomorphisms.\n\nmiller_loop_twist: EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2 -> t_Fp_12\nmiller_loop_twist P Q =  last_f where\n   negQ = EC::neg P::E' Q\n   (last_f, _) = f_Ts ! 0\n   f_Ts = [(P::Fp_12.field_unit, negQ)] #\n          [ miller_step_twist P negQ fT ci | fT <- f_Ts | ci <- tail negative_t]\n\nmiller_step_twist:  EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2\n                    -> (t_Fp_12, EC::AffinePoint t_Fp_2)\n                    -> Bit -> (t_Fp_12, EC::AffinePoint t_Fp_2)\nmiller_step_twist P negQ (f, T) ci = (f', T') where\n    f0 = f12.mul (f12.sq f, line_function (phi_4 T) (phi_4 T) (phi_3 P))\n    T0 = EC::double P::E' T\n    (f', T') = if ci\n               then (P::Fp_12.mul (f0, line_function (phi_4 T0) (phi_4 negQ) (phi_3 P)),\n                     EC::add P::E' T0 negQ)\n               else (f0, T0)\n\n*\/\n\n\/* Note first that the generic line_function(A,B,P) tests whether A=B or A=-B.\n   We know when calling it when A=B occurs (in the doubling steps), and argued above that\n   A=-B never happens in the cases we care about.  So we can separate out two functions\n   `line_function_add` and `line_function_double`\n\n   line_function_add (A,B,P) = (B2-A2)\/(B1-A1)*(P1-A1) + A2 - P2\n   line_function_double (A,B,P) = (3 A1^2) \/ (2 A2) * (P1-A1) + A2 - P2\n\n   where A = (A1,A2), B=(B1,B2), and P=(P1, P2), in affine coordinates, and all on the twist\n*\/\n\n\/*\n  For the question of how to eliminate division, even when using projective\n  coordinates for A, Costello, Lange, and Naehrig explain how (but in their\n  paper using a different system of projective coordinates).  Here, in the\n  Jacobian system, we can retrace the derivation.\n\n  For the addition step, point A is the projective, non-point-at-infinity, T =\n  (xT:yT:zT), so A1 = xT\/zT^2 and A2 = yT\/zT^3.  B is point Q, already in\n  affine coordinates (xQ, yQ), so B1 = xQ, B2 = yQ, and P = (xP, yP) is in\n  affine coordinate on curve E and is mapped via phi_3 to curve E'.  Thus P1 =\n  w^2 xP, P2 = w^3 yP.  So we can compute the line_function output:\n\n    line_function_add(T, Q, P))\n  = (as defined above)\n    (B2-A2)\/(B1-A1)*(P1-A1) + A2 - P2\n  = (substituting these variables)\n    (yQ - yT\/zT^3)\/(xQ-xT\/zT^2) * (w^2 xP - xT\/zT^2) + yT\/zT^3 - w^3 yP\n  = (simplifying the fraction)\n    (yQ zT^3 - yT)\/(xQ zT^3 -xT zT) * (w^2 xP - xT\/zT^2) + yT\/zT^3 - w^3 yP\n\n  Now we can multiply this by any value in a proper subfield of Fp_12 without\n  affecting the result of the final exponentiation, which sends all such\n  values to 1.  So we can use a factor of k = (xQ zT^3 - xT zT) (which lies in\n  Fp_2) to eliminate most of the division:\n\n    k * line_function_add(T, Q, P)\n  = (algebra)\n    (yQ zT^3 - yT) (w^2 xP - xT\/zT^2) +  (xQ zT^3 - xT zT)(yT\/zT^3 - w^3 yP)\n  = (expand out, collect terms)\n     w^2 xP (yQ zT^3 - yT)\n     - w^3 yP (xQ zT^3 - xT zT)\n     - yQ xT zT + yT xT \/ zT^2 + xQ yT - xT yT \/ zT^2\n  = (cancel matching terms)\n     w^2 xP (yQ zT^3 - yT)\n     - w^3 yP (xQ zT^3 - xT zT)\n     - yQ xT zT + xQ yT\n\n  The C code produces -4 times these values, but as -4 in is a proper subfield\n  this does not affect the result of the final exponentiation.\n*\/\n\n\/\/ line_add_opt: (t_Fp_2,t_Fp_2,t_Fp_2) -> (t_Fp_2, t_Fp_2) -> (t_Fp,t_Fp) -> t_Fp_12\nline_add_opt: EC::ProjectivePoint t_Fp_2 -> EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nline_add_opt (xT, yT, zT) (xQ, yQ) (xP, yP) = ret where\n    xP' = Fp_to_Fp_2 xP\n    yP' = Fp_to_Fp_2 yP\n    l0 = Fp_2.sub (Fp_2.mul (yQ, Fp_2.mul (xT, zT)), Fp_2.mul (xQ, yT)) \/\/ yQ xT zT - xQ yT\n    l1 = Fp_2.mul (Fp_2.sub (yT, Fp_2.mul (yQ, zT3)), xP') \/\/ xP (yT - yQ zT^3)\n    l2 = Fp_2.mul (Fp_2.sub (Fp_2.mul (xQ, zT3), Fp_2.mul (xT, zT)), yP') \/\/ yP (xQ zT^3 - xT zT)\n    zT3 = Fp_2.mul (zT, Fp_2.sq zT) \/\/ zT^3\n    ret = fp6_to_fp12_xy00z0 [ mul_by_4 Fp_2 l2  \/\/ factor of w^3\n                             , mul_by_4 Fp_2 l1  \/\/ factor of w^2\n                             , mul_by_4 Fp_2 l0                              ]\n\n\/*\n  Similarly, for the doubling step, we have\n\n    line_function_dbl(T, Q, P)\n  = (definition)\n    (3 A1^2) \/ (2 A2) * (P1-A1) + A2 - P2\n  = (substitute the variables)\n    (3 xT^2 \/ zT^4) \/ (2 yT\/zT^3) * (w^2 xP - xT\/zT^2) + yT\/zT^3 - w^3 yP\n  = (simplify the fraction)\n    (3 xT^2) \/ (2 yT zT) * (w^2 xP - xT\/zT^2) + yT\/zT^3 - w^3 yP\n\n  This time we can use a factor of k' = (2 yT zT^3), also in Fp_2\n\n    k' * line_function_dbl(T, Q, P)\n  = (algebra)\n    (3 xT^2 zT^2) (w^2 xP - xT\/zT^2) + (2 yT zT^3) (yT\/zT^3 - w^3 yP)\n  = (expand out, collect terms)\n    3 w^2 xP xT^2 zT^2\n    - 2 w^3 yP yT zT^3\n   -  3 xT^3 + 2 yT^2\n\n  In this cases, the C code computes -2 times these values; again this does not\n  affect the result of the final exponentiation.\n*\/\n\n\/\/ line_double_opt: (t_Fp_2,t_Fp_2,t_Fp_2) -> (t_Fp,t_Fp) -> t_Fp_12\nline_double_opt: EC::ProjectivePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nline_double_opt (xT,yT,zT) (xP, yP) = ret where\n    xP' = P::Fp_to_Fp_2 xP\n    yP' = P::Fp_to_Fp_2 yP\n    l0 = Fp_2.sub (mul_by_3 Fp_2 (cubed xT), mul_by_2 Fp_2 (Fp_2.sq yT)) \/\/ 3xT^3 - 2yT^2\n    l1 = Fp_2.neg (mul_by_3 Fp_2 (Fp_2.mul (Fp_2.sq xT, Fp_2.mul (Fp_2.sq zT, xP')))) \/\/ -3 xP xT^2 zT^2\n    l2 = Fp_2.mul (mul_by_2 Fp_2 (Fp_2.mul (yT, cubed zT)), yP') \/\/ 2 yP yT zT^3\n\n    ret = fp6_to_fp12_xy00z0 [ mul_by_2 Fp_2 l2 \/\/ factor of w^3\n                             , mul_by_2 Fp_2 l1 \/\/ factor of w^2\n                             , mul_by_2 Fp_2 l0                              ]\n    cubed x = Fp_2.mul (x, Fp_2.sq x)\n\n\n\/* Putting all that together, with the conjugation trick of step 5, gives this function,\n   which we will use as a high-level specification for the C code. *\/\n\nmiller_step_opt:  EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2\n                    -> (t_Fp_12, EC::ProjectivePoint t_Fp_2)\n                    -> Bit\n                    -> (t_Fp_12, EC::ProjectivePoint t_Fp_2)\nmiller_step_opt P Q (f, T) ci = (f', T') where\n    f0 = Fp_12.mul (Fp_12.sq f, line_double_opt T P)\n    T0 = point_double Fp_2 T\n    (f', T') = if ci\n               then (Fp_12.mul (f0, line_add_opt T0 Q P),\n                     point_add_affine_alt Fp_2 T0 Q) \/\/ _alt, we know T and Q are not at infinity\n               else (f0, T0)\n\nmiller_loop_opt: EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2 -> t_Fp_12\nmiller_loop_opt P Q =  fp12_conjugate last_f where\n   (last_f, _) = f_Ts ! 0\n   f_Ts = [(Fp_12.field_unit, EC::projectify P::E' Q)] #\n          [ miller_step_opt P Q fT ci | fT <- f_Ts | ci <- tail negative_t]\n   \/\/ t = -2^63 - 2^62 - 2^60 - 2^57 - 2^48 - 2^16\n   negative_t:[64]\n   negative_t = <| x^^63 + x^^62 + x^^60 + x^^57 + x^^48 + x^^16 |>\n\n\nmiller_loop_opt_checked:  EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2 -> t_Fp_12\nmiller_loop_opt_checked P Q =\n    if EC::is_point_O E' Q  \\\/ EC::is_point_O E P\n    then Fp_12.field_unit\n    else miller_loop_opt P Q\n\n\/\/ This version avoids the extra check for z1 == 0, relative to point_add_affine\n\npoint_add_affine_alt: {t} FieldRep t -> EC::ProjectivePoint t -> EC::AffinePoint t -> EC::ProjectivePoint t\npoint_add_affine_alt F p1 p2 = p3 where\n    (x1, y1, z1) = normalize_point F p1\n    (x2, y2) = normalize_affine_point F p2\n    z1z1 = F.sq z1\n    h = F.mul(x2,z1z1)\n    r = F.mul(F.mul(y2,z1), z1z1)\n\n    h_1 = F.sub(h, x1)\n    hh = F.sq h_1\n    i = (F.add (hh,hh))\n    i_1 = F.add (i,i)\n\n    j = F.mul (h_1, i_1)\n\n    r_1 = F.sub(r, y1)\n    r_2 = F.add(r_1, r_1)\n\n    v = F.mul(x1, i_1)\n\n    x3 = F.sub(F.sub(F.sub(F.sq r_2, j), v), v)\n\n    j_1 = F.mul(j, y1)\n    y3 = F.sub(v, x3)\n    y3_1 = F.mul(y3, r_2)\n    y3_2 = F.sub(F.sub(y3_1, j_1), j_1)\n\n    z3 = F.add(z1,h_1)\n    z3_1 = F.sq z3\n    z3_2 = F.sub (z3_1, z1z1)\n    z3_3 = F.sub (z3_2, hh)\n\n    p3 = (x3, y3_2, z3_3)\n\nlshift_fp: t_Fp -> Size_t -> t_Fp\nlshift_fp a c = shifts @ c where shifts = [a] # [Fp.add (a',a') | a' <- shifts ]\n\nlshift_fp2: t_Fp_2 -> Size_t -> t_Fp_2\nlshift_fp2 [a1,a0] c = [lshift_fp a1 c, lshift_fp a0 c]\n\nline_by_Px2: t_Fp_6 -> (t_Fp, t_Fp) -> t_Fp_6\nline_by_Px2 [[l2_1, l2_0], [l1_1, l1_0], l0]  (Px, Py) = [l2', l1', l0] where\n    l1' = [Fp.mul (l1_1, Px), Fp.mul (l1_0, Px)]\n    l2' = [Fp.mul (l2_1, Py), Fp.mul (l2_0, Py)]\n\nline_double_imp: (t_Fp_2, t_Fp_2, t_Fp_2) -> t_Fp_6\nline_double_imp (X1, Y1, Z1) = [l2, l1, l0] where\n    A = Fp_2.sq X1\n    E = mul_by_3 Fp_2 A\n    F = Fp_2.sq E\n    B = Fp_2.sq Y1\n    l0_a = Fp_2.add (E, X1)\n    l0_b = Fp_2.sub (Fp_2.sq l0_a, A)\n    l0_c = Fp_2.sub (l0_b, F)\n    l0 = Fp_2.sub (l0_c, lshift_fp2 B 2)\n    l1 = Fp_2.mul (mul_by_3 Fp_2 (Fp_2.sq X1), Fp_2.sq Z1)\n    l2 = Fp_2.mul (Fp_2.mul (Fp_2.add (Z1, Z1), Y1), Fp_2.sq Z1)\n\nline_add_imp (x1,y1,z1) (x2,y2) = [l2, l1, l0] where\n    F = Fp_2\n    z1z1 = F.sq z1\n    h = F.mul(x2,z1z1)\n    r = F.mul(F.mul(y2,z1), z1z1)\n\n    h_1 = F.sub(h, x1)\n    hh = F.sq h_1\n    i = (F.add (hh,hh))\n    i_1 = F.add (i,i)\n\n    r_1 = F.sub(r, y1)\n    r_2 = F.add(r_1, r_1)\n\n    z3 = F.add(z1,h_1)\n    z3_1 = F.sq z3\n    z3_2 = F.sub (z3_1, z1z1)\n    z3_3 = F.sub (z3_2, hh)\n\n    l0 = mul_by_2 F (F.sub (F.mul (r_2, x2), F.mul (y2, z3_3)))\n    l1 = r_2\n    l2 = z3_3\n\nstart_dbl_n_imp: {n} (fin n, n >= 1) => [n](t_Fp_2, t_Fp_2, t_Fp_2) -> [n](t_Fp, t_Fp) -> t_Fp_12\nstart_dbl_n_imp Ts Px2s = rets!0 where\n    line_a = line_double_imp (Ts@0)\n    line_b = line_by_Px2 line_a (Px2s@0)\n    ret_a = fp6_to_fp12_xy00z0 line_b\n    \/\/ standard loop-to-comprehension transcription of the C code\n    rets = [ret_a] # [Fp_12.mul (ret,  fp6_to_fp12_xy00z0 line) | ret <- rets | line <- lines]\n    lines = [line_by_Px2 (line_double_imp T) P | T <- tail Ts | P <- tail Px2s]\n\n\/\/ effect of one point.\nstart_dbl_1: (t_Fp_2, t_Fp_2, t_Fp_2) -> (t_Fp, t_Fp) -> t_Fp_12\nstart_dbl_1 T Px2 = ret where\n    line_a = line_double_imp T\n    line_b = line_by_Px2 line_a Px2\n    ret = fp6_to_fp12_xy00z0 line_b\n\n\/\/ effect on point T -- each of the T_i, Q_i affected independently in the same way\n\/\/ named _alt to avoid conflict with the definition in HashToG2.cry\nadd_n_dbl_alt: {k} (fin k) => EC::ProjectivePoint t_Fp_2 ->  EC::AffinePoint t_Fp_2 -> EC::ProjectivePoint t_Fp_2\nadd_n_dbl_alt T Q = doubles@`k where\n    doubles = [point_add_affine_alt Fp_2 T Q] # [ point_double Fp_2 D | D <- doubles]\n\n\/\/ effect on ret - n=1 case\nadd_n_dbl_ret: {k} (fin k) =>\n      t_Fp_12 -> EC::ProjectivePoint t_Fp_2 -> EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nadd_n_dbl_ret r T Q Px2 = rets@`k where\n    ret_a = Fp_12.mul (r, fp6_to_fp12_xy00z0 (line_by_Px2 (line_add_imp T Q) Px2))\n    T_a = point_add_affine_alt Fp_2 T Q\n    \/\/ standard loop-to-comprehension transcription of the C code, for the loop on `k`\n    Ts = [T_a] # [point_double Fp_2 Ti | Ti <- Ts]\n    lines = [line_by_Px2 (line_double_imp Ti) Px2 | Ti <- Ts ]\n    rets = [ret_a] # [Fp_12.mul (Fp_12.sq ret, fp6_to_fp12_xy00z0 line) | ret <- rets | line <- lines]\n\n\/\/ and for n >= 1\nadd_n_dbl_n_ret: {n, k} (fin n, n >= 1, fin k) =>\n     t_Fp_12 ->[n](EC::ProjectivePoint t_Fp_2) -> [n](EC::AffinePoint t_Fp_2) -> [n](EC::AffinePoint t_Fp)\n     -> t_Fp_12\nadd_n_dbl_n_ret r Ts Qs Px2s = F_prod Fp_12 rets where\n    rets = [add_n_dbl_ret`{k} r (Ts@0) (Qs@0) (Px2s@0)] #\n           [add_n_dbl_ret`{k} Fp_12.field_unit T Q Px2 | T <- tail Ts | Q <- tail Qs | Px2 <- tail Px2s]\n\n\/\/\/\/ miller_loop_n\n\nmiller_loop_imp: EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nmiller_loop_imp Q P = fp12_conjugate ret_f where\n    (xP, yP) = P\n    Px2 = (Fp.neg (Fp.add (xP, xP)), Fp.add (yP, yP))\n    (xQ, yQ) = Q\n    T = (xQ, yQ, Fp_2.field_unit)\n    ret_a = start_dbl_n_imp [T] [Px2]\n    T_a = point_double Fp_2 T\n    ret_b = add_n_dbl_ret`{2} ret_a T_a Q Px2\n    T_b = add_n_dbl_alt`{2} T_a Q\n    ret_c = add_n_dbl_ret`{3} ret_b T_b Q Px2\n    T_c = add_n_dbl_alt`{3} T_b Q\n    ret_d = add_n_dbl_ret`{9} ret_c T_c Q Px2\n    T_d = add_n_dbl_alt`{9} T_c Q\n    ret_e = add_n_dbl_ret`{32} ret_d T_d Q Px2\n    T_e = add_n_dbl_alt`{32} T_d Q\n    ret_f = add_n_dbl_ret`{16} ret_e T_e Q Px2\n\nmiller_loop_n_1_imp:  EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nmiller_loop_n_1_imp Q P = (if Q == (z2,z2) \\\/ P == (z1,z1)\n                           then Fp_12.field_unit\n                           else miller_loop_imp Q P) where\n    z1 = Fp.field_zero\n    z2 = Fp_2.field_zero\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/Keygen.cry","filetype":"cry","content":"module implementation::Keygen where\n\n\/\/ Definitions needed for the code proof of blst_keygen\n\nimport Parameters as P\nimport Primitive::Keyless::Hash::SHA256\nimport Primitive::Symmetric::KDF::HKDF256\nimport rfc8017\n\nimport Common::bv\n\nimport implementation::Types\nimport implementation::Field\n\n\/\/ Implementation types - now in implementation::Types\n\/\/\n\/*\ntype Vec256 = [4][64]\ntype Vec384 = [6][64]\ntype Vec512 = [8][64]\n\ntype Limb = [64]\n\ntype Pow256 = [32][8]\n\n\/\/ Vectors represent numbers, using a little-endian representation\n\n\/**\n * The integer represented by a vector (Vec256, Vec384, ...)\n *\/\nvec_abs: {n} (fin n) => [n]Limb -> [n*64]\nvec_abs limbs = join (reverse limbs)\n\nvec256_abs x = vec_abs`{256\/64} x\nvec512_abs = vec_abs`{512\/64}\n\n\/**\n * A vector representing a given integer.  The integer should be non-negative.\n *\/\nvec_rep:  {n} (fin n) => [n*64] -> [n]Limb\nvec_rep x = reverse (split x)\n\nvec256_rep x = vec_rep`{256\/64} x\n*\/\n\n\/\/ Pow256 uses a little-endian representation\n\npow256_abs: Pow256 -> [256]\npow256_abs x = join (reverse x)\n\n\/\/ for Montgomery mod r\n\nr_modulus = toInteger P::r \/\/ 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001 \/\/ r\n\nr_R = 2^^256\n\nr_R_inv = toInteger 0x1bbe869330009d577204078a4f77266aab6fca8f09dc705f13f75b69fe75c040\n\nr_RR = 2^^512\n\n\/\/ Montgomery representation of values; Integer form\n\nr_R_reduced = r_R % r_modulus\nr_RR_reduced = r_RR % r_modulus\nr_R_inv_reduced = r_R_inv % r_modulus\n\nr_to_mont x = (x*r_R) % r_modulus\n\nr_from_mont x = (x*r_R_inv) % r_modulus\n\nr_add_mont x y = (x+y) % r_modulus\n\nr_mul_mont x y = (x*y*r_R_inv) % r_modulus\n\nproperty keygen_finish_integer x = r_mul_mont (r_from_mont x) (2^^512 % r_modulus) == (x % r_modulus)\n\n\/\/ ... and bitvector form\n\nbv_r = (fromInteger r_modulus):[256] \/\/ = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\nbv_R = (fromInteger r_R_reduced):[256]\nbv_R_inv = (fromInteger r_R_inv):[256] \/\/ = 0x1bbe869330009d577204078a4f77266aab6fca8f09dc705f13f75b69fe75c040\nbv_RR = (fromInteger r_RR_reduced):[256]\n\nmul_mont_r_bv: [256] -> [256] -> [256]\nmul_mont_r_bv a b = safe_mod (bv_r, safe_product (zext a, safe_product (b, bv_R_inv)))\n\nredc_r_bv: [512] -> [256]\nredc_r_bv x = safe_mod (bv_r, safe_product (x, zext bv_R_inv))\n\nproperty keygen_finish_bv x =\n  safe_mod (bv_r, x) == mul_mont_r_bv (redc_r_bv x) bv_RR\n\n\/\/ concretized versions\n\n\/\/ r_modulus_rep = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\n\nmul_mont_256_rep: Vec256 -> Vec256 -> Vec256\nmul_mont_256_rep x y = vec256_rep (mul_mont_r_bv (vec256_abs x) (vec256_abs y))\n\nr_redc_rep: Vec512 -> Vec256\nr_redc_rep x = vec256_rep (redc_r_bv (vec512_abs x))\n\nr_RR_rep: Vec256 \/\/ representing R^2 mod r\nr_RR_rep = [14526898881837571181, 3129137299524312099, 419701826671360399, 524908885293268753]\n\n\/\/ property p2 x = mul_mont_256_rep (from_mont_rep x) RR == (x % r_modulus_rep)\n\nlimbs_from_be_bytes_rep48: [48][8] -> [6]Limb\nlimbs_from_be_bytes_rep48 bytes = reverse (split (join bytes))\n\nle_bytes_from_limbs_rep4: Vec256 -> Pow256\nle_bytes_from_limbs_rep4 limbs = reverse (split (join (reverse limbs)))\n\nproperty le_bytes_from_limbs_rep4_prop limbs =\n    pow256_abs (le_bytes_from_limbs_rep4 limbs) == vec256_abs limbs\n\n\/**\n * KeyGen as implemented in the code\n *\/\nKeyGenStep_rep: {IKM_len, info_len} (validHMACSizes 20 (1+IKM_len)\n                                    , validHMACSizes 32 (35+info_len)\n                                    ) =>\n        [256] -> [IKM_len][8] -> [info_len][8] -> Vec256\nKeyGenStep_rep salt IKM key_info = SK where\n    type L = (3 * 256) \/^ 16 \/\/ (ceil lg2 r) = 256, so L = 3*16=48\n    PRK = HKDF_Extract (split salt) (IKM # [0]) \/\/ I2OSP`{xLen=1} 0)\n    OKM = HKDF_Expand`{L=L} PRK (key_info # I2OSP`{xLen=2} `L)\n    OKM_vec = (limbs_from_be_bytes_rep48 OKM) # [0,0]\n    SK = mul_mont_256_rep (r_redc_rep OKM_vec) r_RR_rep\n\nKeyGenLoop_rep: {IKM_len, info_len} (validHMACSizes 20 (1+IKM_len)\n                                    , validHMACSizes 32 (35+info_len)\n                                    ) =>\n        [256] -> [IKM_len][8] -> [info_len][8] -> [inf]Vec256\nKeyGenLoop_rep salt IKM info = keys where\n    salts = [salt] # [sha salt' | salt' <- salts]\n    keys = [zero] #\n           \/\/ hang on to a nonzero key, try again with revised salt otherwise\n           [if k == zero then key_gen_step salt' else k | k <- keys | salt' <- salts]\n    key_gen_step s = KeyGenStep_rep s IKM info\n\nKeyGen_rep: {IKM_len, info_len} ( validHMACSizes 20 (1+IKM_len)\n                                , validHMACSizes 32 (35+info_len)\n                                ) =>\n        ([IKM_len][8], [info_len][8]) -> Pow256\nKeyGen_rep (IKM, key_info) = le_bytes_from_limbs_rep4 SK_vec where\n    SK_vec = (KeyGenLoop_rep (sha (join \"BLS-SIG-KEYGEN-SALT-\")) IKM key_info) @ 4\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/CurveOperation.cry","filetype":"cry","content":"module implementation::CurveOperation where\n\nimport Common::Field\nimport FieldExtras\nimport Parameters (t_Fp, to_Fp, t_Fp_2, Fp, Fp_2, E, E')\nimport ShortWeierstrassCurve\nimport ProjectiveCurveOperations\nimport implementation::Types\nimport implementation::Field\n\n\n\/\/ We have two different  \"abstraction\" functions for projective points.\n\/\/ The first maps concrete representation of points in projective coordinates\n\/\/ to abtract representations (as a triple of field elements), still in\n\/\/ projective coordinates.  The second takes the concrete representations to\n\/\/ affine coordinates.\n\/\/\n\/\/ Mapping to affine is useful because there are two different projective addition\n\/\/ operations used in the code, which do not give the same projective coordinates\n\/\/ for the sum.  They do however agree on the point represented.  So in the affine\n\/\/ space, these give the same result.\n\n\ntype POINTonE1_t = (Vec384, Vec384, Vec384)\ntype POINTonE1_affine_t = (Vec384, Vec384)\n\nPOINTonE1_invariant: POINTonE1_t -> Bool\nPOINTonE1_invariant (x,y,z) = fp_invariant x \/\\ fp_invariant y \/\\ fp_invariant z\n   POINTonE1_abs: POINTonE1_t -> ProjectivePoint t_Fp\nPOINTonE1_abs (x,y,z) = (fp_abs x, fp_abs y, fp_abs z)\n\nPOINTonE1_rep: ProjectivePoint t_Fp -> POINTonE1_t\nPOINTonE1_rep (x,y,z) = (fp_rep x, fp_rep y, fp_rep z)\n\nPOINTonE1_normalize: POINTonE1_t -> POINTonE1_t\nPOINTonE1_normalize (x,y,z) = (fp_normalize x, fp_normalize y, fp_normalize z)\n\nPOINTonE1_abs': POINTonE1_t -> AffinePoint t_Fp\nPOINTonE1_abs' p = affinify E (POINTonE1_abs p)\n\nPOINTonE1_affine_invariant: POINTonE1_affine_t -> Bool\nPOINTonE1_affine_invariant (x,y) = fp_invariant x \/\\ fp_invariant y\n   POINTonE1_affine_abs: POINTonE1_affine_t -> AffinePoint t_Fp\nPOINTonE1_affine_abs (x,y) = (fp_abs x, fp_abs y)\n\nPOINTonE1_affine_rep: AffinePoint t_Fp -> POINTonE1_affine_t\nPOINTonE1_affine_rep (x,y) = (fp_rep x, fp_rep y)\n\ntype POINTonE2_t = (Fp_2_rep_t, Fp_2_rep_t, Fp_2_rep_t)\ntype POINTonE2_affine_t = (Fp_2_rep_t, Fp_2_rep_t)\n\nPOINTonE2_invariant: POINTonE2_t -> Bool\nPOINTonE2_invariant (x,y,z) = fp2_invariant x \/\\ fp2_invariant y \/\\ fp2_invariant z\n   POINTonE2_abs: POINTonE2_t -> ProjectivePoint t_Fp_2\nPOINTonE2_abs (x,y,z) = (fp2_abs x, fp2_abs y, fp2_abs z)\n\nPOINTonE2_rep: ProjectivePoint t_Fp_2-> POINTonE2_t\nPOINTonE2_rep (x,y,z) = (fp2_rep x, fp2_rep y, fp2_rep z)\n\nPOINTonE2_normalize: POINTonE2_t -> POINTonE2_t\nPOINTonE2_normalize (x,y,z) = (fp2_normalize x, fp2_normalize y, fp2_normalize z)\n\nPOINTonE2_affine_invariant: POINTonE2_affine_t -> Bool\nPOINTonE2_affine_invariant (x,y) = fp2_invariant x \/\\ fp2_invariant y\n   POINTonE2_affine_abs: POINTonE2_affine_t -> AffinePoint t_Fp_2\nPOINTonE2_affine_abs (x,y) = (fp2_abs x, fp2_abs y)\n\nPOINTonE2_affine_rep: AffinePoint t_Fp_2 -> POINTonE2_affine_t\nPOINTonE2_affine_rep (x,y) = (fp2_rep x, fp2_rep y)\n\nnormalize_affine_point: {t} FieldRep t ->  AffinePoint t -> AffinePoint t\nnormalize_affine_point F (x, y) = (F.normalize x, F.normalize y)\n\nnormalize_point:  {t} FieldRep t -> ProjectivePoint t -> ProjectivePoint t\nnormalize_point F (x, y, z) = (F.normalize x, F.normalize y, F.normalize z)\n\n\/\/ e1_op f x y = POINTonE1_rep (f E (POINTonE1_abs x) (POINTonE1_abs y))\n\n\/\/ algorithms from transcription of the C code\n\/\/ assignments in straight-line code are transcribed to definitions in a `where` block\n\/\/ NOTE: where variables are assigned to multiple times, we name each with a suffix,\n\/\/ _1, _2, etc.  Some care is needed to be sure to refer to the correct name.\n\n\/\/ If cryptol had \"where*\" or \"let*\" this would be easier.\n\n\/\/ In some places a raw input is normalized, which gives us some nicer theorems\n\/\/ in particular for the abs_rep rules.  This should not affect the correspondence with\n\/\/ the code because the inputs there are all assumed to satisfy the invariant.\n\npoint_dadd: {t} FieldRep t -> ProjectivePoint t -> ProjectivePoint t -> t -> Bit -> ProjectivePoint t\npoint_dadd F p1 p2  a4 a4_is_null = out where\n    (x1, y1, z1) = normalize_point F p1\n    (x2, y2, z2) = normalize_point F p2\n    dbl_h = F.add (y1, y1)     dbl_r = F.sq x1\n    dbl_sx = F.add (x1, x1)\n    dbl_r_1 = mul_by_3 F dbl_r\n\n    add_h = F.sq z1\n    x3 = F.sq z2\n    z3 = F.mul (z1, z2)     dbl_r_2 = if a4_is_null\n              then dbl_r_1\n              else F.add (dbl_r_1, F.mul (F.sq add_h, a4)) \/* R = 3*X1^2+a*Z1^4 *\/\n\n    y3 = F.mul (y1, z2) \/\/  mul_##field(p3.Y, p1->Y, p2->Z);\n    add_r = F.mul (y2, z1)\n    y3_1 = F.mul (y3, x3)\n    add_r_1 = F.mul (add_r, add_h)\n\n    x3_1 = F.mul (x3, x1) \/\/ mul_##field(p3.X, p3.X, p1->X);     \/* U1 = X1*Z2^2 *\/\n    add_h_1 = F.mul (add_h, x2)\n\n    add_r_2 = F.sub (add_r_1, y3_1) \/\/ sub_##field(add.R, add.R, p3.Y);    \/* R = S2-S1 *\/\n    add_sx = F.add (add_h_1, x3_1)\n    add_h_2 = F.sub (add_h_1, x3_1)\n\n    \/* make the choice between addition and doubling *\/\n    is_dbl = F_is_zero F add_h_2 \/\\ F_is_zero F add_r_2\n    (x3_2, y3_2, z3_1) = select (x1, y1,z1) (x3_1, y3_1, z3) is_dbl\n    (add_h_3, add_r_3, add_sx_1) = select (dbl_h, dbl_r_2, dbl_sx) (add_h_2, add_r_2, add_sx) is_dbl\n\n    dbl_h_1 = F.sq add_h_3 \/\/ sqr_##field(dbl.H, add.H);          \/* H^2 *\/\n    dbl_r_3 = F.mul (add_h_3, y3_2)\n    y3_3 = F.mul (dbl_h_1, x3_2)\n    dbl_r_4 = F.mul (dbl_r_3, dbl_h_1)\n\n    dbl_h_2 = F.mul (dbl_h_1, add_sx_1) \/\/ mul_##field(dbl.H, dbl.H, add.sx);  \/* H^2*sx *\/\n    x3_3 = F.sq add_r_3          \/\/ sqr_##field(p3.X, add.R);           \/* R^2 *\/\n    x3_4 = F.sub (x3_3, dbl_h_2) \/\/ sub_##field(p3.X, p3.X, dbl.H);     \/* X3 = R^2-H^2*sx *\/\n\n    y3_4 = F.sub(y3_3, x3_4)     \/\/ sub_##field(p3.Y, p3.Y, p3.X);      \/* H^2*U1-X3 *\/\n    y3_5 = F.mul (y3_4, add_r_3) \/\/ mul_##field(p3.Y, p3.Y, add.R);     \/* R*(H^2*U1-X3) *\/\n    y3_6 = F.sub (y3_5, dbl_r_4) \/\/ sub_##field(p3.Y, p3.Y, dbl.R);     \/* Y3 = R*(H^2*U1-X3)-H^3*S1 *\/\n\n    z3_2 = F.mul (z3_1, add_h_3) \/\/ mul_##field(p3.Z, p3.Z, add.H);     \/* Z3 = H*Z1*Z2 *\/\n\n    p3 = select (x1, y1, z1) (x3_4, y3_6,z3_2) (F_is_zero F z2)\n    out = select (x2, y2, z2) p3 (F_is_zero F z1)\n\n\npoint_dadd_affine: {t} FieldRep t -> ProjectivePoint t -> AffinePoint t  -> ProjectivePoint t\npoint_dadd_affine F p1 p2 = out where\n    (x1, y1, z1) = normalize_point F p1\n    (x2, y2) = normalize_affine_point F p2\n    dbl_h = F.add (y2, y2)     dbl_sx = F.add (x2, x2)\n    dbl_r= mul_by_3 F (F.sq x2)\n\n    add_r = F.mul (F.mul(F.sq z1, z1), y2) \/\/ y2*z1^3\n    add_h = F.mul (F.sq z1, x2) \/\/ x2*z1^2\n\n    add_sx = F.add(add_h, x1)\n    add_h_1 = F.sub(add_h, x1)\n    add_r_1 = F.sub(add_r, y1)\n\n    z3 = F.mul (add_h_1, z1)     \/* make the choice between addition and doubling *\/\n    is_dbl = F_is_zero F add_h_1 \/\\ F_is_zero F add_r_1\n    \/\/ new names here picked to confom to point_dadd\n    (x3_2, y3_2, z3_1) = select (x2, y2, dbl_h)  (x1, y1, z3) is_dbl\n    (add_h_3, add_r_3, add_sx_1) = select (dbl_h, dbl_r, dbl_sx) (add_h_1, add_r_1, add_sx) is_dbl\n\n    dbl_h_1 = F.sq add_h_3 \/\/ sqr_##field(dbl.H, add.H);          \/* H^2 *\/\n    dbl_r_3 = F.mul (add_h_3, y3_2)\n    y3_3 = F.mul (dbl_h_1, x3_2)\n    dbl_r_4 = F.mul (dbl_r_3, dbl_h_1)\n\n    dbl_h_2 = F.mul (dbl_h_1, add_sx_1) \/\/ mul_##field(dbl.H, dbl.H, add.sx);  \/* H^2*sx *\/\n    x3_3 = F.sq add_r_3          \/\/ sqr_##field(p3.X, add.R);           \/* R^2 *\/\n    x3_4 = F.sub (x3_3, dbl_h_2) \/\/ sub_##field(p3.X, p3.X, dbl.H);     \/* X3 = R^2-H^2*sx *\/\n\n    y3_4 = F.sub(y3_3, x3_4)     \/\/ sub_##field(p3.Y, p3.Y, p3.X);      \/* H^2*U1-X3 *\/\n    y3_5 = F.mul (y3_4, add_r_3) \/\/ mul_##field(p3.Y, p3.Y, add.R);     \/* R*(H^2*U1-X3) *\/\n    y3_6 = F.sub (y3_5, dbl_r_4) \/\/ sub_##field(p3.Y, p3.Y, dbl.R);     \/* Y3 = R*(H^2*U1-X3)-H^3*S1 *\/\n\n    p1inf = F_is_zero F z1\n    p2inf = (F_is_zero F x2) \/\\ (F_is_zero F y2) \/\/ Note check p2=(0,0)\n    p3 = select (x1, y1, z1) (x3_4, y3_6,z3_1) p2inf\n    \/\/ out = select (x2, y2, F.field_unit) p3 (F_is_zero F z1)\n    x' = select x2 p3.0 p1inf\n    y' = select y2 p3.1 p1inf\n    z' = select F.field_unit p3.2 (p1inf && (~ p2inf))\n    out = (x',y',z')\n\n\npoint_add: {t} FieldRep t -> ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\npoint_add F p1 p2 = out where\n    (x1, y1, z1) = normalize_point F p1\n    (x2, y2, z2) = normalize_point F p2\n    z1z1 = F.sq z1\n    z2z2 = F.sq z2\n    u1 = F.mul (x1, z2z2)\n    h = F.mul(x2,z1z1)\n    s1 = F.mul(F.mul(y1,z2), z2z2)\n    r = F.mul(F.mul(y2,z1), z1z1)\n    h_1 = F.sub(h, u1)\n    i = F.sq (F.add (h_1,h_1))\n    j = F.mul (h_1, i)\n    r_1 = F.sub(r, s1)\n    r_2 = F.add(r_1, r_1)\n    v = F.mul(u1, i)\n\n    x3 = F.sub(F.sub(F.sub(F.sq(r_2),j),v), v)\n\n    y3 = F.sub(v, x3)\n    y3_1 = F.mul(y3, r_2) \/\/ NOTE: p_add_bl swaps the order of this product.\n    s1_1 = F.mul(s1, j)\n    y3_2 = F.sub(F.sub(y3_1, s1_1),s1_1)\n\n    z3 = F.add(z1,z2)\n    z3_1 = F.sq z3\n    z3_2 = F.sub (z3_1, z1z1)\n    z3_3 = F.sub (z3_2, z2z2)\n    z3_4 = F.mul (z3_3, h_1)\n\n    p3 = select (x1,y1,z1) (x3, y3_2, z3_4) (F.is_equal (z2, F.field_zero))\n    out = select (x2,y2,z2) p3 (F.is_equal (z1, F.field_zero))\n\n\npoint_add_affine: {t} FieldRep t -> ProjectivePoint t -> AffinePoint t -> ProjectivePoint t\npoint_add_affine F p1 p2 = out where\n    (x1, y1, z1) = normalize_point F p1\n    (x2, y2) = normalize_affine_point F p2\n\n    z1z1 = F.sq z1\n    h = F.mul(x2,z1z1)\n    r = F.mul(F.mul(y2,z1), z1z1)\n\n    h_1 = F.sub(h, x1)\n    hh = F.sq h_1\n    i = (F.add (hh,hh))\n    i_1 = F.add (i,i)\n\n    j = F.mul (h_1, i_1)\n\n    r_1 = F.sub(r, y1)\n    r_2 = F.add(r_1, r_1)\n\n    v = F.mul(x1, i_1)\n\n    x3 = F.sub(F.sub(F.sub(F.sq r_2, j), v), v)\n\n    j_1 = F.mul(j, y1)\n    y3 = F.sub(v, x3)\n    y3_1 = F.mul(y3, r_2)\n    y3_2 = F.sub(F.sub(y3_1, j_1), j_1)\n\n    z3 = F.add(z1,h_1)\n    z3_1 = F.sq z3\n    z3_2 = F.sub (z3_1, z1z1)\n    z3_3 = F.sub (z3_2, hh)\n\n    p3 = (x3, y3_2, z3_3)\n    out = select (x2,y2,F.field_unit) p3 (F.is_equal (z1, F.field_zero))\n\n\npoint_double: {t} FieldRep t -> ProjectivePoint t -> ProjectivePoint t\npoint_double F (x1,y1,z1) = (x3_2, y3_2, z3_1) where\n    a = F.sq x1\n    b = F.sq y1\n    c = F.sq b\n\n    d = F.add(x1, b)\n    d_1 = F.sq d\n    d_2 = F.sub (d_1, a)\n    d_3 = F.sub (d_2, c)\n    d_4 = F.add (d_3,d_3)\n\n    a_1 = mul_by_3 F a\n\n    x3 = F.sq a_1\n    x3_1 = F.sub (x3, d_4)\n    x3_2 = F.sub (x3_1, d_4)\n\n    z3 = F.add (z1, z1)\n    z3_1 = F.mul (z3, y1)\n\n    c_1 = mul_by_8 F c\n    y3 = F.sub (d_4, x3_2)\n    y3_1 = F.mul (y3, a_1)\n    y3_2 = F.sub (y3_1, c_1)\n\n\npoint_neg: {t} FieldRep t -> ProjectivePoint t -> ProjectivePoint t\npoint_neg F (x,y,z) = (x, F.neg y, z)\n\nPOINTonE1_affine_on_curve: AffinePoint t_Fp -> Bool\nPOINTonE1_affine_on_curve p = XXX==YY \\\/ (x==0 \/\\ y==0) where\n  (x,y) = p\n  XXX = Fp.add (Fp.mul (Fp.sq x, x), E.b)\n  YY = Fp.sq y\n\nPOINTonE2_affine_on_curve: AffinePoint t_Fp_2 -> Bool\nPOINTonE2_affine_on_curve p = XXX==YY \\\/ (Fp_2.is_equal(x,Fp_2.field_zero) \/\\ Fp_2.is_equal(y,Fp_2.field_zero)) where\n  (x,y) = p\n  XXX = Fp_2.add (Fp_2.mul (Fp_2.sq x, x), E'.b)\n  YY = Fp_2.sq y\n\nPOINTonE2_on_curve: ProjectivePoint t_Fp_2 -> Bool\nPOINTonE2_on_curve (x,y,z) = (Fp_2.is_equal(Fp_2.sq y, xxx) \\\/ Fp_2.is_equal(z, Fp_2.field_zero)) where\n  xxx = Fp_2.add (Fp_2.mul (Fp_2.sq x, x), Fp_2.mul (E'.b, z6))\n  z6 = Fp_2.sq (Fp_2.mul (Fp_2.sq z, z))\n\np_double_a0_l: {t} FieldRep t -> ProjectivePoint t -> ProjectivePoint t\np_double_a0_l F  (x1,y1,z1) = (x3, y3, z3) where\n    a = F.sq x1 \/\/  A = X1^2\n    b = F.sq y1 \/\/  B = Y1^2\n    c = F.sq b \/\/  C = B^2\n    t0 = F.sub(F.sub (F.sq (F.add (x1, b)), a), c) \/\/ (X1+B)^2-A-C\n    d = F.add (t0,t0) \/\/   D = 2*((X1+B)^2-A-C)\n    e = mul_by_3 F a \/\/  E = 3*A\n    f = F.sq e \/\/   F = E^2\n    x3 = F.sub (F.sub (f, d), d)  \/\/ X3 = F-2*D\n    y3 = F.sub (F.mul (e, F.sub (d, x3)), mul_by_8 F c) \/\/  Y3 = E*(D-X3)-8*C\n    t1 = F.add (z1,z1)\n    z3 = F.mul (t1, y1) \/\/ Z3 = 2*Y1*Z1\n\n\np_add_cc: {t} FieldRep t -> ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add_cc F (X1,Y1,Z1) (X2,Y2,Z2) = (X3, Y3, Z3) where\n  \/\/ add-1986-cc normal (not 3-operand) formula\n  U1 = F.mul(X1, F.sq Z2)  \/\/ U1 = X1*Z2^2\n  U2 = F.mul(X2, F.sq Z1)  \/\/ U2 = X2*Z1^2\n  S1 = F.mul(Y1, F.mul (Z2, F.sq Z2)) \/\/ S1 = Y1*Z2^3\n  S2 = F.mul(Y2, F.mul (Z1, F.sq Z1)) \/\/ S2 = Y2*Z1^3\n  P = F.sub (U2, U1) \/\/ P = U2-U1\n  R = F.sub (S2, S1) \/\/ R = S2-S1\n  P2 = F.sq P \/\/ P^2\n  P3 = F.mul(P, P2) \/\/ P^3\n\n  X3 = F.sub(F.sq R, F.mul(F.add (U1, U2), P2)) \/\/ X3 = R^2-(U1+U2)*P^2\n  Y3 = F.sub(F.mul(R, F.sub(F.mul(U1, P2), X3)), \/\/ Y3 = R*(U1*P^2-X3)-S1*P^3\n             F.mul(S1, P3))\n  Z3 = F.mul(Z1, F.mul(Z2, P)) \/\/ Z3 = Z1*Z2*P\n\np_add_bl: {t} FieldRep t -> ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add_bl F (X1,Y1,Z1) (X2,Y2,Z2) = (X3, Y3, Z3) where\n    \/\/ add-1986-bl normal (not 3-operand) formula\n    Z1Z1 = F.sq Z1                         Z2Z2 = F.sq Z2                         U1 = F.mul (X1, Z2Z2)                  U2 = F.mul (X2, Z1Z1)                  S1 = F.mul (Y1, F.mul (Z2, Z2Z2))      S2 = F.mul (Y2, F.mul (Z1, Z1Z1))      H = F.sub (U2, U1)                     I = F.sq (F.add (H, H))        \/\/ I = (2*H)^2\n    J = F.mul (H, I)                       r = F.add (F.sub (S2, S1), F.sub (S2, S1))      V = F.mul (U1, I)                  \/\/ V = U1*I\n    X3 = F.sub (F.sub (F.sq r, J), F.add (V, V))                       Y3 = F.sub (F.mul (r, F.sub (V, X3)), F.mul (F.add(S1, S1), J))     Z3 = F.mul (F.sub (F.sub (F.sq (F.add (Z1, Z2)), Z1Z1), Z2Z2), H)  \/\/ Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2)*H\n\n\/*\nThe \"madd-2007-bl\" addition formulas https:\/\/hyperelliptic.org\/EFD\/g1p\/auto-shortw-jacobian-0.html\nis a simple algebraic simplification of the \"add-2007-bl\" formula when Z2 = 1.\n*\/\np_add_madd_2007_bl: {t} EllipticCurve t -> ProjectivePoint t -> AffinePoint t -> ProjectivePoint t\np_add_madd_2007_bl C (X1,Y1,Z1) (X2,Y2) = (X3, Y3, Z3) where\n    F = C.base_field\n    \/\/ using the  \"madd-2007-bl\" addition formula\n    Z1Z1 = F.sq Z1                         U2 = F.mul (X2, Z1Z1)                  S2 = F.mul (Y2, F.mul (Z1, Z1Z1))      H = F.sub (U2, X1)                 \/\/ H = U2-X1\n    HH = F.sq H                        \/\/ HH = H^2\n    t0 = F.add(HH,HH)\n    I = F.add (t0, t0)                 \/\/ I = 4*HH\n    J = F.mul (H, I)                       t1 = F.sub(S2, Y1)\n    r = F.add (t1, t1)                 \/\/ r = 2*(S2-Y1)\n    V = F.mul (X1, I)                      X3 = F.sub (F.sub (F.sq r, J), F.add (V, V))                       Y3 = F.sub (F.mul (r, F.sub (V, X3)), F.mul (F.add(Y1, Y1), J)) \/\/ Y3 = r*(V-X3)-2*Y1*J\n    Z3 = F.sub (F.sub (F.sq (F.add (Z1, H)), Z1Z1), HH)                \/\/ Z3 = (Z1+H)^2-Z1Z1-HH\n","variant":"hybrid","set":"holdout"}
{"filename":"BLST-Verification\/spec\/implementation\/Psi.cry","filetype":"cry","content":"module implementation::Psi where\n\nimport Frobenius\nimport G2SubGroupCheck\nimport Pairing\nimport Parameters\nimport ShortWeierstrassCurve\n\npsi_imp: ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\npsi_imp P = projective_pair_to_jacobian_imp qpp where\n  pp = jacobian_to_projective_pair P\n  qpp = psi_projective_imp pp\n\npsi_x_factor = Fp_2.mul (alpha, [Fp.field_zero,psi_c1@0])\nqi_x_abs x = fp2_frobenius (Fp_2.mul (x, psi_x_factor))\npsi_y_factor = Fp_2.mul (alpha, Fp_2.neg psi_c2)\nqi_y_abs x = fp2_frobenius (Fp_2.mul (x, psi_y_factor))\n\npsi_projective_imp (xn, xd, yn, yd) = (qxn, qxd, qyn, qyd) where\n  qxn = Fp_2.mul (qi_x_abs xn, psi_c1)\n  qxd = qi_x_abs xd\n  qyn = Fp_2.mul (qi_y_abs yn, psi_c2)\n  qyd = qi_y_abs yd\n\n\/\/ This is a simple algebraic reanrrangement of `projective_pair_to_jacobian`\nprojective_pair_to_jacobian_imp: projective_pair_fp2 -> ProjectivePoint t_Fp_2\nprojective_pair_to_jacobian_imp (xn, xd, yn, yd) = (X', Y', Z') where\n  X' = Fp_2.mul (xn, Fp_2.mul (yd, Z'))\n  Y' = Fp_2.mul (Fp_2.sq Z', Fp_2.mul (xd, yn))\n  Z' = Fp_2.mul (xd, yd)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/Types.cry","filetype":"cry","content":"\/\/ Implementation types for blst\n\/\/\n\nmodule implementation::Types where\n\ntype Vec256 = [4][64]\ntype Vec384 = [6][64]\ntype Vec512 = [8][64]\ntype Vec768 = [12][64]\ntype Pow256 = [32][8]\ntype Limb = [64]\ntype Size_t = [64]\n\n\/\/ Vectors represent numbers, using a little-endian representation\n\n\/**\n * The integer (bitvector) represented by a vector (Vec256, Vec384, ...)\n *\/\nvec_abs: {n} (fin n) => [n]Limb -> [n*64]\nvec_abs limbs = join (reverse limbs)\n\nvec256_abs = vec_abs`{256\/64}\nvec384_abs = vec_abs`{384\/64}\nvec512_abs = vec_abs`{512\/64}\nvec768_abs = vec_abs`{768\/64}\n\n\/**\n * A vector representing a given (bitvector) integer.  The integer should be non-negative.\n *\/\nvec_rep:  {n} (fin n) => [n*64] -> [n]Limb\nvec_rep x = reverse (split x)\n\nvec256_rep = vec_rep`{256\/64}\nvec384_rep = vec_rep`{384\/64}\nvec768_rep = vec_rep`{768\/64}\n\n\/**\n * Represent a Boolean as a limb, with value 1 for true, 0 for false\n *\/\nbool_to_limb: Bool -> Limb\nbool_to_limb b = if b then (1:Limb) else 0\n\nselect: {t} t -> t-> Bit -> t\nselect a b c = if c then a else b\n\n\/\/ \"Scalars\" represent integers as a sequence of bytes, and allow for the\n\/\/ the exact number of used bits to be given\n\/\/ The bytes are in little-endian order\n\nscalar_to_integer: {n} (fin n, n >= 1, n <= 2^^60) => [n][8] -> Limb -> Integer\nscalar_to_integer bytes n_bits = vs!0 where\n    bits = join (reverse bytes)\n    vs = [0] # [ if j < n_bits then 2*v + (if b then 1 else 0) else 0\n               | b <- bits \/\/ bits from the MSB down\n               | j <- reverse [0 .. 8*n - 1]                | v <- vs ] \/\/ accumulated value\n","variant":"hybrid","set":"unsupervised"}
{"filename":"BLST-Verification\/spec\/implementation\/x86\/inverse.cry","filetype":"cry","content":"module implementation::x86::inverse where\n\nimport implementation::Types\nimport implementation::x86::helpers\n\n__smulx_383_n_shift_by_31\n  : Vec384 \/\/ a, stored at low offsets of rsi\n  -> Vec384 \/\/ b, stored at high offsets of rsi\n  -> [64] \/\/ f0\n  -> [64] \/\/ g0\n  -> (Vec384, [64], [64])\n__smulx_383_n_shift_by_31 a b f0 g0 = result\n  where\n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0] = a\n    r14_0 = 0\n    rdx_0 = f0\n    rcx_0 = g0\n    rbx_0 = rdx_0\n    rax_1 = rdx_0\n    rax_2 = sar rax_1 0x3f\n    rbp_3 = 0\n    (cf_4, rbp_4) = sub rbp_3 rax_2\n    rdx_5 = rdx_0 ^ rax_2\n    (cf_6, rdx_6) = add rdx_5 rbp_4\n    r8_7 = r8_0 ^ rax_2\n    r9_8 = r9_0 ^ rax_2\n    r10_9 = r10_0 ^ rax_2\n    r11_10 = r11_0 ^ rax_2\n    r12_11 = r12_0 ^ rax_2\n    rax_12 = rax_2 ^ r13_0\n    (cf_13, r8_13) = add r8_7 rbp_4\n    (cf_14, r9_14) = adc r9_8 0 cf_13\n    (cf_15, r10_15) = adc r10_9 0 cf_14\n    (cf_16, r11_16) = adc r11_10 0 cf_15\n    (cf_17, r12_17) = adc r12_11 0 cf_16\n    (cf_18, rax_18) = adc rax_12 0 cf_17\n    (rbp_19, r8_19) = mulx r8_13 rdx_6\n    (r13_20, r9_20) = mulx r9_14 rdx_6\n    (cf_21, r9_21) = add r9_20 rbp_19\n    (rbp_22, r10_22) = mulx r10_15 rdx_6\n    (cf_23, r10_23) = adc r10_22 r13_20 cf_21\n    (r13_24, r11_24) = mulx r11_16 rdx_6\n    (cf_25, r11_25) = adc r11_24 rbp_22 cf_23\n    (rbp_26, r12_26) = mulx r12_17 rdx_6\n    (cf_27, r12_27) = adc r12_26 r13_24 cf_25\n    (cf_28, rbp_28) = adc rbp_26 0 cf_27\n    (rdx_29, rax_29) = imul1 rdx_6 rax_18\n    (cf_30, rax_30) = add rax_29 rbp_28\n    (cf_31, r14_31) = adc r14_0 rdx_29 cf_30\n    rdx_32 = rcx_0\n    offload0 = r8_19\n    offload1 = r9_21\n    offload2 = r10_23\n    offload3 = r11_25\n    offload4 = r12_27\n    offload5 = rax_30\n    r8_39 = b @ 0\n    r9_40 = b @ 1\n    r10_41 = b @ 2\n    r11_42 = b @ 3\n    r12_43 = b @ 4\n    r13_44 = b @ 5\n    rax_45 = rdx_32\n    rax_46 = sar rax_45 0x3f\n    rbp_47 = 0\n    (cf_48, rbp_48) = sub rbp_47 rax_46\n    rdx_49 = rdx_32 ^ rax_46\n    (cf_50, rdx_50) = add rdx_49 rbp_48\n    r8_51 = r8_39 ^ rax_46\n    r9_52 = r9_40 ^ rax_46\n    r10_53 = r10_41 ^ rax_46\n    r11_54 = r11_42 ^ rax_46\n    r12_55 = r12_43 ^ rax_46\n    rax_56 = rax_46 ^ r13_44\n    (cf_57, r8_57) = add r8_51 rbp_48\n    (cf_58, r9_58) = adc r9_52 0 cf_57\n    (cf_59, r10_59) = adc r10_53 0 cf_58\n    (cf_60, r11_60) = adc r11_54 0 cf_59\n    (cf_61, r12_61) = adc r12_55 0 cf_60\n    (cf_62, rax_62) = adc rax_56 0 cf_61\n    (rbp_63, r8_63) = mulx r8_57 rdx_50\n    (r13_64, r9_64) = mulx r9_58 rdx_50\n    (cf_65, r9_65) = add r9_64 rbp_63\n    (rbp_66, r10_66) = mulx r10_59 rdx_50\n    (cf_67, r10_67) = adc r10_66 r13_64 cf_65\n    (r13_68, r11_68) = mulx r11_60 rdx_50\n    (cf_69, r11_69) = adc r11_68 rbp_66 cf_67\n    (rbp_70, r12_70) = mulx r12_61 rdx_50\n    (cf_71, r12_71) = adc r12_70 r13_68 cf_69\n    (cf_72, rbp_72) = adc rbp_70 0 cf_71\n    (rdx_73, rax_73) = imul1 rdx_50 rax_62\n    (cf_74, rax_74) = add rax_73 rbp_72\n    (cf_75, rdx_75) = adc rdx_73 0 cf_74\n    (cf_76, r8_76) = add r8_63 offload0\n    (cf_77, r9_77) = adc r9_65 offload1 cf_76\n    (cf_78, r10_78) = adc r10_67 offload2 cf_77\n    (cf_79, r11_79) = adc r11_69 offload3 cf_78\n    (cf_80, r12_80) = adc r12_71 offload4 cf_79\n    (cf_81, rax_81) = adc rax_74 offload5 cf_80\n    (cf_82, r14_82) = adc r14_31 rdx_75 cf_81\n    rdx_83 = rbx_0\n    r8_84 = shrd r8_76 r9_77 (zext`{64} 0x1f)\n    r9_85 = shrd r9_77 r10_78 (zext`{64} 0x1f)\n    r10_86 = shrd r10_78 r11_79 (zext`{64} 0x1f)\n    r11_87 = shrd r11_79 r12_80 (zext`{64} 0x1f)\n    r12_88 = shrd r12_80 rax_81 (zext`{64} 0x1f)\n    rax_89 = shrd rax_81 r14_82 (zext`{64} 0x1f)\n    r14_90 = sar r14_82 0x3f\n    rbp_91 = 0\n    (cf_92, rbp_92) = sub rbp_91 r14_90\n    r8_93 = r8_84 ^ r14_90\n    r9_94 = r9_85 ^ r14_90\n    r10_95 = r10_86 ^ r14_90\n    r11_96 = r11_87 ^ r14_90\n    r12_97 = r12_88 ^ r14_90\n    rax_98 = rax_89 ^ r14_90\n    (cf_99, r8_99) = add r8_93 rbp_92\n    (cf_100, r9_100) = adc r9_94 0 cf_99\n    (cf_101, r10_101) = adc r10_95 0 cf_100\n    (cf_102, r11_102) = adc r11_96 0 cf_101\n    (cf_103, r12_103) = adc r12_97 0 cf_102\n    (cf_104, rax_104) = adc rax_98 0 cf_103\n    result0 = r8_99\n    result1 = r9_100\n    result2 = r10_101\n    result3 = r11_102\n    result4 = r12_103\n    result5 = rax_104\n    rdx_111 = rdx_83 ^ r14_90\n    rcx_111 = rcx_0 ^ r14_90\n    (cf_113, rdx_113) = add rdx_111 rbp_92\n    (cf_114, rcx_114) = add rcx_111 rbp_92\n    result = ([result0, result1, result2, result3, result4, result5], rdx_113, rcx_114)\n\n__smulx_191_n_shift_by_31\n  : [3][64] \/\/ a, stored at low offsets of rsi\n  -> [3][64] \/\/ b, stored at high offsets of rsi\n  -> [64] \/\/ f0\n  -> [64] \/\/ g0\n  -> ([3][64], [64], [64])\n__smulx_191_n_shift_by_31 a b f0 g0 = result\n  where\n    [r8_0, r9_0, r10_0] = take a\n    rdx_0 = f0\n    rcx_0 = g0\n    rbx_0 = rdx_0\n    rax_1 = rdx_0\n    rax_2 = sar rax_1 0x3f\n    rbp_3 = 0\n    (cf_4, rbp_4) = sub rbp_3 rax_2\n    rdx_5 = rdx_0 ^ rax_2\n    (cf_6, rdx_6) = add rdx_5 rbp_4\n    r8_7 = r8_0 ^ rax_2\n    r9_8 = r9_0 ^ rax_2\n    rax_9 = rax_2 ^ r10_0\n    (cf_10, r8_10) = add r8_7 rbp_4\n    (cf_11, r9_11) = adc r9_8 0 cf_10\n    (cf_12, rax_12) = adc rax_9 0 cf_11\n    (rbp_13, r8_13) = mulx r8_10 rdx_6\n    (r10_14, r9_14) = mulx r9_11 rdx_6\n    (cf_15, r9_15) = add r9_14 rbp_13\n    (cf_16, r10_16) = adc r10_14 0 cf_15\n    (rdx_17, rax_17) = imul1 rdx_6 rax_12\n    (cf_18, r10_18) = add r10_16 rax_17\n    (cf_19, rdx_19) = adc rdx_17 0 cf_18\n    r14_20 = rdx_19\n    rdx_21 = rcx_0\n    r11_22 = b @ 0\n    r12_23 = b @ 1\n    r13_24 = b @ 2\n    rax_25 = rdx_21\n    rax_26 = sar rax_25 0x3f\n    rbp_27 = 0\n    (cf_28, rbp_28) = sub rbp_27 rax_26\n    rdx_29 = rdx_21 ^ rax_26\n    (cf_30, rdx_30) = add rdx_29 rbp_28\n    r11_31 = r11_22 ^ rax_26\n    r12_32 = r12_23 ^ rax_26\n    rax_33 = rax_26 ^ r13_24\n    (cf_34, r11_34) = add r11_31 rbp_28\n    (cf_35, r12_35) = adc r12_32 0 cf_34\n    (cf_36, rax_36) = adc rax_33 0 cf_35\n    (rbp_37, r11_37) = mulx r11_34 rdx_30\n    (r13_38, r12_38) = mulx r12_35 rdx_30\n    (cf_39, r12_39) = add r12_38 rbp_37\n    (cf_40, r13_40) = adc r13_38 0 cf_39\n    (rdx_41, rax_41) = imul1 rdx_30 rax_36\n    (cf_42, r13_42) = add r13_40 rax_41\n    (cf_43, rdx_43) = adc rdx_41 0 cf_42\n    (cf_44, r11_44) = add r11_37 r8_13\n    (cf_45, r12_45) = adc r12_39 r9_15 cf_44\n    (cf_46, r13_46) = adc r13_42 r10_18 cf_45\n    (cf_47, r14_47) = adc r14_20 rdx_43 cf_46\n    rdx_48 = rbx_0\n    r11_49 = shrd r11_44 r12_45 (zext`{64} 0x1f)\n    r12_50 = shrd r12_45 r13_46 (zext`{64} 0x1f)\n    r13_51 = shrd r13_46 r14_47 (zext`{64} 0x1f)\n    r14_52 = sar r14_47 0x3f\n    rbp_53 = 0\n    (cf_54, rbp_54) = sub rbp_53 r14_52\n    r11_55 = r11_49 ^ r14_52\n    r12_56 = r12_50 ^ r14_52\n    r13_57 = r13_51 ^ r14_52\n    (cf_58, r11_58) = add r11_55 rbp_54\n    (cf_59, r12_59) = adc r12_56 0 cf_58\n    (cf_60, r13_60) = adc r13_57 0 cf_59\n    result0 = r11_58\n    result1 = r12_59\n    result2 = r13_60\n    rdx_64 = rdx_48 ^ r14_52\n    rcx_65 = rcx_0 ^ r14_52\n    (cf_66, rdx_66) = add rdx_64 rbp_54\n    (cf_67, rcx_67) = add rcx_65 rbp_54\n    result = ([result0, result1, result2], rdx_66, rcx_67)\n\n__smulx_383x63\n  : Vec384 \/\/ u, stored at low offsets of rsi\n  -> Vec384 \/\/ v, stored at high offsets of rsi\n  -> [64] \/\/ f0\n  -> [64] \/\/ g0\n  -> Vec384\n__smulx_383x63 u v f0 g0 = result\n  where\n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0] = u\n    rdx_0 = f0\n    rcx_0 = g0\n    rbp_1 = rdx_0\n    rbp_2 = sar rbp_1 0x3f\n    rax_3 = 0\n    (cf_4, rax_4) = sub rax_3 rbp_2\n    rdx_5 = rdx_0 ^ rbp_2\n    (cf_6, rdx_6) = add rdx_5 rax_4\n    r8_7 = r8_0 ^ rbp_2\n    r9_8 = r9_0 ^ rbp_2\n    r10_9 = r10_0 ^ rbp_2\n    r11_10 = r11_0 ^ rbp_2\n    r12_11 = r12_0 ^ rbp_2\n    r13_12 = r13_0 ^ rbp_2\n    (cf_13, r8_13) = add r8_7 rax_4\n    (cf_14, r9_14) = adc r9_8 0 cf_13\n    (cf_15, r10_15) = adc r10_9 0 cf_14\n    (cf_16, r11_16) = adc r11_10 0 cf_15\n    (cf_17, r12_17) = adc r12_11 0 cf_16\n    (cf_18, r13_18) = adc r13_12 0 cf_17\n    (rbp_19, r8_19) = mulx r8_13 rdx_6\n    (rax_20, r9_20) = mulx r9_14 rdx_6\n    (cf_21, r9_21) = add r9_20 rbp_19\n    (rbp_22, r10_22) = mulx r10_15 rdx_6\n    (cf_23, r10_23) = adc r10_22 rax_20 cf_21\n    (rax_24, r11_24) = mulx r11_16 rdx_6\n    (cf_25, r11_25) = adc r11_24 rbp_22 cf_23\n    (rbp_26, r12_26) = mulx r12_17 rdx_6\n    (cf_27, r12_27) = adc r12_26 rax_24 cf_25\n    (rax_28, r13_28) = mulx r13_18 rdx_6\n    rdx_29 = rcx_0\n    (cf_30, r13_30) = adc r13_28 rbp_26 cf_27\n    offload0 = r8_19\n    offload1 = r9_21\n    offload2 = r10_23\n    offload3 = r11_25\n    offload4 = r12_27\n    offload5 = r13_30\n    r8_37 = v @ 0\n    r9_38 = v @ 1\n    r10_39 = v @ 2\n    r11_40 = v @ 3\n    r12_41 = v @ 4\n    r13_42 = v @ 5\n    rbp_43 = rdx_29\n    rbp_44 = sar rbp_43 0x3f\n    rax_45 = 0\n    (cf_46, rax_46) = sub rax_45 rbp_44\n    rdx_47 = rdx_29 ^ rbp_44\n    (cf_48, rdx_48) = add rdx_47 rax_46\n    r8_49 = r8_37 ^ rbp_44\n    r9_50 = r9_38 ^ rbp_44\n    r10_51 = r10_39 ^ rbp_44\n    r11_52 = r11_40 ^ rbp_44\n    r12_53 = r12_41 ^ rbp_44\n    r13_54 = r13_42 ^ rbp_44\n    (cf_55, r8_55) = add r8_49 rax_46\n    (cf_56, r9_56) = adc r9_50 0 cf_55\n    (cf_57, r10_57) = adc r10_51 0 cf_56\n    (cf_58, r11_58) = adc r11_52 0 cf_57\n    (cf_59, r12_59) = adc r12_53 0 cf_58\n    (cf_60, r13_60) = adc r13_54 0 cf_59\n    (rbp_61, r8_61) = mulx r8_55 rdx_48\n    (rax_62, r9_62) = mulx r9_56 rdx_48\n    (cf_63, r9_63) = add r9_62 rbp_61\n    (rbp_64, r10_64) = mulx r10_57 rdx_48\n    (cf_65, r10_65) = adc r10_64 rax_62 cf_63\n    (rax_66, r11_66) = mulx r11_58 rdx_48\n    (cf_67, r11_67) = adc r11_66 rbp_64 cf_65\n    (rbp_68, r12_68) = mulx r12_59 rdx_48\n    (cf_69, r12_69) = adc r12_68 rax_66 cf_67\n    (rax_70, r13_70) = mulx r13_60 rdx_48\n    (cf_71, r13_71) = adc r13_70 rbp_68 cf_69\n    (cf_72, r8_72) = add r8_61 offload0\n    (cf_73, r9_73) = adc r9_63 offload1 cf_72\n    (cf_74, r10_74) = adc r10_65 offload2 cf_73\n    (cf_75, r11_75) = adc r11_67 offload3 cf_74\n    (cf_76, r12_76) = adc r12_69 offload4 cf_75\n    (cf_77, r13_77) = adc r13_71 offload5 cf_76\n    result0 = r8_72\n    result1 = r9_73\n    result2 = r10_74\n    result3 = r11_75\n    result4 = r12_76\n    result5 = r13_77\n    result = [result0, result1, result2, result3, result4, result5]\n\n__smulx_767x63\n  : Vec384 \/\/ u, stored at low offsets of rsi\n  -> Vec768 \/\/ v, stored at high offsets of rsi\n  -> [64] \/\/ f0\n  -> [64] \/\/ g0\n  -> Vec768\n__smulx_767x63 u v f0 g0 = result\n  where\n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0] = u\n    rdx_0 = f0\n    rcx_0 = g0\n    rax_7 = rdx_0\n    rax_8 = sar rax_7 0x3f\n    rbp_9 = 0\n    (cf_10, rbp_10) = sub rbp_9 rax_8\n    rdx_14 = rdx_0 ^ rax_8\n    (cf_15, rdx_15) = add rdx_14 rbp_10\n    r8_16 = r8_0 ^ rax_8\n    r9_17 = r9_0 ^ rax_8\n    r10_18 = r10_0 ^ rax_8\n    r11_19 = r11_0 ^ rax_8\n    r12_20 = r12_0 ^ rax_8\n    rax_21 = rax_8 ^ r13_0\n    (cf_22, r8_22) = add r8_16 rbp_10\n    (cf_23, r9_23) = adc r9_17 0 cf_22\n    (cf_24, r10_24) = adc r10_18 0 cf_23\n    (cf_25, r11_25) = adc r11_19 0 cf_24\n    (cf_26, r12_26) = adc r12_20 0 cf_25\n    (cf_27, rax_27) = adc rax_21 0 cf_26\n    (rbp_28, r8_28) = mulx r8_22 rdx_15\n    (r13_29, r9_29) = mulx r9_23 rdx_15\n    (cf_30, r9_30) = add r9_29 rbp_28\n    (rbp_31, r10_31) = mulx r10_24 rdx_15\n    (cf_32, r10_32) = adc r10_31 r13_29 cf_30\n    (r13_33, r11_33) = mulx r11_25 rdx_15\n    (cf_34, r11_34) = adc r11_33 rbp_31 cf_32\n    (rbp_35, r12_35) = mulx r12_26 rdx_15\n    (cf_36, r12_36) = adc r12_35 r13_33 cf_34\n    (cf_37, rbp_37) = adc rbp_35 0 cf_36\n    (rdx_38, rax_38) = imul1 rdx_15 rax_27\n    (cf_39, rax_39) = add rax_38 rbp_37\n    (cf_40, rdx_40) = adc rdx_38 0 cf_39\n    offload0 = r8_28\n    offload1 = r9_30\n    offload2 = r10_32\n    offload3 = r11_34\n    offload4 = r12_36\n    offload5 = rax_39\n    offload6 = rdx_40\n    rdx_48 = rdx_40 >>$ 0x3f\n    offload7 = rdx_48\n    rdx_50 = rcx_0\n    rax_51 = rcx_0\n    r8_52 = v @ 0\n    r9_53 = v @ 1\n    r10_54 = v @ 2\n    r11_55 = v @ 3\n    r12_56 = v @ 4\n    r13_57 = v @ 5\n    r14_58 = v @ 6\n    r15_59 = v @ 7\n    rbx_60 = v @ 8\n    rbp_61 = v @ 9\n    rcx_62 = v @ 10\n    rdi_63 = v @ 11\n    rax_64 = sar rax_51 0x3f\n    rsi_65 = 0\n    (cf_66, rsi_66) = sub rsi_65 rax_64\n    rdx_67 = rdx_50 ^ rax_64\n    (cf_68, rdx_68) = add rdx_67 rsi_66\n    r8_69 = r8_52 ^ rax_64\n    r9_70 = r9_53 ^ rax_64\n    r10_71 = r10_54 ^ rax_64\n    r11_72 = r11_55 ^ rax_64\n    r12_73 = r12_56 ^ rax_64\n    r13_74 = r13_57 ^ rax_64\n    r14_75 = r14_58 ^ rax_64\n    r15_76 = r15_59 ^ rax_64\n    rbx_77 = rbx_60 ^ rax_64\n    rbp_78 = rbp_61 ^ rax_64\n    rcx_79 = rcx_62 ^ rax_64\n    rdi_80 = rdi_63 ^ rax_64\n    (cf_81, r8_81) = add r8_69 rsi_66\n    (cf_82, r9_82) = adc r9_70 0 cf_81\n    (cf_83, r10_83) = adc r10_71 0 cf_82\n    (cf_84, r11_84) = adc r11_72 0 cf_83\n    (cf_85, r12_85) = adc r12_73 0 cf_84\n    (cf_86, r13_86) = adc r13_74 0 cf_85\n    (cf_87, r14_87) = adc r14_75 0 cf_86\n    (cf_88, r15_88) = adc r15_76 0 cf_87\n    (cf_89, rbx_89) = adc rbx_77 0 cf_88\n    (cf_90, rbp_90) = adc rbp_78 0 cf_89\n    (cf_91, rcx_91) = adc rcx_79 0 cf_90\n    (cf_92, rdi_92) = adc rdi_80 0 cf_91\n    (rax_93, r8_93) = mulx r8_81 rdx_68\n    (rsi_94, r9_94) = mulx r9_82 rdx_68\n    (cf_95, r9_95) = add r9_94 rax_93\n    (rax_96, r10_96) = mulx r10_83 rdx_68\n    (cf_97, r10_97) = adc r10_96 rsi_94 cf_95\n    (rsi_98, r11_98) = mulx r11_84 rdx_68\n    (cf_99, r11_99) = adc r11_98 rax_96 cf_97\n    (rax_100, r12_100) = mulx r12_85 rdx_68\n    (cf_101, r12_101) = adc r12_100 rsi_98 cf_99\n    (rsi_102, r13_102) = mulx r13_86 rdx_68\n    (cf_103, r13_103) = adc r13_102 rax_100 cf_101\n    (rax_104, r14_104) = mulx r14_87 rdx_68\n    (cf_105, r14_105) = adc r14_104 rsi_102 cf_103\n    (rsi_106, r15_106) = mulx r15_88 rdx_68\n    (cf_107, r15_107) = adc r15_106 rax_104 cf_105\n    (rax_108, rbx_108) = mulx rbx_89 rdx_68\n    (cf_109, rbx_109) = adc rbx_108 rsi_106 cf_107\n    (rsi_110, rbp_110) = mulx rbp_90 rdx_68\n    (cf_111, rbp_111) = adc rbp_110 rax_108 cf_109\n    (rax_112, rcx_112) = mulx rcx_91 rdx_68\n    (cf_113, rcx_113) = adc rcx_112 rsi_110 cf_111\n    (rsi_114, rdi_114) = mulx rdi_92 rdx_68\n    (cf_117, rax_117) = adc rax_112 rdi_114 cf_113\n    (cf_118, r8_118) = add r8_93 offload0\n    (cf_119, r9_119) = adc r9_95 offload1 cf_118\n    (cf_120, r10_120) = adc r10_97 offload2 cf_119\n    (cf_121, r11_121) = adc r11_99 offload3 cf_120\n    (cf_122, r12_122) = adc r12_101 offload4 cf_121\n    (cf_123, r13_123) = adc r13_103 offload5 cf_122\n    (cf_124, r14_124) = adc r14_105 offload6 cf_123\n    rdi_125 = offload7\n    (cf_126, r15_126) = adc r15_107 rdi_125 cf_124\n    (cf_127, rbx_127) = adc rbx_109 rdi_125 cf_126\n    (cf_128, rbp_128) = adc rbp_111 rdi_125 cf_127\n    (cf_129, rcx_129) = adc rcx_113 rdi_125 cf_128\n    (cf_130, rax_130) = adc rax_117 rdi_125 cf_129\n    result0 = r8_118\n    result1 = r9_119\n    result2 = r10_120\n    result3 = r11_121\n    result4 = r12_122\n    result5 = r13_123\n    result6 = r14_124\n    result7 = r15_126\n    result8 = rbx_127\n    result9 = rbp_128\n    result10 = rcx_129\n    result11 = rax_130\n    result =\n      [ result0, result1, result2, result3, result4, result5\n      , result6, result7, result8, result9, result10, result11\n      ]\n\n__ab_approximation_31\n  : Integer \/\/ number of iterations\n  -> Vec384   -> Vec384   -> [4][64] \/\/ result; f0, g0, f1, g1\n__ab_approximation_31 iters a b = result\n  where\n    r9_0 = a @ 5\n    r11_0 = b @ 5\n    rbx_0 = a @ 4\n    rbp_0 = b @ 4\n    r8_0 = a @ 3\n    r10_0 = b @ 3\n    rax_1 = r9_0\n    rax_2 = rax_1 || r11_0\n    zf_2 = rax_2 == 0\n    r9_3 = cmove r9_0 rbx_0 zf_2\n    r11_4 = cmove r11_0 rbp_0 zf_2\n    rbx_5 = cmove rbx_0 r8_0 zf_2\n    r8_6 = a @ 2\n    rbp_7 = cmove rbp_0 r10_0 zf_2\n    r10_8 = b @ 2\n    rax_9 = r9_3\n    rax_10 = rax_9 || r11_4\n    zf_10 = rax_10 == 0\n    r9_11 = cmove r9_3 rbx_5 zf_10\n    r11_12 = cmove r11_4 rbp_7 zf_10\n    rbx_13 = cmove rbx_5 r8_6 zf_10\n    r8_14 = a @ 1\n    rbp_15 = cmove rbp_7 r10_8 zf_10\n    r10_16 = b @ 1\n    rax_17 = r9_11\n    rax_18 = rax_17 || r11_12\n    zf_18 = rax_18 == 0\n    r9_19 = cmove r9_11 rbx_13 zf_18\n    r11_20 = cmove r11_12 rbp_15 zf_18\n    rbx_21 = cmove rbx_13 r8_14 zf_18\n    r8_22 = a @ 0\n    rbp_23 = cmove rbp_15 r10_16 zf_18\n    r10_24 = b @ 0\n    rax_25 = r9_19\n    rax_26 = rax_25 || r11_20\n    zf_26 = rax_26 == 0\n    r9_27 = cmove r9_19 rbx_21 zf_26\n    r11_28 = cmove r11_20 rbp_23 zf_26\n    rbx_29 = cmove rbx_21 r8_22 zf_26\n    rbp_30 = cmove rbp_23 r10_24 zf_26\n    rax_31 = r9_27\n    rax_32 = rax_31 || r11_28\n    zf_33 = rax_32 == 0\n    rcx_33 = bsr rax_32\n    rcx_34 = 1 + rcx_33\n    r9_35 = cmove r9_27 rbx_29 zf_33\n    r11_36 = cmove r11_28 rbp_30 zf_33\n    rcx_37 = cmove rcx_34 rax_32 zf_33\n    rcx_38 = 0 - rcx_37\n    r9_39 = shld r9_35 rbx_29 (drop`{56} rcx_38)\n    r11_40 = shld r11_36 rbp_30 (drop`{56} rcx_38)\n    rcx_41 = r9_39\n    rcx_42 = rcx_41 || r11_40\n    rcx_43 = sar rcx_42 (zext`{64} 0x3f)\n    rcx_44 = (drop`{56} rcx_43) && zext 0x21\n    r9_45 = shr r9_39 rcx_44\n    r11_46 = shr r11_40 rcx_44\n    r8_47 = shl r8_22 rcx_44\n    r10_48 = shl r10_24 rcx_44\n    r8_49 = shrd_ret r8_22 r8_47 r9_45 rcx_44\n    r10_50 = shrd_ret r10_24 r10_48 r11_46 rcx_44\n    result = __inner_loop_31 iters r8_49 r10_50\n\n__inner_loop_31\n  : Integer \/\/ number of iterations\n  -> [64]   -> [64]   -> [4][64] \/\/ result; f0, g0, f1, g1\n__inner_loop_31 iters a_init b_init = result\n  where\n    [post_a, post_b, post_fg0, post_fg1, post_bias] = loop iters [a_init, b_init, 0x7FFFFFFF80000000, 0x800000007FFFFFFF, 0x7FFFFFFF7FFFFFFF]\n    tmp_f0 = zext`{64} (drop`{32} post_fg0)\n    tmp_g0 = shr post_fg0 0x20\n    tmp_f1 = zext`{64} (drop`{32} post_fg1)\n    tmp_g1 = shr post_fg1 0x20\n    tmp_bias = shr post_bias 0x20\n    result = [zext tmp_f0 - tmp_bias, zext tmp_g0 - tmp_bias, zext tmp_f1 - tmp_bias, zext tmp_g1 - tmp_bias]\n    loop : Integer -> [5][64] -> [5][64]\n    loop counter [a, b, fg0, fg1, bias] = loopresult\n      where\n        r8_0 = a\n        r10_0 = b\n        rcx_0 = fg0\n        r13_0 = fg1\n        r15_0 = bias\n        (cf_1, _) = sub r8_0 r10_0\n        rax_2 = r8_0\n        rbx_3 = r10_0\n        rbp_4 = rcx_0\n        r14_5 = r13_0\n        r8_6 = cmovb r8_0 r10_0 cf_1\n        r10_7 = cmovb r10_0 rax_2 cf_1\n        rcx_8 = cmovb rcx_0 r13_0 cf_1\n        r13_9 = cmovb r13_0 rbp_4 cf_1\n        (cf_10, r8_10) = sub r8_6 r10_7\n        (cf_12, rcx_12) = sub (add rcx_8 r15_0).1 r13_9\n        zf_13 = (rax_2 && zext 0x1) == 0\n        r8_14 = cmove r8_10 rax_2 zf_13\n        r10_15 = cmove r10_7 rbx_3 zf_13\n        rcx_16 = cmove rcx_12 rbp_4 zf_13\n        r13_17 = cmove r13_9 r14_5 zf_13\n        r8_18 = shr r8_14 0x01\n        (cf_19, r13_19) = add r13_17 r13_17\n        (cf_20, r13_20) = sub r13_19 r15_0\n        curcounter = counter - 1\n        curresult = [r8_18, r10_15, rcx_16, r13_20, r15_0]\n        loopresult = if curcounter == 0 then curresult else loop curcounter curresult\n\n__inner_loop_62\n  : Integer \/\/ number of iterations\n  -> [64]   -> [64]   -> [4][64] \/\/ result; f0, g0, f1, g1\n__inner_loop_62 iters a_init b_init = result\n  where\n    result = drop (loop iters [a_init, b_init, 1, 0, 0, 1])\n    loop : Integer -> [6][64] -> [6][64]\n    loop counter [a, b, f0, g0, f1, g1] = loopresult\n      where\n        r8_0 = a\n        r10_0 = b\n        rdx_0 = f0\n        rcx_0 = g0\n        r12_0 = f1\n        r13_0 = g1\n        rax_0 = 0\n        zf_2 = (r8_0 && zext 0x1) == 0\n        rbx_3 = r10_0\n        rax_4 = cmovne rax_0 r10_0 zf_2\n        (cf_5, rbx_5) = sub rbx_3 r8_0\n        rbp_6 = r8_0\n        (cf_7, r8_7) = sub r8_0 rax_4\n        r8_8 = cmovb r8_7 rbx_5 cf_7\n        r10_9 = cmovb r10_0 rbp_6 cf_7\n        rax_10 = rdx_0\n        rdx_11 = cmovb rdx_0 r12_0 cf_7\n        r12_12 = cmovb r12_0 rax_10 cf_7\n        rbx_13 = rcx_0\n        rcx_14 = cmovb rcx_0 r13_0 cf_7\n        r13_15 = cmovb r13_0 rbx_13 cf_7\n        rax_16 = 0\n        rbx_17 = 0\n        r8_18 = r8_8 >> 1\n        rbp_19 = (rbp_6 && zext 0x1) == 0\n        rax_20 = cmovne rax_16 r12_12 zf_2\n        rbx_21 = cmovne rbx_17 r13_15 zf_2\n        (cf_22, r12_22) = add r12_12 r12_12\n        (cf_23, r13_23) = add r13_15 r13_15\n        (cf_24, rdx_24) = sub rdx_11 rax_20\n        (cf_25, rcx_25) = sub rcx_14 rbx_21\n        curcounter = counter - 1\n        curresult = [r8_18, r10_9, rdx_24, rcx_25, r12_22, r13_23]\n        loopresult = if curcounter == 0 then curresult else loop curcounter curresult\n\nctx_inverse_mod_383\n  : Vec384 \/\/ a; pointer in rsi\n  -> Vec384 \/\/ n; pointer in rdx\n  -> Vec768 ctx_inverse_mod_383 a n = result   where\n    a_2 = a\n    b_3 = n\n    loa_4 = a_2\n    lob_5 = b_3\n    [f0_6, g0_6, f1_6, g1_6] = __ab_approximation_31 31 loa_4 lob_5\n    (hia_7, f0_7, g0_7) = __smulx_383_n_shift_by_31 loa_4 lob_5 f0_6 g0_6\n    offloadu_7 = f0_7\n    (hib_8, f1_8, g1_8) = __smulx_383_n_shift_by_31 loa_4 lob_5 f1_6 g1_6\n    offloadv_8 = f1_8\n    [f0_9, g0_9, f1_9, g1_9] = __ab_approximation_31 31 hia_7 hib_8\n    (loa_10, f0_10, g0_10) = __smulx_383_n_shift_by_31 hia_7 hib_8 f0_9 g0_9\n    (lob_11, f1_11, g1_11) = __smulx_383_n_shift_by_31 hia_7 hib_8 f1_9 g1_9\n    tmp12_rax_0 = offloadu_7\n    tmp12_r11_0 = offloadv_8\n    tmp12_rbx_0 = f1_11\n    tmp12_r10_0 = tmp12_rax_0\n    (tmp12_rdx_05, tmp12_rax_05) = imul1 f0_10 tmp12_rax_0\n    tmp12_r8_1 = tmp12_rax_05\n    tmp12_rax_1 = tmp12_r11_0\n    tmp12_r9_1 = tmp12_rdx_05\n    (tmp12_rdx_2, tmp12_rax_2) = imul1 g0_10 tmp12_rax_1\n    (tmp12_cf_3, tmp12_r8_3) = add tmp12_r8_1 tmp12_rax_2\n    (tmp12_cf_4, tmp12_r9_4) = adc tmp12_r9_1 tmp12_rdx_2 tmp12_cf_3\n    tmp12_ret0 = tmp12_r8_3\n    tmp12_ret1 = tmp12_r9_4\n    tmp12_r9_5 = sar tmp12_r9_4 0x3f\n    tmp12_ret2 = tmp12_r9_5\n    tmp12_ret3 = tmp12_r9_5\n    tmp12_ret4 = tmp12_r9_5\n    tmp12_ret5 = tmp12_r9_5\n    tmp12_rax_55 = tmp12_r10_0\n    (tmp12_rdx_6, tmp12_rax_6) = imul1 tmp12_rbx_0 tmp12_rax_55\n    tmp12_r8_6 = tmp12_rax_6\n    tmp12_rax_7 = tmp12_r11_0\n    tmp12_r9_7 = tmp12_rdx_6\n    (tmp12_rdx_8, tmp12_rax_8) = imul1 g1_11 tmp12_rax_7\n    (tmp12_cf_9, tmp12_r8_9) = add tmp12_r8_6 tmp12_rax_8\n    (tmp12_cf_10, tmp12_r9_10) = adc tmp12_r9_7 tmp12_rdx_8 tmp12_cf_9\n    tmp12_ret6 = tmp12_r8_9\n    tmp12_ret7 = tmp12_r9_10\n    tmp12_r9_11 = sar tmp12_r9_10 0x3f\n    tmp12_ret8 = tmp12_r9_11\n    tmp12_ret9 = tmp12_r9_11\n    tmp12_ret10 = tmp12_r9_11\n    tmp12_ret11 = tmp12_r9_11\n    lou_12 = [tmp12_ret0, tmp12_ret1, tmp12_ret2, tmp12_ret3, tmp12_ret4, tmp12_ret5]\n    lov_12 = [tmp12_ret6, tmp12_ret7, tmp12_ret8, tmp12_ret9, tmp12_ret10, tmp12_ret11]\n    [f0_14, g0_14, f1_14, g1_14] = __ab_approximation_31 31 loa_10 lob_11\n    (hia_15, f0_15, g0_15) = __smulx_383_n_shift_by_31 loa_10 lob_11 f0_14 g0_14\n    (hib_16, f1_16, g1_16) = __smulx_383_n_shift_by_31 loa_10 lob_11 f1_14 g1_14\n    hiu_17 = __smulx_383x63 lou_12 lov_12 f0_15 g0_15\n    hiv_18 = __smulx_383x63 lou_12 lov_12 f1_16 g1_16\n    [f0_19, g0_19, f1_19, g1_19] = __ab_approximation_31 31 hia_15 hib_16\n    (loa_20, f0_20, g0_20) = __smulx_383_n_shift_by_31 hia_15 hib_16 f0_19 g0_19\n    (lob_21, f1_21, g1_21) = __smulx_383_n_shift_by_31 hia_15 hib_16 f1_19 g1_19\n    lou_22 = __smulx_383x63 hiu_17 hiv_18 f0_20 g0_20\n    lov_23 = __smulx_383x63 hiu_17 hiv_18 f1_21 g1_21\n    [f0_24, g0_24, f1_24, g1_24] = __ab_approximation_31 31 loa_20 lob_21\n    (hia_25, f0_25, g0_25) = __smulx_383_n_shift_by_31 loa_20 lob_21 f0_24 g0_24\n    (hib_26, f1_26, g1_26) = __smulx_383_n_shift_by_31 loa_20 lob_21 f1_24 g1_24\n    hiu_27 = __smulx_383x63 lou_22 lov_23 f0_25 g0_25\n    hiv_28 = __smulx_383x63 lou_22 lov_23 f1_26 g1_26\n    [f0_29, g0_29, f1_29, g1_29] = __ab_approximation_31 31 hia_25 hib_26\n    (loa_30, f0_30, g0_30) = __smulx_383_n_shift_by_31 hia_25 hib_26 f0_29 g0_29\n    (lob_31, f1_31, g1_31) = __smulx_383_n_shift_by_31 hia_25 hib_26 f1_29 g1_29\n    lou_32 = __smulx_383x63 hiu_27 hiv_28 f0_30 g0_30\n    lov_33 = __smulx_383x63 hiu_27 hiv_28 f1_31 g1_31\n    [f0_34, g0_34, f1_34, g1_34] = __ab_approximation_31 31 loa_30 lob_31\n    (hia_35, f0_35, g0_35) = __smulx_383_n_shift_by_31 loa_30 lob_31 f0_34 g0_34\n    (hib_36, f1_36, g1_36) = __smulx_383_n_shift_by_31 loa_30 lob_31 f1_34 g1_34\n    hiu_37 = __smulx_383x63 lou_32 lov_33 f0_35 g0_35\n    hiv_38 = __smulx_383x63 lou_32 lov_33 f1_36 g1_36\n    [f0_39, g0_39, f1_39, g1_39] = __ab_approximation_31 31 hia_35 hib_36\n    (loa_40, f0_40, g0_40) = __smulx_383_n_shift_by_31 hia_35 hib_36 f0_39 g0_39\n    (lob_41, f1_41, g1_41) = __smulx_383_n_shift_by_31 hia_35 hib_36 f1_39 g1_39\n    lou_42 = __smulx_383x63 hiu_37 hiv_38 f0_40 g0_40\n    lov_43 = __smulx_383x63 hiu_37 hiv_38 f1_41 g1_41\n    [f0_44, g0_44, f1_44, g1_44] = __ab_approximation_31 31 loa_40 lob_41\n    (hia_45, f0_45, g0_45) = __smulx_383_n_shift_by_31 loa_40 lob_41 f0_44 g0_44\n    (hib_46, f1_46, g1_46) = __smulx_383_n_shift_by_31 loa_40 lob_41 f1_44 g1_44\n    hiu_47 = __smulx_383x63 lou_42 lov_43 f0_45 g0_45\n    hiv_48 = __smulx_383x63 lou_42 lov_43 f1_46 g1_46\n    [f0_49, g0_49, f1_49, g1_49] = __ab_approximation_31 31 hia_45 hib_46\n    (loa_50, f0_50, g0_50) = __smulx_383_n_shift_by_31 hia_45 hib_46 f0_49 g0_49\n    (lob_51, f1_51, g1_51) = __smulx_383_n_shift_by_31 hia_45 hib_46 f1_49 g1_49\n    lou_52 = __smulx_383x63 hiu_47 hiv_48 f0_50 g0_50\n    lov_53 = __smulx_383x63 hiu_47 hiv_48 f1_51 g1_51\n    [f0_54, g0_54, f1_54, g1_54] = __ab_approximation_31 31 loa_50 lob_51\n    (hia_55, f0_55, g0_55) = __smulx_383_n_shift_by_31 loa_50 lob_51 f0_54 g0_54\n    (hib_56, f1_56, g1_56) = __smulx_383_n_shift_by_31 loa_50 lob_51 f1_54 g1_54\n    hiu_57 = __smulx_383x63 lou_52 lov_53 f0_55 g0_55\n    hiv_58 = __smulx_383x63 lou_52 lov_53 f1_56 g1_56\n    [f0_59, g0_59, f1_59, g1_59] = __ab_approximation_31 31 hia_55 hib_56\n    (loa_60, f0_60, g0_60) = __smulx_383_n_shift_by_31 hia_55 hib_56 f0_59 g0_59\n    (lob_61, f1_61, g1_61) = __smulx_383_n_shift_by_31 hia_55 hib_56 f1_59 g1_59\n    lou_62 = __smulx_383x63 hiu_57 hiv_58 f0_60 g0_60\n    lov_63 = __smulx_383x63 hiu_57 hiv_58 f1_61 g1_61\n    tmp64_r13_0 = sar (lov_63 @ 5) 0x3f\n    lov_64 = lov_63 # [tmp64_r13_0, tmp64_r13_0, tmp64_r13_0, tmp64_r13_0, tmp64_r13_0, tmp64_r13_0]\n    [f0_65, g0_65, f1_65, g1_65] = __ab_approximation_31 31 loa_60 lob_61\n    (hia_66, f0_66, g0_66) = __smulx_383_n_shift_by_31 loa_60 lob_61 f0_65 g0_65\n    (hib_67, f1_67, g1_67) = __smulx_383_n_shift_by_31 loa_60 lob_61 f1_65 g1_65\n    hiu_68 = __smulx_383x63 lou_62 (take lov_64) f0_66 g0_66\n    hiv_69 = __smulx_767x63 lou_62 lov_64 f1_67 g1_67\n    [f0_70, g0_70, f1_70, g1_70] = __ab_approximation_31 31 hia_66 hib_67\n    (loa_71, f0_71, g0_71) = __smulx_383_n_shift_by_31 hia_66 hib_67 f0_70 g0_70\n    (lob_72, f1_72, g1_72) = __smulx_383_n_shift_by_31 hia_66 hib_67 f1_70 g1_70\n    lou_73 = __smulx_383x63 hiu_68 (take hiv_69) f0_71 g0_71\n    lov_74 = __smulx_767x63 hiu_68 hiv_69 f1_72 g1_72\n    [f0_75, g0_75, f1_75, g1_75] = __ab_approximation_31 31 loa_71 lob_72\n    (hia_76, f0_76, g0_76) = __smulx_383_n_shift_by_31 loa_71 lob_72 f0_75 g0_75\n    (hib_77, f1_77, g1_77) = __smulx_383_n_shift_by_31 loa_71 lob_72 f1_75 g1_75\n    hiu_78 = __smulx_383x63 lou_73 (take lov_74) f0_76 g0_76\n    hiv_79 = __smulx_767x63 lou_73 lov_74 f1_77 g1_77\n    [f0_80, g0_80, f1_80, g1_80] = __ab_approximation_31 31 hia_76 hib_77\n    (loa_81, f0_81, g0_81) = __smulx_383_n_shift_by_31 hia_76 hib_77 f0_80 g0_80\n    (lob_82, f1_82, g1_82) = __smulx_383_n_shift_by_31 hia_76 hib_77 f1_80 g1_80\n    lou_83 = __smulx_383x63 hiu_78 (take hiv_79) f0_81 g0_81\n    lov_84 = __smulx_767x63 hiu_78 hiv_79 f1_82 g1_82\n    [f0_85, g0_85, f1_85, g1_85] = __ab_approximation_31 31 loa_81 lob_82\n    (hia_86, f0_86, g0_86) = __smulx_383_n_shift_by_31 loa_81 lob_82 f0_85 g0_85\n    (hib_87, f1_87, g1_87) = __smulx_383_n_shift_by_31 loa_81 lob_82 f1_85 g1_85\n    hiu_88 = __smulx_383x63 lou_83 (take lov_84) f0_86 g0_86\n    hiv_89 = __smulx_767x63 lou_83 lov_84 f1_87 g1_87\n    [f0_90, g0_90, f1_90, g1_90] = __ab_approximation_31 31 hia_86 hib_87\n    (loa_92, f0_92, g0_92) = __smulx_383_n_shift_by_31 hia_86 hib_87 f0_90 g0_90\n    (lob_93, f1_93, g1_93) = __smulx_383_n_shift_by_31 hia_86 hib_87 f1_90 g1_90\n    lou_94 = __smulx_383x63 hiu_88 (take hiv_89) f0_92 g0_92\n    lov_95 = __smulx_767x63 hiu_88 hiv_89 f1_93 g1_93\n    [f0_96, g0_96, f1_96, g1_96] = __ab_approximation_31 31 loa_92 lob_93\n    (hia_97, f0_97, g0_97) = __smulx_383_n_shift_by_31 loa_92 lob_93 f0_96 g0_96\n    (hib_98, f1_98, g1_98) = __smulx_383_n_shift_by_31 loa_92 lob_93 f1_96 g1_96\n    hiu_99 = __smulx_383x63 lou_94 (take lov_95) f0_97 g0_97\n    hiv_100 = __smulx_767x63 lou_94 lov_95 f1_98 g1_98\n    [f0_101, g0_101, f1_101, g1_101] = __ab_approximation_31 31 hia_97 hib_98\n    (loa_102, f0_102, g0_102) = __smulx_191_n_shift_by_31 (take`{3} hia_97) (take`{3} hib_98) f0_101 g0_101\n    (lob_103, f1_103, g1_103) = __smulx_191_n_shift_by_31 (take`{3} hia_97) (take`{3} hib_98) f1_101 g1_101\n    lou_104 = __smulx_383x63 hiu_99 (take hiv_100) f0_102 g0_102\n    lov_105 = __smulx_767x63 hiu_99 hiv_100 f1_103 g1_103\n    [f0_106, g0_106, f1_106, g1_106] = __ab_approximation_31 31 (loa_102 # drop`{3} loa_92) (lob_103 # drop`{3} lob_93)\n    (hia_107, f0_107, g0_107) = __smulx_191_n_shift_by_31 loa_102 lob_103 f0_106 g0_106\n    (hib_108, f1_108, g1_108) = __smulx_191_n_shift_by_31 loa_102 lob_103 f1_106 g1_106\n    hiu_109 = __smulx_383x63 lou_104 (take lov_105) f0_107 g0_107\n    hiv_110 = __smulx_767x63 lou_104 lov_105 f1_108 g1_108\n    [f0_111, g0_111, f1_111, g1_111] = __ab_approximation_31 31 (hia_107 # drop`{3} hia_97) (hib_108 # drop`{3} hib_98)\n    (loa_112, f0_112, g0_112) = __smulx_191_n_shift_by_31 hia_107 hib_108 f0_111 g0_111\n    (lob_113, f1_113, g1_113) = __smulx_191_n_shift_by_31 hia_107 hib_108 f1_111 g1_111\n    lou_114 = __smulx_383x63 hiu_109 (take hiv_110) f0_112 g0_112\n    lov_115 = __smulx_767x63 hiu_109 hiv_110 f1_113 g1_113\n    [f0_116, g0_116, f1_116, g1_116] = __ab_approximation_31 31 (loa_112 # drop`{3} loa_92) (lob_113 # drop`{3} lob_93)\n    (hia_117, f0_117, g0_117) = __smulx_191_n_shift_by_31 loa_112 lob_113 f0_116 g0_116\n    (hib_118, f1_118, g1_118) = __smulx_191_n_shift_by_31 loa_112 lob_113 f1_116 g1_116\n    hiu_119 = __smulx_383x63 lou_114 (take lov_115) f0_117 g0_117\n    hiv_120 = __smulx_767x63 lou_114 lov_115 f1_118 g1_118\n    earlyresult = take`{6} hiv_120\n    [f0_121, g0_121, f1_121, g1_121] = __inner_loop_62 55 (hia_117 @ 0) (hib_118 @ 0)\n    v_122 = __smulx_767x63 hiu_119 hiv_120 f1_121 g1_121\n    resultlow = take v_122\n    [r14_122, r15_122, rbx_122, rbp_122, rcx_122, rax_122] = drop v_122\n    rdx_123 = rax_122\n    tmp123_rax_0 = sar rax_122 0x3f\n    r8_123 = tmp123_rax_0 && (n @ 0)\n    r9_123 = tmp123_rax_0 && (n @ 1)\n    r10_123 = tmp123_rax_0 && (n @ 2)\n    r11_123 = tmp123_rax_0 && (n @ 3)\n    r12_123 = tmp123_rax_0 && (n @ 4)\n    rax_123 = tmp123_rax_0 && (n @ 5)\n    (tmp124_cf_0, r14_124) = add r14_122 r8_123\n    (tmp124_cf_1, r15_124) = adc r15_122 r9_123 tmp124_cf_0\n    (tmp124_cf_2, rbx_124) = adc rbx_122 r10_123 tmp124_cf_1\n    (tmp124_cf_3, rbp_124) = adc rbp_122 r11_123 tmp124_cf_2\n    (tmp124_cf_4, rcx_124) = adc rcx_122 r12_123 tmp124_cf_3\n    (tmp124_cf_5, rdx_124) = adc rdx_123 rax_123 tmp124_cf_4\n    result6 = r14_124\n    result7 = r15_124\n    result8 = rbx_124\n    result9 = rbp_124\n    result10 = rcx_124\n    result11 = rdx_124\n    result : Vec768\n    result = resultlow # [result6, result7, result8, result9, result10, result11]","variant":"hybrid","set":"unsupervised"}
{"filename":"formal-verso\/example-proofs\/CustomTypes.cry","filetype":"cry","content":"\/*\n * Cryptol-level stuff for modeling the custom type.\n *\n * The Rust representation of the type is a struct with two members\n * (count and last_incr), both u32.\n *\n * The native representation is a pair ([32], [32]).\n *\n * The Soroban-level representation is a Values::MapObject::T with the\n * field names as keys and the values being Values::U32::T.\n *\/\n\nmodule CustomTypes where\n\nimport Option as Option\nimport Values as Values\nimport submodule Values::Symbol as Values::Symbol\nimport submodule Values::MapObject as Values::MapObject\nimport submodule Values::U32 as Values::U32\nimport submodule Values::Raw as Values::Raw\n\ntype T = ([32], [32])\n\ndefault_value : T\ndefault_value = (0, 0)\n\ncountsym : Values::Symbol::T\ncountsym = Values::Symbol::from_native \"count\"\nlastsym : Values::Symbol::T\nlastsym = Values::Symbol::from_native \"last_incr\"\n\ncountsym_raw : Values::Raw::T\ncountsym_raw = Values::Symbol::to_raw countsym\nlastsym_raw : Values::Raw::T\nlastsym_raw = Values::Symbol::to_raw lastsym\n\n\/*\n * Check if the underlying MapObject is well formed.\n * XXX: we can't easily exclude extraneous map fields\n *\/\nvalid_with_heap : Values::MapObject::T -> Values::HostHeap -> Bool\nvalid_with_heap state_val heap =\n   Values::mapobj_has_key countsym_raw state_val heap \/\\\n   Values::mapobj_has_key lastsym_raw state_val heap \/\\\n   Values::raw_is_u32 count_val \/\\\n   Values::raw_is_u32 last_val\n   where\n      count_val = Values::mapobj_get countsym_raw state_val heap\n      last_val = Values::mapobj_get lastsym_raw state_val heap\n\n\/*\n * Extract the native representation from a MapObject.\n *\n * Should have already asserted that the elements are U32.\n * Crashes if they aren't.\n *\/\nval_to_native : Values::MapObject::T -> Values::HostHeap -> T\nval_to_native state_val heap =\n   (count_native, last_native)\n   where\n      count_raw = Values::MapObject::get countsym_raw state_val heap\n      last_raw = Values::MapObject::get lastsym_raw state_val heap\n      count_optval = Values::U32::from_raw count_raw\n      last_optval = Values::U32::from_raw last_raw\n      count_val =\n         if Option::is_some count_optval then Option::unsafe_unwrap count_optval\n                  else Values::U32::from_native 0\n      last_val =\n         if Option::is_some last_optval then Option::unsafe_unwrap last_optval\n                  else Values::U32::from_native 0\n      count_native = Values::U32::to_native count_val\n      last_native = Values::U32::to_native last_val\n","variant":"hybrid","set":"unsupervised"}
{"filename":"formal-verso\/example-proofs\/CustomTypes2.cry","filetype":"cry","content":"\/*\n * Cryptol-level stuff for modeling the custom type.\n *\n * The Rust representation of the type is a tuple struct with two\n * members, both u32.\n *\n * The native representation is a pair ([32], [32]).\n *\n * The Soroban-level representation is a Values::VecObject::T that\n * points to two Values::U32::T.\n *\/\n\nmodule CustomTypes2 where\n\nimport Option as Option\nimport Values as Values\nimport submodule Values::Symbol as Values::Symbol\nimport submodule Values::VecObject as Values::VecObject\nimport submodule Values::U32 as Values::U32\nimport submodule Values::Raw as Values::Raw\n\ntype T = ([32], [32])\n\ndefault_value : T\ndefault_value = (0, 0)\n\n\/*\n * Check if the underlying VecObject is well formed.\n *\/\nvalid_with_heap : Values::VecObject::T -> Values::HostHeap -> Bool\nvalid_with_heap state_val heap =\n   Values::vecobj_valid_with_heap state_val heap \/\\\n   Values::vecobj_len state_val heap == 2 \/\\\n   Values::raw_is_u32 count_val \/\\\n   Values::raw_is_u32 last_val\n   where\n      count_val = Values::vecobj_get state_val 0 heap\n      last_val = Values::vecobj_get state_val 1 heap\n\n\/*\n * Extract the native representation from a VecObject.\n *\n * Should have already asserted that the elements are U32.\n * Crashes if they aren't.\n *\/\nval_to_native : Values::VecObject::T -> Values::HostHeap -> T\nval_to_native state_val heap =\n   (count_native, last_native)\n   where\n      count_raw = Values::VecObject::get state_val 0 heap\n      last_raw = Values::VecObject::get state_val 1 heap\n      count_optval = Values::U32::from_raw count_raw\n      last_optval = Values::U32::from_raw last_raw\n      count_val =\n         if Option::is_some count_optval then Option::unsafe_unwrap count_optval\n                  else Values::U32::from_native 0\n      last_val =\n         if Option::is_some last_optval then Option::unsafe_unwrap last_optval\n                  else Values::U32::from_native 0\n      count_native = Values::U32::to_native count_val\n      last_native = Values::U32::to_native last_val\n","variant":"hybrid","set":"unsupervised"}
{"filename":"formal-verso\/example-proofs\/DataKeyEnum.cry","filetype":"cry","content":"module DataKeyEnum where\n\nimport Values as Values\nimport HostValues as HostValues\nimport submodule Values::VecObject as Values::VecObject\nimport submodule Values::Raw as Values::Raw\n\ntype T = (Values::SymbolT, Values::AddressObjectT)\n\nto_raw : Values::VecObject::T -> Values::Val\nto_raw vecobj = Values::VecObject::to_raw vecobj\n\nfrom_native : T -> HostValues::Heap -> (HostValues::Heap, Values::VecObject::T)\nfrom_native v heap = (Values::VecObject::pair v.0.val v.1.val heap)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"formal-verso\/lib\/Store.cry","filetype":"cry","content":"module Store where\n\nimport Array\nimport Option as Option\nimport Values as Values\nimport submodule Values::Raw as Raw\n\ntype T = Store\n\nprivate\n  newtype Store = { array : Array Raw::T OptionRawVal }\n  \/\/ Can't use Option Raw::T due to saw-script#1988\n  \/\/ first bit = exists, rest = data\n  type OptionRawVal = [65]\n\nhas : Store -> Raw::T -> Bit\nhas s k = Option::is_ok (get s k)\n\nget : Store -> Raw::T -> Option::T Raw::T\nget s k =\n   Option::mk (head orv) (Raw::from_payload (tail orv))\n   where orv = arrayLookup s.array k\n\nset : Store -> Raw::T -> Raw::T -> Store\nset s k v =\n   Store { array = arrayUpdate s.array k (0b1 # payload) }\n   where payload = Raw::get_payload v\n","variant":"hybrid","set":"unsupervised"}
{"filename":"formal-verso\/lib\/Values.cry","filetype":"cry","content":"\/*\n * Soroban SDK values.\n *\n * This is intentionally supposed to have the same bit encoding as the\n * Soroban SDK. See src\/val.rs in soroban-env-common, plus also a few\n * other modules like num.rs.\n *\n * Values are a tagged union stored in a 64-bit machine integer, where\n * the lower 8 bits are used as a type tag. The remaining 56 bits are\n * (in some cases) divided into a 32-bit major part and 24-bit minor\n * part. The major part is the upper half of the full 64-bit value.\n * That is:\n *      63       32  31        8  7       0\n *     |-- major --||-- minor --||-- tag --|\n *\n * The type Val is this type-tagged representation of any Soroban\n * value.\n *\n * The following types are wrappers around it theoretically restricted\n * to the values corresponding to their type, as in the Rust code:\n *    Void::T\n *    Bool::T\n *    U32::T\n *     :\n *\n * The layout of this module is intended to mirror val.rs, though it's\n * difficult to do exactly.\n *\n * Also, my intent is to not let the type tags escape from this module,\n * which is somewhat in conflict with the desire to match val.rs.\n *\n * Note: i'm using math ints for bit sizes and widths, not because\n * they need to be unbounded, but in the hopes that accidentally\n * mixing sizes with values or pieces of values will reliably lead to\n * type errors.\n *\/\n\nmodule Values where\n\nimport Option as Option\nimport HostValues as HostValues\n\n\/\/ Sizes\nprivate\n   type WORD_BITS  = 64\n   type TAG_BITS   =  8\n   type BODY_BITS  = 56\n   type MAJOR_BITS = 32\n   type MINOR_BITS = 24\n\n\/\/ trivial but worth stating and crosschecking\nproperty BODY_TAG_WORD_BITS    = `BODY_BITS  + `TAG_BITS   == `WORD_BITS\nproperty MAJOR_MINOR_BODY_BITS = `MAJOR_BITS + `MINOR_BITS == `BODY_BITS\n\/\/ apparently you can't do this except by loading the file and running\n\/\/ :prove from the repl :-(\n\/\/prove MAJOR_MINOR_BODY_BITS\n\/\/prove BODY_TAG_WORD_BITS\n\n\/\/ Masks\n\/\/\n\/\/ In keeping with tag.rs we'll use FOO_MASK to mean a right-aligned\n\/\/ mask of the proper size; the intended usage for extracting a field\n\/\/ is apparently\n\/\/    (val >> shift-amount) && FOO_MASK\n\/\/ but val.rs doesn't seem to define constants for the shift amounts.\n\/\/\n\/\/ We'll also define FOO_SHIFT as the shift amounts.\n\/\/\n\nprivate\n   mask_of_width : Integer -> [64]\n   mask_of_width w = (1 << w) - 1\n\n   TAG_MASK   = mask_of_width `TAG_BITS\n   BODY_MASK  = mask_of_width `BODY_BITS\n   MAJOR_MASK = mask_of_width `MAJOR_BITS\n   MINOR_MASK = mask_of_width `MINOR_BITS\n\n   TAG_SHIFT   = 0 : Integer\n   BODY_SHIFT  = `TAG_BITS\n   MAJOR_SHIFT = `MINOR_BITS + `TAG_BITS\n   MINOR_SHIFT = `TAG_BITS\n\n\/\/ check these came out as expected\nproperty TAG_MASK_BITS   = TAG_MASK   == 0x00000000000000ff\nproperty BODY_MASK_BITS  = BODY_MASK  == 0x00ffffffffffffff\nproperty MAJOR_MASK_BITS = MAJOR_MASK == 0x00000000ffffffff\nproperty MINOR_MASK_BITS = MINOR_MASK == 0x0000000000ffffff\nproperty TAG_MASK_SHIFTED   = (TAG_MASK << TAG_SHIFT)     == 0x00000000000000ff\nproperty BODY_MASK_SHIFTED  = (BODY_MASK << BODY_SHIFT)   == 0xffffffffffffff00\nproperty MAJOR_MASK_SHIFTED = (MAJOR_MASK << MAJOR_SHIFT) == 0xffffffff00000000\nproperty MINOR_MASK_SHIFTED = (MINOR_MASK << MINOR_SHIFT) == 0x00000000ffffff00\n\/\/prove TAG_MASK_BITS\n\/\/prove BODY_MASK_BITS\n\/\/prove MAJOR_MASK_BITS\n\/\/prove MINOR_MASK_BITS\n\/\/prove TAG_MASK_SHIFTED\n\/\/prove BODY_MASK_SHIFTED\n\/\/prove MAJOR_MASK_SHIFTED\n\/\/prove MINOR_MASK_SHIFTED\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ type tags\n\/\/ val.rs 42-157\n\nprivate\n   type Tag = [TAG_BITS]\n\n\/*\n * These magic numbers are the ones used in val.rs.\n *\n * Commented-out ones are those we don't use yet.\n *\/\n\nprivate\n   tag_false = 0 : Tag\n   tag_true = 1 : Tag\n   tag_void = 2 : Tag\n   \/\/tag_error = 3 : Tag\n   tag_u32val = 4 : Tag\n   tag_i32val = 5 : Tag\n   \/\/tag_u64small = 6 : Tag\n   \/\/tag_i64small = 7 : Tag\n   \/\/tag_timepointsmall = 8 : Tag\n   \/\/tag_durationsmall = 9 : Tag\n   \/\/tag_u128small = 10 : Tag\n   \/\/tag_i128small = 11 : Tag\n   \/\/tag_u256small = 12 : Tag\n   \/\/tag_i256small = 13 : Tag\n   tag_symbolsmall = 14 : Tag\n\n   \/\/ upper bound of \"small\" types and lower bound of \"object\" types\n   \/\/ (these are called \"code\" rather than \"tag\" in the sdk source;\n   \/\/ for now at least I'm proceeding on the assumption that the lack\n   \/\/ of correspondence between here and there is less important than\n   \/\/ consistency of naming here)\n   small_tag_upper_bound = 15 : Tag\n   object_tag_lower_bound = 63 : Tag\n\n   \/\/tag_u64object = 64 : Tag\n   \/\/tag_i64object = 65 : Tag\n   \/\/tag_timepointobject = 66 : Tag\n   \/\/tag_durationobject = 67 : Tag\n   \/\/tag_u128object = 68 : Tag\n   \/\/tag_i128object = 69 : Tag\n   \/\/tag_u256object = 70 : Tag\n   \/\/tag_i256object = 71 : Tag\n   \/\/tag_bytesobject = 72 : Tag\n   tag_stringobject = 73 : Tag\n   tag_symbolobject = 74 : Tag\n   tag_vecobject = 75 : Tag\n   tag_mapobject = 76 : Tag\n   tag_addressobject = 77 : Tag\n\n   \/\/ correspondingly, upper bound of \"object\" types\n   object_tag_upper_bound = 78 : Tag\n\n   \/\/ tag for invalid values\n   badtag = 0x7f : Tag\n\n\/\/\n\/\/ checks on type tags\n\/\/\n\nprivate\n   tag_is_object : Tag -> Bool\n   tag_is_object x =\n      (x > object_tag_lower_bound) && (x < object_tag_upper_bound)\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ small symbol encoding\n\n\/*\n * There are 63 valid symbol chars (0-9, A-Z, a-z, and _) so\n * we can pack up to 9 of them in 54 bits of the 56-bit body\n * field. Soroban does this in order to avoid having to materialize\n * object-style strings in the common case, and we follow along\n * because we're trying to use the same representations.\n *\/\n\nprivate\n   type MAX_SMALL_CHARS = 9\n   type CODE_BITS = 6\n   CODE_MASK = mask_of_width `CODE_BITS\n   \/\/ size and mask for the whole encoded string (goes in the body field)\n   type SMALLSYM_BITS = MAX_SMALL_CHARS * CODE_BITS\n   SMALLSYM_MASK = mask_of_width `SMALLSYM_BITS\n\nproperty SMALLSYM_BODY_BITS = `SMALLSYM_BITS + 2 == `BODY_BITS\nproperty CODE_MASK_BITS     = CODE_MASK     == 0x000000000000003f\nproperty SMALLSYM_MASK_BITS = SMALLSYM_MASK == 0x003fffffffffffff\n\/\/prove CODE_MASK_BITS\n\/\/prove SMALLSYM_MASK_BITS\n\nprivate\n   smallsym_body_valid : [BODY_BITS] -> Bool\n   smallsym_body_valid body = zext body == (zext body && SMALLSYM_MASK)\n\n\/\/ symbol.rs lines 229-238 (where it's \"encode_byte\")\nprivate\n   smallsym_encode : Char -> [CODE_BITS]\n   smallsym_encode ch =\n      if ch == '_' then 1\n      | elem ch ['0'..'9'] then 2 + drop (ch - '0')\n      | elem ch ['A'..'Z'] then 12 + drop (ch - 'A')\n      | elem ch ['a'..'z'] then 38 + drop (ch - 'a')\n      else error\n         (\"symbol bad char: encountered \" # [ch]\n           # \", supported range [a-zA-Z0-9_]\")\n\n   smallsym_decode : [CODE_BITS] -> Char\n   smallsym_decode code =\n      if code == 1 then '_'\n      | elem code [2 .. 2+9] then '0' + zext (code - 2)\n      | elem code [12 .. 12+25] then 'A' + zext (code - 12)\n      | elem code [38 .. 38+25] then 'a' + zext (code - 38)\n      | code == 0 then 0 \/* XXX undesirable *\/\n      else error \"false\"\n\n\/\/ symbol.rs lines 240-256 (where it's \"try_from_bytes\")\n\/\/\n\/\/ XXX I'm not sure either of these handles the characters in the same\n\/\/ order as the rust code.\n\/\/\n\/\/ XXX currently you have to know how many characters are in the\n\/\/ decoded string. This is not optimal.\n\/\/private\nsmallsym_body_of_string : {n} (n <= MAX_SMALL_CHARS) => String n -> [56]\nsmallsym_body_of_string s = zext (join (map smallsym_encode s))\n\nsmallsym_string_of_body : {n} (n <= MAX_SMALL_CHARS) => [56] -> String n\nsmallsym_string_of_body bits =\n   take`{n} ((map smallsym_decode (split`{9} bits')) : String 9)\n   where\n      bits' = drop bits : [SMALLSYM_BITS]\n\n\n\/\/ XXX can't make it private; using an accessor function in\n\/\/ to_mir_value in soroban.saw breaks SAW.\n\/\/private\nnewtype Val = { bits: [WORD_BITS] }\n\n\/\/\n\/\/ You can't (yet) derive typeclass instances for newtypes, so until\n\/\/ then we need this (and to use it explicitly where it would be nicer\n\/\/ to write \"==\")\nprivate\n   small_val_eq : Val -> Val -> Bool\n   small_val_eq v1 v2 = v1.bits == v2.bits\n\n   full_eq : Val -> Val -> HostValues::Heap -> Bool\n   full_eq v1 v2 heap =\n      if tag1 != tag2 then False\n      | tag1 < small_tag_upper_bound then small_val_eq v1 v2\n      \/\/| tag1 == tag_symbolobject  \/\/ XXX notyet, the heap doesn't support them yet\n      | tag1 == tag_vecobject then\n           if handle1 == handle2 then True\n           | HostValues::present_as_vec handle1 heap == False then False\n           | HostValues::present_as_vec handle2 heap == False then False\n           else\n              HostValues::vec_representation_equiv rawraw_eq rep1 rep2 heap\n              where\n                 rep1 = Option::crashing_unwrap (HostValues::lookup_vec handle1 heap)\n                 rep2 = Option::crashing_unwrap (HostValues::lookup_vec handle2 heap)\n           where\n              handle1 = major_of_val v1\n              handle2 = major_of_val v2\n      | tag1 == tag_mapobject then\n           if handle1 == handle2 then True\n           | HostValues::present_as_map handle1 heap == False then False\n           | HostValues::present_as_map handle2 heap == False then False\n           else\n              HostValues::map_representation_equiv rawraw_eq rep1 rep2 heap\n              where\n                 rep1 = Option::crashing_unwrap (HostValues::lookup_map handle1 heap)\n                 rep2 = Option::crashing_unwrap (HostValues::lookup_map handle2 heap)\n           where\n              handle1 = major_of_val v1\n              handle2 = major_of_val v2\n      | tag1 == tag_addressobject then\n\n           \/\/ AddressObjects don't contain other things; they're\n           \/\/ opaque blobs. Two are equal if they have the same bits.\n           \/\/ (and only the major field is significant)\n           handle1 == handle2\n           where\n              handle1 = major_of_val v1\n              handle2 = major_of_val v2\n      else False\n      where\n         tag1 = tag_of_val v1\n         tag2 = tag_of_val v2\n\n   rawraw_eq : [WORD_BITS] -> [WORD_BITS] -> HostValues::Heap -> Bool\n   rawraw_eq rr1 rr2 heap = full_eq v1 v2 heap\n      where\n         v1 = Val { bits = rr1 }\n         v2 = Val { bits = rr2 }\n\n\/*\n * Field extraction functions\n * (these don't neatly correspond to anything in the rust code)\n *\/\n\nprivate\n   body_of_val : Val -> [BODY_BITS]\n   body_of_val v = drop ((v.bits >> BODY_SHIFT) && BODY_MASK)\n\n   tag_of_val : Val -> Tag\n   tag_of_val v = drop ((v.bits >> TAG_SHIFT) && TAG_MASK)\n\n   major_of_val : Val -> [MAJOR_BITS]\n   major_of_val v = drop ((v.bits >> MAJOR_SHIFT) && MAJOR_MASK)\n\n   minor_of_val : Val -> [MINOR_BITS]\n   minor_of_val v = drop ((v.bits >> MINOR_SHIFT) && MINOR_MASK)\n\n   rawraw_of_val : Val -> [WORD_BITS]\n   rawraw_of_val v = v.bits\n\n   rawraw_of_vals: {n} fin n => [n] Val -> [n] [64]\n   rawraw_of_vals vs = map rawraw_of_val vs\n\n   val_of_rawraw : [WORD_BITS] -> Val\n   val_of_rawraw rr = Val { bits = rr }\n\n\n\/*\n * Construction functions\n * (likewise)\n *\/\nprivate\n   val_of_body_tag : [56] -> Tag -> Val\n   val_of_body_tag body tag =\n      Val { bits = (body' || tag') }\n      where\n         body' = zext`{64} body << BODY_SHIFT\n         tag' = zext`{64} tag << TAG_SHIFT\n\n   val_of_major_minor_tag : [32] -> [24] -> Tag -> Val\n   val_of_major_minor_tag major minor tag =\n      Val { bits = (major' || minor' || tag') }\n      where\n         major' = zext`{64} major << MAJOR_SHIFT\n         minor' = zext`{64} minor << MINOR_SHIFT\n         tag' = zext`{64} tag << TAG_SHIFT\n\n\/*\n * Constructors and constants\n *\/\n\nprivate\n   badval = val_of_body_tag 0 badtag\n\n   val_unit = val_of_body_tag 0 tag_void\n   val_true = val_of_body_tag 0 tag_true\n   val_false = val_of_body_tag 0 tag_false\n\n   encode_32 : [32] -> Val\n   encode_32 x = val_of_major_minor_tag x 0 tag_u32val\n   encode_u32 x = encode_32 x\n   encode_i32 x = encode_32 x\n\n   decode_32 : Val -> [32]\n   decode_32 v = major_of_val v\n   decode_u32 x = decode_32 x\n   decode_i32 x = decode_32 x\n\n   encode_symbolsmall s =\n      val_of_body_tag (smallsym_body_of_string s) tag_symbolsmall\n   decode_symbolsmall v =\n      smallsym_string_of_body (body_of_val v)\n\n      encode_symbolobject _s =\n      error \"Cannot encode symbol objects yet\"\n   decode_symbolobject _v =\n      error \"Cannot decode symbol objects yet\"\n\n\nsubmodule Raw where\n   type T = Val\n\n   \/*\n    * Inspection functions\n    *\/\n\n      val_is_good : T -> Bool\n   val_is_good v =\n      if small_val_eq v val_false \\\/\n         small_val_eq v val_true \\\/\n         small_val_eq v val_unit then True\n       | tag == tag_u32val then minor_of_val v == 0\n       | tag == tag_i32val then minor_of_val v == 0\n       | tag == tag_symbolsmall then smallsym_body_valid (body_of_val v)\n       | tag == tag_symbolobject then\n                        error \"Cannot interpret symbol objects yet\"\n       | tag == tag_mapobject then\n            minor_of_val v == 0\n       else False\n      where tag = tag_of_val v\n\n   \/*\n    * External functions matching those from val.rs\n    *\/\n\n      get_payload : T -> [64]\n   get_payload x = x.bits\n\n      from_payload : [64] -> T\n   from_payload x = Val { bits = x }\n\n      shallow_eq : T -> T -> Bool\n   shallow_eq x y = x.bits == y.bits\n\n      private\n      get_tag : T -> Tag\n      get_tag v = tag_of_val v\n\n      private\n      has_tag : Tag -> T -> Bool\n      has_tag t v = tag_of_val v == t\n\n      get_body : T -> [BODY_BITS]\n   get_body v = body_of_val v\n\n      has_body : T -> [BODY_BITS] -> Bool\n   has_body v w = body_of_val v == w\n\n      private\n      from_body_and_tag : [BODY_BITS] -> Tag -> T\n      from_body_and_tag body tag = val_of_body_tag body tag\n\n      private\n      from_major_minor_and_tag : [MAJOR_BITS] -> [MINOR_BITS] -> Tag -> T\n      from_major_minor_and_tag major minor tag =\n         val_of_major_minor_tag major minor tag\n\n      has_minor : T -> [MINOR_BITS] -> Bool\n   has_minor v minor = minor_of_val v == minor\n\n      has_major : T -> [MAJOR_BITS] -> Bool\n   has_major v major = major_of_val v == major\n\n      get_minor : T -> [MINOR_BITS]\n   get_minor v = minor_of_val v\n\n      get_major : T -> [MAJOR_BITS]\n   get_major v = major_of_val v\n\n      is_object : T -> Bool\n   is_object v = tag_is_object (tag_of_val v)\n\n      is_void : T -> Bool\n   is_void v = small_val_eq v val_unit\n\n      is_true : T -> Bool\n   is_true v = small_val_eq v val_true\n\n      is_false : T -> Bool\n   is_false v = small_val_eq v val_false\n\n   \/\/ additional type tests\n   \/\/\n   \/\/ XXX: these need to be the entire validity predicate or bad things happen\n   \/\/ when they're used as preconditions. should reorganize to make things\n   \/\/ clearer.\n   \/\/\n   \/\/ XXX: also should reorganize to avoid duplicating this logic.\n\n   is_bool : T -> Bool\n   is_bool v = is_true v \\\/ is_false v\n\n   is_u32 : T -> Bool\n   is_u32 v = tag_of_val v == tag_u32val \/\\ minor_of_val v == 0\n\n   is_i32 : T -> Bool\n   is_i32 v = tag_of_val v == tag_i32val \/\\ minor_of_val v == 0\n\n   is_string : T -> Bool\n   is_string v =\n      tag_of_val v == tag_stringobject \/\\ minor_of_val v == 0\n\n   is_symbol : T -> Bool\n   is_symbol v =\n      (tag_of_val v == tag_symbolsmall \/\\ smallsym_body_valid (body_of_val v)) \\\/\n      (tag_of_val v == tag_symbolobject \/\\ minor_of_val v == 0)\n\n   is_vec : T -> Bool\n   is_vec v = tag_of_val v == tag_vecobject \/\\ minor_of_val v == 0\n\n   is_map : T -> Bool\n   is_map v = tag_of_val v == tag_mapobject \/\\ minor_of_val v == 0\n\n   \/\/ go straight to full_eq\n   eq: T -> T -> HostValues::Heap -> Bool\n   eq x y heap = full_eq x y heap\n\n\nsubmodule Void where\n   newtype T = { val : Val }\n\n   unit : T\n   unit = T { val = val_unit }\n\n   valid' : Val -> Bool\n   valid' v = small_val_eq v val_unit\n\n   valid : T -> Bool\n   valid x = valid' x.val\n\n   to_raw : T -> Val\n   to_raw x = x.val\n\n   from_raw : Val -> Option::T T\n   from_raw x =\n      if valid' x then Option::some (T { val = x })\n      else Option::none' (T { val = badval })\n\n   to_native : T -> ()\n   to_native _ = ()\n\n   from_native : () -> T\n   from_native () = unit\n\nunit = Void::unit\n\n\nsubmodule Bool where\n   newtype T = { val : Val }\n\n   true : T\n   true = T { val = val_true }\n\n   false : T\n   false = T { val = val_false }\n\n   valid' : Val -> Bool\n   valid' v = small_val_eq v val_true \\\/ small_val_eq v val_false\n\n   valid : T -> Bool\n   valid b = valid' b.val\n\n   to_raw : T -> Val\n   to_raw b = b.val\n\n   from_raw : Val -> Option::T T\n   from_raw b =\n      if valid' b then Option::some (T { val = b })\n      else Option::none' (T { val = badval })\n\n   to_native : T -> Bool\n   to_native b =\n      if small_val_eq b.val true.val then True else False\n\n   from_native : Bool -> T\n   from_native b = if b then true else false\n\ntrue = Bool::true\nfalse = Bool::false\n\n\nsubmodule U32 where\n   newtype T = { val : Val }\n\n   valid' : Val -> Bool\n   valid' v = tag_of_val v == tag_u32val \/\\ minor_of_val v == 0\n\n   valid : T -> Bool\n   valid k = valid' k.val\n\n   to_raw : T -> Val\n   to_raw k = k.val\n\n   from_raw : Val -> Option::T T\n   from_raw v =\n      if valid' v then Option::some (T { val = v })\n      else Option::none' (T { val = badval })\n\n   to_native : T -> [32]\n   to_native k = decode_u32 k.val\n\n   from_native : [32] -> T\n   from_native k = T { val = encode_u32 k }\n\n   ZERO : T\n   ZERO = from_native 0\n\n   ONE : T\n   ONE = from_native 1\n\n   MIN : T\n   MIN = from_native 0\n\n   MAX : T\n   MAX = from_native (~0)\n\nu32_zero = U32::ZERO\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ i32\n\/\/ val.rs lines 505-514, 799-801\n\/\/ num.rs lines 13, 21-24, 67-77\n\nsubmodule I32 where\n   newtype T = { val : Val }\n\n   valid' : Val -> Bool\n   valid' v = tag_of_val v == tag_i32val \/\\ minor_of_val v == 0\n\n   valid : T -> Bool\n   valid k = valid' k.val\n\n   to_raw : T -> Val\n   to_raw k = k.val\n\n   from_raw : Val -> Option::T T\n   from_raw v =\n      if valid' v then Option::some (T { val = v })\n      else Option::none' (T { val = badval })\n\n   to_native : T -> [32]\n   to_native k = decode_i32 k.val\n\n   from_native : [32] -> T\n   from_native k = T { val = encode_i32 k }\n\n   ZERO : T\n   ZERO = from_native 0\n\n   ONE : T\n   ONE = from_native 1\n\n   MIN : T\n   MIN = from_native 0x80000000\n\n   MAX : T\n   MAX = from_native 0x7fffffff\n\ni32_zero = I32::ZERO\n\n\n\/\/ Note that the rust code has an additional layer of type logic\n\/\/ around RawVal called Object that's shared by all the host-side\n\/\/ objects. We don't model that; we just use Raw.\n\nsubmodule StringObject where\n   newtype T = { val : Val }\n\n   valid' : Val -> Bool\n   valid' v = tag_of_val v == tag_stringobject \/\\ minor_of_val v == 0\n\n   valid : T -> Bool\n   valid vs = valid' vs.val\n\n   \/\/ note: call plain valid first\n   valid_with_heap : T -> HostValues::Heap -> Bool\n   valid_with_heap vs heap = HostValues::present_as_string handle heap\n      where handle = major_of_val vs.val\n\n   to_raw : T -> Val\n   to_raw vs = vs.val\n\n   from_raw : Val -> Option::T T\n   from_raw v =\n      if valid' v then Option::some (T { val = v })\n      else Option::none' (T { val = badval })\n\n   from_handle : [32] -> T\n   from_handle handle = T { val = val_of_major_minor_tag handle 0 tag_stringobject }\n\n   \/\/ allocating constructors\n\n   from_stringrep : HostValues::StringRepresentation -> HostValues::Heap -> (HostValues::Heap, T)\n   from_stringrep rep heap = (heap', from_handle handle)\n      where (heap', handle) = HostValues::alloc_string rep heap\n\n   dummy: () -> HostValues::Heap -> (HostValues::Heap, T)\n   dummy () heap = from_stringrep rep heap\n      where rep = HostValues::string_representation_dummy\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ symbol\n\/\/ symbol.rs (more or less all of it)\n\nsubmodule Symbol where\n   newtype T = { val : Val }\n\n   valid' : Val -> Bool\n   valid' v =\n      \/\/ Don't allow symbol objects here. They aren't actually\n      \/\/ supported, and with the eq change noted below allowing them\n      \/\/ to exist can create problems.\n      \/\/valid_symbolsmall \\\/ valid_symbolobject\n      valid_symbolsmall\n      where\n         tag = tag_of_val v\n         valid_symbolsmall = tag == tag_symbolsmall \/\\ smallsym_body_valid (body_of_val v)\n         valid_symbolobject = tag == tag_symbolobject \/\\ minor_of_val v == 0\n\n   valid : T -> Bool\n   valid x = valid' x.val\n\n   to_raw : T -> Val\n   to_raw x = x.val\n\n   from_raw : Val -> Option::T T\n   from_raw v =\n      if valid' v then Option::some (T { val = v })\n      else Option::none' (T { val = badval })\n\n   from_native : {n} fin n => String n -> T\n   from_native x\n      | n <= MAX_SMALL_CHARS => T { val = encode_symbolsmall x }\n      | n > MAX_SMALL_CHARS => T { val = encode_symbolobject x }\n\n   \/*\n   to_native : {n} fin n => T -> String n\n   to_native x =\n      if tag == tag_symbolsmall then decode_symbolsmall x.val\n      else decode_symbolobject x.val\n      where\n         tag = tag_of_val x.val\n*\/\n\n   \/* workarounds: *\/\n   is_small : T -> Bool\n   is_small x = tag_of_val x.val == tag_symbolsmall\n\n   to_native_small : {n} n <= MAX_SMALL_CHARS => T -> String n\n   to_native_small x = decode_symbolsmall x.val\n\n   to_native_object : {n} n > MAX_SMALL_CHARS => T -> String n\n   to_native_object x = decode_symbolobject x.val\n\n   \/\/ defer equality to raw to avoid duplication (since full_eq needs\n   \/\/ to be recursive)\n   eq: T -> T -> HostValues::Heap -> Bool\n   \/\/ XXX this causes saw to diverge exploring invalid heaps\n   \/\/ (note: when unwinding this also update valid' above)\n   \/\/eq x y heap = full_eq x.val y.val heap\n   \/\/ and XXX this won't work for SymbolObject\n   eq x y heap = small_val_eq x.val y.val\n\n\n\/\/ Note that the rust code has an additional layer of type logic\n\/\/ around RawVal called Object that's shared by all the host-side\n\/\/ objects. We don't model that; we just use Raw.\n\nsubmodule VecObject where\n   newtype T = { val : Val }\n\n   valid' : Val -> Bool\n   valid' v = tag_of_val v == tag_vecobject \/\\ minor_of_val v == 0\n\n   valid : T -> Bool\n   valid vs = valid' vs.val\n\n   \/\/ note: call plain valid first\n   valid_with_heap : T -> HostValues::Heap -> Bool\n   valid_with_heap vs heap = HostValues::present_as_vec handle heap\n      where handle = major_of_val vs.val\n\n   to_raw : T -> Val\n   to_raw vs = vs.val\n\n   from_raw : Val -> Option::T T\n   from_raw v =\n      if valid' v then Option::some (T { val = v })\n      else Option::none' (T { val = badval })\n\n   from_handle : [32] -> T\n   from_handle handle = T { val = val_of_major_minor_tag handle 0 tag_vecobject }\n\n   \/\/ XXX: this should not exist, but for the time being we need it to\n   \/\/ live in the None case of Option::T and similar circumstances.\n   \/\/ When we can use Cryptol sums and the real Option type, it should\n   \/\/ go away.\n   invalid : T\n   invalid = T {val = badval }\n\n   \/\/ allocating constructors\n\n   from_vecrep : HostValues::VecRepresentation -> HostValues::Heap -> (HostValues::Heap, T)\n   from_vecrep rep state = (state', from_handle handle)\n      where (state', handle) = HostValues::alloc_vec rep state\n\n   empty: HostValues::Heap -> (HostValues::Heap, T)\n   empty state = from_vecrep rep state\n      where rep = HostValues::vec_representation_empty\n\n   singleton: Val -> HostValues::Heap -> (HostValues::Heap, T)\n   singleton v state = from_vecrep rep state\n      where rep = HostValues::vec_representation_singleton (rawraw_of_val v)\n\n   pair: Val -> Val -> HostValues::Heap -> (HostValues::Heap, T)\n   pair v w state = from_vecrep rep state\n      where rep = HostValues::vec_representation_pair (rawraw_of_val v) (rawraw_of_val w)\n\n   triple: Val -> Val -> Val -> HostValues::Heap -> (HostValues::Heap, T)\n   triple v w x state = from_vecrep rep state\n      where rep = HostValues::vec_representation_triple (rawraw_of_val v) (rawraw_of_val w) (rawraw_of_val x)\n\n   quad: Val -> Val -> Val -> Val -> HostValues::Heap -> (HostValues::Heap, T)\n   quad v w x y state = from_vecrep rep state\n      where rep = HostValues::vec_representation_quad (rawraw_of_val v) (rawraw_of_val w) (rawraw_of_val x) (rawraw_of_val y)\n\n   quint: Val -> Val -> Val -> Val -> Val -> HostValues::Heap -> (HostValues::Heap, T)\n   quint v w x y z state = from_vecrep rep state\n      where rep = HostValues::vec_representation_quint (rawraw_of_val v) (rawraw_of_val w) (rawraw_of_val x) (rawraw_of_val y) (rawraw_of_val z)\n\n      n: [32] -> Val -> HostValues::Heap -> (HostValues::Heap, T)\n   n num v state = from_vecrep rep state\n      where rep = HostValues::vec_representation_n num (rawraw_of_val v)\n\n   seq: {n} n < 0xffffffff => [n] Val -> HostValues::Heap -> (HostValues::Heap, T)\n   seq vs state = from_vecrep rep state\n      where rep = HostValues::vec_representation_seq (rawraw_of_vals vs)\n\n   \/\/ lookups\n   \/\/ these will all misbehave on nonexistent values; use valid_with_heap first\n   \/\/ (XXX: using Option::crashing_unwrap crashes... look into why)\n   getrep: T -> HostValues::Heap -> HostValues::VecRepresentation\n   getrep vs heap = Option::unsafe_unwrap optval\n      where\n         handle = major_of_val vs.val\n         optval = HostValues::lookup_vec handle heap\n\n   len: T -> HostValues::Heap -> [32]\n   len vs heap = rep.size\n      where rep = getrep vs heap\n\n   \/\/ get the kth value; return unit when out of bounds\n   get: T -> [32] -> HostValues::Heap -> Val\n   get vs k heap = val_of_rawraw rawraw\n      where\n         rep = getrep vs heap\n         dfl = rawraw_of_val (Void::to_raw unit)\n         rawraw = HostValues::vec_representation_get_default rep k dfl\n\n   \/\/ get all the values\n   getall: {n} n <= 0xffffffff => T -> HostValues::Heap -> [n] Val\n   getall vs heap = map val_of_rawraw rawraws\n      where\n         rep = getrep vs heap\n         dfl = rawraw_of_val (Void::to_raw unit)\n         rawraws = HostValues::vec_representation_getall`{n} rep dfl\n\n   \/\/ defer equality to raw to avoid duplication (since full_eq needs\n   \/\/ to be recursive)\n   eq: T -> T -> HostValues::Heap -> Bool\n   eq vs1 vs2 heap = full_eq vs1.val vs2.val heap\n\n   \/\/ allocating modifications\n   addtail: T -> Val -> HostValues::Heap -> (HostValues::Heap, T)\n   addtail v x heap = from_vecrep rep' heap\n      where\n         rep = getrep v heap\n         rep' = HostValues::vec_representation_addtail rep (rawraw_of_val x)\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ mapobject\n\/\/ val.rs line 331\n\nsubmodule MapObject where\n   newtype T = { val : Val }\n\n   valid' : Val -> Bool\n   valid' v = tag_of_val v == tag_mapobject \/\\ minor_of_val v == 0\n\n   valid : T -> Bool\n   valid m = valid' m.val\n\n   \/\/ note: call plain valid first\n   valid_with_heap : T -> HostValues::Heap -> Bool\n   valid_with_heap m heap = HostValues::present_as_map handle heap\n      where handle = major_of_val m.val\n\n   to_raw : T -> Val\n   to_raw m = m.val\n\n   from_raw : Val -> Option::T T\n   from_raw v =\n      if valid' v then Option::some (T { val = v })\n      else Option::none' (T { val = badval })\n\n   from_handle : [32] -> T\n   from_handle handle = T { val = val_of_major_minor_tag handle 0 tag_mapobject }\n\n   \/\/ XXX: this should not exist, but for the time being we need it to\n   \/\/ live in the None case of Option::T and similar circumstances.\n   \/\/ When we can use Cryptol sums and the real Option type, it should\n   \/\/ go away.\n   invalid : T\n   invalid = T {val = badval }\n\n   \/\/ allocating constructors\n\n   from_maprep : HostValues::MapRepresentation -> HostValues::Heap -> (HostValues::Heap, T)\n   from_maprep rep heap = (heap', from_handle handle)\n      where (heap', handle) = HostValues::alloc_map rep heap\n\n   empty: HostValues::Heap -> (HostValues::Heap, T)\n   empty heap = from_maprep rep heap\n      where rep = HostValues::map_representation_empty\n\n   singleton: Val -> Val -> HostValues::Heap -> (HostValues::Heap, T)\n   singleton k v heap = from_maprep rep heap\n      where\n         k' = rawraw_of_val k\n         v' = rawraw_of_val v\n         rep = HostValues::map_representation_singleton k' v'\n\n   pair: Val -> Val -> Val -> Val -> HostValues::Heap -> (HostValues::Heap, T)\n   pair k1 v1 k2 v2 heap = from_maprep rep heap\n      where\n         k1' = rawraw_of_val k1\n         v1' = rawraw_of_val v1\n         k2' = rawraw_of_val k2\n         v2' = rawraw_of_val v2\n         rep = HostValues::map_representation_pair k1' v1' k2' v2'\n\n   seq: {n} n < 0xffffffff => [n] Val -> [n] Val -> HostValues::Heap -> (HostValues::Heap, T)\n   seq ks vs state = from_maprep rep state\n      where rep = HostValues::map_representation_seq (rawraw_of_vals ks) (rawraw_of_vals vs)\n\n   \/\/ lookups\n   \/\/ these will all misbehave on nonexistent values; use valid_with_heap first\n   \/\/ (XXX: using Option::crashing_unwrap crashes... look into why)\n   getrep: T -> HostValues::Heap -> HostValues::MapRepresentation\n   getrep m heap = Option::unsafe_unwrap optval\n      where\n         handle = major_of_val m.val\n         optval = HostValues::lookup_map handle heap\n\n      has_key: Val -> T -> HostValues::Heap -> Bool\n   has_key k m heap = HostValues::map_representation_has_key (rawraw_of_val k) rep\n      where rep = getrep m heap\n\n      get: Val -> T -> HostValues::Heap -> Val\n   get k m heap = val_of_rawraw rawraw\n      where\n         rep = getrep m heap\n         dfl = rawraw_of_val (Void::to_raw unit)\n         rawraw = HostValues::map_representation_get_default (rawraw_of_val k) rep dfl\n\n      multiget ks m heap = map val_of_rawraw rawraws\n      where\n         rawks = map rawraw_of_val ks\n         rep = getrep m heap\n         dfl = rawraw_of_val (Void::to_raw unit)\n         rawraws = HostValues::map_representation_multiget_default rawks rep dfl\n\n   \/\/ defer equality to raw to avoid duplication (since full_eq needs\n   \/\/ to be recursive)\n   eq: T -> T -> HostValues::Heap -> Bool\n   eq vs1 vs2 heap = full_eq vs1.val vs2.val heap\n\n\nsubmodule AddressObject where\n   newtype T = { val : Val }\n\n   valid' : Val -> Bool\n   valid' v = tag_of_val v == tag_addressobject \/\\ minor_of_val v == 0\n\n   valid : T -> Bool\n   valid vs = valid' vs.val\n\n   to_raw : T -> Val\n   to_raw vs = vs.val\n\n   eq: T -> T -> Bool\n   eq v1 v2 = small_val_eq v1.val v2.val\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ workarounds for saw-script #1964\n\/\/ (cannot refer to cryptol submodule elements directly)\n\n\/* re-export HostValues::Heap because we need it in soroban.saw *\/\ntype HostHeap = HostValues::Heap\n\n\/* also need the heap space predicate *\/\nheap_has_space = HostValues::heap_has_space\n\ntype VoidT = Void::T\ntype BoolT = Bool::T\ntype U32T = U32::T\ntype StringObjectT = StringObject::T\ntype SymbolT = Symbol::T\ntype VecObjectT = VecObject::T\ntype MapObjectT = MapObject::T\ntype AddressObjectT = AddressObject::T\ntype RawT = Raw::T\n\nvoid_valid = Void::valid\nvoid_from_raw = Void::from_raw\nvoid_to_raw = Void::to_raw\nvoid_from_native = Void::from_native\nvoid_to_native = Void::to_native\n\nbool_valid = Bool::valid\nbool_from_raw = Bool::from_raw\nbool_to_raw = Bool::to_raw\nbool_from_native = Bool::from_native\nbool_to_native = Bool::to_native\n\nu32_valid = U32::valid\nu32_from_raw = U32::from_raw\nu32_to_raw = U32::to_raw\nu32_from_native = U32::from_native\nu32_to_native = U32::to_native\n\nstrobj_valid = StringObject::valid\nstrobj_valid_with_heap = StringObject::valid_with_heap\nstrobj_to_raw = StringObject::to_raw\nstrobj_from_raw = StringObject::from_raw\nstrobj_dummy = StringObject::dummy\n\nsymbol_valid = Symbol::valid\nsymbol_from_raw = Symbol::from_raw\nsymbol_to_raw = Symbol::to_raw\nsymbol_from_native = Symbol::from_native\nsymbol_is_small = Symbol::is_small\nsymbol_eq = Symbol::eq\n\nvecobject_valid = VecObject::valid\nvecobj_valid_with_heap = VecObject::valid_with_heap\nvecobject_from_raw = VecObject::from_raw\nvecobject_to_raw = VecObject::to_raw\nvecobj_invalid = VecObject::invalid\nvecobj_empty = VecObject::empty\nvecobj_singleton = VecObject::singleton\nvecobj_pair = VecObject::pair\nvecobj_triple = VecObject::triple\nvecobj_quad = VecObject::quad\nvecobj_quint = VecObject::quint\nvecobj_n = VecObject::n\nvecobj_seq = VecObject::seq\nvecobj_len = VecObject::len\nvecobj_get = VecObject::get\n\/\/ without this the type doesn't propagate correctly\nvecobj_getall: {n} n <= 0xffffffff => VecObject::T -> HostValues::Heap -> [n] Val\nvecobj_getall = VecObject::getall\nvecobj_eq = VecObject::eq\nvecobj_addtail = VecObject::addtail\n\nmapobj_valid = MapObject::valid\nmapobj_valid_with_heap = MapObject::valid_with_heap\nmapobj_from_raw = MapObject::from_raw\nmapobj_to_raw = MapObject::to_raw\nmapobj_invalid = MapObject::invalid\nmapobj_empty = MapObject::empty\nmapobj_singleton = MapObject::singleton\nmapobj_pair = MapObject::pair\nmapobj_seq = MapObject::seq\nmapobj_has_key = MapObject::has_key\nmapobj_get = MapObject::get\nmapobj_multiget = MapObject::multiget\n\naddressobj_valid = AddressObject::valid\naddressobj_to_raw = AddressObject::to_raw\naddressobj_eq = AddressObject::eq\n\n\/\/ don't do this; it seems to crash (XXX: figure out why and fix it)\n\/\/raw_valid = Raw::val_is_good\nraw_valid : Raw::T -> Bool\nraw_valid _ = True\n\nraw_from_payload = Raw::from_payload\nraw_get_payload = Raw::get_payload\n\nraw_is_void = Raw::is_void\nraw_is_bool = Raw::is_bool\nraw_is_u32 = Raw::is_u32\nraw_is_i32 = Raw::is_i32\nraw_is_symbol = Raw::is_symbol\nraw_is_vec = Raw::is_vec\nraw_is_map = Raw::is_map\nraw_eq = Raw::eq\n","variant":"hybrid","set":"holdout"}
{"filename":"formal-verso\/lib\/Auth.cry","filetype":"cry","content":"module Auth where\n\nimport Values as Values\nimport submodule Values::Symbol as Values::Symbol\nimport submodule Values::AddressObject as Values::AddressObject\nimport submodule Values::VecObject as Values::VecObject\n\n\/*\n * Model for the Soroban SDK authorization system.\n *\n * The basis of the authorization system is a concept of call-graph\n * fragments.\n *\n * As I understand it (note that my understanding is based on a lot of\n * guesswork because the documentation is not very clear, and may be\n * quite wrong so far) this probably works as follows:\n *\n * 1. Each call-graph fragment is associated with a particular\n * Address, and represents a projection of a contract execution call\n * graph where (a) all functions in a given contract are folded\n * together, and (b) contracts that don't make authorization calls\n * about the Address in question are dropped. Chains or subgraphs of\n * dropped nodes are replaced with a single edge. Nodes dropped at the\n * root of the graph are dropped completely.\n *\n * Thus, a fragment (a, f -> g -> h) represents a call chain from f to\n * g to h, where f, g, and h each make an authorization check on\n * address a. This allows f to call g and then g to call h, but does\n * not allow f to call h directly, or allow either g or h to be called\n * spontaneously rather than starting from f. However, other contracts\n * that don't check for authorization from a can be interspersed\n * freely.\n *\n * These fragments are described as trees rather than graphs; it\n * appears that each end corresponds to a single invocation, not a\n * general ability to invoke. So for a situation where f calls g\n * twice, and each call to g calls h, you write a fragment of the\n * form\n *       f --> g -> h\n *         \\-> g -> h\n * rather than either the form\n *       f --> g --> h\n *         \\-> g -\/\n * or just\n *       f -> g -> h\n * but this is not totally clear. It is also not clear if these\n * two fragments are different:\n *       f --> g -> w\n *         \\-> g -> z\n * and\n *       f --> g -> z\n *         \\-> g -> w\n * that is, whether the sub-nodes are ordered or not.\n *\n * Update: yes, each subtree corresponds to a single execution\n * sequence. If there are two calls from f to g, then there are two g\n * subtrees, and if g is going to call h each subtree has its own h;\n * that is, there are no diamonds. Also, while in general reentrancy\n * is prohibited there's apparently a special case where it's not,\n * but this results in subtrees of the form f -> f -> g not cycles.\n * So the part that says \"this is not totally clear\" is correct.\n *\n * Update: subnodes are somewhat ordered. If there are multiple subtrees\n * for the same function these subtrees are consumed in order. However,\n * if there are multiple subtrees for different functions, those can be\n * consumed in any order because it searches for unused subtrees from\n * the beginning of the list each time. That is, the two fragments above\n * are different but these two are equivalent:\n *       f --> g -> w\n *         \\-> h -> z\n * and\n *       f --> h -> z\n *         \\-> g -> w\n *\n * 2. When we start executing we have some collection of call graph\n * fragments that we're allowed to execute; these have been signed\n * by the principal behind the Address associated with the fragment.\n *\n * 3. During execution, when an authorization call happens, we search\n * for a fragment with an unused node matching it that will let us\n * conclude the call is authorized. Then we mark off the node we just\n * matched in the fragment as used. When all the nodes in the fragment\n * have been used, the whole fragment is marked used and\/or discarded.\n *\n * Update: subtrees of fragments (including the whole tree as one\n * case) become unreachable when the function rooting the subtree\n * returns, but it's not required that the whole subtree gets used.\n *\n * 4. It appears that a node in a fragment matches if:\n *    - it names the same contract\n *    - the enclosed arguments list matches (see further notes below)\n *    - and either:\n *         - it is the root of the fragment\n *         - it is the (or a) next unused node in the fragment and its\n *           parent in the fragment is still in the current call chain\n *\n * That is, as you execute you pick fragments that authorize you to\n * execute, and these authorize particular patterns of calls, which\n * then get discharged and marked used one at a time. If\/once\n * execution deviates from the pattern the fragment can no longer\n * authorize further calls.\n *\n * Update: the last sentence there is not quite true; the fragment is\n * marked used as its pieces are matched, but the only thing that\n * cancels fragments or subtrees of fragments is when the function\n * that matched the root returns, as described above. (However, any\n * failure nonetheless causes the whole thing to crash out and stop.)\n *\n * As noted above, it's unclear if the patterns of calls are intended\n * to be ordered. Thus, given the example\n *       f --> g -> w\n *         \\-> g -> z\n * it's not clear if the sequence\n *    call f, call g, call z, return z, return g, call g, call w, return all\n * is potentially authorized or only the sequence\n *    call f, call g, call w, return z, return g, call g, call w, return all\n * though it is definitely the case that just\n *    call f, call g, call z, return z, return g, return f\n * or\n *    call f, call g, call w, return w, return g, return f\n * are authorized, and\n *    call f, call g, call z, return z, call w\n * is not.\n *\n * Update: the ordering behavior is as described above. In this case\n * the g -> w subtree will be matched on the first call to g so if\n * the first call to g ends up being the g -> z one it will fail.\n * Note that this means that \n *    call f, call g, call w, return w, return g, return f\n * is authorized but\n *    call f, call g, call z, return z, return g, return f\n * is not, despite what I'd previously thought.\n *\n * It's also unclear if you can have more than one active fragment for\n * the same Address at a time. That is, if you have the two fragments\n *       f -> g -> w\n *       g -> z\n * it's not clear if this sequence is authorized:\n *    call f, call g, call z, return z, return g, call g, call w, return all\n * because it uses the g -> z fragment while the other fragment is\n * partially discharged and then returns to using it. Similarly, it's\n * not clear if the sequence\n *    call f, call g, call z, call g, call w, return z, return w, return all\n * with two live invocations of g at once is supposed to be\n * authorized. From the apparent intent of the system it seems like\n * the first should be authorized but not the second, but it's hard to\n * see how they can readily be distinguished.\n *\n * Update: yes, you can have more than one active fragment for the\n * same Address. However, it matches against all currently active\n * fragments before starting any new ones. So given the example in the\n * previous paragraph,\n *    call f, call g, call z, return z, return g, call g, call w, return all\n *    call f, call g, call z, call g, call w, return z, return w, return all\n * are both not authorized because it will pick the g from the first\n * fragment for the first g execution, but\n *    call f, call g, call w, return w, return g, call g, call z, return all\n *    call f, call g, call w, call g, call z, return w, return z, return all\n * are both authorized. Also, although calling g -> g (or g -> w -> g)\n * is normally prohibited by an unrelated mechanism, that isn't an\n * authorization issue so these:\n *    call f, call g, call w, return w, call g, return g, call z, return all\n *    call f, call g, call w, call g, return w, return g, call z, return all\n * are both authorized; that is, the second fragment can be started by\n * a call to g at any point, and finishing the first call to g doesn't\n * affect the second fragment.\n *\n * Finally, if there are multiple possibly matching fragments, it's\n * not clear which you select to match, and contrary to a vague\n * statement in the docs, it does matter. For example, given these\n * two fragments:\n *       f -> g -> w\n *       f -> g -> z\n * which do you pick to start using and mark partially used when a\n * sequence begins with call f? It seems like to satisfy the apparent\n * intent of the system you have to choose both nondeteriminstically\n * and only resolve which one you actually mark used when it becomes\n * unambiguous. (And if you still have multiple potentially used\n * fragments when you're done executing, which do you pick? If they're\n * the same it doesn't matter, and if one's a subgraph of another it's\n * clear you should pick the smaller one, but in general there's no\n * obvious answer.)\n *\n * Update: the fragments are provided in some order and if they begin\n * with the same function they're matched in the order given, so in\n * the above example your first f call must be the one that proceeds\n * to w. There is no nondeterministic matching or backtracking here;\n * that kind of thing is undesirable in security systems.\n *\n * 5. In addition to the structural matching described above, each\n * node also has a list of values in it, which correspond to the\n * arguments to be passed to the function. These need to be matched at\n * runtime by the arguments given. It isn't clear how these values are\n * supposed to be matched and the documentation is silent, but it\n * appears the intent is just an equality test: the values found at\n * runtime should be the same list as the values found in the fragment.\n *\n * There are two variants of the authorization hypercall, one of which\n * defaults to the argument list from the current invocation, and the\n * other of which takes an explicit argument list. It seems the idea\n * is that the latter can be arbitrary (though related somehow to the\n * current invocation) and the person creating the authorization\n * fragments is supposed to know what'll be posted at runtime so they\n * can include the right list of values in their fragments. This\n * allows e.g. suppressing arguments that are irrelevant to the\n * Address being consulted.\n *\n * Given all the uncertainty above, and given that the more complete\n * model I started out with completely overwhelmed the verification\n * system, I've implemented the following.\n *\n * (Note that because we don't actually support cross-contract calls\n * yet, we can only use this for one contract at a time, so what's\n * here is sufficient for current purposes.)\n *\n * A. We can only have one authorized call-graph fragment.\n *\n * B. That fragment can only have one node in it.\n *\n * C. Call-graph nodes track the function involved but not the\n * argument list.\n *\n * D. We can only be matching in one place at one time. That place\n * can be:\n *    - before the single node in the single fragment\n *    - after the single node in the single fragment\n *    - after the single fragment\n *\n * In the first case, if the current call matches, we succeed and\n * advance past the node.\n *\n * In the first case, if the current call doesn't match we assume the\n * fragment's done and move past it.\n *\n * In the second case the fragment is done so we move past it.\n *\n * In the third case we always fail because there's nothing left to\n * match against.\n *\n * E. In principle if we are partway through a fragment and the\n * current contract function returns we should skip over any pieces of\n * the current fragment this renders inaccessible. In this version\n * this does nothing because we can't be partway through a fragment.\n * (XXX: However, there should be an external hook for triggering this\n * case. That doesn't exist yet, because it's not clear what it should\n * look like until we have logic for cross-contract calls.)\n *\n * F. The top-level contract spec should assert the following\n * preconditions:\n *    - that the authorization state is valid (with \"valid\")\n *    - what the current invocation is (with \"invocation\"), passing\n *      the current contract function name (with a more complete model\n *      this would also pass the current function argument list too)\n *    - that the match state is the initial state (with \"initial\")\n *      (in principle one may start with a partially discharged state,\n *      but there isn't currently direct support for asserting it and\n *      given the current model limitations it isn't very useful)\n * then it should add authorization fragments with \"authorize\".\n * (Currently this can only be done once for the single fragment\n * supported, and the node list should be a list of a single contract\n * function name, without an argument list because that isn't\n * supported either.) It should then bind the resulting auth object to\n * the contract's pre-state.\n *\n * G. The top-level contract spec should then generate an updated auth\n * model by using one of the authorization functions (corresponding to\n * the authorization call the contract makes) and bind the result to\n * the contract's post-state.\n *\n * H. The saw-script wrapper code in soroban.saw provides wrappers for\n * these operations and ghost-state tracking for the pre-state and\n * post-state, as well as specs for the hypercalls involved.\n *\n * I. Because we don't have contract IDs yet (they are BytesObjects,\n * which we don't have support for) we use the Symbol for the function\n * name as the contract function name. In the long run this should\n * probably be either the contract ID or the contract ID paired with\n * the function name.\n *\/\n\n\ntype T = Auth\n\nprivate\n   \/*\n    * We use the following representation:\n    *\n    * (1) to represent the authorization fragment:\n    *    - the address for the fragment\n    *    - the number of nodes in the fragment (fixed to 1)\n    *    - the contract function name for the single node\n    *\n    * Because we don't support contract IDs yet, for now use the\n    * Symbol for the function name instead.\n    *\n    * We'll use 8-bit values to count the number of nodes to try to\n    * reduce the state space. and keep things from getting out of\n    * hand.\n    *\n    * (2) to represent the matching state:\n    *    - whether the fragment is done\n    *    - the next node in the fragment to match against\n    *      (always either 0 or 1)\n    *\n    * (3) to represent the currently running invocation:\n    *    - the current contract function name (as noted above, a\n    *      Symbol for the function name)\n    *\/\n\n   \/\/ type for the array index\n   type NodeNum = [8]\n\n   newtype Auth = {\n      \/\/ The address and number of nodes for the fragment\n      address: Addr,\n      numnodes: NodeNum,\n\n      \/\/ The contract (actually function name) for the one node\n      contract: Values::Symbol::T,\n\n      \/\/ The match state: whether the fragment is done, and if\n      \/\/ not the next node we're going to use within it.\n      fragdone: Bool,\n      nextnode: NodeNum,\n\n      \/\/ The current invocation state. This may need to grow later.\n      invokedcontract: Values::Symbol::T\n   }\n\n      type Heap = Values::HostHeap\n   type Addr = Values::AddressObject::T\n\n\n\/*\n * Check that an Auth is valid. Meant for preconditions.\n *\n * For this version, we can have only one node in the fragment. The\n * commented-out code is for having more than one.\n *\/\nvalid: Auth -> Bool\nvalid auth = conditions\n   where\n      conditions =\n         fragment_valid &&\n         matchstate_valid &&\n         invokedcontract_valid\n            fragment_valid = (auth.numnodes == 1) && addr_valid && node_valid 0\n         where\n            addr_valid = Values::AddressObject::valid auth.address\n                        node_valid node = contract_valid\n               where\n                                    contract = auth.contract\n                  contract_valid = Values::Symbol::valid contract\n      \/\/ Note: because fragments aren't allowed to be\n      \/\/ empty, nextnode == 0 is always valid. However,\n      \/\/ auth.numnodes is not meaningful if fragdone is\n      \/\/ true. Don't rely on it.\n      matchstate_valid = (nextnode == 0) || (nextnode < auth.numnodes)\n         where\n            nextnode = auth.nextnode\n      invokedcontract_valid =\n         Values::Symbol::valid auth.invokedcontract\n\n\/*\n * Check that an Auth is valid _and_ in an initial state:\n * nothing has been consumed yet. Meant for preconditions.\n *\/\ninitial: Auth -> Bool\ninitial auth = valid auth && (auth.fragdone == False) && (auth.nextnode == 0)\n\n\/*\n * Check the invocation state of an Auth.\n *\/\ninvocation: Heap -> Auth -> Values::Symbol::T -> Bool\ninvocation heap auth sym =\n   Values::Symbol::eq auth.invokedcontract sym heap\n\n\nprivate\n   \/*\n    * Convert a list of nodes to an array for use as the fragment.\n    *\n    * The default value in the array is the first node. We have to be\n    * careful to be consistent about that so that SMT-level equality\n    * of arrays is consistent with intended-contents-only equality.\n    *\n    * For this version that has only one node in the fragment, pluck\n    * out the first entry in the argument and use that. The commented\n    * out code is for having more than one node.\n    *\/\n   makenodes: {n} (0 < n, n < 256) =>\n      \/\/[n] Values::Symbol::T -> (NodeNum, Array NodeNum Values::Symbol::T)\n      [n] Values::Symbol::T -> (NodeNum, Values::Symbol::T)\n   makenodes nodes = (1, nodes ! 0)\n   \/\/makenodes nodes = arrays ! 0\n   \/\/   where\n   \/\/      [first] # rest = nodes\n   \/\/      arrays =\n   \/\/         [(1, arrayConstant first)] # [(i + 1, arrayUpdate array i node)\n   \/\/                                         | (i, array) <- arrays\n   \/\/                                         | node <- rest]\n\n\/*\n * Bind a fragment to an authorization state.\n *\n * Leaves the matching state and invocation state alone, so you can\n * assert about that separately.\n *\n * This version has only one node in the fragment. The commented-out\n * code is for having more than one node.\n *\/\nauthorize: {n} (0 < n, n < 256) =>\n   Auth -> Addr -> [n] Values::Symbol::T -> Auth\nauthorize auth addr nodes = auth'\n   where\n            (num, contract) = makenodes nodes\n      auth' = Auth {\n         address = addr,\n         numnodes = num,\n                  contract = contract,\n\n         fragdone = auth.fragdone,\n         nextnode = auth.nextnode,\n\n         invokedcontract = auth.invokedcontract\n      }\n\n\nprivate\n   \/*\n    * Update the current node.\n    *\/\n   set_nextnode: Auth -> Addr -> NodeNum -> Auth\n   set_nextnode auth addr node = auth'\n      where\n         auth' = Auth {\n            address = auth.address,\n            numnodes = auth.numnodes,\n                        contract = auth.contract,\n\n            fragdone = auth.fragdone,\n            nextnode = node,\n\n            invokedcontract = auth.invokedcontract\n         }\n\n   \/*\n    * Mark the fragment done.\n    *\/\n   set_fragdone: Auth -> Bool -> Auth\n   set_fragdone auth state = auth'\n      where\n         auth' = Auth {\n            address = auth.address,\n            numnodes = auth.numnodes,\n                        contract = auth.contract,\n\n            fragdone = state,\n            nextnode = auth.nextnode,\n\n            invokedcontract = auth.invokedcontract\n         }\n\n   \/*\n    * We are done with the fragment. Mark it done, and set nextnode to\n    * 0 as if we were going on to another fragment.\n    *\/\n   finish_fragment: Auth -> Addr -> Auth\n   finish_fragment auth addr = auth''\n      where\n         auth' = set_fragdone auth True\n         auth'' = set_nextnode auth' addr 0\n\n   \/*\n    * Move to the next node in the fragment. If we run out, mark it\n    * done.\n    *\/\n   advance_to_next_node: Auth -> Addr -> Auth\n   advance_to_next_node auth addr =\n      if done then finish_fragment auth addr\n      else set_nextnode auth addr nextnode'\n      where\n         nextnode' = auth.nextnode + 1\n         done = nextnode' >= auth.numnodes\n\n   \/*\n    * Check if the given node of the given fragment matches the\n    * contract presented for authorization (the contract in question\n    * is always the current invoked contract)\n    *\n    * For this version with only one node in the fragment, always\n    * use the only node. (The commented out code is for multiple\n    * nodes.)\n    *\/\n   match_node: Heap -> Auth -> NodeNum -> Bool\n   match_node heap auth _node = ok\n      where\n                  contract = auth.contract\n         ok = Values::Symbol::eq contract auth.invokedcontract heap\n\n   \/*\n    * Match against the fragment. If it has run out, or if match_node\n    * says the next node doesn't match, return false.\n    *\/\n   match_fragment: Heap -> Auth -> Addr -> Bool\n   match_fragment heap auth addr = (auth.nextnode < auth.numnodes) && matches\n      where\n         matches = addr_matches && node_matches\n         addr_matches = Values::addressobj_eq addr auth.address\n         node_matches = match_node heap auth auth.nextnode\n\n   \/*\n    * Try matching the fragment. If that works, move to the\n    * next node and succeed. If not, finish the fragment, and then\n    * fail because there isn't another fragment to try.\n    *\n    * Return an updated Auth state as well as success\/failure.\n    *\/\n   check_fragment: Heap -> Auth -> Addr -> (Auth, Bool)\n   check_fragment heap auth addr =\n      \/\/ try the active fragment\n      if matches then to_nextnode else retry_nextfrag\n      where\n         matches = match_fragment heap auth addr\n         \/\/ the active fragment matched, advance to its next node\n         \/\/ and succeed\n         to_nextnode = (auth', True)\n            where auth' = advance_to_next_node auth addr\n         \/\/ the active fragment didn't match; drop it\n         retry_nextfrag = (auth', False)\n            where\n               auth' = finish_fragment auth addr\n\n\/*\n * Check whether the invoked function (and, theoretically, args) are\n * authorized. Returns an updated authorization state as well as the\n * success\/failure result.\n *\/\ncheck_noargs: Heap -> Auth -> Addr -> (Auth, Bool)\ncheck_noargs heap auth addr = check_fragment heap auth addr\n\n\/* XXX: args aren't supported so ignore them *\/\ncheck_withargs: Heap -> Auth -> Addr -> Values::VecObject::T -> (Auth, Bool)\ncheck_withargs heap auth addr _args = check_fragment heap auth addr\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"formal-verso\/lib\/EventLog.cry","filetype":"cry","content":"module Events where\n\nimport Array\n\nimport Values as Values\nimport submodule Values::Raw as Values::Raw\nimport submodule Values::VecObject as Values::VecObject\n\ntype T = EventLog\n\nprivate\n   type Topic = Values::VecObject::T\n   type Value = Values::Raw::T\n   type Topics = Array Integer Topic\n   type Values = Array Integer Value\n\n   newtype EventLog = {\n      topics: Topics,\n      values: Values,\n      count: Integer\n   }\n\nadd : EventLog -> Values::VecObject::T -> Values::Raw::T -> EventLog\nadd elog topic val =\n   EventLog { topics = topics', values = values', count = count' }\n   where\n      topics' = arrayUpdate elog.topics elog.count topic\n      values' = arrayUpdate elog.values elog.count val\n      count' = elog.count + 1\n\nprivate\n   equiv_entry : Topic -> Value -> Topic -> Value -> Values::HostHeap -> Bool\n   equiv_entry t1 v1 t2 v2 heap =\n      Values::vecobj_eq t1 t2 heap \/\\ Values::raw_eq v1 v2 heap\n\n   equiv_at : EventLog -> EventLog -> Values::HostHeap -> Integer -> Bool\n   equiv_at el1 el2 heap i =\n      if equiv_entry t1 v1 t2 v2 heap == False then False\n      | i >= el1.count then True\n      else equiv_at el1 el2 heap (i + 1)\n      where\n         t1 = arrayLookup el1.topics i\n         v1 = arrayLookup el1.values i\n         t2 = arrayLookup el2.topics i\n         v2 = arrayLookup el2.values i\n\nequiv : EventLog -> EventLog -> Values::HostHeap -> Bool\nequiv el1 el2 heap =\n   if el1.count != el2.count then False\n   else equiv_at el1 el2 heap 0\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"formal-verso\/lib\/Option.cry","filetype":"cry","content":"module Option where\n\ntype T a = Option a\n\ntype Option a =\n  { is_ok : Bit\n  , value : a\n  }\n\n\/*\n * XXX: is this supposed to be \"option\" or \"result\"?\n *\n * Rust's \"option\" is None or Some (like ocaml's) and \"result\" is Ok\n * or Err, but... we are not in a position to be able to store an\n * error value given the above definition, so it shouldn't really be\n * \"result\".\n *\n * I'm going to add \"some\" and \"none\" functions as a stopgap for more\n * clarity until I get a chance to clean it up.\n *\n * Also, it appears this type (as opposed to the other option\n * surrogate in Storage.cry) are never exported into SAW, so there's\n * no clear reason we can't use Cryptol's own Option. XXX...\n *\n * Update: for now at least, add \"none'\" that takes a dummy value to\n * store in the value part, since we need to put something there and\n * we can't actually use zero because there's currently no way to\n * derive (or explicitly instantiate) the Zero typeclass for the\n * newtypes we're using.\n *\/\n\nok : {a} a -> Option a\nok x = mk True x\n\n\nsome : {a} a -> Option a\nsome x = mk True x\n\nnone : {a} Zero a => Option a\nnone = mk False zero\n\nnone' : {a} a -> Option a\nnone' z = mk False z\n\n\nmk : {a} Bit -> a -> Option a\nmk valid value = { is_ok = valid, value = value }\n\nis_ok : {a} Option a -> Bit\nis_ok o = o.is_ok\n\nis_some : {a} Option a -> Bit\nis_some o = o.is_ok\n\nunsafe_unwrap : {a} Option a -> a\nunsafe_unwrap o = o.value\n\ncrashing_unwrap : {a} Option a -> a\ncrashing_unwrap o = if o.is_ok then o.value else error \"Option::crashing_unwrap\"\n\nunwrap_or : {a} Option a -> a -> a\nunwrap_or o def = if o.is_ok then o.value else def\n\nok_implies : {a} (a -> Bit) -> Option a -> Bit\nok_implies p o = if o.is_ok then p o.value else True\n\nok_and : {a} (a -> Bit) -> Option a -> Bit\nok_and p o = if o.is_ok then p o.value else False\n\nfmap : {a, b} Option a -> (a -> b) -> Option b\nfmap o f =\n  { is_ok = o.is_ok\n  , value = f o.value\n  }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"formal-verso\/lib\/HostValues.cry","filetype":"cry","content":"\/*\n * Values stored on the host side.\n *\n * In the Soroban world these values are stored in the VM host and\n * accessed\/manipulated with hypercalls. The VM guest uses 32-bit\n * object handles to refer to them.\n *\n * For modeling this, we need (a) a representation of the stored\n * values and also (b) a table that maps object handles to them that\n * we can use to get at these values directly.\n *\n * This file defines both.\n *\n * XXX: for the moment the representation here is rather ad hoc. In\n * the long run it might be better to set it up to match the Soroban\n * host code more closely so it can sometime maybe be used as a basis\n * for verifying that code.\n *\n * Note: if we want to have this and the contract-facing values in\n * separate files, only one can depend on the other. For the moment,\n * the choice is that Values depends on HostValues.  It's definitely\n * possible that this should get restructured once it's clearer what\n * things actually look like after they get built out further. Obvious\n * possibilities are:\n *\n * 1. Values depends on HostValues (current state). Advantages:\n * natural relationship, doesn't mess up the abstraction layer in\n * Values. Disadvantages: we can't refer to Values::Raw from here so\n * the contents of vectors and maps have to be unwrapped, stored here\n * as u64, and rewrapped inside Values, which is ugly.\n *\n * 2. HostValues depends on Values. Advantage: the use of integer\n * handles when Values point to HostValues gives an obvious place to\n * cut the circular dependency. The only thing Values need in them is\n * a u32, and while it might be tidier to be able to call that a\n * HostValues::Handle, that's not really necessary or critical. Then\n * we can refer to raw values (Values::Raw::T) here for e.g. the\n * contents of vectors and maps. Disadvantages: since HostValues is\n * part of the implementation of Values, it should really be\n * underneath it, and this way is backwards.  inversion mentioned\n * above; Also, it means the nicely wrapped-up types in Values, which\n * all have a regularized interface and so forth, can't themselves\n * hide the host value lookups inside them. This messes up the\n * abstractions. It'll be particularly messy for the types that can be\n * either small (non-host) or large (host-stored) values, like U64 and\n * Symbol.\n *\n * 3. Split Values::Raw to its own file. Advantages: the proper way to\n * break the circular dependency, and eliminates the tradeoffs in\n * options 1\/2. Disadvantages: creates more things, and exposes many\n * more internal elements.\n *\n * 4. Merge this file into Values. Advantages: eliminates all the other\n * problems. Disadvantage: large and messy.\n *\n * TBD. Watch this space.\n *\/\nmodule HostValues where\n\nimport Array\n\nimport Option as Option\n\n\/*\n * Interface types. We map Handle to any\/all of the representation\n * types (which may include values of type RawRawVal); the state of\n * the mapping is called Heap because it's ultimately an allocation\n * heap. These types are intended to be written qualified, as in\n * HostValues::Handle and HostValues::Heap.\n *\/\ntype Handle = [32]\ntype RawRawVal = [64]\ntype Heap = HostHeap\n\n\n\/* assign V for every key in KS *\/\narrayScatterConstant : {a, b, n} fin n => Array a b -> [n] a -> b -> Array a b\narrayScatterConstant arr ks v = arrs ! 0\n   where arrs = [arr] # [arrayUpdate arr' k v | arr' <- arrs | k <- ks]\n\n\/* assign the corresponding V in VS for every key in KS *\/\narrayScatterVals : {a, b, n} fin n => Array a b -> [n] a -> [n] b -> Array a b\narrayScatterVals arr ks vs = arrs ! 0\n   where arrs = [arr] # [arrayUpdate arr' k v | arr' <- arrs | k <- ks | v <- vs]\n\n\n\/*\n * Because for the moment we don't need to track the actual strings,\n * I'm going to start off with a null\/dummy string representation.\n *\/\ntype StringRepresentation = ()\n\nstring_representation_dummy : StringRepresentation\nstring_representation_dummy = ()\n\ninvalid_string_representation : StringRepresentation\ninvalid_string_representation = ()\n\n\n\/*\n * Vectors map 32-bit indexes to 64-bit unwrapped raw values.\n * Values.cry rewraps those values as needed.\n *\n * XXX we should come up with some shorter names here\n *\/\ntype VecData = Array [32] RawRawVal\nnewtype VecRepresentation = {\n   data: VecData,\n   size: [32]\n}\n\nvec_representation_empty : VecRepresentation\nvec_representation_empty =\n   VecRepresentation { data = arrayConstant 0, size = 0 }\n\nvec_representation_singleton : RawRawVal -> VecRepresentation\nvec_representation_singleton n =\n   VecRepresentation { data = arr, size = 1 }\n   where arr = arrayUpdate (arrayConstant 0) 0 n\n\nvec_representation_pair : RawRawVal -> RawRawVal -> VecRepresentation\nvec_representation_pair n m =\n   VecRepresentation { data = arr, size = 2 }\n   where arr = arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m\n\nvec_representation_triple : RawRawVal -> RawRawVal -> RawRawVal -> VecRepresentation\nvec_representation_triple n m o =\n   VecRepresentation { data = arr, size = 3 }\n   where arr = arrayUpdate (arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m) 2 o\n\nvec_representation_quad : RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> VecRepresentation\nvec_representation_quad n m o p =\n   VecRepresentation { data = arr, size = 4 }\n   where arr = arrayUpdate (arrayUpdate (arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m) 2 o) 3 p\n\nvec_representation_quint : RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> VecRepresentation\nvec_representation_quint n m o p q =\n   VecRepresentation { data = arr, size = 5 }\n   where arr = arrayUpdate (arrayUpdate (arrayUpdate (arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m) 2 o) 3 p) 4 q\n\n\/*\n * N copies of V\n *\n * This has to agree with the equivalent vec_representation_seq, on\n * the _whole_ array and not just the meaningful part, because that's\n * what happens in the SMT and thus with the implicit assertions that\n * happen in SAW, so we can't just do arrayConstant.\n *\/\nvec_representation_n: [32] -> RawRawVal -> VecRepresentation\nvec_representation_n n v =\n   if n == 0 then vec_representation_empty\n   else vec_representation_addtail (vec_representation_n (n - 1) v) v\n\nvec_representation_seq: {n} n <= 0xffffffff => [n] RawRawVal -> VecRepresentation\nvec_representation_seq seq =\n   VecRepresentation { data = arr, size = `n }\n   where arr = arrayRangeUpdate (arrayConstant 0) 0 seq\n\n\/* Vector used when an invalid\/error version is needed *\/\ninvalid_vec_representation : VecRepresentation\ninvalid_vec_representation = vec_representation_empty\n\n\/* get nth value, or return default value if out of range *\/\nvec_representation_get_default : VecRepresentation -> [32] -> RawRawVal -> RawRawVal\nvec_representation_get_default rep n dfl =\n   if n < rep.size then arrayLookup rep.data n else dfl\n\n\/* get all values -- ideally n is rep.size and the default value isn't used *\/\nvec_representation_getall : {n} n <= 0xffffffff => VecRepresentation -> RawRawVal -> [n] RawRawVal\nvec_representation_getall rep dfl = vals\n   where vals @ i = vec_representation_get_default rep i dfl\n\n\/* test contents for equivalence *\/\nprivate\n   vec_representation_equiv_at :\n          (RawRawVal -> RawRawVal -> Heap -> Bool) ->\n          VecRepresentation -> VecRepresentation -> Heap ->\n          [32] ->\n          Bool\n   vec_representation_equiv_at subcmp rep1 rep2 heap i =\n      if i >= rep1.size then True\n      | subcmp x1 x2 heap == False then False\n      else vec_representation_equiv_at subcmp rep1 rep2 heap (i + 1)\n      where\n         x1 = arrayLookup rep1.data i\n         x2 = arrayLookup rep2.data i\n\nvec_representation_equiv :\n       (RawRawVal -> RawRawVal -> Heap -> Bool) ->\n       VecRepresentation -> VecRepresentation -> Heap ->\n       Bool\nvec_representation_equiv subcmp rep1 rep2 heap =\n   if rep1.size != rep2.size then False\n   else vec_representation_equiv_at subcmp rep1 rep2 heap 0\n\n\/* updates *\/\nvec_representation_addtail : VecRepresentation -> RawRawVal -> VecRepresentation\nvec_representation_addtail rep v =\n   VecRepresentation { data = data', size = size' }\n   where\n      data' = arrayUpdate rep.data rep.size v\n      size' = rep.size + 1\n\n\n\/*\n * Maps map 64-bit unwrapped raw keys to 64-bit unwrapped raw values.\n * Values.cry rewraps those values as needed.\n *\/\n\ntype MapHere = Array RawRawVal Bool\ntype MapData = Array RawRawVal RawRawVal\nnewtype MapRepresentation = {\n   here: MapHere,\n   data: MapData\n}\n\nmap_representation_empty: MapRepresentation\nmap_representation_empty =\n   MapRepresentation { here = arrayConstant False, data = arrayConstant 0 }\n\nmap_representation_add: RawRawVal -> RawRawVal -> MapRepresentation -> MapRepresentation\nmap_representation_add k v rep =\n   MapRepresentation { here = here', data = data' }\n   where\n      here' = arrayUpdate rep.here k True\n      data' = arrayUpdate rep.data k v\n\nmap_representation_singleton: RawRawVal -> RawRawVal -> MapRepresentation\nmap_representation_singleton k v =\n   map_representation_add k v map_representation_empty\n\nmap_representation_pair: RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> MapRepresentation\nmap_representation_pair k1 v1 k2 v2 =\n   map_representation_add k2 v2 (map_representation_singleton k1 v1)\n\n\/* Sequence *\/\nmap_representation_seq: {n} n <= 0xffffffff => [n] RawRawVal -> [n] RawRawVal -> MapRepresentation\nmap_representation_seq ks vs =\n   MapRepresentation { here = here, data = data }\n   where\n      here = arrayScatterConstant empty.here ks True\n      data = arrayScatterVals empty.data ks vs\n      empty = map_representation_empty\n\n\/* Map used when an invalid\/error version is needed *\/\ninvalid_map_representation : MapRepresentation\ninvalid_map_representation = map_representation_empty\n\n\/* check if k is present *\/\nmap_representation_has_key : RawRawVal -> MapRepresentation -> Bool\nmap_representation_has_key k rep =\n   arrayLookup rep.here k\n\n\/* get value for k, or return default value if not present *\/\nmap_representation_get_default : RawRawVal -> MapRepresentation -> RawRawVal -> RawRawVal\nmap_representation_get_default k rep dfl =\n   if arrayLookup rep.here k == False then dfl\n   else arrayLookup rep.data k\n\n\/* get values for ks, returning default value where not present *\/\nmap_representation_multiget_default : {n} [n] RawRawVal -> MapRepresentation -> RawRawVal -> [n] RawRawVal\nmap_representation_multiget_default ks rep dfl = result\n   where result @ i = map_representation_get_default (ks @ i) rep dfl\n\n\/* test contents for equivalence *\/\nmap_representation_equiv :\n       (RawRawVal -> RawRawVal -> Heap -> Bool) ->\n       MapRepresentation -> MapRepresentation -> Heap ->\n       Bool\nmap_representation_equiv _subcmp _rep1 _rep2 _heap =\n      error \"map_representation_equiv: not yet implemented\"\n\n\nprivate\n   \/*\n    * The supported types of host-side values are:\n    *    - 64-bit, 128-bit, and 256-bit signed and unsigned integers\n    *    - timepoints\n    *    - durations\n    *    - bytes (essentially arrays of u8)\n    *    - strings\n    *    - symbols (restricted strings)\n    *    - vectors\n    *    - maps\n    *    - addresses\n    *\n    * of which we currently only provide u64, string, and vector.\n    *\n    * It would be better not to need HostInvalid but until we have\n    * a better Option.cry we need a value to stuff in failures.\n    *\/\n\/* apparently we can't have this at all, even if SAW never sees it\n   enum HostVal =\n        HostInvalid\n      | HostU64 [64]\n      | HostVec VecRepresentation\n*\/\n   type TypeTag = [2]\n   TagU64 = 0\n   TagString = 1\n   TagVec = 2\n   TagMap = 3\n\n   newtype HostHeap = {\n            types: Array Handle TypeTag,\n      values_u64: Array Handle [64],\n      values_string: Array Handle StringRepresentation,\n      \/\/ Can't do this (saw-script #1988)\n      \/\/values_vec: Array Handle VecRepresentation,\n      \/\/ Instead make a pair of arrays\n      values_vecdata: Array Handle VecData,\n      values_vecsize: Array Handle [32],\n      values_maphere: Array Handle MapHere,\n      values_mapdata: Array Handle MapData,\n      next: Handle\n   }\n\n\n\/*\n * Assert that the heap can allocate at least as many more objects as\n * \"headroom\". If adding in headroom makes the value smaller, the\n * value overflowed.\n *\/\nheap_has_space : Heap -> [32] -> Bool\nheap_has_space h headroom = h.next + headroom >= h.next\n\nempty_heap : Heap\nempty_heap =\n   HostHeap {\n      types = arrayConstant 0,\n      values_u64 = arrayConstant 0,\n      values_string = arrayConstant string_representation_dummy,\n      values_vecdata = arrayConstant (arrayConstant 0),\n      values_vecsize = arrayConstant 0,\n      values_maphere = arrayConstant (arrayConstant False),\n      values_mapdata = arrayConstant (arrayConstant 0),\n      next = 0\n   }\n\n\/* this also doesn't work\n   \/*\n    * Allocate a value and store it in the state.\n    *\/\n   alloc : HostVal -> Heap -> (Heap, Handle)\n   alloc v s = (s', handle)\n      where\n         handle = s.next\n         values' = arrayUpdate s.values handle v\n         s' = HostHeap { values = values', next = s.next + 1 }\n\n   \/*\n    * Look up a value. Out of range handles produce None.\n    *\/\n   lookup : Handle -> Heap -> Option::T HostVal\n   lookup h s =\n      if h < s.next then Option::some (arrayLookup s.values h)\n      else Option::none' HostInvalid\n*\/\n\n\/*\n * Typed allocate wrappers\n *\/\n\nalloc_u64 : [64] -> Heap -> (Heap, Handle)\nalloc_u64 n s = (s', handle)\n   where\n      handle = s.next\n      types' = arrayUpdate s.types handle TagU64\n      values_u64' = arrayUpdate s.values_u64 handle n\n      s' = HostHeap {\n         types = types',\n         values_u64 = values_u64',\n         values_string = s.values_string,\n         values_vecdata = s.values_vecdata,\n         values_vecsize = s.values_vecsize,\n         values_maphere = s.values_maphere,\n         values_mapdata = s.values_mapdata,\n         next = s.next + 1\n      }\n\nalloc_string : StringRepresentation -> Heap -> (Heap, Handle)\nalloc_string rep s = (s', handle)\n   where\n      handle = s.next\n      types' = arrayUpdate s.types handle TagString\n      values_string' = arrayUpdate s.values_string handle rep\n      s' = HostHeap {\n         types = types',\n         values_u64 = s.values_u64,\n         values_string = values_string',\n         values_vecdata = s.values_vecdata,\n         values_vecsize = s.values_vecsize,\n         values_maphere = s.values_maphere,\n         values_mapdata = s.values_mapdata,\n         next = s.next + 1\n      }\n\nalloc_vec : VecRepresentation -> Heap -> (Heap, Handle)\nalloc_vec rep s = (s', handle)\n   where\n      handle = s.next\n      types' = arrayUpdate s.types handle TagVec\n            values_vecdata' = arrayUpdate s.values_vecdata handle rep.data\n      values_vecsize' = arrayUpdate s.values_vecsize handle rep.size\n      s' = HostHeap {\n         types = types',\n         values_u64 = s.values_u64,\n         values_string = s.values_string,\n         values_vecdata = values_vecdata',\n         values_vecsize = values_vecsize',\n         values_maphere = s.values_maphere,\n         values_mapdata = s.values_mapdata,\n         next = s.next + 1\n      }\n\nalloc_map : MapRepresentation -> Heap -> (Heap, Handle)\nalloc_map rep s = (s', handle)\n   where\n      handle = s.next\n      types' = arrayUpdate s.types handle TagMap\n      values_maphere' = arrayUpdate s.values_maphere handle rep.here\n      values_mapdata' = arrayUpdate s.values_mapdata handle rep.data\n      s' = HostHeap {\n         types = types',\n         values_u64 = s.values_u64,\n         values_string = s.values_string,\n         values_vecdata = s.values_vecdata,\n         values_vecsize = s.values_vecsize,\n         values_maphere = values_maphere',\n         values_mapdata = values_mapdata',\n         next = s.next + 1\n      }\n\n\/*\n * Typed lookup wrappers\n *\/\n\npresent_as_u64 : Handle -> Heap -> Bool\npresent_as_u64 h s =\n   if h >= s.next then False\n   | arrayLookup s.types h != TagU64 then False\n   else True\n\npresent_as_string : Handle -> Heap -> Bool\npresent_as_string h s =\n   if h >= s.next then False\n   | arrayLookup s.types h != TagString then False\n   else True\n\npresent_as_vec : Handle -> Heap -> Bool\npresent_as_vec h s =\n   if h >= s.next then False\n   | arrayLookup s.types h != TagVec then False\n   else True\n\npresent_as_map : Handle -> Heap -> Bool\npresent_as_map h s =\n   if h >= s.next then False\n   | arrayLookup s.types h != TagMap then False\n   else True\n\nlookup_u64 : Handle -> Heap -> Option::T [64]\nlookup_u64 h s =\n   if h >= s.next then Option::none' 0\n   | arrayLookup s.types h != TagU64 then Option::none' 0\n   else Option::some (arrayLookup s.values_u64 h)\n\nlookup_string : Handle -> Heap -> Option::T StringRepresentation\nlookup_string h s =\n   if h >= s.next then Option::none' invalid_string_representation\n   | arrayLookup s.types h != TagString then Option::none' invalid_string_representation\n   else Option::some (arrayLookup s.values_string h)\n\nlookup_vec : Handle -> Heap -> Option::T VecRepresentation\nlookup_vec h s =\n   if h >= s.next then Option::none' invalid_vec_representation\n   | arrayLookup s.types h != TagVec then Option::none' invalid_vec_representation\n   else\n      Option::some rep\n      where\n         data = arrayLookup s.values_vecdata h\n         size = arrayLookup s.values_vecsize h\n                  rep = VecRepresentation { data = data, size = size }\n\nlookup_map : Handle -> Heap -> Option::T MapRepresentation\nlookup_map h s =\n   if h >= s.next then Option::none' invalid_map_representation\n   | arrayLookup s.types h != TagMap then Option::none' invalid_map_representation\n   else\n      Option::some rep\n      where\n         here = arrayLookup s.values_maphere h\n         data = arrayLookup s.values_mapdata h\n         rep = MapRepresentation { here = here, data = data }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"formal-verso\/lib\/Log.cry","filetype":"cry","content":"module Log where\n\nimport Option as Option\nimport Values as Values\nimport submodule Values::Raw as Raw\n\ntype T = Log\n\n\/*\n * In this version we just count the log messages\n *\/\n\nprivate\n  newtype Log = { count : Integer }\n\nadd : Log -> Log\nadd ll = Log { count = ll.count + 1 }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"formal-verso\/lib\/Util.cry","filetype":"cry","content":"module Util where\n\n\/** Length-polymorphic sequence equality. *\/\nlenPolyEq : {a, n, m} (Eq a, fin n) => [n]a -> [m]a -> Bit\nlenPolyEq xs ys\n  | n == m => xs == ys\n  | n != m => False\n","variant":"hybrid","set":"supervised"}
{"filename":"ckzg-eip-4844-verification\/spec\/LLVM\/Permutations.cry","filetype":"cry","content":"\/**\n * The functions in this module are written to more closely match the LLVM\n * generated for the C code we are trying to prove equivalent to our other\n * Cryptol specs. So this is an intermediate step along our proof trail.\n *\/\nmodule LLVM::Permutations where\n\nimport Common::Utils\nimport Spec::Permutations\n\n\/**\n * Return the bit-reversed permutation, which is an involution (inverts itself).\n * @see https:\/\/github.com\/ethereum\/c-kzg-4844\/blob\/430371ed270e97b5b77babc92c0bafa768f68b32\/src\/common\/utils.c#L103\n * Standard algorithm: https:\/\/en.wikipedia.org\/wiki\/Bit-reversal_permutation\n *\/\nbit_reversal_permutation_fast : {size, n}\n    (fin size, size >= 1, n >= 2, size * BYTE_WIDTH >= width n, 64 >= width n)\n    => [n][size * BYTE_WIDTH] -> [n][size * BYTE_WIDTH]\nbit_reversal_permutation_fast sequence =\n    bit_reversal_permutation_fast_rec`{size, n, width (n - 1)} sequence unused_bit_len 0\n    where\n        unused_bit_len = 64 - lg2 `(n)\n\n\/**\n * Recursive helper function for `bit_reversal_permutation_fast`.\n * ```repl\n * :check bit_reversal_permutation_fast_rec`{1, 4, 2} [0x01, 0x03, 0x02, 0x04] 62 3 == [0x01, 0x03, 0x02, 0x04]\n * :check bit_reversal_permutation_fast_rec`{1, 4, 2} [0x01, 0x03, 0x02, 0x04] 62 2 == [0x01, 0x03, 0x02, 0x04]\n * :check bit_reversal_permutation_fast_rec`{1, 4, 2} [0x01, 0x02, 0x03, 0x04] 62 1 == [0x01, 0x03, 0x02, 0x04]\n * :check bit_reversal_permutation_fast_rec`{1, 4, 2} [0x01, 0x02, 0x03, 0x04] 62 0 == [0x01, 0x03, 0x02, 0x04]\n * ```\n *\/\nbit_reversal_permutation_fast_rec : {size, n, nbits}\n    (fin size, size >= 1, n >= 2, size * BYTE_WIDTH >= width n, 64 >= width n, nbits == width (n - 1))\n    => [n][size * BYTE_WIDTH] -> [64] -> [64] -> [n][size * BYTE_WIDTH]\nbit_reversal_permutation_fast_rec sequence unused_bit_len i =\n        if i >= `(n) then sequence\n        else if r > i\n        then bit_reversal_permutation_fast_rec`{size, n, nbits} sequence' unused_bit_len (i + 1)\n        else bit_reversal_permutation_fast_rec`{size, n, nbits} sequence unused_bit_len (i + 1)\n    where\n    r = (reverse i) >> unused_bit_len\n    sequence' = swap`{size, n} sequence i r\n\n\/**\n * Helper function for `bit_reversal_permutation_fast`.\n * @see https:\/\/github.com\/ethereum\/c-kzg-4844\/blob\/430371ed270e97b5b77babc92c0bafa768f68b32\/src\/common\/utils.c#L122\n * ```repl\n * :check swap`{1, 4} [0x01, 0x02, 0x03, 0x04] 1 2 == [0x01, 0x03, 0x02, 0x04]\n * :check swap`{1, 4} [0x01, 0x02, 0x03, 0x04] 2 1 == [0x01, 0x03, 0x02, 0x04]\n * :check swap`{1, 4} [0x01, 0x02, 0x03, 0x04] 3 3 == [0x01, 0x02, 0x03, 0x04]\n * ```\n * NOTE: we just chose these values at \"random\"\n *\/\nswap : {size, n}\n    (fin size, size >= 1, n >= 2, size * BYTE_WIDTH >= width n, 64 >= width n)\n    => [n][size * BYTE_WIDTH] -> [64] -> [64] -> [n][size  * BYTE_WIDTH]\nswap values i r =\n    [swap_elem j | j <- [0 .. (n-1)]]\n    where\n        swap_elem j =\n            if j == r then values@i\n            else if j == i then values@r\n            else values@j\n\n\/*\n *  ==========\n *  Properties\n *  ==========\n *\/\n\n\/**\n * Prove that the `bit_reversal_permutation_fast` function is equivalent\n *  to `bit_reversal_permutation` found in `Spec`.\n * ```repl\n * :check bit_reversal_permutations_equiv`{1, 4}\n * :check bit_reversal_permutations_equiv`{4, 8}\n * :check bit_reversal_permutations_equiv`{8, 256}\n * ```\n *\/\nbit_reversal_permutations_equiv : {size, n}\n    (fin size, size >= 1, n >= 2, size * BYTE_WIDTH >= width n, 64 >= width n)\n    => [n][size * BYTE_WIDTH] -> Bit\nproperty bit_reversal_permutations_equiv seq =\n    bit_reversal_permutation`{size * BYTE_WIDTH, n} seq == bit_reversal_permutation_fast`{size, n} seq\n","variant":"hybrid","set":"supervised"}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/KZG.cry","filetype":"cry","content":"\/**\n * The module contains functions that perform the BLS KZG operations.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#kzg\n *\/\nmodule Spec::KZG where\n\nimport Common::ModArith\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::G1\nimport Spec::BlsEC::GP\nimport Spec::BlsEC::Pairing\nimport Spec::BlsHelpers\nimport Spec::BlsSerde\nimport Spec::Permutations\nimport Spec::Polynomials\nimport Spec::TrustedSetup\n\n\/**\n * Create the polynomial commitment for the given `Blob`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#blob_to_kzg_commitment\n *\/\nblob_to_kzg_commitment : Blob -> KZGCommitment\nblob_to_kzg_commitment blob =\n    g1_lincomb (bit_reversal_permutation KZG_SETUP_G1_LAGRANGE) (blob_to_polynomial blob)\n\n\/**\n * Given `y == p(z)` for a polynomial `p(x)`, compute `q(z)`: the KZG quotient polynomial evaluated at `z` for the\n *  special case where `z` is in roots of unity.\n * For more details, read https:\/\/dankradfeist.de\/ethereum\/2021\/06\/18\/pcs-multiproofs.html section \"Dividing\n *  when one of the points is zero\". The code below computes q(x_m) for the roots of unity special case.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_quotient_eval_within_domain\n * NOTE: Test found in 'Test\/KZG\/ComputeQuotient\/TV1.cry'\n *\/\ncompute_quotient_eval_within_domain : BlsFieldElement -> Polynomial -> BlsFieldElement -> BlsFieldElement\ncompute_quotient_eval_within_domain z polynomial y = toIntegral result where\n    result = sum [compute i | i <- [0 .. (FIELD_ELEMENTS_PER_BLOB-1)]]\n    f i = (fromIntegral (polynomial@i)) - (fromIntegral y)\n    omega i = fromIntegral`{BLS_MODULUS} (ROOTS_OF_UNITY_BRP@i)\n    numerator i = (f i) * (omega i)\n    \/\/ Adding the BLS_MODULUS doesn't affect the computation because it is modular arithmetic with that modulus\n    denominator i = z' * (z' - (omega i))\n    z' = fromIntegral z\n    \/\/ Skip the evaluation point (z) in the sum\n    compute i = if omega i != z' then div_mod (numerator i) (denominator i) else 0\n\n\/**\n * Helper function for `compute_kzg_proof` and `compute_blob_kzg_proof`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_kzg_proof_impl\n * Called by `compute_kzg_proof` for which we have a test vector.\n *\/\ncompute_kzg_proof_impl : Polynomial -> BlsFieldElement -> (KZGProof, BlsFieldElement)\ncompute_kzg_proof_impl polynomial z = (proof, y) where\n    \/\/ For all x_i, compute p(x_i) - p(z)\n    y = evaluate_polynomial_in_evaluation_form polynomial z\n    polynomial_shifted = [(fromIntegral`{BLS_MODULUS} p) - (fromIntegral y) | p <- polynomial]\n    \/\/ For all x_i, compute (x_i - z)\n    denominator_poly = [(fromIntegral`{BLS_MODULUS} x) - (fromIntegral z) | x <- ROOTS_OF_UNITY_BRP]\n    \/\/ Compute the quotient polynomial directly in evaluation form\n    quotient_polynomial = [quotient i a b | a <- polynomial_shifted | b <- denominator_poly | i <- [0 .. FIELD_ELEMENTS_PER_BLOB-1]]\n    \/\/ Handle the conditional computation of computing the quotient\n    quotient : Integer -> Z BLS_MODULUS -> Z BLS_MODULUS -> BlsFieldElement\n    quotient i a b =\n        if b == 0 then\n            \/\/ The denominator is zero hence `z` is a root of unity: we must handle it as a special case.\n            \/\/ This case can only happen once at most.\n            compute_quotient_eval_within_domain (ROOTS_OF_UNITY_BRP@i) polynomial y\n        else\n            \/\/ Compute: q(x_i) = (p(x_i) - p(z)) \/ (x_i - z).\n            toIntegral (div_mod`{BLS_MODULUS} a b)\n    proof = g1_lincomb (bit_reversal_permutation KZG_SETUP_G1_LAGRANGE) quotient_polynomial\n\n\/**\n * Compute KZG proof at point `z` for the polynomial represented by `blob`.\n * Do this by computing the quotient polynomial in evaluation form: q(x) = (p(x) - p(z)) \/ (x - z).\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_kzg_proof\n * NOTE: Test found in 'Test\/KZG\/ComputeProof\/TV1.cry'\n *\/\ncompute_kzg_proof : Blob -> Bytes32 -> (KZGProof, Bytes32)\ncompute_kzg_proof blob z_bytes = (proof, y) where\n    polynomial = blob_to_polynomial blob\n    (proof, y') = compute_kzg_proof_impl polynomial (bytes_to_bls_field z_bytes)\n    y = split`{BYTES_PER_FIELD_ELEMENT} y'\n\n\/**\n * Verify KZG proof that `p(z) == y` where `p(z)` is the polynomial represented by `polynomial_kzg`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#verify_kzg_proof_impl\n * Called by `verify_kzg_proof` for which we have a test vector.\n *\/\nverify_kzg_proof_impl : KZGCommitment -> BlsFieldElement -> BlsFieldElement -> KZGProof -> Bit\nverify_kzg_proof_impl commitment z y proof = pairing_check points where\n    \/\/ Verify: P - y = Q * (X - z)\n    x_minus_z = g2_add (bytes96_to_G2 (KZG_SETUP_G2_MONOMIAL@1)) g2_mult\n    g2_mult = g2_multi_optimized G2 ((`(BLS_MODULUS) - z) % `(BLS_MODULUS))\n    p_minus_y = g1_add (bytes48_to_G1 commitment) g1_mult\n    g1_mult = g1_multi_optimized G1 ((`(BLS_MODULUS) - y) % `(BLS_MODULUS))\n    points = [(p_minus_y, (g2_negate G2)), ((bytes48_to_G1 proof), x_minus_z)]\n\n\/**\n * Verify KZG proof that `p(z) == y` where `p(z)` is the polynomial represented by `polynomial_kzg`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#verify_kzg_proof\n * NOTE: Test found in 'Test\/KZG\/VerifyProof\/TV1.cry'\n *\/\nverify_kzg_proof : Bytes48 -> Bytes32 -> Bytes32 -> Bytes48 -> Bit\nverify_kzg_proof commitment_bytes z_bytes y_bytes proof_bytes =\n    verify_kzg_proof_impl (bytes_to_kzg_commitment commitment_bytes)\n                          (bytes_to_bls_field z_bytes)\n                          (bytes_to_bls_field y_bytes)\n                          (bytes_to_kzg_proof proof_bytes)\n\n\/**\n * Return the Fiat-Shamir challenge required by the rest of the protocol.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_challenge\n *\/\ncompute_challenge: Blob -> KZGCommitment -> BlsFieldElement\ncompute_challenge blob commitment = result where\n    degree_poly = groupBy`{8, 16} `(FIELD_ELEMENTS_PER_BLOB)\n    commitment_bytes = groupBy`{8} commitment\n    data = FIAT_SHAMIR_PROTOCOL_DOMAIN # degree_poly # blob # commitment_bytes\n    result = hash_to_bls_field data\n\n\/**\n * Given a blob, return the KZG proof that is used to verify it against the commitment.\n * This method does not verify that the commitment is correct with respect to `blob`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_blob_kzg_proof\n *\/\ncompute_blob_kzg_proof: Blob -> Bytes48 -> KZGProof\ncompute_blob_kzg_proof blob commitment_bytes = proof where\n    commitment = bytes_to_kzg_commitment commitment_bytes\n    polynomial = blob_to_polynomial blob\n    evaluation_challenge = compute_challenge blob commitment\n    (proof, e) = compute_kzg_proof_impl polynomial evaluation_challenge\n\n\/**\n * Given a blob, return the KZG proof that is used to verify it against the commitment.\n * This method does not verify that the commitment is correct with respect to `blob`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#verify_blob_kzg_proof\n *\/\nverify_blob_kzg_proof: Blob -> Bytes48 -> Bytes48 -> Bit\nverify_blob_kzg_proof blob commitment_bytes proof_bytes =\n    verify_kzg_proof_impl commitment evaluation_challenge y proof where\n        commitment = bytes_to_kzg_commitment commitment_bytes\n        polynomial = blob_to_polynomial blob\n        evaluation_challenge = compute_challenge blob commitment\n        y = evaluate_polynomial_in_evaluation_form polynomial evaluation_challenge\n        proof = bytes_to_kzg_proof proof_bytes\n\n\n\/**\n * Verify multiple KZG proofs efficiently.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#verify_kzg_proof_batch\n * Add an additional assumption that k is represented with 64 bits.\n * This additional assumption is required by compute_powers\n *\/\nverify_kzg_proof_batch : {k} (fin k, 64 >= width k) => [k]KZGCommitment -> [k]BlsFieldElement -> [k]BlsFieldElement -> [k]KZGProof -> Bit\nverify_kzg_proof_batch commitments zs ys proofs = pairing_check points where\n    degree_poly = groupBy`{8, 8} `(FIELD_ELEMENTS_PER_BLOB)\n    num_commitments = groupBy`{8, 8} `(k)\n    data_1 = RANDOM_CHALLENGE_KZG_BATCH_DOMAIN # degree_poly # num_commitments\n    data_2 = [ c # z # y # p | c <- commitments | z <- zs | y <- ys | p <- proofs ]\n    data = data_1 # (groupBy`{8} (join data_2))\n    r = hash_to_bls_field data\n    r_powers = compute_powers`{k} r \n    proof_lincomb = g1_lincomb proofs r_powers\n    proof_z_lincomb = g1_lincomb proofs ([z * r_power | z <- zs | r_power <- r_powers])\n    C_minus_ys = [ g1_add (bytes48_to_G1 commitment) (g1_multi G1 ((`(BLS_MODULUS) - y) % `(BLS_MODULUS))) \n                    | commitment <- commitments | y <- ys ] \n    C_minus_y_as_KZGCommitments = [ g1_to_bytes48 x | x <- C_minus_ys ]\n    C_minus_y_lincomb = g1_lincomb C_minus_y_as_KZGCommitments r_powers\n    points = [((bytes48_to_G1 proof_lincomb), (g2_negate (bytes96_to_G2 (KZG_SETUP_G2_MONOMIAL@1)))),\n                            ((g1_add (bytes48_to_G1 C_minus_y_lincomb) (bytes48_to_G1 proof_z_lincomb)), G2)]\n\n\/**\n * Given a list of blobs and blob KZG proofs, verify that they correspond to the provided commitments.\n * Will return True if there are zero blobs\/commitments\/proofs.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#verify_blob_kzg_proof_batch\n * The input parameters are required to have the same length `k` and `k` is represented with 64 bits.\n * The second assumption is also required by `verify_kzg_proof_batch`.\n *\/\nverify_blob_kzg_proof_batch : {k} (fin k, 64 >= width k) => [k]Blob -> [k]Bytes48 -> [k]Bytes48 -> Bit\nverify_blob_kzg_proof_batch blobs commitments_bytes proofs_bytes = verify_kzg_proof_batch commitments evaluation_challenges ys proofs where\n    commitments = map bytes_to_kzg_commitment commitments_bytes\n    polynomials = map blob_to_polynomial blobs \n    evaluation_challenges = [ compute_challenge blob commitment | blob <- blobs | commitment <- commitments ] \n    ys = [ evaluate_polynomial_in_evaluation_form polynomial evaluation_challenge | polynomial <- polynomials | evaluation_challenge <- evaluation_challenges ]\n    proofs = [ bytes_to_kzg_proof proof_bytes | proof_bytes <- proofs_bytes]\n\n\/*\n * ======================\n * Test Vector Generators\n * ======================\n *\/\n\n\/**\n * This function is used to generate a random, but valid data `Blob`.\n *\/\nvalid_blob_generator : Blob -> Blob\nvalid_blob_generator blob = assert (blob != blob') \"error\" blob' where\n    x = [bytes | bytes <- (groupBy`{BYTES_PER_FIELD_ELEMENT} blob)]\n    y = map (\\b -> (join b)) x\n    y' = map (\\b -> b % `BLS_MODULUS) y\n    x' = [groupBy`{8} poly | poly <- y']\n    blob' = join x'\n\n\/**\n * This function is used to generate a random, valid Z bytes.\n *\/\nz_bytes_generator : Bytes32 -> Bytes32\nz_bytes_generator z = z\n","variant":"hybrid","set":"unsupervised"}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsSerde.cry","filetype":"cry","content":"\/**\n * The module contains functions that perform BLS serialization and deserialization operations.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls\/point_compression.py\n * These functions are intended to match the corresponding py_ecc functions.\n *\/\nmodule Spec::BlsSerde where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::FQP\nimport Spec::BlsEC::G1\nimport Spec::BlsEC::GP\n\n\/**\n * Size of a G1 point\n *\/\ntype G1Bits = 384\n\n\/**\n * Serialized G1 point\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#custom-types\n *\/\ntype Bytes48 = [G1Bits]\n\n\/*\n * These are convenience values for working with the\n *  compressed point flags.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/constants.py#L12-L15\n *\/\nPOW_2_381 = 2^^381\nPOW_2_382 = 2^^382\nPOW_2_383 = 2^^383\n\n\/**\n * Compressed G1 point at infinity\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#constants\n *\n * Note: the name, though it is somewhat misleading, is chosen to match the Python spec.\n *\/\nG1_POINT_AT_INFINITY : Bytes48\nG1_POINT_AT_INFINITY = 0xc0 # zero\n\n\/**\n * Helper function for decompressing a G1 or G2 compresed point.\n *\n * The most-significant three bits of a G1 or G2 encoding should be masked away before\n * the coordinate(s) are interpreted.\n * These bits are used to unambiguously represent the underlying element.\n * The format: (c_flag, b_flag, a_flag, x)\n *  - c_flag: is '1' to indicated a compressed point, '0' otherwise.\n *  - b_flag: is '1' to indicate a point at infinity, '0' otherwise.\n *     - NOTE: the c_flag must also be set to indicate an intentionally\n *             compressed infinity point.\n *  - a_flag: is used to store the most significant bit of the y-coordinate.\n *  - x: is the x-coordinate of the point.\n *\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls\/point_compression.py#L43\n *\n * ```repl\n * :check get_flags (0xC0 # (zero:[384-8])) == (True, True, False)\n * :check get_flags (0xE0 # (zero:[384-8])) == (True, True, True)\n * ```\n * NOTE: `Bytes48 == [384]`\n *\/\nget_flags : Bytes48 -> (Bit, Bit, Bit)\nget_flags z = (c_flag, b_flag, a_flag) where\n    \/\/ The index operator '!0' as applied gives us the\n    \/\/   LSB which is what we want.\n    c_flag = ((z >> 383) && 1)!0  \/\/ The most significant bit\n    b_flag = ((z >> 382) && 1)!0  \/\/ The second-most significant bit\n    a_flag = ((z >> 381) && 1)!0  \/\/ The third-most significant bit\n\n\/**\n * Decompress the G1 compressed point\n *\n * Recovers x and y coordinates from the compressed point.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls\/point_compression.py#L80\n *\n* ```repl\n * :check decompress_G1 G1_POINT_AT_INFINITY == G1_INFINITY\n * :check decompress_G1 G1_2P_COMPRESSED == G1_2P\n * :check decompress_G1 G1_7P_COMPRESSED == G1_7P\n * ```\n *\/\ndecompress_G1 : Bytes48 -> G1Point\ndecompress_G1 z =\n    \/\/ c_flag == 1 indicates the compressed form\n    \/\/ MSB should be 1\n    if ~c_flag then\n        error \"decompress_G1: c_flag must be 1\"\n     | b_flag != isInfinity then\n        error \"b_flag should be 1\"\n     | b_flag then\n        \/\/ 3 MSBs should be b110\n        if a_flag then\n            error \"decompress_G1: a point at infinity should have a_flag == 0\"\n        else G1_INFINITY\n     \/\/ Else, not point at infinity\n     \/\/ 3 MSBs should be b100 or b101\n     | xBits >= q then\n        error \"decompress_G1: point value should be less than field modulus\"\n     | (y^^2) != (x^^3 + b) then\n        error \"The given point is not on G1: y^^2 = x^^3 + 4\"\n     \/\/ Choose the y whose leftmost bit is equal to the a_flag\n     | (((fromZ y) * 2) \/ q) != (bit_to_integer a_flag) then\n        { xCoord = x, yCoord = y'}\n     else\n        { xCoord = x, yCoord = y}\n     where\n        isInfinity = (z % POW_2_381) == 0\n        \/\/ We want to use the type Z Fq for all modular arithmetic, but\n        \/\/  we have to use Fq as a value which is not allowable with\n        \/\/  Z Fq, so we sometimes need to convert back and forth between\n        \/\/  Z Fq and Integer.\n        (c_flag, b_flag, a_flag) = get_flags z\n        xBits = (toInteger z) % POW_2_381\n        x = fromInteger xBits\n        q = `(Fq)\n        b = 4 : Z Fq \/\/ Our elliptic curve equation is y^^2 = x^^3 + 4\n        \/\/ Try solving y coordinate from the equation y^^2 = x^^3 + b using quadratic residue\n        y = pow_mod base exp\n        base = x^^3 + b\n        exp = ((q + 1) \/ 4) % q\n        y' = fromInteger (q - (fromZ y))\n\n\/**\n * Compress the G1 point\n *\n * Encodes x and y coordinates in the compressed point.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/point_compression.py#L58-L77\n *\n * ```repl\n * :check compress_G1 G1_INFINITY == G1_POINT_AT_INFINITY\n * :check compress_G1 G1_2P == G1_2P_COMPRESSED\n * :check compress_G1 G1_7P == G1_7P_COMPRESSED\n * ```\n *\/\ncompress_G1 : G1Point -> Bytes48\ncompress_G1 point =\n    if point == G1_INFINITY then\n        \/\/ Set c_flag = 1 and b_flag = 1. leave a_flag = x = 0\n        fromInteger (POW_2_383 + POW_2_382)\n    else\n        \/\/ Set c_flag = 1 and b_flag = 0\n        fromInteger (x + a_flag * POW_2_381 + POW_2_383)\n    where\n        \/\/ Record y's leftmost bit to the a_flag\n        x = fromZ point.xCoord\n        y = fromZ point.yCoord\n        q = toInteger `(Fq)\n        a_flag = (y * 2) \/ q\n\n\/**\n * Check the property that compression => decompression is the same point.\n * This check is performed by running random tests.\n * ```repl\n * :set tests=10000\n * :check check_compression_decompress_inverse\n * ```\n *\/\ncheck_compression_decompress_inverse : G1Point -> Bit\nproperty check_compression_decompress_inverse point = precondition ==> statement where\n    precondition = g1_is_valid_point point\n    statement = decompress_G1 (compress_G1 point) == point\n\n\/**\n * Make sure the compressed G1 point is valid, i.e. not infinity and in the subgroup.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/ciphersuites.py#L113\n * ```repl\n * :check key_validate G1_1P_COMPRESSED == True\n * \/\/ :error key_validate G1_INVALID_POINT_COMPRESSED \/\/ Cryptol cannot currently do this\n * ```\n * NOTE: I have manually checked that calling `key_validate` on an invalid compressed point\n *  fails with an error thrown. Unfortunately, there is not a way in the Cryptol REPL to\n *  say that I expect an error to be thrown.\n * NOTE: this repl test is slow (couple of seconds).\n *\/\nkey_validate : Bytes48 -> Bit\nkey_validate bytes =\n    if bytes == G1_POINT_AT_INFINITY then\n        False\n    else\n        subgroup_check point\n    where\n        point = decompress_G1 bytes\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_INVALID_INFINITY_COMPRESSED : Bytes48\nG1_INVALID_INFINITY_COMPRESSED = c_flag + b_flag + a_flag where\n    c_flag = (1 << 383) \/\/ is compressed\n    b_flag = (1 << 382) \/\/ is infinity\n    a_flag = (1 << 381) \/\/ invalid a_flag when infinity\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_INVALID_TO_BIG_COMPRESSED : Bytes48\nG1_INVALID_TO_BIG_COMPRESSED = c_flag + `(Fq) + 1 where\n    c_flag = (1 << 383) \/\/ is compressed\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_INVALID_POINT_COMPRESSED : Bytes48\nG1_INVALID_POINT_COMPRESSED = c_flag + b_flag + a_flag + 13 where\n    c_flag = (1 << 383) \/\/ is compressed\n    b_flag = (0 << 382) \/\/ not infinity\n    a_flag = (1 << 381) \/\/ doesn't matter since invalid point\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_1P_COMPRESSED : Bytes48\nG1_1P_COMPRESSED = c_flag + b_flag + a_flag + (toIntegral G1.xCoord) where\n    c_flag = (1 << 383) \/\/ is compressed\n    b_flag = (0 << 382) \/\/ not infinity\n    a_flag = (0 << 381) \/\/ because the MSB of G1.yCoord is '0'\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_2P_COMPRESSED : Bytes48\nG1_2P_COMPRESSED = c_flag + b_flag + a_flag + (toIntegral G1_2P.xCoord) where\n    c_flag = (1 << 383) \/\/ is compressed\n    b_flag = (0 << 382) \/\/ not infinity\n    a_flag = (1 << 381) \/\/ because the MSB of G1_2P.yCoord is '1'\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_3P_COMPRESSED : Bytes48\nG1_3P_COMPRESSED = c_flag + b_flag + a_flag + (toIntegral G1_3P.xCoord) where\n    c_flag = (1 << 383) \/\/ is compressed\n    b_flag = (0 << 382) \/\/ not infinity\n    a_flag = (0 << 381) \/\/ because the MSB of G1_3P.yCoord is '0'\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_7P_COMPRESSED : Bytes48\nG1_7P_COMPRESSED = c_flag + b_flag + a_flag + (toIntegral G1_7P.xCoord) where\n    c_flag = (1 << 383) \/\/ is compressed\n    b_flag = (0 << 382) \/\/ not infinity\n    a_flag = (1 << 381) \/\/ because the MSB of G1_7P.yCoord is '0'\n\n\/**\n * Size of a G2 point\n *\/\ntype G2Bits = 768\n\n\/**\n * Serialized G2 point\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#custom-types\n *\/\ntype Bytes96 = [G2Bits]\n\n\/**\n * Compressed G2 point at infinity\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#constants\n *\n * Note: the name, though it is somewhat misleading, is chosen to match the Python spec.\n *\/\nG2_POINT_AT_INFINITY : Bytes96\nG2_POINT_AT_INFINITY = 0xc0 # zero\n\n\/**\n * Test point for the decompression function `bytes96_to_G2`\n *\/\nG2_2P_COMPRESSED : Bytes96\nG2_2P_COMPRESSED = c_flag + b_flag + a_flag + x_real + x_imag where\n    c_flag = (1 << 767) \/\/ is compressed\n    b_flag = (0 << 766) \/\/ not infinity\n    a_flag = (1 << 765) \/\/ because the MSB of G2_2P.yCoeffs.imag is '1'\n    x_real = (toIntegral (G2_2P.xCoeffs@0))\n    x_imag = (toIntegral (G2_2P.xCoeffs@1)) << 384\n\n\/**\n * Test point for the decompression function `bytes96_to_G2`\n *\/\nG2_3P_COMPRESSED : Bytes96\nG2_3P_COMPRESSED = c_flag + b_flag + a_flag + x_real + x_imag where\n    c_flag = (1 << 767) \/\/ is compressed\n    b_flag = (0 << 766) \/\/ not infinity\n    a_flag = (0 << 765) \/\/ because the MSB of G2_3P.yCoeffs.imag is '0'\n    x_real = (toIntegral (G2_3P.xCoeffs@0))\n    x_imag = (toIntegral (G2_3P.xCoeffs@1)) << 384\n\n\/**\n * Compress the G2 point\n *\n * Encodes x and y coordinates in the compressed point.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/point_compression.py#L145\n *\n * ```repl\n * :check compress_G2 G2_INFINITY == G2_POINT_AT_INFINITY\n * :check compress_G2 G2_2P == G2_2P_COMPRESSED\n * :check compress_G2 G2_3P == G2_3P_COMPRESSED\n * ```\n * The compressed point (z1, z2) has the bit order:\n *  z1: (c_flag1, b_flag1, a_flag1, x1)\n *  z2: (c_flag2, b_flag2, a_flag2, x2)\n *  where\n *  - c_flag1 is always set to 1\n *  - b_flag1 indicates infinity when set to 1\n *  - a_flag1 helps determine the y-coordinate when decompressing,\n *  - a_flag2, b_flag2, and c_flag2 are always set to 0\n *\/\ncompress_G2 : G2Point -> Bytes96\ncompress_G2 point =\n    if point == G2_INFINITY then\n        \/\/ Set c_flag = 1 and b_flag = 1. leave a_flag = x = 0\n        (fromInteger (POW_2_383 + POW_2_382)) # (zero:[G1Bits])\n    else\n        z1Bits + z2Bits\n    where\n        x_re = fromZ (point.xCoeffs@0)\n        x_im = fromZ (point.xCoeffs@1)\n        y_re = fromZ (point.yCoeffs@0)\n        y_im = fromZ (point.yCoeffs@1)\n        q = toInteger `(Fq)\n        \/\/ Record the leftmost bit of y_im to the a_flag1\n        \/\/ If y_im happens to be zero, then use the bit of y_re\n        a_flag1 = if y_im > 0 then (y_im * 2) \/ q else (y_re * 2) \/ q\n        \/\/ Imaginary part of x goes to z1, real part goes to z2\n        \/\/ c_flag1 = 1, b_flag1 = 0\n        z1 = x_im + a_flag1 * POW_2_381 + POW_2_383\n        z2 = x_re\n        z1Bits = (fromInteger z1) # (zero:[G1Bits])\n        z2Bits = (fromInteger z2)\n\n\/**\n * Decompress the G2 compressed point\n *\n * Recovers x and y coordinates from the compressed point.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/point_compression.py#L175\n *\n* ```repl\n * :check decompress_G2 G2_POINT_AT_INFINITY == G2_INFINITY\n * :check decompress_G2 G2_2P_COMPRESSED == G2_2P\n * :check decompress_G2 G2_3P_COMPRESSED == G2_3P\n * ```\n *\/\ndecompress_G2 : Bytes96 -> G2Point\ndecompress_G2 z =\n    \/\/ c_flag == 1 indicates the compressed form\n    \/\/ MSB should be 1\n    if ~c_flag1 then\n        error \"decompress_G2: c_flag1 must be 1\"\n     | b_flag1 != is_inf_pt then\n        error \"b_flag1 should be 1\"\n     | b_flag1 then\n        \/\/ 3 MSBs should be b110\n        if a_flag1 then\n            error \"decompress_G2: a point at infinity should have a_flag1 == 0\"\n        else G2_INFINITY\n     \/\/ Else, not point at infinity\n     \/\/ 3 MSBs should be b100 or b101\n     \/\/ Ensure that x1 is less than the field modulus.\n     | x1Bits >= q then\n        error \"decompress_G2: x1 value should be less than field modulus\"\n     \/\/ Ensure that z2 is less than the field modulus.\n     | z2 >= (fromInteger q) then\n        error \"decompress_G2: z2 value should be less than field modulus\"\n     \/\/ The check for y being invalid is in fq2_modular_squareroot\n     \/\/ Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\n     \/\/ If y_im happens to be zero, then use the bit of y_re\n     | (y_im > 0) && condition1 then\n        { xCoeffs = x\n        , yCoeffs = (y ~* -1)\n        }\n     | (y_im == 0) && condition2 then\n        { xCoeffs = x\n        , yCoeffs = (y ~* -1)\n        }\n     else\n        { xCoeffs = x\n        , yCoeffs = y\n        }\n    where\n    is_inf_pt = ((z1 % POW_2_381) == 0) && (z2 == 0)\n    z1 = take`{G2Bits \/ 2} z\n    z2 = drop`{G2Bits \/ 2} z\n    (c_flag1, b_flag1, a_flag1) = get_flags z1\n    x1Bits = (toInteger z1) % POW_2_381\n    x1 = fromInteger x1Bits\n    q = `(Fq)\n    x2 = fromIntegral`{Fq} z2\n    \/\/ x1 is the imaginary part, x2 is the real part\n    x = [x2, x1]\n    y = fq2_modular_squareroot (x~^^3 ~+~ b2)\n    (y_re, y_im) = (fromZ (y@0), fromZ (y@1))\n    b2 = FQ2_B2\n    condition1 = ((y_im * 2) \/ q) != (bit_to_integer (a_flag1))\n    condition2 = ((y_re * 2) \/ q) != (bit_to_integer (a_flag1))\n\n\/**\n * Given value=x, returns the value y such that y^^2 % q == x,\n *  and errors if this is not possible. In cases where there are two solutions,\n *  the value with higher imaginary component is favored;\n *  if both solutions have equal imaginary component the value with higher real\n *  component is favored.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/point_compression.py#L123\n * ```repl\n * let y_squared = G2.xCoeffs~^^3 ~+~ FQ2_B2\n * :check ((fq2_modular_squareroot y_squared) ~* -1) == G2.yCoeffs\n * ```\n *\/\nfq2_modular_squareroot : Fq2 -> Fq2\nfq2_modular_squareroot value =\n    if elem check EVEN_EIGHTH_ROOTS_OF_UNITY then\n        if ((x1_im > x2_im) || ((x1_im == x2_im) && (x1_re > x2_re))) then x1 else x2\n    else\n        error \"Failed to find a modular squareroot\"\n    where\n        candidate_squareroot = value~^^((FQ2_ORDER + 8) \/ 16)\n        check = candidate_squareroot~^^2 ~\/~ value\n        candidate_rou_index = (find_eighth_root_of_unity_index check) \/ 2\n        x1 = candidate_squareroot ~\/~ (EIGHTH_ROOTS_OF_UNITY@candidate_rou_index)\n        x2 = fqp_neg x1\n        (x1_re, x1_im) = (fromZ (x1@0), fromZ (x1@1))\n        (x2_re, x2_im) = (fromZ (x2@0), fromZ (x2@1))\n\nFQ2_ONE = [1, 1]\nEIGHTH_ROOTS_OF_UNITY = [FQ2_ONE~^^((FQ2_ORDER * k) \/ 8) | k <- [0..7]]\nEVEN_EIGHTH_ROOTS_OF_UNITY = [EIGHTH_ROOTS_OF_UNITY@i | i <- [0, 2, 4, 6]]\n\n\/**\n * Find the index of the eighth root of unity.\n * When this function is called, we know that we've already found an even\n *  eighth root of unity, so we only check those.\n *\/\nfind_eighth_root_of_unity_index : Fq2 -> Integer\nfind_eighth_root_of_unity_index value =\n    sum [if value == rou then i else 0 | rou <- EVEN_EIGHTH_ROOTS_OF_UNITY | i <- [0, 2, 4, 6]]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsHelpers.cry","filetype":"cry","content":"\/**\n * The module contains functions that perform BLS operations.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bls12-381-helpers\n *\/\nmodule Spec::BlsHelpers where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::G1\nimport Spec::BlsEC::GP\nimport Spec::BlsSerde\n\n\/**\n * BLS field elements are 256-bits long.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#custom-types\n *\/\ntype BlsFieldSize = 256\ntype BlsFieldElement = [BlsFieldSize]\n\n\/**\n * Compute the modular inverse of x\n *  i.e. return y such that x * y % BLS_MODULUS == 1\n * Precondition: x != 0 BLS_MODULUS\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bls_modular_inverse\n * NOTE: Cryptol can not perform exponentiation with negative exponents,\n *  we cannot just execute `x^^(-1) % BLS_MODULUS` like the Python spec does.\n * ```repl\n * :check bls_modular_inverse 1 == 1\n * :check bls_modular_inverse 2 == 0x39f6d3a994cebea4199cec0404d0ec02a9ded2017fff2dff7fffffff80000001\n * :check bls_modular_inverse 3 == 0x4d491a377113a8daccd13ab0066be558e27e6d5755543d54aaaaaaaa00000001\n * ```\n * NOTE: we just chose the values at \"random.\" Checked against: https:\/\/planetcalc.com\/3298\/.\n *\/\nbls_modular_inverse : BlsFieldElement -> BlsFieldElement\nbls_modular_inverse x = toIntegral (modular_inverse x') where\n    x' = fromIntegral`{BLS_MODULUS} x\n\n\/**\n * Divide two field elements: x by y\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#div\n * ```repl\n * :check bls_div 1 2 == 0x39f6d3a994cebea4199cec0404d0ec02a9ded2017fff2dff7fffffff80000001\n * :check bls_div 13 1 == 13\n * :check bls_div 57 13 == 0x1ac0b075a72457fcf8210a7802390a776218122813b0da27276276272762762c\n * ```\n * NOTE: we just chose the last value at \"random\"\n *\/\nbls_div : BlsFieldElement -> BlsFieldElement -> BlsFieldElement\nbls_div x y = toIntegral (div_mod x' y') where\n    x' = fromIntegral`{BLS_MODULUS} x\n    y' = fromIntegral`{BLS_MODULUS} y\n\n\/**\n * Return x to power of [0, n-1].\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_powers\n * ```repl\n * let expected_powers = [1, 3, 3^^2, 3^^3, 3^^4, 3^^5, 3^^6, ((3^^7):BlsFieldElement)]\n * :check compute_powers`{8} 3 == expected_powers\n * :check compute_powers`{0} 3 == []\n * :check compute_powers`{1} 7 == [1:BlsFieldElement]\n * :check compute_powers`{2} 7 == [1:BlsFieldElement, 7]\n * ```\n *\/\ncompute_powers : {n} (fin n, width n <= 64) => BlsFieldElement -> [n]BlsFieldElement\ncompute_powers x\n    | n == 0 => []\n    | n == 1 => [1]\n    | n == 2 => [1, x]\n    | n > 2 => powers where\n        x' = fromIntegral`{BLS_MODULUS} x\n        powers' = [1] # [(powers'@i) * x' | i <- [0 .. n-2]]\n        powers = map toIntegral powers'\n\n\/**\n * Performs a multi-scalar multiplication between G1 `points` and `scalars`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#multi_exp\n * For the actual implementation,\n *   @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/85e2452301382a9d099df16f38deac8178355358\/tests\/core\/pyspec\/eth2spec\/utils\/bls.py#L262\n * NOTE: the Python multi_exp handles both G1 and G2 points, and just calls their\n *  corresponding `add` and `multiply` functions. This implementation is for G1 points only.\n * ```repl\n * :check g1_multi_exp`{1} [G1] [1] == G1\n * :check g1_multi_exp`{2} [G1, G1] [2, 3] == G1_5P\n * :check g1_multi_exp`{2} [G1_3P, G1_2P] [1, 2] == G1_7P\n * :check g1_multi_exp`{3} [G1_4P, G1_2P, G1_3P] [2, 3, 5] == g1_multi_exp`{2} [G1_5P, G1_7P] [3, 2]\n * ```\n *\/\ng1_multi_exp : {len} (fin len, len >= 1) => [len]G1Point -> [len]UInt256 -> G1Point\ng1_multi_exp points scalars = results!0 where\n    results = [G1_INFINITY] # [g1_add r (g1_multi_optimized p s) | r <- results | p <- points | s <- scalars]\n\n\/**\n * Deserialize the G1 bytes into a G1 point\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dcdcf25d8152cd078a9888eeddda4a550e1de009\/tests\/core\/pyspec\/eth2spec\/utils\/bls.py#L337\n * ```repl\n * :check bytes48_to_G1 G1_POINT_AT_INFINITY == G1_INFINITY\n * :check bytes48_to_G1 G1_2P_COMPRESSED == G1_2P\n * :check bytes48_to_G1 G1_7P_COMPRESSED == G1_7P\n * ```\n * NOTE: We're not testing any of the invalid points since they throw runtime errors,\n *  and Cryptol does not have a way to expect that. One can manually test to verify\n *  these errors are thrown.\n *\/\nbytes48_to_G1 : Bytes48 -> G1Point\nbytes48_to_G1 bytes = decompress_G1 bytes\n\n\/**\n * Serialize the G1 point into G1 bytes\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dcdcf25d8152cd078a9888eeddda4a550e1de009\/tests\/core\/pyspec\/eth2spec\/utils\/bls.py#L315\n * ```repl\n * :check g1_to_bytes48 G1_INFINITY == G1_POINT_AT_INFINITY\n * :check g1_to_bytes48 G1_2P == G1_2P_COMPRESSED\n * :check g1_to_bytes48 G1_7P == G1_7P_COMPRESSED\n * ```\n *\/\ng1_to_bytes48 : G1Point -> Bytes48\ng1_to_bytes48 point = compress_G1 point\n\n\/**\n * Deserialize the G2 bytes into a G2 point\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dcdcf25d8152cd078a9888eeddda4a550e1de009\/tests\/core\/pyspec\/eth2spec\/utils\/bls.py#L337\n * ```repl\n * :check bytes96_to_G2 G2_POINT_AT_INFINITY == G2_INFINITY\n * :check bytes96_to_G2 G2_2P_COMPRESSED == G2_2P\n * :check bytes96_to_G2 G2_3P_COMPRESSED == G2_3P\n * ```\n * NOTE: We're not testing any of the invalid points since they throw runtime errors,\n *  and Cryptol does not have a way to expect that. One can manually test to verify\n *  these errors are thrown.\n *\/\nbytes96_to_G2 : Bytes96 -> G2Point\nbytes96_to_G2 bytes = decompress_G2 bytes\n\n\/**\n * Serialize the G2 point into G2 bytes\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dcdcf25d8152cd078a9888eeddda4a550e1de009\/tests\/core\/pyspec\/eth2spec\/utils\/bls.py#L315\n * ```repl\n * :check g2_to_bytes96 G2_INFINITY == G2_POINT_AT_INFINITY\n * :check g2_to_bytes96 G2_2P == G2_2P_COMPRESSED\n * :check g2_to_bytes96 G2_3P == G2_3P_COMPRESSED\n * ```\n *\/\ng2_to_bytes96 : G2Point -> Bytes96\ng2_to_bytes96 point = compress_G2 point\n\n\/**\n * A KZG commitment is just a G1 point\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#custom-types\n *\/\ntype KZGCommitment = Bytes48\n\n\/**\n * BLS multiscalar multiplication in G1. This can be naively implemented using double-and-add.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#g1_lincomb\n * NOTE: we don't need to check for non-equal lengths for `points` and `scalars`,\n *  because our type parameter `n` enforces that for us.\n * NOTE: the `points` being passed in are compressed G1 points.\n * ```repl\n * :check g1_lincomb [] [] == G1_POINT_AT_INFINITY\n * :check g1_lincomb`{1} [G1_1P_COMPRESSED] [1] == G1_1P_COMPRESSED\n * :check g1_lincomb`{2} [G1_1P_COMPRESSED, G1_1P_COMPRESSED] [2, 5] == G1_7P_COMPRESSED\n * :check g1_lincomb`{3} [G1_2P_COMPRESSED, G1_2P_COMPRESSED, G1_1P_COMPRESSED] [1, 1, 3] == G1_7P_COMPRESSED\n * :check g1_lincomb`{3} [G1_3P_COMPRESSED, G1_2P_COMPRESSED, G1_1P_COMPRESSED] [1, 2, 0] == G1_7P_COMPRESSED\n * ```\n *\/\ng1_lincomb : {n} (fin n) => [n]KZGCommitment -> [n]BlsFieldElement -> KZGCommitment\ng1_lincomb points scalars\n    | n == 0 => G1_POINT_AT_INFINITY\n    | n > 0 => g1_to_bytes48 result where\n        points_g1 = [bytes48_to_G1 point | point <- points]\n        result = g1_multi_exp`{n} points_g1 scalars\n\n\/**\n * BLS Primitive root of unity.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#constants\n *\/\nPRIMITIVE_ROOT_OF_UNITY : Z BLS_MODULUS\nPRIMITIVE_ROOT_OF_UNITY = 7\n\n\/**\n * Compute the roots of unity for the `order`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_roots_of_unity\n * Precondition: `(BLS_MODULUS - 1) % order == 0`\n * Assertion: `order == n`\n *\/\ncompute_roots_of_unity : {n} (fin n, width n <= 64) => UInt64 -> [n]BlsFieldElement\ncompute_roots_of_unity order = assert (order == `n) \"order must be equal to n\" result where\n        order' = toInteger order\n        root_of_unity = pow_mod PRIMITIVE_ROOT_OF_UNITY ((`(BLS_MODULUS) - 1) \/ order')\n        root_of_unity' = toIntegral root_of_unity\n        result = compute_powers`{n} root_of_unity'\n\n\/**\n * Bytes used to encode a commitment.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#constants\n *\/\ntype BYTES_PER_COMMITMENT = 48\n\n\/**\n * Bytes used to encode a proof.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#constants\n *\/\ntype BYTES_PER_PROOF = 48\n\n\/**\n * Bytes used to encode a BLS scalar field element.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#constants\n *\/\ntype BYTES_PER_FIELD_ELEMENT = 32\n\n\/**\n * The bytes of a BLS scalar field element.\n *\/\ntype Bytes32 = [BYTES_PER_FIELD_ELEMENT][8]\n\n\/**\n * Convert untrusted bytes to a trusted and validated BLS scalar field element.\n * This function does not accept inputs greater than the BLS modulus.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bytes_to_bls_field\n * ```repl\n * let bytes = [0x73,0xed,0xa7,0x53,0x29,0x9d,0x7d,0x48,0x33,0x39,0xd8,0x08,0x09,0xa1,0xd8,0x05,0x53,0xbd,0xa4,0x02,0xff,0xfe,0x5b,0xfe,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00]\n * let field_element = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000000\n * :check bytes_to_bls_field bytes == field_element\n * ```\n *\/\nbytes_to_bls_field : Bytes32 -> BlsFieldElement\nbytes_to_bls_field bytes = assert (field_element < `(BLS_MODULUS)) error_msg field_element where\n    field_element = join bytes \/\/ Crytol is big endian\n    error_msg = \"BLS scalar field element must be less than modulus\"\n\n\/**\n * Convert a BLS scalar field element to bytes.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bls_field_to_bytes\n *\/\nbls_field_to_bytes : BlsFieldElement -> Bytes32 \nbls_field_to_bytes value = groupBy`{8} value\n\n\/**\n * Perform BLS validation required by the types `KZGProof` and `KZGCommitment`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#validate_kzg_g1\n * ```repl\n * :check validate_kzg_g1 G1_1P_COMPRESSED\n * \/\/ :error key_validate G1_INVALID_POINT_COMPRESSED \/\/ Cryptol cannot currently do this\n * ```\n * NOTE: I have manually checked that calling `key_validate` on an invalid compressed point\n *  fails with an error thrown. Unfortunately, there is not a way in the Cryptol REPL to\n *  say that I expect an error to be thrown.\n * NOTE: this repl test is slow (couple of seconds).\n *\/\nvalidate_kzg_g1 : Bytes48 -> Bit\nvalidate_kzg_g1 b =\n    if b == G1_POINT_AT_INFINITY then True\n    else key_validate b\n\n\/**\n * Convert untrusted bytes into a trusted and validated `KZGCommitment`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bytes_to_kzg_commitment\n * ```repl\n * :check (bytes_to_kzg_commitment G1_1P_COMPRESSED) == G1_1P_COMPRESSED\n * ```\n * NOTE: this repl test is slow (couple of seconds).\n *\/\nbytes_to_kzg_commitment : Bytes48 -> KZGCommitment\nbytes_to_kzg_commitment b =\n    assert (validate_kzg_g1 b) \"validate_kzg_g1 failed\" b\n\n\/**\n * Same as for `KZGCommitment`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#custom-types\n *\/\ntype KZGProof = Bytes48\n\n\/**\n * Convert untrusted bytes into a trusted and validated `KZGProof`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bytes_to_kzg_proof\n  * ```repl\n * :check (bytes_to_kzg_proof G1_1P_COMPRESSED) == G1_1P_COMPRESSED\n * ```\n * NOTE: this repl test is slow (couple of seconds).\n *\/\nbytes_to_kzg_proof : Bytes48 -> KZGProof\nbytes_to_kzg_proof b =\n    assert (validate_kzg_g1 b) \"validate_kzg_g1 failed\" b\n\n\/**\n * Unit tests for `g1_lincomb`.\n * ```repl\n * :check test_compute_roots_of_unity\n * ```\n *\/\ntest_compute_roots_of_unity : Bit\nproperty test_compute_roots_of_unity =\n    compute_roots_of_unity`{4} 4 == expected_roots where\n    expected_roots =\n        [ 0x0000000000000000000000000000000000000000000000000000000000000001\n        , 0x00000000000000008d51ccce760304d0ec030002760300000001000000000000\n        , 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000000\n        , 0x73eda753299d7d47a5e80b39939ed33467baa40089fb5bfefffeffff00000001\n        ]\n\n\n\/**\n * Hash `data` and convert the output to a BLS scalar field element.\n * The output is not uniform over the BLS field.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#hash_to_bls_field\n * TODO: Temporarily set to always return 0; need to use SHA2-256\n *\/\nhash_to_bls_field: {n} (fin n, n >= 1) => [n][8] -> BlsFieldElement\nhash_to_bls_field data = 0\n\n\/**\n * The two constants FIAT_SHAMIR_PROTOCOL_DOMAIN and RANDOM_CHALLENGE_KZG_BATCH_DOMAIN\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#blob\n *\/\nFIAT_SHAMIR_PROTOCOL_DOMAIN : [16][8]\nFIAT_SHAMIR_PROTOCOL_DOMAIN = \"FSBLOBVERIFY_V1_\" : [16][8]\nRANDOM_CHALLENGE_KZG_BATCH_DOMAIN : [16][8]\nRANDOM_CHALLENGE_KZG_BATCH_DOMAIN = \"RCKZGBATCH___V1_\" : [16][8]","variant":"hybrid","set":"unsupervised"}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/Permutations.cry","filetype":"cry","content":"\/*\n * The functions in this module are derived from the consensus-specs.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#helper-functions\n *\/\nmodule Spec::Permutations where\n\nimport Common::Utils\n\n\/**\n * Check if `value` is a power of two integer.\n * Return `1:[1]` if true and `0:[1]` otherwise.\n * NOTE: We use the `Utils::bit_to_bool` function because SAW cannot\n *  convert the `Bit` type internally to an LLVM integer type.\n *\/\nis_power_of_two : {n} (fin n, n >= 1) => [n] -> [1]\nis_power_of_two value = bit_to_bool (is_power_of_two_bit value)\n\n\/**\n * Check if `value` is a power of two integer.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#is_power_of_two\n *\/\nis_power_of_two_bit : {n} (fin n, n >= 1) => [n] -> Bit\nis_power_of_two_bit value = (value > 0) && ((value && (value - 1)) == 0)\n\n\/**\n * Reverse the bits of an integer of length `n`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#reverse_bits\n * NOTE: The Python spec only reverses the low-order bits\n * ```repl\n * :check reverse_bits`{16, 16} 0x18C3 == 0xC318\n * :check reverse_bits`{16, 16} 0x00AA == 0x5500\n * :check reverse_bits`{16, 8} 0x00A5 == 0x00A5\n * ```\n * NOTE: we just chose these values at \"random\"\n *\/\nreverse_bits : {n, order_bit_length} (fin n, n >= 1, order_bit_length >= 1, order_bit_length <= n)\n    => [n] -> [n]\nreverse_bits value = zero # reverse (drop`{n - order_bit_length} value)\n\n\/**\n * Reverse the low-order bits of a 64-bit integer.\n * This function matches the `reverse_bits_limited` function in c-kzg\n * @see https:\/\/github.com\/ethereum\/c-kzg-4844\/blob\/main\/src\/common\/utils.c#L84\n *\/\nreverse_bits_limited : [64] -> [64] -> [64]\nreverse_bits_limited order value = (reverse value) >> unused_bit_len where\n    unused_bit_len = 64 - lg2 order\n\n\/**\n * Return the bit-reversed permutation, which is an involution (inverts itself).\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bit_reversal_permutation\n * Standard algorithm: https:\/\/en.wikipedia.org\/wiki\/Bit-reversal_permutation\n * ```repl\n * let val = [0x18, 0xC3, 0xD5, 0x02, 0x40, 0xAB, 0xC3, 0x18]\n * let expected_permutation = [0x18, 0x40, 0xd5, 0xc3, 0xc3, 0xab, 0x02, 0x18]\n * let permuted_val = bit_reversal_permutation`{8, 8} val\n * :check permuted_val == expected_permutation\n * :check bit_reversal_permutation`{8, 8} permuted_val == val\n * ```\n *\/\nbit_reversal_permutation : {size, len} (fin size, size >= 1, len >= 2, size >= width (len - 1))\n    => [len][size] -> [len][size]\nbit_reversal_permutation sequence =\n    [sequence@(reverse_bits`{size, width (len - 1)} i) | i <- [0 .. (len-1)]]\n\n\/*\n *  ==========\n *  Properties\n *  ==========\n *\/\n\n\/**\n * Function `is_power_of_two_bit` should be true for all powers of two.\n * ```repl\n * :prove check_is_power_of_two\n * ```\n * NOTE: We'll just prove up to 2^^4096 --- that seems plenty and is still fast.\n *\/\nproperty check_is_power_of_two = all is_power_of_two_bit`{4096} [ 2^^n | n <- [0 .. 4096-1]]\n\n\/**\n * Property: calling `reverse_bits` twice on an value should return that value.\n * Assumes the same bit size of the input and the same desired low-order bits.\n * ```repl\n * :prove check_reverse_bits_involution`{256, 8}\n * :prove check_reverse_bits_involution`{256, 16}\n * :prove check_reverse_bits_involution`{256, 32}\n * :prove check_reverse_bits_involution`{256, 64}\n * :prove check_reverse_bits_involution`{256, 128}\n * :prove check_reverse_bits_involution`{256, 256}\n * ```\n *\/\ncheck_reverse_bits_involution : {n, order_bit_length} (fin n, n >= 1, order_bit_length >= 1, order_bit_length <= n)\n    => [n] -> Bit\nproperty check_reverse_bits_involution val = precondition ==> statement where\n    precondition = lg2 val < `order_bit_length\n    statement = (reverse_bits`{n, order_bit_length} (reverse_bits`{n, order_bit_length} val)) == val\n\n\/**\n * Property: Both implementations for \"reverse_bits\" are equivalent for 64-bit values.\n * ```repl\n * :prove check_reverse_bits_equiv`{64}\n * ```\n *\/\ncheck_reverse_bits_equiv : {order_bit_length} (order_bit_length >= 1, order_bit_length <= 64)\n    => [64] -> [64] -> Bit\nproperty check_reverse_bits_equiv order val = precondition ==> statement where\n    precondition = lg2 order == `order_bit_length\n    statement = reverse_bits`{64, order_bit_length} val == reverse_bits_limited order val\n\n\/**\n * Property: calling `bit_reversal_permutation` twice on an value should return that value.\n * ```repl\n * :prove check_bit_reversal_permutation_involution`{256, 8}\n * :prove check_bit_reversal_permutation_involution`{256, 16}\n * :prove check_bit_reversal_permutation_involution`{256, 32}\n * :prove check_bit_reversal_permutation_involution`{256, 64}\n * :prove check_bit_reversal_permutation_involution`{256, 128}\n * :prove check_bit_reversal_permutation_involution`{256, 256}\n * ```\n *\/\ncheck_bit_reversal_permutation_involution : {size, len} (fin size, size >= 1, len >= 2, size >= width (len - 1))\n    => [len][size] -> Bit\nproperty check_bit_reversal_permutation_involution val =\n    (bit_reversal_permutation`{size, len} (bit_reversal_permutation`{size, len} val)) == val\n","variant":"hybrid","set":"unsupervised"}
{"filename":"ckzg-eip-4844-verification\/spec\/Common\/ModArith.cry","filetype":"cry","content":"\/*\n * This module contains helper functions related to modular arithmetic operations.\n *\/\nmodule Common::ModArith where\n\n\/**\n * Convert from a fixed size bit type to a `Z` type.\n * ```repl\n * :check (fromIntegral`{13} (3:[384])) == (3 : Z 13)\n * :check (fromIntegral`{13} (14:[384])) == (1 : Z 13)\n * :check (fromIntegral`{13} (13:[384])) == (0 : Z 13)\n * ```\n *\/\nfromIntegral : {n, m} (fin n, n >= 1, fin m, m >= 1) => [m] -> Z n\nfromIntegral value = fromInteger (toInteger value)\n\n\/**\n * Convert from a `Z` type to a fixed size bit type.\n * ```repl\n * :check (toIntegral`{m=384} (3 : Z 13) == (3:[384]))\n * ```\n *\/\ntoIntegral : {n, m} (fin n, n >= 1, fin m, m >= 1) => Z n -> [m]\ntoIntegral value = fromInteger (fromZ value)\n\n\/**\n * Calculates the gcd and Bezout coefficients,\n *   using the Extended Euclidean Algorithm (recursive).\n *   (Source: https:\/\/extendedeuclideanalgorithm.com\/code)\n * NOTE: 's' and 't' are used for the B\u00e9zout coefficients,\n *   that satisfy the equation `a*s + b*t = gcd(a,b)`.\n *   `s1` and `t1` are the previous computed coefficients.\n *   `s2` and `t2` are the current computed coefficients.\n * ```repl\n * :check xgcd 7 5 1 0 0 1 == (1, -2, 3)\n * ```\n *\/\nxgcd : Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> (Integer, Integer, Integer)\nxgcd a b s1 s2 t1 t2 =\n    if b == 0 then\n        (abs (a), 1, 0)\n    \/\/ if r == 0, then b will be the gcd and\n    \/\/    s2, t2 the Bezout coefficients\n    else if r == 0 then\n        (abs (b), s2, t2)\n    else\n        xgcd b r s2 s3 t2 t3\n    where\n        q = a \/ b\n        r = a - q * b\n        s3 = s1 - q * s2\n        t3 = t1 - q * t2\n\n\/**\n * Calculates the multiplicative inverse of a number 'x' mod 'm',\n *  using the Extended Euclidean Algorithm. If 'x' does not have a\n *  multiplicative inverse mod 'm', then return 0.\n *  (Source: https:\/\/extendedeuclideanalgorithm.com\/code)\n * ```repl\n * :check multinv 3 7 == 5\n * :check multinv 88831 319 == 167\n * ```\n *\/\nmultinv : Integer -> Integer -> Integer\nmultinv x m =\n    \/\/ 'b' only has a multiplicative inverse if the 'gcd' is 1\n    if gcd == 1\n    then t % m\n    else 0\n    \/\/ Get the 'gcd' and the second Bezout coefficient 't' from\n    \/\/  the Extended Euclidean Algorithm. Note that 's' is unused.\n    \/\/  Default values for the last four parameters are standard.\n    where (gcd, s, t) = xgcd m x 1 0 0 1\n\n\/**\n * Compute the modular inverse of x\n *  i.e. return y such that x * y % n == 1\n * Precondition: x != 0 mod n\n * ```repl\n * :check modular_inverse`{319} (fromInteger 7492) == 177\n * :check modular_inverse`{319} (fromInteger (-3)) == 106\n * ```\n * NOTE: we just chose the values at \"random.\" Checked against: https:\/\/planetcalc.com\/3298\/.\n *\/\nmodular_inverse : {n} (fin n, n >= 1) => Z n -> Z n\nmodular_inverse x = fromInteger (multinv (fromZ x) `n)\n\n\/**\n * Divide two field elements: x by y\n * ```repl\n * :check div_mod (3 : Z 319) (fromInteger 7492) == 212\n * :check div_mod (3 : Z 319) (fromInteger (-7492)) == 107\n * :check div_mod (3 : Z 319) 0 == 0\n * ```\n *\/\ndiv_mod : {n} (fin n, n >= 1) => Z n -> Z n -> Z n\ndiv_mod x y = x * (modular_inverse y)\n\n\/**\n * Exponentiation in the specified modulo field `n`.\n * @see https: * ```repl\n * :check pow_mod (3 : Z 7) 2 == 2\n * :check pow_mod`{2} (fromInteger 1) 18 == 1\n * :check pow_mod`{3} (0 : Z 3) 5 == 0\n *\/\npow_mod : {n} (fin n, n >= 1) => Z n -> Integer -> Z n\npow_mod base exp = base ^^ exp\n","variant":"hybrid","set":"supervised"}
{"filename":"ckzg-eip-4844-verification\/spec\/Common\/Utils.cry","filetype":"cry","content":"\/*\n * This module contains helper functions unrelated to the consensus-specs.\n *\/\nmodule Common::Utils where\n\ntype BYTE_WIDTH = 8\n\ntype UInt64 = [64]\n\ntype UInt256 = [256]\n\n\/**\n * Convert a `Bit` to a 1-bit value.\n * We use this function because SAW cannot convert\n *  the `Bit` type internally to an LLVM integer type.\n * ```repl\n * :check bit_to_bool True == 1\n * :check bit_to_bool False == 0\n * ```\n *\/\nbit_to_bool : Bit -> [1]\nbit_to_bool b = if b then 1 else 0\n\n\/**\n * Convert a 1-bit value to a `Bit`.\n * ```repl\n * :check bool_to_bit 1 == True\n * :check bool_to_bit 0 == False\n * ```\n *\/\nbool_to_bit : [1] -> Bit\nbool_to_bit b = if b == 1 then True else False\n\n\/**\n * Convert an Integral value of 'n' bits to a `Bit`.\n * ```repl\n * :check bit_to_integer True == 1\n * :check bit_to_integer False == 0\n * ```\n *\/\nbit_to_integer : Bit -> Integer\nbit_to_integer b = if b then 1 else 0\n","variant":"hybrid","set":"supervised"}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/FQP.cry","filetype":"cry","content":"\/**\n * This module provides support for polynomial extension fields.\n * Specifically, we need to support Fq2 and Fq12.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L204\n *\/\nmodule Spec::BlsEC::FQP where\n\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::Poly(poly_extended_euclidean)\n\n\/**\n * A polynomial field extension type contains a list of\n *  coefficients which are elements of Fq.\n *\/\ntype FQP n = [n](Z Fq)\n\n\/**\n * A G2 point is comprised of two Fq2 elements, or sets of coefficients, each of degree two.\n * Each element is comprised of a real and imaginary coeffsicient.\n *\/\ntype Fq2 = FQP 2\n\n\/**\n * A G12 point is comprised of two Fq12 elements, or sets of coefficients, each of degree twelve.\n *\/\ntype Fq12 = FQP 12\n\n\/**\n * The modulus coefficients for the quadratic extension field Fq2.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_properties.py#L30\n *\/\nFQ2_MODULUS_COEFFICIENTS : Fq2\nFQ2_MODULUS_COEFFICIENTS = [1, 0]\n\n\/**\n * The modulus coefficients for the twelfth extension field Fq12.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_properties.py#L31\n *\/\nFQ12_MODULUS_COEFFICIENTS : Fq12\nFQ12_MODULUS_COEFFICIENTS = [2, 0, 0, 0, 0, 0, -2, 0, 0, 0, 0, 0]\n\n\/**\n * Addition of two sets of coefficients.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L232\n * ```repl\n * :check G2_y ~+~ G2_x == G2_y_plus_x\n * :check G12_y ~+~ G12_x == G12_y_plus_x\n * :check G12_x ~*~ G12_x == G12_xSquared\n * :check G12_x ~*~ G12_x ~*~ G12_x == G12_xCubed\n * ```\n *\/\n(~+~) : {n} (fin n, n >= 1) => FQP n -> FQP n -> FQP n\n(~+~) coeffs1 coeffs2 = [c1i + c2i | c1i <- coeffs1 | c2i <- coeffs2]\n\n\/**\n * Subtraction of two sets of coefficients.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L240\n * ```repl\n * :check G2_y ~-~ G2_x == G2_y_minus_x\n * :check G12_y ~-~ G12_x == G12_y_minus_x\n * ```\n *\/\n(~-~) : {n} (fin n, n >= 1) => FQP n -> FQP n -> FQP n\n(~-~) coeffs1 coeffs2 = [c1i - c2i | c1i <- coeffs1 | c2i <- coeffs2]\n\n\/**\n * Multiplication of two sets of coefficients.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L251\n * ```repl\n * :check G2_x ~*~ G2_x == G2_xSquared\n * :check G2_x ~*~ G2_x ~*~ G2_x == G2_xCubed\n * ```\n *\/\n(~*~) : {n} (fin n, n <= 12, n >= 2) => FQP n -> FQP n -> FQP n\n(~*~) coeffs1 coeffs2 = reduce_while b modulus_coeffs (2 * `(n) - 1) where\n    b = poly_multi coeffs1 coeffs2\n\nreduce_while : {a, n} (fin n, n <= 12, n >= 2, fin a, a == 2 * n - 1) => [a](Z Fq) -> [n](Z Fq) -> Integer -> [n](Z Fq)\nreduce_while b mod_coeffs len =\n    if len == `(n) then take`{n} b\n    else reduce_while b' mod_coeffs (len - 1)\n    where\n        top = b@(len-1)\n        exp = len - `(n) - 1\n        b' = [compute bj j | bj <- b | j <- [0 .. (a-1)]]\n        compute bj j =\n            if (j >= exp) && (j <= exp + `(n) - 1) then\n                bj - (top * (mod_coeffs@(j-exp)))\n            else bj\n\n\/**\n * Compute the initial polynomial multiplication.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L253\n * ```repl\n * :check poly_multi [2, 3] [5, 7] == [10, 29, 21]\n * let expected = [8,22,39,87,130,149,133,153,233,278,178,188,276,239,207,125,94,88,51,35,41,28,30]\n * :check poly_multi [2,3,3,1,2,5,6,1,2,5,3,5] [4,5,6,25,12,1,4,6,2,1,2,6] == expected\n * ```\n *\/\npoly_multi : {n, a} (fin n, 2 * n >= 1, fin a, a == 2 * n - 1) => FQP n -> FQP n -> FQP a\npoly_multi l r =\n    if (all (\\x -> x == 0) l) then zero\n    else ((scalar_mult (l@0) r) # zero) ~+~ (((poly_multi (l << 1) r) # zero) >> 1)\n    where scalar_mult x ys = map ((*) x) ys\n\n\/**\n * Multiplication of an integer and a set of coefficients.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L249\n * ```repl\n * :check G2_x ~* 2 == G2_xDoubled\n * :check 2 *~ G2_x == G2_xDoubled\n * ```\n *\/\n(*~) : {n} (fin n, n >= 1) => Integer -> FQP n -> FQP n\n(*~) value coeffs = [value' * ci | ci <- coeffs] where\n    value' = fromInteger value\n\n(~*) : {n} (fin n, n >= 1) => FQP n -> Integer -> FQP n\n(~*) coeffs value = value *~ coeffs\n\n\/**\n * Division of two sets of coefficients.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L280\n * ```repl\n * :check G2_x ~\/~ G2_x == [1, 0]\n * :check G2_y ~\/~ G2_x == G2_y_div_mod_x\n * :check G12_x ~\/~ G12_x == [1] # zero\n * :check G12_y ~\/~ G12_x == G12_y_div_mod_x\n * ```\n *\/\n(~\/~) : {n} (fin n, n <= 12, n >= 2) => FQP n -> FQP n -> FQP n\n(~\/~) coeffs1 coeffs2 = coeffs1 ~*~ (fqp_inv coeffs2)\n\n\/**\n * Compute the inverse of a Fq2 element.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L302\n * ```repl\n * :check fqp_inv G2_x == G2_xInverse\n * :check fqp_inv (fqp_inv G2_x) == G2_x\n * :check fqp_inv G2_y == G2_yInverse\n * :check fqp_inv (fqp_inv G2_y) == G2_y\n * :check fqp_inv G12_x == G12_xInverse\n * :check fqp_inv (fqp_inv G12_x) == G12_x\n * ```\n *\/\nfqp_inv : {n} (fin n, n <= 12, n >= 2) => FQP n -> FQP n\nfqp_inv coeffs = poly_extended_euclidean`{n+1} lm low hm high where\n    lm = [1] # n_zeros\n    hm = [0] # n_zeros\n    low = coeffs # [0]\n    high = modulus_coeffs # [1]\n    n_zeros = repeat`{n} 0\n\n\/**\n * The modulus coefficients of the polynomial extension fields.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_properties.py#L30-L31\n *\/\nmodulus_coeffs : {n} (fin n, n <= 12, n >= 2) => FQP n\nmodulus_coeffs =\n    \/\/ The appending by 'zero' is to help the Cryptol type checker.\n    \/\/ It actually evaluates to an empty bitvector.\n    if `(n) == 2 then FQ2_MODULUS_COEFFICIENTS # zero\n     | `(n) == 12 then take`{n} FQ12_MODULUS_COEFFICIENTS\n    else zero\n\n\/**\n * Exponentiation of a set of coeffsicients by a scalar.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L291\n * ```repl\n * :check G2_x~^^0 == [1, 0]\n * :check G2_x~^^1 == G2_x\n * :check G2_x~^^2 == G2_xSquared\n * :check G2_x~^^3 == G2_xCubed\n * :check G12_x~^^0 == [1] # zero\n * :check G12_x~^^1 == G12_x\n * :check G12_x~^^2 == G12_xSquared\n * :check G12_x~^^3 == G12_xCubed\n * ```\n *\/\n(~^^) : {n} (fin n, n <= 12, n >= 2) => FQP n -> Integer -> FQP n\n(~^^) coeffs scalar =\n    if scalar == 0 then\n        [1] # zero\n     | scalar == 1 then\n        coeffs\n     | scalar % 2 == 0 then\n        (coeffs ~*~ coeffs) ~^^ (scalar \/ 2)\n     else\n        ((coeffs ~*~ coeffs) ~^^ (scalar \/ 2)) ~*~ coeffs\n\n\/**\n * Negate the set of coefficients.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L355\n * ```repl\n * :check fqp_neg (fqp_neg G2_x) == G2_x\n * :check fqp_neg (fqp_neg G12_x) == G12_x\n * ```\n *\/\nfqp_neg : {n} (fin n, n >= 1) => FQP n -> FQP n\nfqp_neg coeffs = [-ci | ci <- coeffs]\n\n\/**\n * Equality of two sets of coefficients.\n * ```repl\n * :check G2_x ~==~ G2_x\n * :check G12_x ~==~ G12_x\n * ```\n *\/\n(~==~) : {n} (fin n, n >= 1) => FQP n -> FQP n -> Bit\n(~==~) coeffs1 coeffs2 = and [c1i == c2i | c1i <- coeffs1 | c2i <- coeffs2]\n\n\/**\n * X coefficients for generator for twisted curve over Fq2.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L44\n *\/\nG2_x : Fq2\nG2_x = [ 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n       , 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758\n       ]\n\n\/**\n * Y coefficients for generator for twisted curve over Fq2.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L44\n *\/\nG2_y : Fq2\nG2_y = [ 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n       , 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582\n       ]\n\n\/**\n * G2_x + G2_y. Computed using py_ecc.\n *\/\nG2_y_plus_x : Fq2\nG2_y_plus_x =\n    [ 2337851671874758553755193637188231783190898931008430971079287309306138512109538745297216704607199160594256266651065\n    , 3986698009736546165718461780529819517744210518930240528684401185085612201771633997414458852832304583413319107585340\n    ]\n\n\/**\n * G2_x - G2_y. Computed using py_ecc.\n *\/\nG2_y_minus_x : Fq2\nG2_y_minus_x =\n    [ 1632449532699825317380915405166111493410839025422880490639470020826550940638108691550521503919468808688732414044745\n    , 1870818876469786139193731976758160400328152687915953296697712908626373202724554996990127355752626211775441853413611\n    ]\n\n\/**\n * G2_x squared. Computed using py_ecc.\n *\/\nG2_xSquared : Fq2\nG2_xSquared =\n    [ 1997086149283677522843833040423074048426674013790346437450988890364808601048656494674186077061491944389142492819694\n    , 3113349101563180256960455051481244719726682130931247942710023183696345206282753395927436272834951815958170074391256\n    ]\n\n\/**\n * G2_x cubed. Computed using py_ecc.\n *\/\nG2_xCubed : Fq2\nG2_xCubed =\n    [ 3341065098200961989598748404381324054605449840948293400785922068969583005812936621662354076014412578129291257715484\n    , 2133050398774337206222816300118221327418763981033055222570091459262312519047975404484651902003138703421962555090218\n    ]\n\n\/**\n * G2_x multipled by two. Computed using py_ecc.\n *\/\nG2_xDoubled : Fq2\nG2_xDoubled =\n    [ 705402139174933236374278232022120289780059905585550480439817288479587571471430053746695200687730351905523852606320\n    , 2115879133266760026524729803771659117416057831014287231986688276459238999047079000424331497079678371637877254171729\n    ]\n\n\/**\n * G2_y \/ G2_x. Computed using py_ecc.\n *\/\nG2_y_div_mod_x : Fq2\nG2_y_div_mod_x =\n    [ 2645964961145567287646174681515652840605182444869364111679220104429646387260976011822898928226591963576020240426619\n    , 3656195751079888906744826605664754595376734064625263022628224160781596224005157110042338963344577397675474692059176\n    ]\n\n\/**\n * G2_x inverse. Computed using py_ecc.\n *\/\nG2_xInverse : Fq2\nG2_xInverse =\n    [ 1223514866584400226619392018844575446040489926980124362465220784014275923982521236729115905530146470033177964357563\n    , 3495453419063574139925455551631318136524378768480668459768684498547208492074727172949503320416899422709399085629096\n    ]\n\n\/**\n * G2_y inverse. Computed using py_ecc.\n *\/\nG2_yInverse : Fq2\nG2_yInverse =\n    [ 3828301281232776537393462114696026453820925117135598932697882187079936548530569912296382199133331215710911400309693\n    , 1450185639544495128598198914056492809111071767684112182252696543466687995844478949870392653614483391964324409513904\n    ]\n\n\/**\n * X coefficients for generator for the curve over Fq12.\n *\/\nG12_x : Fq12\nG12_x =\n    [ 0, 0, 0, 0\n    , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n    , 0, 0, 0, 0, 0\n    , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n    , 0\n    ]\n\n\/**\n * Y coefficients for generator for the curve over Fq12.\n *\/\nG12_y : Fq12\nG12_y =\n    [ 0, 0, 0\n    , 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n    , 0, 0, 0, 0, 0\n    , 1472406309213353956798468635167385199506877017588472562248853724925831900559844855499883907296819622485916638215732\n    , 0, 0\n    ]\n\n\/**\n * G12_y + G12_x. Computed using py_ecc.\n *\/\nG12_y_plus_x : Fq12\nG12_y_plus_x =\n    [ 0, 0, 0\n    , 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n    , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n    , 0, 0, 0, 0\n    , 1472406309213353956798468635167385199506877017588472562248853724925831900559844855499883907296819622485916638215732\n    , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n    , 0\n    ]\n\n\/**\n * G12_x - G12_y. Computed using py_ecc.\n *\/\nG12_y_minus_x : Fq12\nG12_y_minus_x =\n    [ 0, 0, 0\n    , 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n    , 3649708485634200775230650709724844011666852867146232645112149491884237864755122837569340028785150488085132346256627\n    , 0, 0, 0, 0\n    , 1472406309213353956798468635167385199506877017588472562248853724925831900559844855499883907296819622485916638215732\n    , 2649187917893293847525729476364543410508662633597071726112325855098110880974216161662606647748774743095332354028488\n    , 0\n    ]\n\n\/**\n * G12_x squared. Computed using py_ecc.\n *\/\nG12_xSquared : Fq12\nG12_xSquared =\n    [ 0, 0\n    , 1997086149283677522843833040423074048426674013790346437450988890364808601048656494674186077061491944389142492819694\n    , 0, 0, 0, 0, 0\n    , 558131476139751367058311005529085335650004058570450752629517146665768302617048450626625097886729935784513790785781\n    , 0, 0, 0\n    ]\n\n\/**\n * G12_x cubed. Computed using py_ecc.\n *\/\nG12_xCubed : Fq12\nG12_xCubed =\n    [ 3341065098200961989598748404381324054605449840948293400785922068969583005812936621662354076014412578129291257715484\n    , 0, 0, 0, 0, 0\n    , 3398402205508355001729823773604352792963539889981388796224142831270396407108357255853836542123378726684229921247154\n    , 0, 0, 0, 0, 0\n    ]\n\n\/**\n * G12_x \/ G12_y. Computed using py_ecc.\n *\/\nG12_y_div_mod_x : Fq12\nG12_y_div_mod_x =\n    [ 0, 0, 0, 0, 0\n    , 2645964961145567287646174681515652840605182444869364111679220104429646387260976011822898928226591963576020240426619\n    , 0, 0, 0, 0, 0\n    , 2506320172577994506258220874942502955664217219847453398140531096237990743617509481331063832123500549068674362096172\n    ]\n\n\/**\n * G12_x inverse. Computed using py_ecc.\n *\/\nG12_xInverse : Fq12\nG12_xInverse =\n    [ 0, 0\n    , 1730471002742493480111726292949161466072993978438463788028594421591099082398631928222300214242262711361673151288254\n    , 0, 0, 0, 0, 0\n    , 3495453419063574139925455551631318136524378768480668459768684498547208492074727172949503320416899422709399085629096\n    , 0, 0, 0\n    ]\n\n\/**\n * Verify that addition is commutative.\n * ```repl\n * :prove fqp_addition_commutative`{2}\n * :prove fqp_addition_commutative`{12}\n * ```\n *\/\nfqp_addition_commutative : {n} (fin n, n >= 1) => FQP n -> FQP n -> Bit\nproperty fqp_addition_commutative a b =\n    a ~+~ b == b ~+~ a\n\n\/**\n * Verify that multiplication is commutative.\n * ```repl\n * :set prover=cvc5\n * :prove fqp_multiplication_commutative`{2}\n * :prove fqp_multiplication_commutative`{12}\n * ```\n * NOTE: this proof works for Z3 v4.13 but not v4.8. Takes >50 seconds.\n *  It is much faster (~5 seconds) with cvc5.\n *\/\nfqp_multiplication_commutative : {n} (fin n, n <= 12, n >= 2) => FQP n -> FQP n -> Bit\nproperty fqp_multiplication_commutative a b =\n    a ~*~ b == b ~*~ a\n\n\/**\n * Verify that multiplying by two is same as addition doubling an element.\n * ```repl\n * :prove fqp_multi_by_two_is_double`{2}\n * :prove fqp_multi_by_two_is_double`{12}\n * ```\n *\/\nfqp_multi_by_two_is_double : {n} (fin n, n <= 12, n >= 2) => FQP n -> Bit\nproperty fqp_multi_by_two_is_double a =\n    a ~* 2 == a ~+~ a\n\n\/**\n * Verify that subtraction is not commutative,\n *   unless both coefficients are equal.\n * ```repl\n * :prove fqp_subtraction_not_commutative`{2}\n * :prove fqp_subtraction_not_commutative`{12}\n * ```\n *\/\nfqp_subtraction_not_commutative : {n} (fin n, n >= 1) => FQP n -> FQP n -> Bit\nproperty fqp_subtraction_not_commutative a b = precondition ==> statement where\n    precondition = a != b\n    statement = a ~-~ b != b ~-~ a\n\n\/**\n * Verify that squaring is that same using either multiplication or exponentiation.\n * ```repl\n * :prove fqp_squared_equiv`{2}\n * :prove fqp_squared_equiv`{12}\n * ```\n *\/\nfqp_squared_equiv : {n} (fin n, n <= 12, n >= 2) => FQP n -> Bit\nproperty fqp_squared_equiv c =\n    c~^^2 == c ~*~ c\n\n\/**\n * Verify that equality is commutative.\n * ```repl\n * :prove fqp_equality_commutative`{2}\n * :prove fqp_equality_commutative`{12}\n * ```\n *\/\nfqp_equality_commutative : {n} (fin n, n >= 1) => FQP n -> FQP n -> Bit\nproperty fqp_equality_commutative a b =\n    a ~==~ b == b ~==~ a\n","variant":"hybrid","set":"unsupervised"}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/G1.cry","filetype":"cry","content":"\/**\n * This module contains functions that perform ECC Point operations.\n * These functions are specific to the BLS curve, and specifically G1.\n *\n * The Deneb Python specs use the py_ecc library for the same operations.\n * This module's functions are based off of py_ecc.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py\n *\/\nmodule Spec::BlsEC::G1 where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\n\n\/**\n * G1 elliptic curve point.\n *\n * NOTE: by using the Z type, all modular arithmetic\n *  is handled automatically and there is no potential\n *  for any overflow errors.\n *\/\ntype G1Point =\n    { xCoord : Z Fq\n    , yCoord : Z Fq\n    }\n\n\/**\n * Representation of G1 point at infinity.\n *\n * NOTE: (0,0) isn't actually the point at infinity, but since we\n *  can't use enums here and (0, 0) is not on the curve, it's an\n *  acceptable substitute.\n *\/\nG1_INFINITY : G1Point\nG1_INFINITY =\n    { xCoord = 0\n    , yCoord = 0\n    }\n\n\/**\n * Generator for curve over Fq.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L35\n *\/\nG1 : G1Point\nG1 =\n    { xCoord = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n    , yCoord = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\n    }\n\n\/**\n * Determines whether or not the given point is on the G1 curve.\n * The point must satisfy the EC equation: y^^2 = x^^3 + 4\n * ```repl\n * :check g1_is_valid_point G1\n * :check g1_is_valid_point G1_2P\n * :check g1_is_valid_point G1_3P\n * :check g1_is_valid_point G1_4P\n * :check g1_is_valid_point G1_5P\n * :check g1_is_valid_point G1_6P\n * :check g1_is_valid_point G1_7P\n * ```\n *\/\ng1_is_valid_point : G1Point -> Bit\ng1_is_valid_point point =\n    y^^2 - x^^3 == 4\n    where\n        x = point.xCoord\n        y = point.yCoord\n\n\/**\n * Double a G1 point\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L84\n * ```repl\n * :check g1_double G1 == G1_2P\n * :check g1_double G1_2P == G1_4P\n * :check g1_double G1_3P == G1_6P\n * :check g1_double (g1_double G1) == G1_4P\n * ```\n *\/\ng1_double : G1Point -> G1Point\ng1_double point = newPoint where\n    x = point.xCoord\n    y = point.yCoord\n    m = div_mod (3 * x^^2) (2 * y)\n    newX = m^^2 - (2 * x)\n    newY = m * (x - newX) - y\n    newPoint =\n        { xCoord = newX\n        , yCoord = newY\n        }\n\n\/**\n * Add two G1 points\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L95\n * ```repl\n * :check g1_add G1 G1_INFINITY == G1\n * :check g1_add G1_INFINITY G1_3P == G1_3P\n * :check g1_add G1_INFINITY G1_INFINITY == G1_INFINITY\n * :check g1_add G1 G1 == G1_2P\n * :check g1_add G1 G1_2P == G1_3P\n * :check g1_add G1 G1_4P == G1_5P\n * :check g1_add G1_3P G1_2P == G1_5P\n * :check g1_add G1_2P G1_4P == G1_6P\n * ```\n *\/\ng1_add : G1Point -> G1Point -> G1Point\ng1_add p1 p2 =\n    if p1 == G1_INFINITY then p2\n     | p2 == G1_INFINITY then p1\n     | p1 == p2 then g1_double p1\n     else\n        { xCoord = newX\n        , yCoord = newY\n        }\n    where\n    x1 = p1.xCoord\n    y1 = p1.yCoord\n    x2 = p2.xCoord\n    y2 = p2.yCoord\n    m = div_mod (y2 - y1) (x2 - x1)\n    newX = m^^2 - x1 - x2\n    newY = m * (x1 - newX) - y1\n\n\/**\n * Multiply a G1 point by a scalar\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L114\n * The optimization of running scalar multiplication on the inverse and then using the\n *  inverse of `y` is described here: https:\/\/www.mdpi.com\/2227-7390\/12\/6\/881, Section 4, second case\n * ```repl\n * :check g1_multi_optimized G1 0 == G1_INFINITY\n * :check g1_multi_optimized G1 1 == G1\n * :check g1_multi_optimized G1 6 == G1_6P\n * :check g1_multi_optimized G1 (`(BLS_MODULUS)-1) == g1_multi G1 (`(BLS_MODULUS)-1)\n * :check g1_multi_optimized G1 `(BLS_MODULUS) == g1_multi G1 `(BLS_MODULUS)\n * :check g1_multi_optimized G1 (`(BLS_MODULUS)+1) == g1_multi G1 (`(BLS_MODULUS)+1)\n * ```\n *\/\ng1_multi_optimized : G1Point -> UInt256 -> G1Point\ng1_multi_optimized point scalar =\n    if scalar >= `(BLS_MODULUS) then g1_multi point scalar\n     \/\/ For the special case of scalars < BLS_MODULUS and\n     \/\/  >= `(BLS_MODULUS) \/ 2, we can compute the inverse\n     \/\/  and then inverse the coordinantes.\n     | scalar >= `(BLS_MODULUS) \/ 2 then {xCoord = x, yCoord = y}\n     else g1_multi point scalar\n    where\n        inverse_scalar = `(BLS_MODULUS) - scalar\n        inverse_point = g1_multi point inverse_scalar\n        y = fromInteger (`(Fq) - (fromZ inverse_point.yCoord))\n        x = inverse_point.xCoord\n\n\/**\n * Multiply a G1 point by a scalar\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L114\n * ```repl\n * :check g1_multi G1 0 == G1_INFINITY\n * :check g1_multi G1 1 == G1\n * :check g1_multi G1 6 == G1_6P\n * :check g1_multi G1_2P 3 == g1_multi G1_3P 2\n * ```\n *\/\ng1_multi : G1Point -> UInt256 -> G1Point\ng1_multi point scalar =\n    if scalar == 0 then G1_INFINITY\n        | scalar == 1 then point\n        \/\/ If scalar is even, just double\n        | scalar % 2 == 0 then g1_multi (g1_double point) (scalar \/ 2)\n        \/\/ If scalar is odd, double and add\n        else g1_add ((g1_multi (g1_double point) (scalar \/ 2))) point\n\n\/**\n * Randomize testing to show the two g1_multi functions are equivalent.\n * ```repl\n * :check g1_multis_equiv\n * ```\n * This takes a couple of minutes.\n *\/\ng1_multis_equiv : UInt256 -> Bit\nproperty g1_multis_equiv scalar =\n    g1_multi G1 scalar == g1_multi_optimized G1 scalar\n\n\/**\n * Determine whether or not the G1 point is a member of the subgroup.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/g2_primitives.py#L34\n * ```repl\n * :check subgroup_check G1_INFINITY == False\n * :check subgroup_check G1 == True\n * :check subgroup_check G1_2P == True\n * ```\n * NOTE: these repl tests are very slow (~5 seconds).\n *\/\nsubgroup_check : G1Point -> Bit\nsubgroup_check point = G1_INFINITY != g1_multi point `(BLS_MODULUS)\n\n\/*\n * ===========\n * Test Points\n * ===========\n *\/\n\n\/\/ All of these points were generated from: http:\/\/www.christelbach.com\/eccalculator.aspx\n\nG1_2P : G1Point\nG1_2P =\n    { xCoord = 838589206289216005799424730305866328161735431124665289961769162861615689790485775997575391185127590486775437397838\n    , yCoord = 3450209970729243429733164009999191867485184320918914219895632678707687208996709678363578245114137957452475385814312\n    }\n\nG1_3P : G1Point\nG1_3P =\n    { xCoord = 1527649530533633684281386512094328299672026648504329745640827351945739272160755686119065091946435084697047221031460\n    , yCoord = 487897572011753812113448064805964756454529228648704488481988876974355015977479905373670519228592356747638779818193\n    }\n\nG1_4P : G1Point\nG1_4P =\n    { xCoord = 1940386630589042756063486004190165295069185078823041184114464346315715796897349637805088429212932248421554491972448\n    , yCoord = 3114296198575988357603748217414299058449850389627766458803888308926785677746356789015548793127623382888106859156543\n    }\n\nG1_5P : G1Point\nG1_5P =\n    { xCoord = 2601793266141653880357945339922727723793268013331457916525213050197274797722760296318099993752923714935161798464476\n    , yCoord = 3498096627312022583321348410616510759186251088555060790999813363211667535344132702692445545590448314959259020805858\n    }\n\nG1_6P : G1Point\nG1_6P =\n    { xCoord = 1063080548659463434646774310890803636667161539235054707411467714858983518890075240133758563865893724012200489498889\n    , yCoord = 3669927104170827068533340245967707139563249539898402807511810342954528074138727808893798913182606104785795124774780\n    }\n\nG1_7P : G1Point\nG1_7P =\n    { xCoord = 3872473689207892378470335395114902631176541028916158626161662840934315241539439160301564344905260612642783644023991\n    , yCoord = 2547806390474846378491145127515427451279430889101277169890334737406180277792171092197824251632631671609860505999900\n    }\n","variant":"hybrid","set":"supervised"}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/GP.cry","filetype":"cry","content":"\/**\n * These functions are specific to the BLS curve and specifically the\n *  ECC points with coordinates in the polynomial extension fields Fq2 and Fq12.\n *\n * The Deneb Python specs has an option to use the py_ecc library for these operations.\n * This module's functions are based off of py_ecc.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py\n *\/\nmodule Spec::BlsEC::GP where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::FQP\n\n\/**\n * The order of Fq2.\n * @see https: *\/\nFQ2_ORDER : Integer\nFQ2_ORDER = `(Fq)^^2 - 1\n\n\/**\n * Twisted curve over Fq2.\n * @see https: *\/\nFQ2_B2 : Fq2\nFQ2_B2 = [4, 4]\n\n\/**\n * Extension curve over Fq12; same b value as over Fq\n * @see https: *\/\nFQ12_B12 : Fq12\nFQ12_B12 = [4] # zero\n\ntype GPPoint n =\n    { xCoeffs : FQP n\n    , yCoeffs : FQP n\n    }\n\n\/**\n * G2 elliptic curve point.\n * This is the quadratic extension field (Fq2) for the field Fq (G1).\n * @see https: *\n * NOTE: by using the Z type, all modular arithmetic\n *  is handled automatically and there is no potential\n *  for any overflow errors.\n *\/\ntype G2Point = GPPoint 2\n\n\/**\n * G12 elliptic curve point.\n * This is the twefth extension field (Fq12) for the field Fq (G1).\n * @see https: *\n * NOTE: by using the Z type, all modular arithmetic\n *  is handled automatically and there is no potential\n *  for any overflow errors.\n *\/\ntype G12Point = GPPoint 12\n\n\/**\n * Representation of G2 point at infinity.\n *\n * NOTE: ((0,0),(0,0)) isn't actually the point at infinity, but since we\n *  can't use enums here and ((0,0),(0,0)) is not on the curve, it's an\n *  acceptable substitute.\n *\/\nG2_INFINITY : G2Point\nG2_INFINITY =\n    { xCoeffs = zero\n    , yCoeffs = zero\n    }\n\n\/**\n * Representation of G12 point at infinity.\n *\n * NOTE: this isn't actually the point at infinity, but since we\n *  can't use enums here and all zeros is not on the curve, it's an\n *  acceptable substitute.\n *\/\nG12_INFINITY : G12Point\nG12_INFINITY =\n    { xCoeffs = zero\n    , yCoeffs = zero\n    }\n\n\/**\n * Generator for twisted curve over Fq2.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L44\n *\/\nG2 : G2Point\nG2 =\n    { xCoeffs =\n        [ 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758\n        ]\n    , yCoeffs =\n        [ 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n        , 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582\n        ]\n    }\n\n\/**\n * Generator for curve over Fq12.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L44\n *\/\nG12 : G12Point\nG12 =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 0, 0, 0, 0, 0\n        , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n        , 0, 0, 0, 0, 0\n        , 1472406309213353956798468635167385199506877017588472562248853724925831900559844855499883907296819622485916638215732\n        , 0, 0\n        ]\n    }\n\n\/**\n * Determines whether or not the given point is on the curve.\n * The point must satisfy the EC equation: y^^2 = x^^3 + 4\n * NOTE: `4 == b`, we will represent `b` differently per curve.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L71\n * ```repl\n * :check g2_is_valid_point G2\n * :check g2_is_valid_point G2_2P\n * :check g2_is_valid_point G2_3P\n * :check g2_is_valid_point G2_6P\n * :check g12_is_valid_point G12\n * :check g12_is_valid_point G12_2P\n * :check g12_is_valid_point G12_3P\n * :check g12_is_valid_point G12_6P\n * ```\n *\/\ngp_is_valid_point : {n} (fin n, n <= 12, n >= 2) => FQP n -> GPPoint n -> Bit\ngp_is_valid_point b point =\n    (y~^^2) ~-~ (x~^^3) == b\n    where\n        x = point.xCoeffs\n        y = point.yCoeffs\n\ng2_is_valid_point : G2Point -> Bit\ng2_is_valid_point point = gp_is_valid_point FQ2_B2 point\n\ng12_is_valid_point : G12Point -> Bit\ng12_is_valid_point point = gp_is_valid_point FQ12_B12 point\n\n\/**\n * Negate a point.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L135\n * ```repl\n * :check g2_negate G2 == G2_Negated\n * :check g2_negate (g2_negate G2) == G2\n * :check g12_negate G12 == G12_Negated\n * :check g12_negate (g12_negate G12) == G12\n * ```\n *\/\ngp_negate : {n} (fin n, n >= 1) => GPPoint n -> GPPoint n\ngp_negate point = newPoint where\n    x = point.xCoeffs\n    y = point.yCoeffs\n    newPoint =\n        { xCoeffs = x\n        , yCoeffs = fqp_neg y\n        }\n\ng2_negate : G2Point -> G2Point\ng2_negate point = gp_negate point\n\ng12_negate : G12Point -> G12Point\ng12_negate point = gp_negate point\n\n\/**\n * Double a point.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L84\n * ```repl\n * :check g2_double G2 == G2_2P\n * :check g2_double G2_3P == G2_6P\n * :check g12_double G12 == G12_2P\n * :check g12_double G12_3P == G12_6P\n * ```\n *\/\ngp_double : {n} (fin n, n <= 12, n >= 2) => GPPoint n -> GPPoint n\ngp_double point = newPoint where\n    x = point.xCoeffs\n    y = point.yCoeffs\n    m = (3 *~ (x~^^2)) ~\/~ (2 *~ y)\n    newX = (m~^^2) ~-~ (2 *~ x)\n    newY = (m ~*~ (x ~-~ newX)) ~-~ y\n    newPoint =\n        { xCoeffs = newX\n        , yCoeffs = newY\n        }\n\ng2_double : G2Point -> G2Point\ng2_double point = gp_double point\n\ng12_double : G12Point -> G12Point\ng12_double point = gp_double point\n\n\/**\n * Add two points.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L95\n * ```repl\n * :check g2_add G2 G2 == G2_2P\n * :check g2_add G2 G2_2P == G2_3P\n * :check g2_add G2_3P G2_3P == G2_6P\n * :check g12_add G12 G12 == G12_2P\n * :check g12_add G12 G12_2P == G12_3P\n * :check g12_add G12_3P G12_3P == G12_6P\n * ```\n *\/\ngp_add : {n} (fin n, n <= 12, n >= 2) => GPPoint n -> GPPoint n -> GPPoint n -> GPPoint n\ngp_add infinity p1 p2 =\n    if p1 == infinity then p2\n     | p2 == infinity then p1\n     | p1 == p2 then gp_double p1\n     else\n        { xCoeffs = newX\n        , yCoeffs = newY\n        }\n    where\n    x1 = p1.xCoeffs\n    y1 = p1.yCoeffs\n    x2 = p2.xCoeffs\n    y2 = p2.yCoeffs\n    m = (y2 ~-~ y1) ~\/~ (x2 ~-~ x1)\n    newX = m~^^2 ~-~ x1 ~-~ x2\n    newY = m ~*~ (x1 ~-~ newX) ~-~ y1\n\ng2_add : G2Point -> G2Point -> G2Point\ng2_add p1 p2 = gp_add G2_INFINITY p1 p2\n\ng12_add : G12Point -> G12Point -> G12Point\ng12_add p1 p2 = gp_add G12_INFINITY p1 p2\n\n\/**\n * Multiply a point by a scalar.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L114\n * ```repl\n * :check g2_multi G2 0 == G2_INFINITY\n * :check g2_multi G2 1 == G2\n * :check g2_multi G2 2 == G2_2P\n * :check g2_multi G2 3 == G2_3P\n * :check g2_multi G2 6 == G2_6P\n * :check g2_multi G2_2P 3 == g2_multi G2_3P 2\n * :check g12_multi G12 0 == G12_INFINITY\n * :check g12_multi G12 1 == G12\n * :check g12_multi G12 2 == G12_2P\n * :check g12_multi G12 3 == G12_3P\n * :check g12_multi G12 6 == G12_6P\n * :check g12_multi G12_2P 3 == g12_multi G12_3P 2\n * ```\n *\/\ngp_multi : {n} (fin n, n <= 12, n >= 2) => GPPoint n -> GPPoint n -> UInt256 -> GPPoint n\ngp_multi infinity point scalar =\n    if scalar == 0 then infinity\n        | scalar == 1 then point\n        \/\/ If scalar is even, just double\n        | scalar % 2 == 0 then gp_multi infinity (gp_double point) (scalar \/ 2)\n        \/\/ If scalar is odd, double and add\n        else gp_add infinity ((gp_multi infinity (gp_double point) (scalar \/ 2))) point\n\ng2_multi : G2Point -> UInt256 -> G2Point\ng2_multi point scalar = gp_multi G2_INFINITY point scalar\n\ng12_multi : G12Point -> UInt256 -> G12Point\ng12_multi point scalar = gp_multi G12_INFINITY point scalar\n\n\/**\n * Multiply a G12 point by a scalar\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L114\n * The optimization of running scalar multiplication on the inverse and then using the\n *  inverse of `y` is described here: https:\/\/www.mdpi.com\/2227-7390\/12\/6\/881, Section 4, second case\n * We just have to take the inverse of every `y` coefficient.\n * ```repl\n * :check g2_multi_optimized G2 0 == g2_multi G2 0\n * :check g2_multi_optimized G2 1 == g2_multi G2 1\n * :check g2_multi_optimized G2 6 == g2_multi G2 6\n * :check g2_multi_optimized G2 (`(BLS_MODULUS)-1) == g2_multi G2 (`(BLS_MODULUS)-1)\n * :check g2_multi_optimized G2 `(BLS_MODULUS) == g2_multi G2 `(BLS_MODULUS)\n * :check g2_multi_optimized G2 (`(BLS_MODULUS)+1) == g2_multi G2 (`(BLS_MODULUS)+1)\n * :check g12_multi_optimized G12 0 == g12_multi G12 0\n * :check g12_multi_optimized G12 1 == g12_multi G12 1\n * :check g12_multi_optimized G12 6 == g12_multi G12 6\n * :check g12_multi_optimized G12 (`(BLS_MODULUS)-1) == G12_NEG_ONE\n * :check g12_multi_optimized G12 (`(BLS_MODULUS)-2) == G12_NEG_TWO\n * :check g12_multi_optimized G12 (`(BLS_MODULUS)-3) == G12_NEG_THREE\n * ```\n *\/\ngp_multi_optimized : {n} (fin n, n <= 12, n >= 2) => GPPoint n -> GPPoint n -> UInt256 -> GPPoint n\ngp_multi_optimized infinity point scalar =\n    if scalar >= `(BLS_MODULUS) then gp_multi infinity point scalar\n     \/\/ For the special case of scalars < BLS_MODULUS and\n     \/\/  >= `(BLS_MODULUS) \/ 2, we can compute the inverse\n     \/\/  and then inverse the coordinantes.\n     | scalar >= `(BLS_MODULUS) \/ 2 then {xCoeffs = xcoeffs, yCoeffs = ycoeffs}\n     else gp_multi infinity point scalar\n    where\n        inverse_scalar = `(BLS_MODULUS) - scalar\n        inverse_point = gp_multi infinity point inverse_scalar\n        ycoeffs = map (\\y -> fromInteger (`(Fq) - (fromZ y))) inverse_point.yCoeffs\n        xcoeffs = inverse_point.xCoeffs\n\ng2_multi_optimized : G2Point -> UInt256 -> G2Point\ng2_multi_optimized point scalar = gp_multi_optimized G2_INFINITY point scalar\n\ng12_multi_optimized : G12Point -> UInt256 -> G12Point\ng12_multi_optimized point scalar = gp_multi_optimized G12_INFINITY point scalar\n\n\/**\n * Determine whether or not the G2 point is a member of the subgroup.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/g2_primitives.py#L34\n * ```repl\n * :check g2_subgroup_check G2_INFINITY == False\n * :check g2_subgroup_check G2 == True\n * :check g2_subgroup_check G2_2P == True\n * ```\n * NOTE: these repl tests are very slow (~10 seconds each for the last two).\n *\/\ng2_subgroup_check : G2Point -> Bit\ng2_subgroup_check point = G2_INFINITY != (g2_multi point `(BLS_MODULUS))\n\n\/**\n * \"Twist\" a point in Fq2 into a point in Fq12.\n * @see https: *\/\nW : Fq12\nW = [0, 1] # zero\n\n\/**\n * Convert a G2 point into a G12 point.\n * @see https: * ```repl\n * :check twist G2 == G12\n * ```\n *\/\ntwist : G2Point -> G12Point\ntwist p = {xCoeffs = newX, yCoeffs = newY} where\n    x = p.xCoeffs\n    y = p.yCoeffs\n    \/\/ Field isomorphism from Z[p] \/ x^^2 to Z[p] \/ x^^2 - 2*x + 2\n    xcoeffs = [(x@0) - (x@1), x@1]\n    ycoeffs = [(y@0) - (y@1), y@1]\n    \/\/ Isomorphism into subfield of Z[p] \/ w^^12 - 2 * w^^6 + 2,\n    \/\/ where w^^6 = x\n    nx = [xcoeffs@0] # five_zeros # [xcoeffs@1] # five_zeros\n    ny = [ycoeffs@0] # five_zeros # [ycoeffs@1] # five_zeros\n    \/\/ Divide x coord by w^^2 and y coord by w^^3\n    newX = nx ~\/~ (W~^^2)\n    newY = ny ~\/~ (W~^^3)\n    five_zeros = repeat`{5} 0\n\n\/*\n * ===========\n * Test Points\n * ===========\n *\/\n\n\/**\n * G2 doubled. Computed using py_ecc: `normalize(double(G2))`.\n *\/\nG2_2P : G2Point\nG2_2P =\n    { xCoeffs =\n        [ 3419974069068927546093595533691935972093267703063689549934039433172037728172434967174817854768758291501458544631891\n        , 1586560233067062236092888871453626466803933380746149805590083683748120990227823365075019078675272292060187343402359\n        ]\n    , yCoeffs =\n        [ 678774053046495337979740195232911687527971909891867263302465188023833943429943242788645503130663197220262587963545\n        , 2374407843478705782611042739236452317510200146460567463070514850492917978226342495167066333366894448569891658583283\n        ]\n    }\n\n\/**\n * G2 tripled. Computed using py_ecc: `normalize(add(G2, double(G2)))`.\n *\/\nG2_3P : G2Point\nG2_3P =\n    { xCoeffs =\n        [ 2795155019138475430256695697248607867022196082692926850257941893956680503583886174445899854256891620515274933186478\n        , 1418901263980595683832511076652430035654903023556505873032297534993731256453342997202098832403658787934376638965468\n        ]\n    , yCoeffs =\n        [ 1713408536894110516522969272885192173669900392782465197506312048399987681703463801235485042423756235640603447122066\n        , 1376945178829045108008380835987620979304438294788415956605678509674588356753313865659068546846109894276784773457993\n        ]\n    }\n\n\/**\n * G2 multiplied by 6. Computed using py_ecc: `normalize(multiply(G2, 6))`.\n *\/\nG2_6P : G2Point\nG2_6P =\n    { xCoeffs =\n        [ 3984640847924757144714972801294669751518204805083279115209564409785869025937099631985667805381121749661329977337231\n        , 608866484358724393780037751128594231300217318157170134017274809385436427203952108566113171210510640978002034144337\n        ]\n    , yCoeffs =\n        [ 3638085773299732811703058316322950283836045952826105333022656670096922749263292332009255347182392556648551235304444\n        , 1315309522598195877039488735068285781409574791250756219351720987511623939545034443010380218936398442802560800338945\n        ]\n    }\n\n\/**\n * G2 negated. Computed using py_ecc: `normalize(neg(G2))`.\n *\/\nG2_Negated : G2Point\nG2_Negated =\n    { xCoeffs =\n        [ 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758\n        ]\n    , yCoeffs =\n        [ 2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882\n        , 3074855889729334937670587859959866275799142626485414915307030157330054773488162299461738339401058098462460928340205\n        ]\n    }\n\n\/**\n * G12 doubled. Computed using py_ecc: `normalize(double(G12))`.\n *\/\nG12_2P : G12Point\nG12_2P =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 3419974069068927546093595533691935972093267703063689549934039433172037728172434967174817854768758291501458544631891\n        , 0, 0, 0, 0, 0\n        , 3085702637220734738417436494616749403912215658780238013160080261412073281518532063392788241082272664317258671945021\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 678774053046495337979740195232911687527971909891867263302465188023833943429943242788645503130663197220262587963545\n        , 0, 0, 0, 0, 0\n        , 847816895216105222315651272001770314991114118284350099884024831234542017398199626189210415118115625674814535309869\n        , 0, 0\n        ]\n    }\n\n\/**\n * G12 tripled. Computed using py_ecc: `normalize(add(G12, double(G12)))`.\n *\/\nG12_3P : G12Point\nG12_3P =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 2795155019138475430256695697248607867022196082692926850257941893956680503583886174445899854256891620515274933186478\n        , 0, 0, 0, 0, 0\n        , 3314282677642727520205697515437815240873236290370797396719235956642557026925566275820787118202399247747445125449282\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 1713408536894110516522969272885192173669900392782465197506312048399987681703463801235485042423756235640603447122066\n        , 0, 0, 0, 0, 0\n        , 1832973098578300992451600694419166481095710360972479322215712298699316162770343964433135566775684661337037799447857\n        , 0, 0\n        ]\n    }\n\n\/**\n * G12 multiplied by 6. Computed using py_ecc: `normalize(multiply(G12, 6))`.\n *\/\nG12_6P : G12Point\nG12_6P =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 3984640847924757144714972801294669751518204805083279115209564409785869025937099631985667805381121749661329977337231\n        , 0, 0, 0, 0, 0\n        , 2314522373438651017950322300652866396447889076475953394735913335923815351124264102732910312043710109696230300963340\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 3638085773299732811703058316322950283836045952826105333022656670096922749263292332009255347182392556648551235304444\n        , 0, 0, 0, 0, 0\n        , 839816652260065229377110122240619827065205829181829385830561226769366420386289987721906250441510775095951918797144\n        , 0, 0\n        ]\n    }\n\n\/**\n * G12 negated. Computed using py_ecc: `normalize(neg(G12))`.\n *\/\nG12_Negated : G12Point\nG12_Negated =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 0, 0, 0, 0, 0\n        , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882\n        , 0, 0, 0, 0, 0\n        , 2530003246008313436619321190568518957050005802350535323083204411198199749930993008942803721832196041551977634344055\n        , 0, 0\n        ]\n    }\n\n\/**\n * The result of G12 multiplied by BLS_MODULUS - 1.\n *\/\nG12_NEG_ONE : G12Point\nG12_NEG_ONE =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 0, 0, 0, 0, 0\n        , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882\n        , 0, 0, 0, 0, 0\n        , 2530003246008313436619321190568518957050005802350535323083204411198199749930993008942803721832196041551977634344055\n        , 0, 0\n        ]\n    }\n\n\/**\n * The result of G12 multiplied by BLS_MODULUS - 2.\n *\/\nG12_NEG_TWO : G12Point\nG12_NEG_TWO =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 3419974069068927546093595533691935972093267703063689549934039433172037728172434967174817854768758291501458544631891\n        , 0, 0, 0, 0, 0\n        , 3085702637220734738417436494616749403912215658780238013160080261412073281518532063392788241082272664317258671945021\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 3323635502175172055438049630502992469028910910047140622029592948100197707060894621654042125998352466817631684596242\n        , 0, 0, 0, 0, 0\n        , 3154592660005562171102138553734133841565768701654657785448033304889489633092638238253477214010900038363079737249918\n        , 0, 0\n        ]\n    }\n\n\/**\n * The result of G12 multiplied by BLS_MODULUS - 3.\n *\/\nG12_NEG_THREE : G12Point\nG12_NEG_THREE =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 2795155019138475430256695697248607867022196082692926850257941893956680503583886174445899854256891620515274933186478\n        , 0, 0, 0, 0, 0\n        , 3314282677642727520205697515437815240873236290370797396719235956642557026925566275820787118202399247747445125449282\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 2289001018327556876894820552850711982886982427156542687825746087724043968787374063207202586705259428397290825437721\n        , 0, 0, 0, 0, 0\n        , 2169436456643366400966189131316737675461172458966528563116345837424715487720493900009552062353331002700856473111930\n        , 0, 0\n        ]\n    }\n\n\/**\n * Verify that negation twice results in the same value.\n * ```repl\n * :prove gp_negation_correct`{2}\n * :prove gp_negation_correct`{12}\n * ```\n *\/\ngp_negation_correct : {n} (fin n, n >= 1) => GPPoint n -> Bit\nproperty gp_negation_correct a =\n    gp_negate (gp_negate a) == a\n","variant":"hybrid","set":"unsupervised"}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/Pairing.cry","filetype":"cry","content":"\/**\n * This module handles the BLS pairing operation and subfunctions.\n * @see https: *\/\nmodule Spec::BlsEC::Pairing where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::FQP\nimport Spec::BlsEC::G1\nimport Spec::BlsEC::GP\n\n\/**\n * Representation for 1.\n * @see https: *\/\nFQ12_ONE : Fq12\nFQ12_ONE = [1] # zero\n\n\/**\n * For each pair of G1, G2 points, run the pairing computation and\n *  compute the product. Finally, run the final exponentiate on the\n *  product and check that it is equal to the element \"one\" of Fq12.\n * @see https: * ```repl\n * :check pairing_check VALID_MULTI_PAIRING_POINTS == True\n * let good_pair = VALID_MULTI_PAIRING_POINTS@0\n * let (g1, g2) = VALID_MULTI_PAIRING_POINTS@1\n * let bad_g1 = g1_multi G1 (`(BLS_MODULUS) - 13)\n * let bad_pair = (bad_g1, g2)\n * :check pairing_check [good_pair, bad_pair] == False\n * ```\n *\/\npairing_check : {n} (fin n) => [n](G1Point, G2Point) -> Bit\npairing_check points = final ~==~ FQ12_ONE where\n    final = final_exponentiate prod\n    prod = foldl (~*~) FQ12_ONE [pairing q p False | (p, q) <- points]\n\n\/**\n * Cast a point in Fq to Fq12.\n * The x and y coordinates are simply the first coefficient with all other coefficients as zero.\n * @see https: * ```repl\n * let expX = [3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507,0,0,0,0,0,0,0,0,0,0,0]\n * let expY = [1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569,0,0,0,0,0,0,0,0,0,0,0]\n * let expected = { xCoeffs = expX, yCoeffs = expY }\n * :check cast_point_to_fq12 G1 == expected\n * ```\n *\/\ncast_point_to_fq12 : G1Point -> G12Point\ncast_point_to_fq12 p = {xCoeffs = newX, yCoeffs = newY} where\n    x = p.xCoord\n    y = p.yCoord\n    newX = [x] # zero\n    newY = [y] # zero\n\n\/**\n * Create a function representing the line between `p1` and `p2`,\n *  and evaluate it at `t`.\n * @see https: * ```repl\n * let one = G12\n * let two = g12_double G12\n * let three = g12_multi G12 3\n * let negone = g12_multi_optimized G12 (`(BLS_MODULUS)-1)\n * let negtwo = g12_multi_optimized G12 (`(BLS_MODULUS)-2)\n * let negthree = g12_multi_optimized G12 (`(BLS_MODULUS)-3)\n * :check linefunc one two one == zero\n * :check linefunc one two two == zero\n * :check linefunc one two three != zero\n * :check linefunc one two negthree == zero\n * :check linefunc one negone one == zero\n * :check linefunc one negone negone == zero\n * :check linefunc one negone two != zero\n * :check linefunc one one one == zero\n * :check linefunc one one two != zero\n * :check linefunc one one negtwo == zero\n * ```\n * Tests from: https: *\/\nlinefunc : G12Point -> G12Point -> G12Point -> Fq12\nlinefunc p1 p2 t =\n    if (p1 == G12_INFINITY) ||\n       (p2 == G12_INFINITY) ||\n       (t == G12_INFINITY) then \/\/ No points-at-infinity allowed\n        error \"Invalid input - no points-at-infinity allowed\"\n    else\n        if x1 != x2 then m1 ~*~ (xt ~-~ x1) ~-~ (yt ~-~ y1)\n         | y1 == y2 then m2 ~*~ (xt ~-~ x1) ~-~ (yt ~-~ y1)\n         else xt ~-~ x1\n    where\n        x1 = p1.xCoeffs\n        y1 = p1.yCoeffs\n        x2 = p2.xCoeffs\n        y2 = p2.yCoeffs\n        xt = t.xCoeffs\n        yt = t.yCoeffs\n        m1 = (y2 ~-~ y1) ~\/~ (x2 ~-~ x1)\n        m2 = 3 *~ (x1~^^2) ~\/~ (2 *~ y1)\n\n\/**\n * @see https: *\/\nate_loop_count : UInt64\nate_loop_count = 15132376222941642752\n\n\/**\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_pairing.py#L29\n *\/\nlog_ate_loop_count : Integer\nlog_ate_loop_count = 62\n\n\/**\n * Miller's algorithm that uses a double and add looping construct to compute the pairing.\n * If the final result (after the final exponentiation) is FQ12_ONE, then the pairing was successful.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_pairing.py#L84\n * ```repl\n * :check miller_loop (twist G2) (cast_point_to_fq12 G1) True == MILLER_LOOP_G2_G1_FQ12\n * ```\n * NOTE: this repl test is very, very slow (~2 minutes).\n *\/\nmiller_loop : G12Point -> G12Point -> Bit -> Fq12\nmiller_loop q p do_final_exponentiate =\n    if (q == G12_INFINITY) ||\n       (p == G12_INFINITY) then FQ12_ONE\n    else double_and_add q FQ12_ONE log_ate_loop_count\n    where\n        double_and_add : G12Point -> Fq12 -> Integer -> Fq12\n        double_and_add r f count =\n            if count < 0 then\n                if do_final_exponentiate then final_exponentiate f else f\n            else\n                if (ate_loop_count && (2^^count)) != 0 then\n                    double_and_add r'' f'' (count - 1)\n                else double_and_add r' f' (count - 1)\n            where\n                f' = f ~*~ f ~*~ (linefunc r r p)\n                r' = g12_double r\n                f'' = f' ~*~ (linefunc r' q p)\n                r'' = g12_add r' q\n\n\/**\n * Final exponentiation of the pairing algorithm.\n * https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_pairing.py#L116\n * The py_ecc \"field_modulus\" is Fq, and \"curve_order\" is the BLS_MODULUS.\n * ```repl\n * :check final_exponentiate G12_x == [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n * ```\n * NOTE: this repl test is very slow (~45 seconds).\n *\/\nfinal_exponentiate : Fq12 -> Fq12\nfinal_exponentiate p = p~^^((`(Fq)^^12 - 1) \/ `(BLS_MODULUS))\n\n\/**\n * Pairing computation.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_pairing.py#L108\n * The tests in `miller_loop` and `pairing_check` cover this function.\n *\/\npairing : G2Point -> G1Point -> Bit -> Fq12\npairing q p do_final_exponentiate =\n    if ~(g2_is_valid_point q) then\n        error \"Invalid input - point Q is not on the correct curve\"\n     | ~(g1_is_valid_point p) then\n        error \"Invalid input - point P is not on the correct curves\"\n    else miller_loop (twist q) (cast_point_to_fq12 p) do_final_exponentiate\n\n\/**\n * Computed `miller_loop(twist(normalize(G2)), cast_point_to_fq12(G1))` with py_ecc.\n * NOTE: this is not a valid KZG proof, it is just a test value.\n *\/\nMILLER_LOOP_G2_G1_FQ12 : Fq12\nMILLER_LOOP_G2_G1_FQ12 =\n    [ 3408834164464458755751340723502736743445402614640994055433339214424916442641449510670327077303074893591740399366532\n    , 1017299873256115394687936133146817339783508925356207904663165117501336940438300180831508525168135575931758510829235\n    , 1919447955347661378578718469488414822573562393353397544098339472673901193098010131520945815709482515519580400649694\n    , 233557331756520805040932826416017142246700002714928636467514104620558679338483625829873520553081791155104026612174\n    , 2882199334237819327910933128503231887000342950792587449681715803095618652567681747054312179958427092970985872417068\n    , 579878855790610229145575079003483905368886712027403088810647643659132674704592975818766405092658613973478871626949\n    , 3268798540077874559188095304926415053902298079662269128631117894259354335713488241073281881110999874366368799440511\n    , 2688711983546324406847903726099677850388169649284572370749691792743294691894680263880362424577638309433508620982332\n    , 3520140447471844017044610248175793726488927385800919015247604269617056365166670232096113218155158979455637700602719\n    , 1555267885602801620621747613743921378408444002839854792606782732724136830563310004098024452104661167182680744848589\n    , 2626389147790168154036854297373352480470342009417426750876875476996308393122833154115295241935326582225976246741447\n    , 873321072950766150592434764742436722571574260472569072177205897167854308426485977134306337249021436737462538398830\n    ]\n\n\/**\n * Randomly generated valid proof pair.\n *\/\nVALID_MULTI_PAIRING_POINTS : [2](G1Point, G2Point)\nVALID_MULTI_PAIRING_POINTS = [\n ({xCoord = 3942577509585645813112967582905379780757916939878725808374136412369021134738667198410219765812816597637590999762994,\n   yCoord = 1088203199345877024923249081294179597401216953118814114064722100932810217381059447963463973664408120385097692508887},\n  {xCoeffs = [352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160,\n    3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758],\n   yCoeffs = [2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882,\n    3074855889729334937670587859959866275799142626485414915307030157330054773488162299461738339401058098462460928340205]}),\n ({xCoord = 3169842563198574659482326102479611290543931141198734323136036543093361601969542502223164030575983014844841304587037,\n   yCoord = 2824376326786724983588666803486546854391198626677433522546039002353746810155815190686926212247090141910905313411994},\n  {xCoeffs = [3394380795309742284085231944467807101526256495961930479404919454683737253440393636117553364774847296670461098299470,\n    3662689612798884582269339769986716851963132127553475998239595135217324880631479103766927470793514208588880068422260],\n   yCoeffs = [2578225059880913843555694372733822992497931377620121352151046101281018929119028392378298954064169396102755595303745,\n    2741696937477620340841025265339742110829389137752838655176100907337011149212882755711342068822769734096710415902962]})\n ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/Poly.cry","filetype":"cry","content":"\/**\n * This module contains polynomial utility functions for polynomial extension fields.\n *\/\nmodule Spec::BlsEC::Poly where\n\nimport Common::ModArith\nimport Spec::BlsEC::Field\n\n\/**\n * Extended euclidean algorithm for polynomials.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L302\n * ```repl\n * let expected_real = 1223514866584400226619392018844575446040489926980124362465220784014275923982521236729115905530146470033177964357563\n * let expected_imag = 3495453419063574139925455551631318136524378768480668459768684498547208492074727172949503320416899422709399085629096\n * let expected = [expected_real, expected_imag]\n * let low = [352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160, 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758, 0]\n * let high = [1, 0, 1]\n * :check poly_extended_euclidean [1, 0, 0] low [0, 0, 0] high == expected\n * ```\n *\/\npoly_extended_euclidean : {n} (fin n, n >= 2) => [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n-1](Z Fq)\npoly_extended_euclidean lm low hm high = take`{n-1} results where\n    (lm', low') = inv_while lm low hm high\n    results = [div_mod lmi (low'@0) | lmi <- lm']\n\n\/**\n * Implements the inner while look of the inverse function.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L311\n * ```repl\n * let expected_lm = [1, 3997412857189233618731963627508854230078445114494716000095659671964648842284302098129323323820452066022319385239514, 0]\n * let expected_low = [3203368238181144282106772347113517508010041690876866219296399795152074745917376658324329538654856903029901947573594, 0, 0]\n * let expected = (expected_lm, expected_low)\n * let low = [352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160, 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758, 0]\n * let high = [1, 0, 1]\n * :check inv_while [1, 0, 0] low [0, 0, 0] high == expected\n * ```\n *\/\ninv_while : {n} (fin n, n >= 1) => [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> ([n](Z Fq), [n](Z Fq))\ninv_while lm low hm high =\n    if (deg low) > 0 then\n        inv_while nm new lm low\n    else (lm, low)\n    where\n        r = poly_rounded_div high low\n        (nm, new) = inv_nested_for lm low hm high r\n\/**\n * The `inv_nested_for` computation.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L311\n * To see why this function and the following subfunctions work, I'll walk through the\n *  pseudo code and rational. Note, the computation for `nm` and `new` are the same,\n *  the first just uses `lm` and the latter `low`. So we'll just work the computation\n *  with one of them, `nm`.\n *\n * Here is our starting code (see link above) with degree 2, and dropping the `new`.\n * for i = 0..2\n *     for j = 2..0\n *         nm[i + j] -= lm[i] * int(r[j])\n *\n * For each element of `nm`, we subtract one or more multiplications of `lm` and `r`.\n *\n * Let's replace the `i + j` indexing into `nm` with `k`.\n * So now we have this:\n *  for k=0..2:\n *      for i=0..k, j=k..0\n *          nm[k] -= lm[i] * r[j]\n *\n * We have `k` which iterates through the elements of `nm`. For each `k`, `i`\n *  always starts at 0 and increments while `i <= k` for each next multiplication\n *  that we need to subtract from the original `nm[k]` element. For each `k`, the\n *  `j` index does the opposite --- it starts a `k` and then decrements down to 0.\n *\n * So lets think about the pairs of indices `i`, `j` that we care about:\n *  when k=0 then [(i=0, j=0)]\n *  when k=1 then [(i=1, j=0), (i=0, j=1)]\n *  when k=2 then [(i=2, j=0), (i=1, j=1), (i=0, j=2)]\n *\n * This kind of computation lends itself to a fold per `k`. But Cryptol\n *  needs us to use a constant sized list of indices, not variable (in `k+1`).\n *\n * To do this, we need some what to represent of pair of indices that shouldn't\n *  actually be used for the subtraction needed. We'll use (-1, -1) for simplicity.\n *\n * Now we have:\n *  when k=0 then [(i=0, j=0), (i=-1, j=-1), (i=-1, j=-1)]\n *  when k=1 then [(i=1, j=0), (i=0, j=1), (i=-1, j=-1)]\n *  when k=2 then [(i=2, j=0), (i=1, j=1), (i=0, j=2)]\n *\n * In summary, we will do the following:\n * 1) Generate the list of indices, including the placeholder (-1, -1) indices\n *  - This is what function`inv_nested_for_index_pairs` does\n * 2) Determine which indices result in a product or zero, stored in a list\n *  - This is what mapping over `inv_nested_for_multi` does\n * 3) Subtract each value in that list from our original element\n *  - This is what `inv_nested_for_compute_value`\n * 4) Do this for both `nm` and `new`\n *  - This is the body of `inv_nested_for`\n *\/\ninv_nested_for : {n} (fin n, n >= 1) => [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> ([n](Z Fq), [n](Z Fq))\ninv_nested_for lm low nm new r = (nm', new') where\n    nm' = [inv_nested_for_compute_value nmi i lm r | nmi <- nm | i <- [0..(n-1)]]\n    new' = [inv_nested_for_compute_value newi i low r | newi <- new | i <- [0..(n-1)]]\n\n\/**\n * This function handles the inner computation of the `inv_nested_for` for each element of each list.\n * ```repl\n * :check inv_nested_for_compute_value 13 0 [3, 5] [2, 7] == (13 - 3*2)\n * ```\n *\/\ninv_nested_for_compute_value : {n} (fin n, n >= 1) => Z Fq -> Integer -> [n](Z Fq) -> [n](Z Fq) -> Z Fq\ninv_nested_for_compute_value ni i l r =\n    foldl (-) ni (map (poly_pair_multi l r) (inv_nested_for_index_pairs`{n} i))\n\n\/**\n * This function performs pair-wise multiplication between two polynomials.\n * ```repl\n * :check poly_pair_multi [13] [13] (-1, 0) == 0\n * :check poly_pair_multi [13] [13] (0, -1) == 0\n * :check poly_pair_multi [13] [13] (-1, -1) == 0\n * :check poly_pair_multi [(2 : Z Fq), (3 : Z Fq)] [(5 : Z Fq), (7 : Z Fq)] (0, 1) == 14\n * ```\n *\/\npoly_pair_multi : {n} (fin n, n >= 1) => [n](Z Fq) -> [n](Z Fq) -> (Integer, Integer) -> Z Fq\npoly_pair_multi l r (i, j) =\n    if (i == -1) || (j == -1) then 0\n    else (l@i) * (r@j)\n\n\/**\n * Computes all combinations of (i,j) pairs where i + j == k.\n * We use the pair (-1, -1) to indicate no computation needed to be performed.\n * ```repl\n * :check inv_nested_for_index_pairs`{3} 0 == [(0, 0), (-1, -1), (-1, -1)]\n * :check inv_nested_for_index_pairs`{3} 1 == [(1, 0), (0, 1), (-1, -1)]\n * :check inv_nested_for_index_pairs`{3} 2 == [(2, 0), (1, 1), (0, 2)]\n * ```\n *\/\ninv_nested_for_index_pairs : {n} (fin n, n >= 1) => Integer -> [n](Integer, Integer)\ninv_nested_for_index_pairs k =\n    [if j <= k then (k-i, j) else (-1,-1) | i <- [0..(n-1)] | j <- [0..(n-1)]]\n\n\/**\n * Compute the degree of the polynomial.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/utils.py#L43\n * ```repl\n * :check deg [0, 0, 0] == 0\n * :check deg [1, 0, 0] == 0\n * :check deg [0, 1, 0] == 1\n * :check deg [0, 0, 1] == 2\n * ```\n *\/\ndeg : {n} (fin n, n >= 1) => [n](Z Fq) -> Integer\ndeg p = compute_d (`(n)-1) where\n    compute_d : Integer -> Integer\n    compute_d d =\n        if ((p@d) == 0) && (d > 0) then\n            compute_d (d - 1)\n        else d\n\n\/**\n * Division of two polynomials.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/utils.py#L50\n * ```repl\n * let high = [1, 0, 1]\n * :check poly_rounded_div high high == [1, 0, 0]\n * let low = [352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160, 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758, 0]\n * let expected = [0, 3760942702196338589502826385415833209682098933908451272344533612462792778154520066649324657897802310897411427023085, 0]\n * :check poly_rounded_div high low == expected\n *\/\npoly_rounded_div : {n} (fin n, n >= 1) => [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq)\npoly_rounded_div a b = compute_outer_loop o0 temp0 start where\n    dega = deg a\n    degb = deg b\n    o0 = (zero:[n](Z Fq))\n    temp0 = [x | x <- a]\n    start = dega - degb\n\n    compute_outer_loop : [n](Z Fq) -> [n](Z Fq) -> Integer -> [n](Z Fq)\n    compute_outer_loop o temp i =\n        if i < 0 then o\n        else compute_outer_loop o' temp' i'\n        where\n            o' = [if j == i then (o@j) + oi' else (o@j) | j <- [0..(n-1)]]\n            oi' = div_mod (temp@(degb + i)) (b@degb)\n            temp' = compute_temp' temp 0\n            i' = i - 1\n\n            compute_temp' : [n](Z Fq) -> Integer -> [n](Z Fq)\n            compute_temp' t c =\n                if c < (degb + 1) then compute_temp' updated_temp (c+1)\n                else t\n                where\n                    updated_temp = [if j == (c + i) then (t@(c + i)) - (o@c) else (t@c) | j <- [0..(n-1)]]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab1\/csearch_nobug.cry","filetype":"cry","content":"\/\/ Binary search in cryptol - bug is eliminated\n\nbsearch : {n} (fin n, 8 >= width n) => ([8],[n][8]) -> [8]\nbsearch (key, lst) = search (0, (length lst)-1, w)\n  where \n    w = length lst\n    \/\/ The function \"search\" is not symbolically terminating,\n    \/\/ so we use an \"extra\" recursion counter (c) for termination purposes\n    \/\/ Note that this is only needed when doing the proof..\n    search (low, high, c) =\n       if (c <= 0) \\\/ (low > high) \\\/ (high > w-1) then -1\n       else if midVal < key then search (mid+1, high, c-1)\n       else if midVal > key then search (low, mid-1, c-1)\n       else mid\n       where  \n          midVal = lst @ mid\n          mid = computeMid (low, high)\n\ncomputeMid (low, high) = (low + (high-low) \/ 2)\n\n\/\/ Returns the first location of a given key in the given list\n\/\/ or -1 if the key is not in the list\nrefSearchIdx (key, lst) = s!0\n   where\n     s = [-1]#[ if (key == x \/\\ h == -1) then c\n         else h | x <- lst |  h <- s | c <- [0...]]\n\nlst3 = [0,   2,   3,   5,   6,   8,   9,  10,  11,  12,  13,  14,  16,  18,\n       20,  21,  22,  23,  24,  25,  26,  27,  28,  30,  31,  32,  33,  34,\n       35,  36,  37,  39,  40,  41,  32,  43,  44,  45,  46,  47,  49,  50,\n       51,  52,  53,  54,  56,  58,  59,  60,  61,  62,  63,  65,  66,  67,\n       68,  69,  70,  71,  72,  73,  74,  76,  77,  78,  79,  80,  81,  82,\n       84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\n       98,  99, 101, 102, 103, 104, 105, 106, 107, 108, 110, 112, 113, 114,\n      116, 117, 119, 120, 121, 122, 124, 125, 126, 127, 129, 130, 131, 132,\n      133, 134, 135, 136, 138, 139, 141, 143, 144, 145, 147, 148, 149, 150,\n      152, 153, 155, 156, 157, 158, 159, 160, 162, 163, 164, 166, 167, 168,\n      169, 170, 172, 174, 175, 176, 177, 178, 179, 181, 182, 183, 184, 185,\n      187, 188, 189, 190, 191, 192, 197, 198, 199, 200, 201, 202, 203, 204,\n      206, 207, 208, 209, 210, 211, 213, 214, 215, 216, 218, 220, 221, 222,\n      223, 224, 226, 228, 229, 230, 231, 232, 234, 235, 236, 237, 238, 239,\n      240, 241, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 255]:[210][9]\n\n\/\/ bsearch and refSearch are equivalent when the input is\n\/\/ only increasing in sequence, so recognize such sequences:\nonlyIncreasing lst = pairComps == ~zero\n  where pairComps = [ x < x' | x  <- [0] # lst | x' <- lst ]\n\n\/\/ The theorem holds, establishing correctness.\nbsearchOK : [8] -> [130][8] -> Bit\nproperty bsearchOK key lst =\n  if onlyIncreasing (lst) \/\\ 0 <= key\n  then bsearch (key, lst) == refSearchIdx (key, lst)\n  else True\n\n\/\/ Cryptol> :l csearch_bug.cry\n\/\/ Loading module Cryptol\n\/\/ Loading module Main\n\/\/ Main>  :prove bsearchOK\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 23.144s, using \"Z3\")\n\/\/ Main> \n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab1\/mid.cry","filetype":"cry","content":"midA : [8] -> [8] -> [8]\nmidA low high = (low+high)\/2\n\nmidS : [8] -> [8] -> [8]\nmidS low high = low + (high - low)\/2\n\n\/\/ This theorem shows that as long as high and low are no greater than 255,\n\/\/ the sum of low +(high-low)\/2 is never greater than 255\nmidS_is_safe : [9] -> [9] -> Bit\nproperty midS_is_safe low high\n   = ~(low < 256 \/\\ high < 256 \/\\ low <= high) \\\/ \n      ((high-low) < 256) \/\\ ((high-low)\/2 < (256 - low))\n\n\/\/ This theorem shows that the midpoint calculation using (low+high)\/2\n\/\/ differs from the calculation using low+(high-low)\/2 by at most 1\n\/\/ unless high is 255 in which case they are equal.\n\nmidpointsAreClose : [9] -> [9] -> Bit\nproperty midpointsAreClose low high\n   = (~(0 <= low \/\\ low <= high \/\\ high < 255)  \\\/\n       ((safeMid <= averageMid \/\\ averageMid <= safeMid+1) \\\/\n        (averageMid <= safeMid \/\\ safeMid <= averageMid+1)))\n     \/\\\n     (~(low <= high \/\\ high == 255) \\\/ (averageMid == safeMid))\n  where\n     averageMid = (low+high)\/2         \/\/ Average of low and high as midpoint\n     safeMid    = (low+(high-low)\/2)   \/\/ Safe midpoint given low and high\n\n\/\/ Cryptol> :l mid.cry\n\/\/ Loading module Cryptol\n\/\/ Loading module Main\n\/\/ Main> :prove midpointsAreClose\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.030s, using \"Z3\")\n\/\/ Main> \n","variant":"hybrid","set":"supervised"}
{"filename":"SAW-course\/src\/lab6A\/saf.cry","filetype":"cry","content":"\/\/:safe usaf (unsafe - no checks for out of bounds errors are made)\nusaf: [1][8] -> [10][8] -> [1][8]\nusaf a b = [(b@(a@0))]\n\n\/\/:safe saf (safe - checks for out of bounds are made)\nsaf : [1][8] -> [10][8] -> [1][8]\nsaf a b = if a@0 > 9 then [0]\n          else if a@0 < 0 then [0]\n\t\t\t else [(b@(a@0))]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab6A\/zero.cry","filetype":"cry","content":"\/\/:safe z1  (unsafe - divide by zero error if b is 0)\nusaf : [8] -> [8] -> [8]\nusaf a b = (a\/b):[8]\n\nsaf : [8] -> [8] -> [8]\nsaf a b = if b == 0 then 1 else (a\/b)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab3E\/elevator.cry","filetype":"cry","content":"type State = {  cb : [4][12],  \/\/ call buttons - 1\/floor, 4 total\n               cbl : [4][12],  \/\/ call button lights - 1\/floor, 4 total\n                eb : [4][12],  \/\/ elevator buttons - 1\/floor, 4 total\n\t\t\t\t\tebl : [4][12],  \/\/ elevator button lights - 1\/button, 4 total\n\t\t\t\t\tids : [12],     \/\/ elevator door sensor\n\t\t\t\t\tods : [4][12],  \/\/ outside door sensor - 1\/floor, 4 total\n\t\t\t\t\tmtr : [12],     \/\/ motor direction, in motion\n\t\t\t\t\t fs : [4][12],  \/\/ floor sensor - 1\/floor, 4 total\n\t\t\t\t\t pe : [12] }    \/\/ person(s) in elevator\n\ninitState : State\ninitState = {  cb = [0,0,0,0], \/\/ no call buttons pressed\n              cbl = [0,0,0,0], \/\/ all call button lights are off\n\t\t\t\t   eb = [0,0,0,0], \/\/ no elevator buttons pressed\n\t\t\t\t  ebl = [0,0,0,0], \/\/ elevator button lights are off\n\t\t\t\t  ids = 0,         \/\/ elevator door is open\n\t\t\t\t  ods = [0,1,1,1], \/\/ outside floor door is open on 1st floor only\n\t\t\t\t  mtr = 0,         \/\/ elevator is stationary\n\t\t\t\t   fs = [1,0,0,0], \/\/ elevator is on 1st floor\n\t\t\t\t\tpe = 0 }        \/\/ no one is in the elevator\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab3B\/alt.cry","filetype":"cry","content":"module alt where\nimport DES\n\n\/\/ Returns a sequence of 1s iff all numbers in (expandKey key) are the same\nfunc x = z\n  where\n    z = [ a == b | a <- x | b <- drop `{1} x ]\n\nproperty WeakKeys key = (func (expandKey key)) == ~zero\n\n\/\/ Then, in cryptol:\n\/\/ alt> :s satNum=all\n\/\/ alt> :sat WeakKeys\n\nWK : [64] -> [64] -> Bit\nproperty WK key pt = (DES.encrypt key (DES.encrypt key pt)) == pt\n\/\/ alt> :s prover=boolector\n\/\/ alt> :prove WK\n\/\/ Counterexample\n\/\/ WK 0xbe38506e28f20628 0x67ff7750c8ef5f99 = False\n\/\/ (Total Elapsed Time: 2.184s, using \"Boolector\")\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab3B\/solution.cry","filetype":"cry","content":"module solution where\nimport DES\n\n\/\/ Returns a sequence of 1s iff all numbers in (expandKey key) are the same\nfunc key = z\n  where\n    z = [ x == y | x <- (expandKey key) | y <- (drop `{1} (expandKey key)) ]\n     \n\/\/ Exercise 1: weak keys\nproperty WeakKeys key = (func key) == ~zero\n\n\/\/ Then, in cryptol:\n\/\/ solution> :s satNum=all\n\/\/ solution> :sat WeakKeys\n\n\/\/ Exercise 2:\n\/\/ Encrypting twice should not produce original plaintext\nWK : [64] -> [64] -> Bit\nproperty WK key pt = (DES.encrypt key (DES.encrypt key pt)) == pt\n\/\/ solution> :s prover=boolector\n\/\/ solution> :prove WK\n\/\/ Counterexample\n\/\/ WK 0xbe38506e28f20628 0x67ff7750c8ef5f99 = False\n\/\/ (Total Elapsed Time: 2.180s, using \"Boolector\")\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab3C\/sn74as181a.cry","filetype":"cry","content":"module sn74as181a where\n\n\/\/ Input: a and b are sequences of True,False\n\/\/ Output: xor of each a,b pair until the end of the\n\/\/ shortest sequence is reached.  Below, both sequences\n\/\/ will be of the same length.\n\/\/ Example:  v_xor [True, False, True, False]\n\/\/                 [True, True, False, False]\n\/\/ 0b0110\nv_xor a b = [ x^y  | x <- a | y <- b ]\n\n\/\/ Input: c is a Bit, a and b are sequences of True,False\n\/\/ Output: sequence of Bits where each Bit is the result\n\/\/ of adding 2 input bits plus a carry from the previous\n\/\/ stage.  The last Bit in the sequence is the last carry\n\/\/ bit.\n\/\/ Example: v_adder True [False,True,False,True]\n\/\/                       [False,True,True,True]\n\/\/ 0b10011\nv_adder c a b = drop `{1} [ w.0 | w <- z ]\n  where\n    z = [(False, c)]#\n        [ (x^y^q.1, (x\/\\y)\\\/(x\/\\q.1)\\\/(y\/\\q.1))\n        | x <-a#[False] | y <- b#[False] | q <- z ]\n\n\/\/ On Page 4 see four occurrences of f74171_q0\n\/\/ if s3 and s2 are T this is  ~((a \/\\ b) \\\/ (a \/\\ ~b)) ->\n\/\/    if a is False then True else False -> ~a\n\/\/ if s3 and s2 are False this is True\n\/\/ if s3 is True and s2 is False this is ~(a \/\\ b) \n\/\/ if s3 is False and s2 is True this is ~(a \/\\ ~b)\n\/\/ (f74181_q0 True True True True True True) -> False\nf74181_q0 a b s0 s1 s2 s3 = ~((b \/\\ s3 \/\\ a) \\\/ (a \/\\ s2 \/\\ ~b))\n\n\/\/ On Page 4 see four occurrences of f74171_q1\n\/\/ if s1 and s0 are True this is ~(~b \\\/ a \\\/ b) = False\n\/\/ if s1 and s0 are False this is ~a\n\/\/ if s1 is True and s0 is False this is ~(~b \\\/ a)\n\/\/ if s1 is False and s0 is True this is ~(a \\\/ b)\n\/\/ (f74181_q1 True True True True True True) -> False\nf74181_q1 a b s0 s1 s2 s3 = ~((~b \/\\ s1) \\\/ (s0 \/\\ b) \\\/ a)\n\nf74181_f0 c a0 b0 m s0 s1 s2 s3 = out\n  where\n    m_neg = ~m\n    tmp = (f74181_q0 a0 b0 s0 s1 s2 s3) ^\n          (f74181_q1 a0 b0 s0 s1 s2 s3)\n    out = ~(c \/\\ m_neg) ^ tmp\n\nf74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3 = out\n  where\n    m_neg = ~m\n    tmp1 = (f74181_q0 a1 b1 s0 s1 s2 s3) ^\n            (f74181_q1 a1 b1 s0 s1 s2 s3)\n    tmp2 = ~((m_neg \/\\\n              (f74181_q1 a0 b0 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q0 a0 b0 s0 s1 s2 s3) \/\\\n              c))\n    out = tmp1 ^ tmp2\n\nf74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3 = out\n  where\n    m_neg = ~m\n    tmp1 = (f74181_q0 a2 b2 s0 s1 s2 s3) ^\n           (f74181_q1 a2 b2 s0 s1 s2 s3)\n    tmp2 = ~((m_neg \/\\\n              (f74181_q1 a1 b1 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n              (f74181_q1 a0 b0 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q0 a0 b0 s0 s1 s2 s3) \/\\\n              (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n              c))\n    out = tmp1 ^ tmp2\n\nf74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n    m_neg = ~m\n    tmp1 = (f74181_q1 a3 b3 s0 s1 s2 s3) ^\n           (f74181_q0 a3 b3 s0 s1 s2 s3)\n    tmp2 = ~((m_neg \/\\\n              (f74181_q1 a2 b2 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q1 a1 b1 s0 s1 s2 s3) \/\\\n              (f74181_q0 a2 b2 s0 s2 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q1 a0 b0 s0 s1 s2 s3) \/\\\n              (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n              (f74181_q0 a2 b2 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q0 a0 b0 s0 s1 s2 s3) \/\\\n              (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n              (f74181_q0 a2 b2 s0 s1 s2 s3) \/\\\n              c))\n    out = tmp1 ^ tmp2\n\nf74181_a_b c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n    out = ((f74181_f0 c a0 b0 m s0 s1 s2 s3) \/\\\n           (f74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3) \/\\\n           (f74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3) \/\\\n           (f74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3))\n\nf74181_prop c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n    out = ~((f74181_q0 a0 b0 s0 s1 s2 s3) \/\\\n            (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n            (f74181_q0 a2 b2 s0 s1 s2 s3) \/\\\n            (f74181_q0 a3 b3 s0 s1 s2 s3))\n\nf74181_gen c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n   out = ~(((f74181_q0 a3 b3 s0 s1 s2 s3) \/\\\n            (f74181_q0 a2 b2 s0 s1 s2 s3) \/\\\n            (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n            (f74181_q1 a0 b0 s0 s1 s2 s3)) \\\/\n           ((f74181_q0 a3 b3 s0 s1 s2 s3) \/\\\n            (f74181_q0 a2 b2 s0 s1 s2 s3) \/\\\n            (f74181_q1 a1 b1 s0 s1 s2 s3)) \\\/\n           ((f74181_q0 a3 b3 s0 s1 s2 s3) \/\\\n            (f74181_q1 a2 b2 s0 s1 s2 s3)) \\\/\n           (f74181_q1 a3 b3 s0 s1 s2 s3))\n\nf74181_cout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n    out = (~(f74181_gen c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)) \\\/\n          ((~(f74181_prop c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)) \/\\ c)\n\nf74181_sumout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 =\n   [(f74181_f0 c a0 b0 m s0 s1 s2 s3),\n    (f74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3),\n    (f74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3),\n    (f74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3),\n    (f74181_cout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)]\n\n\/\/ Functional specification\nf74181_spec c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 =\n   [f74181_f0 c a0 b0 m s0 s1 s2 s3,\n    f74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3,\n    f74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3,\n    f74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3,\n    f74181_cout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3,\n    f74181_prop c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3,\n    f74181_gen c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3,\n    f74181_a_b c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3]\n\n\/\/ Wiring diagram\nf74181_netlist c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 =\n  [f0,f1,f2,f3,cout,p,g,a_b]\n  where\n    w0 = ~m\n    w1 = ~b0\n    w2 = ~b1\n    w3 = ~b2\n    w4 = ~b3\n    w5 = a0\n    w6 = b0 \/\\ s0\n    w7 = s1 \/\\ w1\n    w8 = w1 \/\\ s2 \/\\ a0\n    w9 = a0 \/\\ s3 \/\\ b0\n    w10 = a1\n    w11 = b1 \/\\ s0\n    w12 = s1 \/\\ w2\n    w13 = w2 \/\\ s2 \/\\ a1\n    w14 = a1 \/\\ s3 \/\\ b1\n    w15 = a2\n    w16 = b2 \/\\ s0\n    w17 = s1 \/\\ w3\n    w18 = w3 \/\\ s2 \/\\ a2\n    w19 = a2 \/\\ s3 \/\\ b2\n    w20 = a3\n    w21 = b3 \/\\ s0\n    w22 = s1 \/\\ w4\n    w23 = w4 \/\\ s2 \/\\ a3\n    w24 = a3 \/\\ s3 \/\\ b3\n    w25 = ~(w5 \\\/ w6 \\\/ w7)\n    w26 = ~(w8 \\\/ w9)\n    w27 = ~(w10 \\\/ w11 \\\/ w12)\n    w28 = ~(w13 \\\/ w14)\n    w29 = ~(w15 \\\/ w16 \\\/ w17)\n    w30 = ~(w18 \\\/ w19)\n    w31 = ~(w20 \\\/ w21 \\\/ w22)\n    w32 = ~(w23 \\\/ w24)\n    w33 = (w25 ^ w26)\n    w34 = (w27 ^ w28)\n    w35 = (w29 ^ w30)\n    w36 = (w31 ^ w32)\n    w37 = ~(w0 \/\\ c)\n    w38 = w0 \/\\ w25\n    w39 = (w0 \/\\ w26 \/\\ c)\n    w40 = (w0 \/\\ w27)\n    w41 = (w0 \/\\ w25 \/\\ w28)\n    w42 = (w0 \/\\ w28 \/\\ w26 \/\\ c)\n    w43 = (w0 \/\\ w29)\n    w44 = (w0 \/\\ w27 \/\\ w30)\n    w45 = (w0 \/\\ w25 \/\\ w30 \/\\ w28)\n    w46 = (w0 \/\\ w30 \/\\ w28 \/\\ w26 \/\\ c)\n    w47 = ~(w26 \/\\ w28 \/\\ w30 \/\\ w32)\n    w48 = ~(c \/\\ w26 \/\\ w28 \/\\ w30 \/\\ w32)\n    w49 = (w25 \/\\ w28 \/\\ w30 \/\\ w32)\n    w50 = (w27 \/\\ w30 \/\\ w32)\n    w51 = (w29 \/\\ w32)\n    w52 = w31\n    w53 = w37\n    w54 = ~(w38 \\\/ w39)\n    w55 = ~(w40 \\\/ w41 \\\/ w42)\n    w56 = ~(w43 \\\/ w44 \\\/ w45 \\\/ w46)\n    w57 = ~(w49 \\\/ w50 \\\/ w51 \\\/ w52)\n    w58 = (w53 ^ w33)\n    w59 = (w54 ^ w34)\n    w60 = (w55 ^ w35)\n    w61 = (w56 ^ w36)\n    w62 = (~w48 \\\/ ~w57)\n    w63 = (w58 \/\\ w59 \/\\ w60 \/\\ w61)\n    f0 = w58\n    f1 = w59\n    f2 = w60\n    f3 = w61\n    a_b = w63\n    p = w47\n    cout = w62\n    g = w57\n\nv00 = f74181_netlist True False False True True False False\n                     False True True False False True True\n\nf74181_fout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = \n   [(f74181_f0 c a0 b0 m s0 s1 s2 s3),\n    (f74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3),\n    (f74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3),\n    (f74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)]\n\nproperty xorWorks c a0 a1 a2 a3 b0 b1 b2 b3 =\n   (f74181_fout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3) == (v_xor a b)\n     where\n       a = [a0,a1,a2,a3]\n       b = [b0,b1,b2,b3]\n       s0 = False\n       s1 = True\n       s2 = True\n       s3 = False\n       m = True\n\nproperty addingWorks c a0 a1 a2 a3 b0 b1 b2 b3 =\n         [out0,out1,out2,out3,cout] == (v_adder c a b)\n  where\n    a = [a0,a1,a2,a3];\n\t b = [b0,b1,b2,b3]\n    s0 = True\n    s1 = False\n    s2 = False\n    s3 = True\n    m = False\n    output = (f74181_spec (~c) a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)\n    out0 = output@0\n    out1 = output@1\n    out2 = output@2\n    out3 = output@3\n    out4 = output@4\n    cout = ~out4\n\nproperty itWorks c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 =\n    (f74181_spec c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3) ==\n    (f74181_netlist c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)\n  where\n    a = [a0,a1,a2,a3]\n    b = [b0,b1,b2,b3]\n\n\/\/ Cryptol> :l sn74as181a.cry\n\/\/ Main> :prove xorWorks\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.011s, using \"Z3\")\n\/\/ Main> :prove addingWorks\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.019s, using \"Z3\")\n\/\/ Main> :prove itWorks\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.023s, using \"Z3\")","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab3C\/f74181_tests.cry","filetype":"cry","content":"module f74181_tests where\nimport sn74as181a\n\nlogicStuff a0 a1 a2 a3 b0 b1 b2 b3 s0 s1 s2 s3 = \n  if s == 0 then ~(a) else\n  if s == 1 then ~(a || b) else\n  if s == 2 then (~a && b) else\n  if s == 3 then 0 else\n  if s == 4 then ~(a && b) else\n  if s == 5 then ~b else\n  if s == 6 then (a ^ b) else\n  if s == 7 then a && ~b else\n  if s == 8 then ~a || b else\n  if s == 9 then ~(a ^ b) else\n  if s == 10 then b else\n  if s == 11 then a && b else\n  if s == 12 then 15 else\n  if s == 13 then a || ~b else\n  if s == 14 then a || b else a\n    where\n      a = [a0,a1,a2,a3]:[4];\n\t   b = [b0,b1,b2,b3]:[4];\n\t   s = [s3,s2,s1,s0]:[4]\n\nproperty logicStuffWorks a0 a1 a2 a3 b0 b1 b2 b3 s0 s1 s2 s3 =\n    (logicStuff a0 a1 a2 a3 b0 b1 b2 b3 s0 s1 s2 s3) ==\n    (f74181_spec True a0 a1 a2 a3 b0 b1 b2 b3 True s0 s1 s2 s3)@@[0,1,2,3]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab3D\/legato.cry","filetype":"cry","content":"\/* An encoding and correctness proof of Legato's multiplier in Cryptol\n\n   For details: \n     http:\/\/www.cs.utexas.edu\/~moore\/acl2\/workshop-2004\/contrib\/legato\/\n\t  Weakest-Preconditions-Report.pdf\n\n   Legato's challenge, as apparently referred to in ACL2 circles, is\n   to prove a deep-embedding of Legato's algorithm correct with respect\n   to a Mostek simulator coded in ACL2. We do *not* attempt to solve\n   Legato's challenge in Cryptol. We merely code and prove that Legato's\n   multiplier is correct.\n*\/\n\n\/* Here's Legato's algorithm, as coded in Mostek assembly\n\n step01:       LDX #8         ; load X immediate with the integer 8\n step02:       LDA #0         ; load A immediate with the integer 0 \n step03:       CLC            ; set C to 0\n step04: LOOP  ROR F1         ; rotate F1 right circular through C \n step05:       BCC ZCOEF      ; branch to ZCOEF if C = 0 \n step06:       CLC            ; set C to 0 \n step07:       ADC F2         ; set A to A+F2+C and C to the carry \n step08: ZCOEF ROR A          ; rotate A right circular through C \n step09:       ROR LOW        ; rotate LOW right circular through C \n step10:       DEX            ; set X to X-1 \n step11:       BNE LOOP       ; branch to LOOP if Z = 0 \n\nNote that apparently the CLC in step3 was later added by Warren Hunt; the\noriginal spec did not include this statement. However, without this\naddition, the algorithm does not work correctly for all starting states,\nso we adopt this change as well.\n*\/\n\n\/\/ An abstraction of the Mostek state; only parts relevant\n\/\/ to the Legato's multiplier are modeled for simplicity\ntype State = ([8] \/\/ F1\n             ,[8] \/\/ F2\n             ,[8] \/\/ A\n             ,[8] \/\/ X\n             ,[8]              ,Bit \/\/ C (Carry)\n             ,Bit \/\/ Z (Zero)\n             )\n\n\/\/ Our encoding of Legato's algorithm follows the original spec quite closely\n\/\/ in spirit, albeit shallowly embedding it in Cryptol. In particular\n\/\/ each line in the program becomes a state transformer.\n\n\/\/ Each line modifies the state and passes the control\n\/\/ to the next. Note that the next instruction is dynamically\n\/\/ chosen for the jump instructions\n\n\/\/ step01: LDX #8; load X immediate with the integer 8 \nstep01 : State -> State\nstep01 (f1, f2, a, _, l, c, z) = step02 (f1, f2, a, 8, l, c, z)\n\n\/\/ step02: LDA #0; load A immediate with the integer 0 \nstep02 : State -> State\nstep02 (f1, f2, _, x, l, c, z) = step03 (f1, f2, 0, x, l, c, z)\n\n\/\/ step03: CLC; set C to 0\nstep03 : State -> State\nstep03 (f1, f2, a, x, l, _, z) = step04 (f1, f2, a, x, l, False, z)\n\n\/\/ step04: LOOP  ROR F1; rotate F1 right circular through C \nstep04 : State -> State\nstep04 (f1, f2, a, x, l, c, z) = step05 (f1', f2, a, x, l, b0, z)\n  where \n    [b7,b6,b5,b4,b3,b2,b1,b0] = f1 \/\/ LSB is on the right\n    f1' = [c,b7,b6,b5,b4,b3,b2,b1] \/\/ ROR; \n\n\/\/ step05 : BCC ZCOEF; branch to ZCOEF if C = 0 \n\/\/ ZCOEF is step8 in our encoding\nstep05 : State -> State\nstep05 (f1, f2, a, x, l, c, z)\n  = if (c == 0)\n         then step08 (f1, f2, a, x, l, c, z)\n         else step06 (f1, f2, a, x, l, c, z)   \/\/ step06: CLC; set C to 0\nstep06 : State -> State\nstep06 (f1, f2, a, x, l, _, z) = step07 (f1, f2, a, x, l, False, z)\n\n\/\/ step07: ADC F2; set A to A+F2+C and C to the carry\nstep07 : State -> State\nstep07 (f1, f2, a, x, l, c, z) = step08 (f1, f2, a', x, l, c', z')\n  where \n    a' = a + f2 + (if c then (1:[8]) else (0:[8]))\n    \/\/ Was there a carry? Check that \"real\" result is larger than 255\n    \/\/ Note that we need at most 9 bits for this addition\n    a'Large : [9]\n    a'Large = (zero # a) + (zero # f2) + (if c then (1:[9]) else (0:[9]))\n    c' = a'Large > (255:[9])\n    \/\/ set the zero flag\n    z' = a' == 0\n\n\/\/ step08 : ZCOEF ROR A; rotate A right circular through C \nstep08 : State -> State\nstep08 (f1, f2, a, x, l, c, z) = step09 (f1, f2, a', x, l, a0, z)\n  where \n    [a7,a6,a5,a4,a3,a2,a1,a0] = a \/\/ LSB is on the right\n    a' = [c,a7,a6,a5,a4,a3,a2,a1] \/\/ ROR; result is the right rotation\n\n\/\/ step09 : ROR LOW; rotate LOW right circular through C \nstep09 : State -> State\nstep09 (f1, f2, a, x, l, c, z) = step10 (f1, f2, a, x, l', l0, z)\n  where \n    [l7,l6,l5,l4,l3,l2,l1,l0] = l \/\/ LSB is on the right\n    l' = [c,l7,l6,l5,l4,l3,l2,l1] \/\/ ROR; result is the right rotation\n\n\/\/ step10: DEX; set X to X-1\nstep10 : State -> State\nstep10 (f1, f2, a, x, l, c, z) = step11 (f1, f2, a, x', l, c, x'==0)\n  where x' = x-1\n\n\/\/ step11: BNE LOOP; branch to LOOP if Z = 0 \n\/\/ LOOP is step04 in our encoding\nstep11 : State -> State\nstep11 (f1, f2, a, x, l, c, z)\n  = if (z == 0)\n       then step04 (f1, f2, a, x, l, c, z)\n       else (f1, f2, a, x, l, c, z)        \/\/ legato: given two 8 bit arguments f1 and f2, return 8 bit\n\/\/ results hi and lo, s.t. f1 * f2 = hi * 256 + lo\n\/\/ We take the initial state as an argument; i.e., the\n\/\/ algorithm will work regardless of the state of the machine\nlegato : ([8], [8], State) -> ([8], [8])\nlegato (f1, f2, st) = (hi, lo)\n  where \n    \/\/ get the relevant parts to construct the starting state\n    (_, _, A, X, LOW, C, Z) = st\n    \/\/ Run legato multiplier; final A is hi; and final LOW is low\n    (_, _, hi, _, lo, _, _) = step01 (f1, f2, A, X, LOW, C, Z)\n\n\/\/ State the correctness of the algorithm\n\/\/ Z3 proves this in about 1.5 minutes\n\/\/ Note that the search space has 2^58 bits in this case\nmultiplyIsCorrect : [8] -> [8] -> State -> Bit\nproperty multiplyIsCorrect x y st =\n  ((x*y == lo) &&\n  (((((zero#x):[16])*((zero#y):[16]))\/256) == ((zero#hi):[16])))\n    where\n      (hi, lo) = legato(x,y,st)\n\n\/\/ cryptol> :l legato.cry\n\/\/ legato> :s prover=z3\n\/\/ legato> :prove multiplyIsCorrect\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 1m:36.607s, using \"Z3\")\n\n","variant":"hybrid","set":"holdout"}
{"filename":"SAW-course\/src\/lab2A\/examples.cry","filetype":"cry","content":"res00 = 567 + 111 res01 = 567 - 111 res02 = 111 - 567 res03 = 567 * 111 res04 = 567 \/ 111 res05 = 567 % 111 res06 = 567 ^^ 11 res07 = (ratio 7 2) \/. (ratio 9 2) \/\/ (ratio 7 9)\nres08 = (ratio 7 2)*4 \/\/ (ratio 14 1)\nres09 = floor(ratio 7 2) \/\/ 3\nres10 = floor(ratio (-7) 2) \/\/ -4\nres11 = ceiling(ratio 7 2) \/\/ 4\nres12 = ceiling(ratio (-7) 2) \/\/ -3\nres13 = trunc(ratio (-7) 2) \/\/ -3\nres14 = trunc(ratio 7 2) \/\/ 3\n\nres20 = (ratio 8 4) == 2 res21 = (ratio 8 4) != 2 res22 = 2 > (ratio 7 2)  res23 = 2 < (ratio 7 2)  res30 = (2 > 4) \\\/ (4 == 3) res31 = (2 < 4) \\\/ (4 != 3) res32 = (or [True, False, True]) res33 = (and [True, False, True]) \/\/ Bit Vector\nres40 = 17 || 29 \/\/ 0b11101 (17 is 10001, 29 is 11101)\nres41 = 17 && 29 \/\/ 0b10001\nres42 = complement 0b110110001000111 \/\/ 0b001001110111000\nres43 = 0b110101 << 2 \/\/ 0b010100\nres44 = 0b110101 >> 2 \/\/ 0b001101\nres45 = 0b110101 <<< 2 \/\/ 0b010111\nres46 = 0b110101 >>> 2 \/\/ Sequences\nres50 = head [23,36,12] res51 = head \"peanut\" res52 = tail [23,36,12] res53 = tail \"pea\" res54 = [23,36,12,62,11]@3 res55 = [23,36,12,62,11]@@[3,1] res56 = [23,36,12,62,11]!3 res57 = [23,36,12,62,11]!![3,1] res58 = foldl (\/) 1000 [1,2,3,4] res59 = foldr (+) 0 [1,2,3,4] res60 = reverse [23,36,12,62,11] res61 = sum [23,36,12,62,11] res62 = product [23,36,12,62,11] res63 = sort [23,36,12,62,11] res64 = sortBy (<) [23,36,12,62,11] ","variant":"hybrid","set":"holdout"}
{"filename":"SAW-course\/src\/lab4\/perm.cry","filetype":"cry","content":"module perm where\n\nremove lst n = drop `{2} [w.0 | w <- z]\n  where\n    z = [(-1,False)]#[ if (q.1 == False \/\\ ~(za == n)) \n                       then (za, q.1)\n                       else (zb, True)\n                     | za <- [-1]#lst | zb <- lst#[-1] | q <- z ]\n\nmember lst n = z ! 0\n  where\n    z = [False]#[ ss \\\/ (p == n) | p <- lst | ss <- z ]\n\nperm x y = if (length x) == 0 \/\\ (length y) == 0 then True else\n           if (length x) == (length y) then (z ! 0).1 else False\n  where\n    z = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n        | q <- [(y,True)]#z | p <- x ]\n\npermReflexive : [10][32] -> [10][32] -> Bit\nproperty permReflexive x y = ~(x == y) \\\/ perm x y\n\npermSymmetric : [10][32] -> [10][32] -> Bit\nproperty permSymmetric x y =\n   if ~(member x (2^^32-1)) \/\\ ~(member y (2^^32-1)) \/\\ perm x y\n   then perm y x else True\n\npermTransitive : [6][32] -> [6][32] -> [6][32] -> Bit\nproperty permTransitive x y z =\n   if ~(member x (2^^32-1)) \/\\ ~(member y (2^^32-1)) \/\\ ~(member z (2^^32-1)) \/\\\n       perm x y \/\\ perm y z\n   then perm x z else True\n\n\/\/ use cvc4 prover","variant":"hybrid","set":"supervised"}
{"filename":"SAW-course\/src\/lab4\/bsort.cry","filetype":"cry","content":"import perm\n\nbsort : {n, a} (Cmp a, Integral a, Literal 1 a, fin n) => [n]a -> [n]a\nbsort lst = take `{n} (bb (lst#[-1,-1...]))\n  where\n    bb seq = if (seq@0) == -1 then seq else (bbl (head seq) (bb (tail seq)))\n    bbl n seq =\n      if ((seq@0) == -1) then [n]#[-1,-1...]\n      else if (n < (seq@0)) then [n]#seq\n      else [(seq@0)]#(bbl n (tail seq))\n      \nvalid lst = z ! 0\n  where\n    z = [True]#[~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst = ~(valid lst) \\\/ perm lst (bsort lst)\n\nnondecreasing : [6][32] -> Bit\nnondecreasing lst = z ! 0\n  where\n    z = [True]#[ if (j1 <= j2) \/\\ k then True else False\n               | k <- z | j1 <- lst | j2 <- drop `{1} lst]\n\nbsortIsOrdered : [6][32] -> Bit\nproperty bsortIsOrdered lst = ~(valid lst) \\\/ nondecreasing (bsort lst)\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab4\/mrgsrt.cry","filetype":"cry","content":"import perm\n\n\/************************************************************************\/\n\/*  The goal of this page:                                              *\/\n\/*    Show how a specification of an operation on finite lists          *\/\n\/*    can be expressed recursively by switching to infinite lists       *\/\n\/*    and back                                                          *\/\n\/*  Define mergesort on lists of positive numbers and prove correctness *\/\n\/************************************************************************\/\n\/* Mergesort - but only for positive numbers \n   subfunctions operate on infinite lists to allow for recursion\n   subfunctions are as follows:\n   splito: \n     Input - lst=finite list\n     Output - infinite list, padded with -1s after the split elements\n     Process: best described as [ lst@i | i <- [1,3...] ]\n   splite:\n     Input - lst=finite list\n     Output - infinite list, padded with -1s after the split elements\n     Process: best described as [ lst@i | i <- [0,2...] ]\n   merge:\n     Inputs: px, py - two infinite lists in nondecreasing order (padded with -1s)\n     Output: infinite list, nondecreasing, containing all of px & py, padded\n     Process: merge two padded infinite lists, up to the padding\n     if px@0 is -1 then return py, if py@0 is -1 then return px\n     otherwise if px@0 is less than py@0 concat px@0 with (merge (tail(px) py)\n     otherwise concat py@0 with (merge px (tail py))\n   mergesrt:\n     Input: p=infinite list (padded)\n     Output: padded, nondecreasing infinite list that is a permutation of x\n     Process: sort list p up to the padding\n     recursively merge the mergesrt of the even elements of p with the mergesrt\n     of the odd elements of p\n*\/\n\n\/\/  Input: lst - -1 padded finite sequence of numbers\n\/\/  Output: lst with only odd indexed elements followed by -1 padding\nsplito : {n,a} [n]a -> [inf]a\nsplito lst = [ lst@i | i <- [1,3...] ]\n\n\/\/  Input: lst - -1 padded finite sequence of numbers\n\/\/  Output: lst with only even indexed elements followed by -1 padding\nsplite : {n,a} [n]a -> [inf]a\nsplite lst = [ lst@i | i <- [0,2...] ]\n\n\/\/  Inputs: px, py: two infinite lists in nondecreasing order (padded with -1s)\n\/\/  Output: infinite list, nondecreasing, containing all of px and py, padded\nmerge : {a} (Literal 1 a, Ring a, Cmp a) => [inf]a -> [inf]a -> [inf]a\nmerge px py = \n      if px@0 == -1 then py\n      else if py@0 == -1 then px\n      else if px@0 < py@0 then [px@0]#(merge (tail px) py)\n      else [py@0]#(merge px (tail py))\n\n\/\/  Input: finite sequence lst of numbers\n\/\/  Output: finite nondecreasing sequence of numbers that is permutation of lst\nmergesort : {cnt, a} (fin cnt, fin a, a >= 1, cnt >= 0) => [cnt][a] -> [cnt][a]\nmergesort lst = take `{cnt} (mergesrt ax)\n  where\n    mergesrt p = \n      if p@0 == -1 \\\/ p@1 == -1 then p\n      else merge (mergesrt (splite p)) (mergesrt (splito p))\n    ax = lst#[-1,-1 ...]\n\n\/\/ For the following use :s base=10\nres00 = take `{3} (splite [1,2,3,4,5,6])\nres01 = take `{3} (splite [1,2,3,4,5,6,7])\nres02 = take `{4} (splite [1,2,3,4,5,6,7,8])\n\nres10 = take `{3} (splito [1,2,3,4,5,6])\nres11 = take `{4} (splito [1,2,3,4,5,6,7])\nres12 = take `{4} (splito [1,2,3,4,5,6,7,8])\n\nres20 = take `{8} (merge ([1,5,7,10]#[-1,-1 ...]) ([3,7,11,14]#[-1,-1 ...]))\n\nres30 = mergesort [6,7,8,2,3,4,1,11,23,5]\nres31 = mergesort [1]\nres32 = mergesort [2,2]\nres33 = mergesort [2,1]\nres34 = mergesort [9,8,7,6,5,4,3,2,1]\nres35 = mergesort [9,8,7,6,5,4,3,2,1,6]\nres36 = mergesort [9,8,7,6,5,4,3,2,1,6,10]\nres37 = mergesort [9,8,7,6,5,4,3,2,10,6,1]\nres38 = mergesort [1,9,8,7,6,5,4,3,2,1,6]\nres39 = mergesort [10,9,8,7,6,5,4,3,2,1,6]\n\nresults = [take `{11} (res30#[-1,-1...]),\n           take `{11} (res31#[-1,-1...]),\n           take `{11} (res32#[-1,-1...]),\n           take `{11} (res33#[-1,-1...]),\n           take `{11} (res34#[-1,-1...]),\n           take `{11} (res35#[-1,-1...]),\n           take `{11} (res36#[-1,-1...]),\n           take `{11} (res37#[-1,-1...]),\n           take `{11} (res38#[-1,-1...]),\n           take `{11} (res39#[-1,-1...])]\n\nvalid lst = z ! 0\n  where\n    z = [True]#[~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst = ~(valid lst) \\\/ perm lst (mergesort lst)\n\n\/\/ use cvc4 for isAPerm (0.595s)\n\nnondecreasing lst = z ! 0\n  where\n    z = [True]#[ if (j1 <= j2) \/\\ k then True else False\n               | k <- z | j1 <- lst | j2 <- drop `{1} lst]\n\nmergesortIsOrdered : [6][32] -> Bit\nproperty mergesortIsOrdered lst =\n    ~(valid lst) \\\/ nondecreasing (mergesort lst)\n\n\/\/ use cvc4 for mergesortIsOrdered (0.176s)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab4\/sort_com.cry","filetype":"cry","content":"import perm\n\n\/\/ Sort algorithm: let lst be the sequence to sort and let acc initially\n\/\/ be a sequence of -1s of the same length as lst.   In a round, elements \n\/\/ of lst are compared with elements of acc, starting from the right (greatest\n\/\/ elements first).  If the lst element is greater than the existing acc\n\/\/ element, the acc element moves down (to the left) by 1 position and\n\/\/ makes way for the lst element to be placed where the acc element had been.\n\/\/ If the lst element is not greater then it is placed before (to the left\n\/\/ of) the acc element it is compared with.  This process has the effect\n\/\/ that greater elements move at most one position to the right and lesser\n\/\/ elements at most one position to the left on a round.  Thus, running a\n\/\/ number of rounds equal to the length of lst, output of one round being\n\/\/ input to the next round, sorts lst.  Empty input sequence is not allowed.\nround : {n, b} (Literal 1 b, Ring b, Cmp b, fin n) => [1 + n]b -> [1 + n]b\nround lst = z ! 0\n  where\n    z = [q]#[ if lst@i > acc@(i+1)\n              then (insert (insert acc (acc@(i+1)) i) (lst@i) (i+1))\n              else (insert acc (lst@i) i)\n        | acc <- z | i <- (reverse (take `{n} [0...])) ]\n    q = insert (makeNegs lst) (last lst) ((length lst)-1)\n\ninsert lst m i = [ if k==i then m else x | x <- lst | k <- [0...]]\n\nmakeNegs lst = [ -1 | i <- lst ]\n\n\/\/ Sort a given input sequence lst - the number of rounds is equal to\n\/\/ the length of lst and obtained with i <- lst.\nsort lst =  z ! 0\n  where\n    z = [ round x | x <- [lst]#z | i <- lst ]\n\n\/\/ Returns True if and only if the sequence lst has no -1s \nvalid lst = z ! 0\n  where\n    z = [True]#[ ~(x == -1) \/\\ y | x <- lst | y <- z ]\n\n\/\/ Theorem stating a valid sequence lst implies lst is a permutation\n\/\/ of (sort lst)\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst =  ~(valid lst) \\\/ perm lst (sort lst)\n\n\/\/ Returns True if and only if for every pair of consecutive numbers in\n\/\/ lst, the left number is never greater than the right number\n\/\/nondecreasing : [6][32] -> Bit\nnondecreasing lst = z ! 0\n  where\n    z = [True]#[ if (j1 <= j2) \/\\ k then True else False\n               | k <- z | j1 <- lst | j2 <- drop `{1} lst]\n\n\/\/ Theorem stating a valid sequence lst implies the sequence (sort lst)\n\/\/ is nondecreasing\nsortIsOrdered : [6][32] -> Bit\nproperty sortIsOrdered lst = ~(valid lst) \\\/ nondecreasing (sort lst)\n\n","variant":"hybrid","set":"supervised"}
{"filename":"SAW-course\/src\/lab4\/sort_rec.cry","filetype":"cry","content":"import perm\n\n\/\/ Sort algorithm: let lst be the sequence to sort and let acc initially \n\/\/ be a sequence of -1s of the same length as lst.   In a round, elements\n\/\/ of lst are compared with elements of acc, starting from the right (greatest\n\/\/ elements first).  If the lst element is greater than the existing acc\n\/\/ element, the acc element moves down (to the left) by 1 position and\n\/\/ makes way for the lst element to be placed where the acc element had been.\n\/\/ If the lst element is not greater then it is placed before (to the left\n\/\/ of) the acc element it is compared with.  This process has the effect\n\/\/ that greater elements move at most one position to the right and lesser\n\/\/ elements at most one position to the left on a round. Thus, running a \n\/\/ number of rounds equal to the length of lst, output of one round being\n\/\/ input to the next round, sorts lst.  Empty input sequence is not allowed.\nround : {n, a} (Literal 1 a, Ring a, Cmp a, fin n) => [1 + n]a -> [1 + n]a -> [1 + n]a\nround lst acc = (func lst ((length lst)-1) acc)\n  where\n    func lt i ac =\n      if i == -1\n      then ac\n      else if (last ac) == -1 \\\/ lt@i <= ac@(i+1)\n           then func lt (i-1) (insert ac (lt@i) i) \n           else func lt (i-1) (insert (insert ac (ac@(i+1)) i) (lt@i) (i+1))\n\ninsert lst m i = [ if k==i then m else x | x <- lst | k <- [0...]]\n\nmakeNegs lst = [ -1 | i <- lst ]\n\n\/\/ Sort a given input sequence lst - the a numbers of rounds equal to\n\/\/ the length of lst\nsort lst = z ! 0\n  where\n    z = [ round x (makeNegs lst)  | x <- [lst]#z | i <- lst ]\n\n\/\/ Returns True if and only if the sequence lst has no -1s\nvalid lst = z ! 0\n  where\n    z = [True]#[ ~(x == -1) \/\\ y | x <- lst | y <- z ]\n\n\/\/ Theorem stating a valid sequence lst implies lst is a permutation\n\/\/ of (sort lst)\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst = ~(valid lst) \\\/ perm lst (sort lst)\n\n\/\/ Returns True if and only if for every pair of consecutive numbers in\n\/\/ lst, the left number is never greater than the right number\nnondecreasing : [6][32] -> Bit\nnondecreasing lst = z ! 0\n  where\n    z = [True]#[ if (j1 <= j2) \/\\ k then True else False\n               | k <- z | j1 <- lst | j2 <- drop `{1} lst]\n\n\/\/ Theorem stating a valid sequence lst implies the sequence (sort lst)\n\/\/ is nondecreasing\nsortIsOrdered : [6][32] -> Bit\nproperty sortIsOrdered lst = ~(valid lst) \\\/ nondecreasing (sort lst)\n\n","variant":"hybrid","set":"holdout"}
{"filename":"SAW-course\/src\/lab3A\/a.cry","filetype":"cry","content":"plus : ([31],[31]) -> [31]\nplus (a, b) = if sab @ 0 then sab' + 1 else sab'\n  where\n     sab = ((zero : [1]) # a) + ((zero : [1]) # b)\n     sab' = drop `{1} sab\n\nadd xs = sums ! 0\n  where\n    sums = [0] # [plus (s, x) | s <- sums | x <- xs]\n\nv (ss) = add [ s <<< c | s <- ss@@[15,13,10,4,0,0]\n                       | c <- [15,17,21,20,8,0]]","variant":"hybrid","set":"supervised"}
{"filename":"SAW-course\/src\/intr\/bitcoin.cry","filetype":"cry","content":"\/\/ Three boxes are presented to you.  One contains Bitcoin, the other two are \n\/\/ empty. Each box has imprinted on it a clue as to its contents; the clues \n\/\/ are:\n\/\/ Box 1: \"The Bitcoin is not here\" \n\/\/ Box 2: \"The Bitcoin is not here\" \n\/\/ Box 3: \"The Bitcoin is in Box 2\"\n\/\/ One message is true; the other two are false.  Which box has the Bitcoin?\n\n\/\/ exactly one of x1 x2 x3 is True\none_is_true : Bit -> Bit -> Bit -> Bit\none_is_true x1 x2 x3 =\n  (~x1 \\\/ ~x2) \/\\ (~x1 \\\/ ~x3) \/\\ (~x2 \\\/ ~x3) \/\\ (x1 \\\/ x2 \\\/ x3)\n\n\/\/ x1 is True\/False if and only if x2 is True\/False\niff : Bit -> Bit -> Bit\niff x1 x2 = x1 == x2\n\n\/\/ not x is True if x is False and is False if x is True\nnot : Bit -> Bit\nnot x = if x then False else True\n\n\/\/ Meaning of signs\n\/\/ if sign1 is True then the Bitcoin is not in box1 otherwise it is in box1\n\/\/ if sign2 is True then the Bitcoin is not in box2 otherwise it is in box2\n\/\/ if sign3 is true then the Bitcoin is in box2 otherwise it is not in box2\nsetup : Bit -> Bit -> Bit -> Bit -> Bit -> Bit\nsetup s1 s2 s3 b1 b2 =\n  (iff s1 (not b1)) \/\\ (iff s2 (not b2)) \/\\ (iff s3 b2)\n\nimplies : Bit -> Bit -> Bit\nimplies x1 x2 = if x1 then x2 else True\n\nans : Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit\nproperty ans s1 s2 s3 b1 b2 b3 =\n  (implies ((one_is_true s1 s2 s3) \/\\ \/\/ one sign is True\n            (one_is_true b1 b2 b3) \/\\ \/\/ one box has the Bitcoin\n\t    (setup s1 s2 s3 b1 b2))   \/\/ signs match\n\t b1)                          \/\/ then b1 has the Bitcoin\n\n\/\/ Main> :l bitcoin.cry \n\/\/ Loading module Cryptol\n\/\/ Loading module Main\n\/\/ Main> :prove ans\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.028s, using \"Z3\")\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/intr\/kalotan.cry","filetype":"cry","content":"\/\/ Kaloton Puzzle\n\/\/   The Kalotans are a tribe with a peculiar quirk: their females\n\/\/   always tell the truth and their males never make two consecutive\n\/\/   true statements, or two consecutive untrue statements.\n\/\/\n\/\/   An anthropologist (let's call him Worf) has begun to study them.\n\/\/   Worf does not yet know the Kalotan language.  One day, he meets a\n\/\/   Kalotan (heterosexual) couple and their child Kibi (also called \"kid\").\n\/\/   Worf asks the kid: ``Are you a boy?''  The kid answers in Kalotan,\n\/\/   which of course Worf doesn't understand.\n\/\/\n\/\/   Worf turns to the parents (who know English) for explanation.  One\n\/\/   of them (parent1) says: \"Kibi said: `I am a girl.'\" The other (parent2)\n\/\/   adds: \"Kibi is a boy.  Kibi lied.\"\n\/\/\n\/\/   Solve for the sex of the parents and Kibi.\n\n\/\/ -----------------------------------------\n\/\/ variables: parent1: T=male, F=female\n\/\/ parent2: T=male, F=female\n\/\/            kid: T=male, F=female\n\/\/            kid-said: T=male, F=female\n\/\/            kid-lied: T=yes, F=no\n\/\/\n\/\/ if parent1 is a female then \n\/\/    kibi said it is a girl (female response) \n\/\/       and\n\/\/    either kibi is a boy and did not lie \n\/\/       or (male response - alt T,F)\n\/\/          kibi is a girl and did lie \n\/\/              otherwise\n\/\/                 (male response does not matter)\n\/\/                  kibi is a boy and kibi lied  (female response)\n\nxor : Bit -> Bit -> Bit\nxor a b = a ^ b\n\nheterosexual_parents : Bit -> Bit -> Bit\nheterosexual_parents parent1 parent2 = ~(parent1 == parent2)\n\nmeaning_of_kid_lied : Bit -> Bit -> Bit -> Bit\nmeaning_of_kid_lied kid_said kid kid_lied = xor (kid_said == kid) kid_lied\n\nparents_said : Bit -> Bit -> Bit -> Bit -> Bit\nparents_said parent1 kid_said kid kid_lied =\n  if ~parent1 then (~kid_said \/\\ (xor kid kid_lied)) else (kid \/\\ kid_lied)\n\npeople_types : Bit -> Bit -> Bit -> Bit -> Bit -> Bit\nproperty people_types parent1 parent2 kid_said kid kid_lied =\n (heterosexual_parents parent1 parent2 \/\\\n  meaning_of_kid_lied kid_said kid kid_lied \/\\\n  parents_said parent1 kid_said kid kid_lied)\n\n\/\/ use: Main> :s satNum=all\n\/\/      Main> :sat people_types\n\n\/\/ The following is unsatisfiable\n\/\/ use: Main> :sat checkit1\nproperty checkit1 parent1 parent2 kid kid_said kid_lied =\n  ~(parent1 \/\\ ~parent2 \/\\ ~kid_said \/\\ kid \/\\ kid_lied) \/\\\n  (people_types parent1 parent2 kid_said kid kid_lied)\n\n\/\/ The following proves\n\/\/ use: Main> :prove checkit2\nproperty checkit2 parent1 parent2 kid kid_said kid_lied =\n  ~(people_types parent1 parent2 kid_said kid kid_lied) \\\/\n  (parent1 \/\\ ~parent2 \/\\ ~kid_said \/\\ kid \/\\ kid_lied) \n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/intr\/comprehensions.cry","filetype":"cry","content":"\/\/ Simple example of a comprehension\nv01 = [x | x <- [1...] | y <- [1..10]]\n\/\/ v01 is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n\/\/ Note: x and y take values interactively and simultaneously.  x is\n\/\/ taken from an infinite list but the comprehension is controlled\n\/\/ by y as it runs out of tokens after receiving value 10.\n\nv02 = [ (x,y) | x <- [10..12] , y <- [1..4]]\n\/\/ v02 is [(10, 1), (10, 2), (10, 3), (10, 4), (11, 1), (11, 2),\n\/\/         (11, 3), (11, 4), (12, 1), (12, 2), (12, 3), (12, 4)]\n\/\/ Note: pairs are constructed from all possible combinations\n\/\/ of values of x between 10 and 12 and y between 1 and 4.\n\nv03 = [ (x,y,z) | x <- [10,11] , y <- [20,21], z <- [30,31]]\n\/\/ v03 is [(10, 20, 30), (10, 20, 31), (10, 21, 30), (10, 21, 31),\n\/\/         (11, 20, 30), (11, 20, 31), (11, 21, 30), (11, 21, 31)]\n\/\/ Note: all possible triples from values taken by x, y, and z\n\nv04 = [ (x,y,z) | x <- [10,11] , y <- [20,21] | z <- [30,31,32]]\n\/\/ v04 is [(10, 20, 30), (10, 21, 31), (11, 20, 32)]\n\/\/ Note: the rightmost | controls the number of triples output\n\nv05 = [1]#[ x+y | x <- v05 | y <- [1]#v05 ]\nv06 = take `{10} v05\n\/\/ v05 is an infinite sequence [1, 2, 3, 5, 8, ...] of Fibonaccis\n\/\/ v06 is a finite subsequence of 10 of the first 10 of those\n\/\/ Note: as v05 is being constructed, it is used inside the\n\/\/ comprehension to construct the next element of the sequence v05\n\n\/\/ Pigeon hole formulas - set base=10\nph = [1,1,1,0,1,2,2,1,1]  \/\/ shows number of pigeons in each of 9 holes\nv07 = [0]#[ x+y | x <- ph | y <- v07 ]  \/\/ sum all holes to get # pigeons\nv08 = v07 ! 0 \/\/ number of pigeons is last State\n\/\/ v07 is [0, 1, 2, 3, 3, 4, 6, 8, 9, 10]\n\/\/ v08 is 10\n\n\/\/ Condition that no hole has > 1 pigeon - set base=2\nv09 = [True]#[ (x <= 1) \/\\ y | x <- ph | y <- v09 ]\nv10 = v09 ! 0\n\/\/ v09 is 0b1111110000\n\/\/ v10 is False meaning at least one hole has more than one pigeon\n\n\/\/ The following reverses a sequence\nlst = [16,42,23,77]\nv11 = [lst] # [[b]#(tail (a >> 1)) | a <- v11 | b <- lst ]\nv12 = v11 ! 0\n\/\/ v11 is [[16, 42, 23, 77], [16, 16, 42, 23], [42, 16, 16, 42],\n\/\/         [23, 42, 16, 16], [77, 23, 42, 16]]\n\/\/ v12 is [77, 23, 42, 16]\n\n\/\/ Creates a list of 16 numbers, beginning with the first one, p,\n\/\/ as input, doubled, then followed by numbers that are double the\n\/\/ previous one.\np = 3\nv13 = [ 2*lr | lr <- [p] # v13 | k <- [1 .. 16]]\n\/\/ v13 is [6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144,\n\/\/         12288, 24576, 49152, 98304, 196608]\n\n\/\/ An infinite version of the above\nv14 = [2*lr | lr <- [p] # v14 | k <- [1...]]\nv15 = take `{12} v14\n\/\/ v14 is [6, 12, 24, 48, 96, ...]\n\/\/ v15 is [6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144, 12288]\n\n\/\/ Try this\n\/\/ Cryptol infers types hence things like v01 : {a} (Literal 1 a, Integral a) => [10]a\n\/\/ and like \"* Using 'Integer' for type argument 'a' of 'Cryptol::infFrom'\n\/\/ but v01:[10][32] narrows the type to a sequence of 10 32 bit numbers and the above\n\/\/ disappears.  This is a monomorphic type.  The inferred type is polymorphic.\n\/\/ Main> :l comprehensions.cry\n\/\/ Main> :s base=10\n\/\/ Main> :t v01\n\/\/ v01 : {a} (Literal 1 a, Integral a) => [10]a\n\/\/ Main> v01\n\/\/ Showing a specific instance of polymorphic result:\n\/\/  * Using 'Integer' for type argument 'a' of 'Cryptol::infFrom'\n\/\/ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\/\/ Main> v01:[10][32]\n\/\/ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\/\/ Main> :t v02\n\/\/ v02 : {a, b} (Literal 4 b, Literal 12 a) => [12](a, b)\n\/\/ Main> v02:[12]([32],[32])\n\/\/ [(10, 1), (10, 2), (10, 3), (10, 4), (11, 1), (11, 2), (11, 3),\n\/\/  (11, 4), (12, 1), (12, 2), (12, 3), (12, 4)]\n\/\/ :t v03\n\/\/ v03 : {a, b, c} (Literal 31 c, Literal 21 b, Literal 11 a) => [8](a, b, c)\n\/\/ Main> v03:[8]([32],[32],[32])\n\/\/ [(10, 20, 30), (10, 20, 31), (10, 21, 30), (10, 21, 31),\n\/\/  (11, 20, 30), (11, 20, 31), (11, 21, 30), (11, 21, 31)]\n\/\/ Main> :t v04\n\/\/ v04 : {a, b, c} (Literal 32 c, Literal 21 b, Literal 11 a) => [3](a, b, c)\n\/\/ Main> v04:[3]([32],[32],[32])\n\/\/ [(10, 20, 30), (10, 21, 31), (11, 20, 32)]\n\/\/ Main> :t v05\n\/\/ v05 : {a} (Ring a, Literal 1 a) => [inf]a\n\/\/ Main> v05\n\/\/ Showing a specific instance of polymorphic result:\n\/\/   * Using 'Integer' for type argument 'a' of '(Cryptol::+)'\n\/\/ [1, 2, 3, 5, 8, ...]\n\/\/ Main> v05:[inf][32]\n\/\/ [1, 2, 3, 5, 8, ...]\n\/\/ Main> :t v06\n\/\/ v06 : {a} (Ring a, Literal 1 a) => [10]a\n\/\/ Main> v06:[10][32]\n\/\/ [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n\/\/ Main> :t v07\n\/\/ v07 : {a} (Ring a, Literal 2 a) => [10]a\n\/\/ Main> v07:[10][32]\n\/\/ [0, 1, 2, 3, 3, 4, 6, 8, 9, 10]\n\/\/ Main> :t v08\n\/\/ v08 : {a} (Literal 2 a, Ring a) => a\n\/\/ Main> :t v11\n\/\/ v11 : {a} (Literal 77 a, Zero a) => [5][4]a\n\/\/ Main> v11:[5][4][32]\n\/\/ [[16, 42, 23, 77], [16, 16, 42, 23], [42, 16, 16, 42],\n\/\/  [23, 42, 16, 16], [77, 23, 42, 16]]\n\/\/ Main> :t v12\n\/\/ v12 : {a} (Literal 77 a, Zero a) => [4]a\n\/\/ Main> v12:[4][32]\n\/\/ [77, 23, 42, 16]\n\/\/ Main> :t v14\n\/\/ v14 : {a} (Literal 3 a, Ring a) => [inf]a\n\/\/ Main> v14:[inf][32]\n\/\/ [6, 12, 24, 48, 96, ...]\n\/\/ Main> :t v15\n\/\/ v15 : {a} (Ring a, Literal 3 a) => [12]a\n\/\/ Main> v15:[12][32]\n\/\/ [6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144, 12288]\n","variant":"hybrid","set":"supervised"}
{"filename":"SAW-course\/src\/intr\/cryptol_crib.cry","filetype":"cry","content":"\/*\n  Cryptol Crib Sheet1\n\n  To Use Cryptol:\n    1. From the linux command line: 'prompt> cryptol' to get this:\n\n         \/ __| '__| | | | '_ \\| __\/ _ \\| |\n        | (__| |  | |_| | |_) | || (_) | |\n         \\___|_|   \\__, | .__\/ \\__\\___\/|_|\n                   |___\/|_| version 2.12.0 (901a1d1)\n\n       Loading module Cryptol\n       Cryptol>\n       Type :? for help\n       Cryptol>\n    2. To load a source file, in this case tests.cry, do this:\n       Cryptol> :l tests.cry\n       Loading module Cryptol\n\t\t Loading module Main\n       Main>\n    3. To set the base to 10 do this:\n       Main> :s base=10\n\t\t Main>\n    4. To invoke a function, in this case rev(..) (reverse a list) do this:\n       Main> rev([1 2 3])\n       [3 2 1]\n       Main>\n    5. To switch to a different backend, in this case yices, do this:\n       Main> :s prover=yices\n\t\t Main>\n    6. All source files are edited using any simple text editor. The following \n       examples are assumed to be written to file then loaded as above. Where \n       Main> shows up, the functions in the file are invoked.\n*\/\n\n\/\/ type signature of (==)\n\/\/ Main> :t (==)\n\/\/ (==) : {a} (Eq a) => a -> a -> Bit\nres00 = 1 == 1\nres01 = \"peanut\" == [112, 101, 97, 110, 117, 116]\nres02 = (ratio 7 2) == (ratio 14 4)\n\n\/\/ type signature of (===) : equality of two functions\n\/\/ Main> :t (===)\n\/\/ (===) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> a -> Bit\nsqDiff1 (x, y) = x^^2 - y^^2\nsqDiff2 (x, y) = (x-y) * (x+y)\n\/\/ Main> :t sqDiff1\n\/\/ sqDiff1 : {a} (Ring a) => (a, a) -> a\n\/\/ Main> :t sqDiff2\n\/\/ sqDiff2 : {a} (Ring a) => (a, a) -> a\n\nsqDiffs_same : ([64],[64]) -> Bit\nproperty sqDiffs_same = sqDiff1 === sqDiff2\n\/\/ Main> :prove sqDiffs_same\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.007s, using \"Z3\")\n\/\/ Hence the two functions are the same on 64 bit inputs\n\n\/\/ Positional type arguments\n\/\/ Main> :t groupBy\n\/\/ groupBy : {each, parts, a} (fin each) => [each * parts]a -> [parts][each]a\n\/\/ Main> res04\n\/\/ [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n\/\/ Mail> res05\n\/\/ [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]]\n\/\/ Mail> res06\n\/\/ [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]]\nres04 = groupBy `{_,3} [1..12]\nres05 = groupBy `{2} [1..12]\nres06 = groupBy `{2,_} [1..12]\n\n\/\/ Main> :t take\n\/\/ take : {front, back, a} [front + back]a -> [front]a\n\/\/ Main> res07\n\/\/ [1,2,3,4]\n\/\/ Main> res08\n\/\/ [1,2,3,4]\nres07 = take `{4,_} [1..12]\nres08 = take `{4} [1..12]\n\n\/\/ Inline argument type declaration\n\/\/ Main> :t addBytes\n\/\/ addBytes : [8] -> [8] -> [8]\n\/\/ Main> addBytes 222 111\n\/\/ 77\naddBytes (x:[8]) (y:[8]) = x + y\n\n\/\/ Inferred types\n\/\/ Main> :t 43\n\/\/ 43 : {a} (Literal 43 a) => a\n\/\/ These can be made monomorphic - see below\n\n\/\/ A 10 bit number\nxx = 3:[10]\nyy = 3:[10]\nzz = 3:[11]\n\/\/ xx + zz can't be added due to type mismatch\n\/\/ Main> :t xx+yy\n\/\/ (xx + yy) : [10]\n\n\/\/ Main> :t xxx+yyy\n\/\/ (xxx + yyy) : {a} (Ring a, Literal 3 a) => a\n\/\/ Main> :t xxx+zz\n\/\/ (xxx + zz) : [11]\n\/\/ Main> :t toInteger(xxx+zz)\n\/\/ toInteger (xxx + zz) : Integer\nxxx = 3\nyyy = 3\n\n\/\/ Main> res09\n\/\/ 2\n\/\/ Main> res10\n\/\/ 18\nres09 = 3+15:[4]\nres10 = 3+toInteger(15:[4])\n\n\/\/ Main> :t (\/)\n\/\/ (\/) : {a} (Integral a) => a -> a -> a\n\/\/ Main> :t (\/.)\n\/\/ (\/.) : {a} (Field a) => a -> a -> a\n\/\/ Main> res11\n\/\/ (ratio 1 1)\nres11 = (ratio 7 2) \/. (ratio 14 4)\n\n\/\/ Main> :t res12\n\/\/ res12 : {a} (Literal 2 a) => [2]a\n\/\/ Main> :t res13\n\/\/ res13 : {a} (Ring ([2]a), Literal 2 a) => [3][2]a\n\/\/ Main> res13\n\/\/ [[1, 2], [2, 4], [3, 6]]\nres12 = [1, 2]\nres13 = [res12, res12+res12, res12+res12+res12]\n\nres14 = [1, 2, 3, 4, 5]\nres15 = [0]#res14\nres16 = res14!0\nres17 = res14!![1,0]\nres18 = res14@0\nres19 = res14@@[0,1]\n\n\/\/ Convert sequence of numbers to characters\nshow : {n} [n]Char -> [n]Char\nshow s = [ c:Char | c <- s]\n\n\/\/ Tuples \n\/\/ Main> res22\n\/\/ ([210, 218, 213, 226, 218, 230], (ratio 37 1), (ratio 26 5))\n\/\/ Main> res23\n\/\/ [210, 218, 213, 226, 218, 230]\n\/\/ Main> :s ascii=on\n\/\/ Main> res26\n\/\/ \"peanut\"\nres20 = (\"peanut\", 34, (ratio 6 5))\nres21 = (\"butter\", (ratio 3 1), 4)\nres22 = res20 + res21\nres23 = res22.0\nres24 = res22.1\nres25 = res22.2\nres26 = show(res20.0)\n\n\/\/ Enumerations\n\/\/ Main> res27\n\/\/ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\/\/ Main> res28\n\/\/ [1, 3, 5, 7, 9]\n\/\/ Main> res29\n\/\/ [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\/\/ Main> res32\n\/\/ True\n\/\/ Main> res33\n\/\/ [-1, -1, -1, -1, -1, ...]\nres27 = [1..10]\nres28 = [1,3..10]\nres29 = [10,9..1]\nres30 = [1..10]:[10][16]\nres31 = [1..10:[16]]\nres32 = res30 == res31\nres33 = [-1,-1...]\n\n\/\/ Some variables:\n\nv00:[32]\nv00 = 45\n\nv01:[64]\nv01 = 72625\n\n\/*\nin the c language:\nunsigned int v0 = 45;\nunsigned long v1 = 72625;\n\nArrays:\n*\/\n\n\/\/ sequence of 8 32 bit numbers\nv02:[8][32]\nv02 = [1, 2, 3, 4, 5, 6, 7, 8]\n\n\/\/ sequence indexing is 0,1,2... so element 1 in this case is 2\nv03 = v02 @ 1\n\n\/\/ sequence of 8 numbers\n\/\/ Main>:t v04 \n\/\/ v04 : {a} (Literal 8 a) => [8]a\nv04 = [1..8]\n\n\/\/ 8 bit number\n\/\/ Main> :s base=2\n\/\/ Main> v05\n\/\/ 0b00010111\nv05:[8]\nv05 = 23\n\n\/\/ Look at bits of v05\n\/\/ Main> v06\n\/\/ True\nv06 = v05@3\n\nv07 = v05@4\n\nv08 = v05@6\n\nv09 = v05@@[0..3]\n\n\/*\nIn the c language\nunsigned int v02[] = { 1, 2, 3, 4, 5, 6, 7, 8 };\nfor (int i=0 ; i < 8 ; i++) cout << v02[i] << \" \";\nprintf(\"%d\",v02[1]);\nunsigned char v05 = 23;\n\nf(x,0,7);\n00010111\nf(x,3,3);\n0\nf(x,4,4);\n1\nf(x,6,6);\n0\nf(x,0,3);\n0111\n\nvoid f(unsigned char z, int s, int e) {\n   for (int i=e ; i >= s ; i--)\n   printf(\"%d\",(int)((z>>i)&1));\n   printf(\\n);\n}\n\nOperations:\n*\/\n\n\/\/ Assign value\n\/\/ Main> :s base=10\n\/\/ Main> v10\n\/\/ 23\nv10:[8]\nv10=23\n\nv11:[8]\nv11=65\n\nv12 = v10+v11\n\nv13 = v10-v11\n\nv14 = v10*v11\n\nv15 = v11\/v10\n\nv16 = v11 % v10\n\nv19 = v10 >> 1\n\n\/\/ Main> :t v20\n\/\/ v20 : [8]\n\/\/ Main> v20\n\/\/ 46\nv20 = v10 << 1\n\n\nv21:[8][32]\nv21 = [2,3,6,4,3,2,7,8]\n\nv22:[8][32]\nv22 = [1,8,3,4,2,1,1,9]\n\n\/\/ Main> :t v23\n\/\/ v23 : [8][32]\n\/\/ Main> v23\n\/\/ [3, 11, 9, 8, 5, 3, 8, 17]\nv23 = v21 + v22\n\n\/*\nFunction examples:\n\nSimple for loop, using [..|..] operator. Type of function is inferred by \ncryptol to be sf:{a b} (fin a,b >= 2) => [a][b] -> [a][b] (maps any finite \nlist of a numbers of width b \u2265 2 to a list of the same type). Symbol @ \nallows array indexing. *\/\n\np:[6][8]\np = [1,2,3,4,5,6]\n\n\/\/ Main> :t sf\n\/\/ sf : {n, a} (Literal 2 a, Ring a) => [n]a -> [n]a\n\/\/ size of list can be finite or infinite depending on input\n\/\/ number of bits (a) depends on input\n\/\/ Main> sf p\n\/\/ [2, 4, 6, 8, 10, 12]\n\/\/ Main> :t (sf p)\n\/\/ (sf p) : [6][8]\nsf z = [ 2*(z@i) | i <- [0...] | j <- z ]\n\n\/*\nReverse the elements of an array. Construct where is used to establish a value\nln that is used twice in rev. Inferred type is rev:{a b} (fin a) => [a]b ->\n[a]b. Observe that b does not have to be a number. Note: there is a built-in\nfunction called reverse with the same functionality as rev.  cryptol \n\nrev : {a, b} (fin b) => [1 + b]a -> [1 + b]a\nrev x = (z!0)\n  where \n    z = [x]#[ [b]#(allButLast a) | b <- x | a <- z ]\n    allButLast q = [ a | a <- q | i <- (tail q) ]\n\nMembership in a list. The function\u2019s input type is explicitly stated to be any\nlength integer list of at least one 32 bit number and a 32 bit number. The\noutput is a single Bit which is True if n is a member of list x. A list s is\ninitialized to False. As n is tested against elements of x either True or False\nis appended to s. If True is appended, all following elements of s will be\nTrue. The last element of s is the output. This is a simple example using\nconcatenation (#) and if-then-else.  cryptol \n*\/\n\n\/\/ Main> member 3 [1,3,4,5]\n\/\/ True\n\/\/ Main> member 3 []\n\/\/ False\nmember : {a,b} (fin b, Cmp a) => a -> [b]a -> Bit\nmember n x = s!0\n   where \n      s = [False]# [ j == n \\\/ k | k <- s | j <- x ]\n\n\/*\nMerge two infinite increasing streams of integers. This is defined recursively\nwhich cryptol does not object to because argument types always match (due to\ninf). First example of tail.\n\ncryptol\n*\/\n\n\/\/ Main> merge [1,3...] [2,4...]\n\/\/ [1, 2, 3, 4, 5, ...]\n\/\/merge : {a} (fin a) => [inf][a] -> [inf][a] -> [inf][a]\nmerge px py = \n      if (px@0) == -1 then py\n      else if (py@0) == -1 then px\n      else if (px@0) < (py@0) then [(px@0)]#(merge (tail px) py)\n      else [(py@0)]#(merge px (tail py))\n\n\/*\nc++ (continued)\nclass Merge : public Stream {\n   Stream *s1, *s2;\npublic:\n   Merge (Stream *a, Stream *b) {\n      if (a->isNull() && b->isNull()) {\n         first = -1;\n      } else if (a->isNull() || (!b->isNull() && a->first >= b->first)) {\n         s1 = b; s2 = a; first = s1->first;\n      } else {\n         s1 = a; s2 = b; first = s1->first;\n      }\n   }\n\n   Stream *rest() {\n      if (isNull()) return new Stream();\n      return new Merge(s1->rest(),s2);\n   }\n};\n\nSum all numbers in an arbitrarily long list. This is a recursive solution \nso lists are padded with zero:[inf][m]. Function f is made tail recursive \nto allow cryptol to complete the sum of the necessary elements.\ncryptol\n*\/\n\n\/\/ Main> sum1 [1,2,3,4]\n\/\/ 10 \nsum1 : {n, a} (Literal 0 a, Ring a, fin n) => [n]a -> a\nsum1 x = z ! 0 where z = [0]#[ a+b | a <- x | b <- z ]\n\n\/*\nc\nuint_32 sum2(uint_32 x[], uint_32 acc, int n) {\n   if (n == 0) return acc;\n   return sum2(x, acc+x[n-1], n-1);\n}\n\nuint_32 sum1(uint_32 x[], int n) {\n   return sum2(x,0,n);\n}\n\nuint_32 p[] = { 1,2,3,4,5,6 };\nprintf(\"%d\",sum1(p,6));\n\nSort a list of numbers using mergesort. Mergesort splits a list into two \nroughly equal sized lists - the odd indexed elements go to one list and \nthe even indexed elements go to the other, recursively sorts both lists, \nthen merges the two now sorted lists. The variable i in srt is needed to \nallow cryptol to show termination.\n\ncryptol\n*\/\n\n\/\/ Main> splite [1..12]\n\/\/ [1, 3, 5, 7, 9, ...]\nsplite : {n,a} (Literal 1 a, Integral a, Eq a, fin n) => [n]a -> [inf]a\nsplite x = s ax\n  where\n    s pt = if ((pt@0) == -1) then pt\n          else [(pt@0)]#(s (drop `{2} pt))\n    ax = x#[-1,-1 ...]\n\n\/\/ Main> splito [1..12]\n\/\/ [2, 4, 6, 8, 10. ...]\nsplito : {n,a} (Literal 1 a, Integral a, Eq a, fin n) => [n]a -> [inf]a\nsplito x = s ax\n  where\n    s pt = if ((pt@0) == -1) then pt\n          else if ((pt@1) == -1) then (drop `{1} pt)\n          else [(pt@1)]#(s (drop `{2} pt))\n    ax = x#[-1,-1 ...]\n\n\/\/ User crafted type signature to use cnt\n\/\/ Main> mergesort [5,2,4,1,9,6,3,2,5]\n\/\/ [1, 2, 2, 3, 4, 5, 5, 6, 9]\nmergesort : {cnt, a} (fin cnt, fin a, a >= 1, cnt >= 1) => [cnt][a] -> [cnt][a]\nmergesort lst = take `{cnt} (mergesrt ax)\n  where\n    mergesrt pt =\n      if (((pt@0) == -1) \\\/ ((pt@1) == -1)) then pt\n      else (merge (mergesrt (splite t)) (mergesrt (splito t)))\n      where\n        t = take `{cnt} pt\n    ax = lst#[-1,-1 ...]\n\n\/*\nc++\nclass Split : public Stream {\n   Stream *s;\npublic:\n   Split(Stream *str) {\n      first = str->first; s = str;\n   }\n   Stream *rest() {\n      if (isNull() || s->rest()-isNull() || s->rest()->rest()->isNull())\n         return new Stream();\n      return new Split(s->rest()->rest());\n   }\n};\n\nclass MergeSort : public Stream {\n   Stream *s;\npublic:\n   MergeSort(Stream *str) {\n      Stream *s1 = new Split(str);\n      Stream *s2 = new Split(str->rest());\n      if (s1->isNull() && s2->isNull()) {\n         s = new Stream(); \n         first = -1;\n      } else if (s2->isNull() && s1->rest()->isNull()) {\n         s = new Stream(); first = s->first;\n      } else {\n         s = new Merge(new MergeSort(s1), new MergeSort(s2));\n         first = s->first;\n      }\n   }\n\n   Stream *rest() { return s->rest(); }\n};\n\nReturns True if and only if elements of list x are in increasing order.\ncryptol\n*\/\n\n\/\/ Main> ord [1..8]\n\/\/ True\n\/\/ Main> ord [1,2,3,2,6]\n\/\/ False\nord : {a,b} (fin a, Cmp b) => [1+a]b -> Bit\nord x = s!0\n   where \n      s = [True]#[ if (j1 <= j2) \/\\ k then True else False\n                 | k <- s | j1 <- x | j2 <- drop `{1} x]\n\n\/*\nc\nbool ordered (u int 32 x[], int sz) {\n   bool *s = new bool[sz+1];\n   s[0] = true;\n   for (int i=0 ; i < sz-1 ; i++)\n      s[i+1] = (x[i] < x[i+1]) ? s[i] & true : false;\n   return s[sz-1];\n}\n\nReturns True if and only if list x does not contain -1.\ncryptol\n*\/\n\n\/\/ Main> valid [1,2,3,4]\n\/\/ True\n\/\/ Main> valid [1,2,-1,4]\n\/\/ False\nvalid : {n, a} (Literal 1 a, Ring a, Eq a, fin n) => [n]a -> Bit\nvalid x = z!0\n  where \n    z = [True]#[ ~(j == -1) \/\\ q | q <- z | j <- x ]\n","variant":"hybrid","set":"holdout"}
{"filename":"SAW-course\/src\/intr\/bat.cry","filetype":"cry","content":"\/\/  Riddle of the Bitcoin and the Tiger(s)\n\/\/  9 rooms - Bitcoin is in one room - other rooms may be empty or have tigers\n\/\/  Player wins if room with Bitcoin is selected.  Player is eaten if room with\n\/\/  a tiger is selected.\n\/\/\n\/\/  Signs on doors of rooms:\n\/\/     ROOM 1: THE BITCOIN IS IN A ROOM WITH AN UNEVEN NUMBER\n\/\/     ROOM 2: THIS ROOM IS EMPTY\n\/\/     ROOM 3: EITHER SIGN 5 TELLS THE TRUTH, OR SIGN 7 IS LYING\n\/\/     ROOM 4: SIGN 1 IS LYING\n\/\/     ROOM 5: SIGN 2 IS LYING OR SIGN 4 TELLS THE TRUTH\n\/\/     ROOM 6: SIGN 3 IS LYING\n\/\/     ROOM 7: THE BITCOIN IS NOT IN ROOM 1\n\/\/     ROOM 8: THIS ROOM HOSTS A TIGER, AND ROOM 9 IS EMPTY\n\/\/     ROOM 9: THIS ROOM HOSTS A TIGER, AND SIGN 6 IS LYING\n\/\/\n\/\/  Sign on the door with BITCOIN is True\n\/\/  Signs on doors hiding a TIGER are False\n\/\/  Signs on doors of empty rooms are either True or False\n\/\/  If you know whether room 8 is empty, you uniquely know what room the\n\/\/  BITCOIN is in\nBitcoin_in_one_room b1 b2 b3 b4 b5 b6 b7 b8 b9 =\n   ((~b1) \\\/ (~b2)) \/\\\n   ((~b1) \\\/ (~b3)) \/\\\n   ((~b1) \\\/ (~b4)) \/\\\n   ((~b1) \\\/ (~b5)) \/\\\n   ((~b1) \\\/ (~b6)) \/\\\n   ((~b1) \\\/ (~b7)) \/\\\n   ((~b1) \\\/ (~b8)) \/\\\n   ((~b1) \\\/ (~b9)) \/\\\n   ((~b2) \\\/ (~b3)) \/\\\n   ((~b2) \\\/ (~b4)) \/\\\n   ((~b2) \\\/ (~b5)) \/\\\n   ((~b2) \\\/ (~b6)) \/\\\n   ((~b2) \\\/ (~b7)) \/\\\n   ((~b2) \\\/ (~b8)) \/\\\n   ((~b2) \\\/ (~b9)) \/\\\n   ((~b3) \\\/ (~b4)) \/\\\n   ((~b3) \\\/ (~b5)) \/\\\n   ((~b3) \\\/ (~b6)) \/\\\n   ((~b3) \\\/ (~b7)) \/\\\n   ((~b3) \\\/ (~b8)) \/\\\n   ((~b3) \\\/ (~b9)) \/\\\n   ((~b4) \\\/ (~b5)) \/\\\n   ((~b4) \\\/ (~b6)) \/\\\n   ((~b4) \\\/ (~b7)) \/\\\n   ((~b4) \\\/ (~b8)) \/\\\n   ((~b4) \\\/ (~b9)) \/\\\n   ((~b5) \\\/ (~b6)) \/\\\n   ((~b5) \\\/ (~b7)) \/\\\n   ((~b5) \\\/ (~b8)) \/\\\n   ((~b5) \\\/ (~b9)) \/\\\n   ((~b6) \\\/ (~b7)) \/\\\n   ((~b6) \\\/ (~b8)) \/\\\n   ((~b6) \\\/ (~b9)) \/\\\n   ((~b7) \\\/ (~b8)) \/\\\n   ((~b7) \\\/ (~b9)) \/\\\n   ((~b8) \\\/ (~b9)) \/\\\n   (b1 \\\/ b2 \\\/ b3 \\\/ b4 \\\/ b5 \\\/ b6 \\\/ b7 \\\/ b8 \\\/ b9)\n\nBitcoin_not_in_tiger_room b1 b2 b3 b4 b5 b6 b7 b8 b9 t1 t2 t3 t4 t5 t6 t7 t8 t9 =\n   ((~b1) \\\/ (~t1)) \/\\\n   ((~b2) \\\/ (~t2)) \/\\\n   ((~b3) \\\/ (~t3)) \/\\\n   ((~b4) \\\/ (~t4)) \/\\\n   ((~b5) \\\/ (~t5)) \/\\\n   ((~b6) \\\/ (~t6)) \/\\\n   ((~b7) \\\/ (~t7)) \/\\\n   ((~b8) \\\/ (~t8)) \/\\\n   ((~b9) \\\/ (~t9))\n\nassign_values_to_signs b1 b2 b3 b4 b5 b6 b7 b8 b9\n                       t1 t2 t3 t4 t5 t6 t7 t8 t9\n                       s1 s2 s3 s4 s5 s6 s7 s8 s9 =\n  (s1 == (b1 \\\/ b3 \\\/ b5 \\\/ b7 \\\/ b9)) \/\\   \/* s1 iff bitcoin in odd # room *\/\n  (s2 == ((~t2) \/\\ (~b2))) \/\\    \/* s2 iff room 2 empty *\/\n  (s3 == (s5 \\\/ (~s7))) \/\\       \/* s3 iff sign 5 is true or sign 7 is false *\/\n  (s4 == (~s1)) \/\\               \/* s4 iff sign 1 is false *\/\n  (s5 == ((~s2) \\\/ s4)) \/\\       \/* s5 iff sign 2 is false or sign 4 is true *\/\n  (s6 == (~s3)) \/\\               \/* s6 iff sign 3 is false *\/\n  (s7 == (~b1)) \/\\               \/* s7 iff bitcoin not in room 1 *\/\n  (s8 == (t8 \/\\ (~t9) \/\\ (~b9))) \/\\  \/* s8 iff tiger in room 8. room 9 empty *\/\n  (s9 == (t9 \/\\ (~s6))) \/\\       \/* s9 iff tiger in room 9, sign 8 is false *\/\n  (~t1 \\\/ ~s1) \/\\                \/* if tiger in room 1 sign in room 1 false *\/\n  (~t2 \\\/ ~s2) \/\\                \/* if tiger in room 2 sign in room 2 false *\/\n  (~t3 \\\/ ~s3) \/\\                \/* if tiger in room 3 sign in room 3 false *\/\n  (~t4 \\\/ ~s4) \/\\                \/* if tiger in room 4 sign in room 4 false *\/\n  (~t5 \\\/ ~s5) \/\\                \/* if tiger in room 5 sign in room 5 false *\/\n  (~t6 \\\/ ~s6) \/\\                \/* if tiger in room 6 sign in room 6 false *\/\n  (~t7 \\\/ ~s7) \/\\                \/* if tiger in room 7 sign in room 7 false *\/\n  (~t8 \\\/ ~s8) \/\\                \/* if tiger in room 8 sign in room 8 false *\/\n  (~t9 \\\/ ~s9) \/\\                \/* if tiger in room 9 sign in room 9 false *\/\n  (~b1 \\\/ s1) \/\\                 \/* if bitcoin in room 1 sign 1 is true *\/\n  (~b2 \\\/ s2) \/\\                 \/* if bitcoin in room 2 sign 2 is true *\/\n  (~b3 \\\/ s3) \/\\                 \/* if bitcoin in room 3 sign 3 is true *\/\n  (~b4 \\\/ s4) \/\\                 \/* if bitcoin in room 4 sign 4 is true *\/\n  (~b5 \\\/ s5) \/\\                 \/* if bitcoin in room 5 sign 5 is true *\/\n  (~b6 \\\/ s6) \/\\                 \/* if bitcoin in room 6 sign 6 is true *\/\n  (~b7 \\\/ s7) \/\\                 \/* if bitcoin in room 7 sign 7 is true *\/\n  (~b8 \\\/ s8) \/\\                 \/* if bitcoin in room 8 sign 8 is true *\/\n  (~b9 \\\/ s9)                    \/* if bitcoin in room 9 sign 9 is true *\/\n\n\/\/ room is true or false - one of b1, b2, b3, b4, b5, b6, b7\n\/\/ so this function returns true or false - true if the bitcoin is in\n\/\/ the input room and false otherwise\nBitcoin_in_room room = room\n\nproperty Bitcoin_and_tiger b1 b2 b3 b4 b5 b6 b7 b8 b9\n                           t1 t2 t3 t4 t5 t6 t7 t8 t9\n                           s1 s2 s3 s4 s5 s6 s7 s8 s9 =\n   ~((Bitcoin_in_one_room b1 b2 b3 b4 b5 b6 b7 b8 b9) \/\\\n     (Bitcoin_not_in_tiger_room b1 b2 b3 b4 b5 b6 b7 b8 b9\n                                t1 t2 t3 t4 t5 t6 t7 t8 t9) \/\\\n     (assign_values_to_signs b1 b2 b3 b4 b5 b6 b7 b8 b9 \n                             t1 t2 t3 t4 t5 t6 t7 t8 t9\n                             s1 s2 s3 s4 s5 s6 s7 s8 s9) \/\\\n     (t8 \\\/ t9))            \/* Room 8 is occupied *\/\n    \\\/ (Bitcoin_in_room b7) \/* Proves that Bitcoin must be in Room 7 *\/\n\n\/\/ Loading module Cryptol\n\/\/ Cryptol> :l bat.cry \n\/\/ Loading module Cryptol\n\/\/ Loading module Main\n\/\/ Main> :prove Bitcoin_and_tiger \n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.032s, using \"Z3\")\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab6C\/linear_search_1.cry","filetype":"cry","content":"\/\/ Returns True iff elmts is a sequence whose numbers are always increasing\n\/\/ in order (all are distinct)\ninputOK : [10][16] -> [8]\ninputOK elmts = z ! 0\n  where\n    z = [1]#[ if x >= y \/\\ q == 1 then 0 else q\n            | q <- z | x <- elmts | y <- (tail elmts) ]\n\n\/\/ Returns the first location of a given key in the given list\n\/\/ or -1 (255) if the key is not in the list\nlinSearchIdx : [16] -> [10][16] -> [8]\nlinSearchIdx key xs = if (inputOK xs) == 1 then s!0 else 255\n  where\n    s = [255]#[ if (key == x \/\\ h == -1) then c else h\n              | x <- xs |  h <- s | c <- [0...]]  ","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab2C\/foxChickenCorn.cry","filetype":"cry","content":"type OneBank = [4]\ntype BankState = {left : OneBank, right: OneBank }\n\nstartState : BankState\nstartState = { left = 0b1111, right = 0b0000 }\nendState : BankState\nendState = { left = 0b0000, right = 0b1111 }\n\nsolution : [8]BankState -> Bit\nproperty solution states =\n\t(neighborsConsistent states) \/\\\n\t(allStatesSafeAndValid states) \/\\\n\t(allStatesUnique states) \/\\\n\t(states ! 0 == endState) \/\\\n\t(states @ 0 == startState)\n\n\/\/ make sure, in sequence states, that the next state in sequence can be\n\/\/ a nextState of the current state in sequence\nneighborsConsistent states = z ! 0\n  where\n    z = [True]#[ ((y == nextState x 0) \\\/\n                  (y == nextState x 1) \\\/\n\t\t\t         (y == nextState x 2)) \/\\ p\n\t            | x <- states | y <- drop `{1} states | p <- z]\n\n\/\/ if s.left is even then s.right is odd and represents the move to opposite\n\/\/ bank.  Then out.left will be s.left OR s.right masked with 0bXXX1\n\/\/ where 0bXXX is 1 << idx and out.right will be s.right masked with 0xXXX0\n\/\/ if s.right is even then s.left is odd and represents the move to opposite\n\/\/ bank.  Then out.right will be s.right OR s.left masked with 0bXXX1\n\/\/ where 0bXXX is 1 << idx and out.left will be s.left masked with 0xXXX0\nnextState : BankState -> [4] -> BankState\nnextState s idx =\n   if s.right % 2 == 1 then\n     { left = s.left || s.right && (0b0001 || (1 << (idx+1))),\n       right = s.right && 0b1110 && (~ (1 << (idx+1):[4])) }\n   else\n     { left = s.left && 0b1110 && (~ (1 << (idx+1):[4])),\n       right = s.right || s.left && (0b0001 || (1 << (idx+1))) }\n\n\/\/ True iff all states in sequence states are safe states and are valid\nallStatesSafeAndValid : {n} (fin n) => [n]BankState -> Bit\nallStatesSafeAndValid states = z ! 0\n  where\n    z = [True]#[ safeAndValidState y \/\\ x | y <- states | x <- z ]\n\n\/\/ a state is safe and valid if no bank has a number 6 or 10 and the xor of\n\/\/ both banks is 0b1111\nsafeAndValidState : BankState -> Bit\nsafeAndValidState s =\n   ~(s.left == 10 \\\/ s.left == 6 \\\/ s.right == 10 \\\/ s.right == 6) \/\\\n\ts.left ^ s.right == 0xF\n\n\/\/ returns True iff there are two or more states in sequence states that\n\/\/ are identical\nallStatesUnique states = ~(z ! 0)\n  where\n    z = [False]#[ (states@i == states@j \/\\ ~(i == j)) \\\/ k\n\t             | k <- z | i <- [0..7] , j <- [0..7] ]\n\npp states = [ xlate state | state <- states]\n\nxlate : BankState -> [51][8]\nxlate state =\n  if (state.left == 0b1111 \/\\ state.right == 0b0000) then\n     \"fox corn chicken farmer || empty                   \"\n  else if (state.left == 0b0011 \/\\ state.right == 0b1100) then\n     \"         chicken farmer || fox corn                \"\n  else if (state.left == 0b1011 \/\\ state.right == 0b0100) then\n     \"     fox chicken farmer || corn                    \"\n  else if (state.left == 0b0111 \/\\ state.right == 0b1000) then\n     \"    corn chicken farmer || fox                     \"\n  else if (state.left == 0b1100 \/\\ state.right == 0b0011) then\n     \"               fox corn || chicken farmer          \"\n  else if (state.left == 0b0000 \/\\ state.right == 0b1111) then\n     \"                  empty || fox corn chicken farmer \"\n  else if (state.left == 0b1101 \/\\ state.right == 0b0010) then\n     \"        fox corn farmer || chicken                 \"\n  else if (state.left == 0b1000 \/\\ state.right == 0b0111) then\n     \"                    fox || corn chicken farmer     \"\n  else if (state.left == 0b0010 \/\\ state.right == 0b1101) then\n     \"                chicken || fox corn farmer         \"\n  else if (state.left == 0b0100 \/\\ state.right == 0b1011) then\n     \"                   corn || fox chicken farmer      \"\n  else\n     \"                      error                        \"\n\n\ns1 = [{left = 0b1111, right = 0b0000},\n      {left = 0b1100, right = 0b0011},\n\t\t{left = 0b1101, right = 0b0010},\n\t\t{left = 0b1000, right = 0b0111},\n\t\t{left = 0b1011, right = 0b0100},\n\t\t{left = 0b0010, right = 0b1101},\n\t\t{left = 0b0011, right = 0b1100},\n\t\t{left = 0b0000, right = 0b1111}]\n\ns2 = [{left = 0b1111, right = 0b0000},\n      {left = 0b1100, right = 0b0011},\n      {left = 0b1101, right = 0b0010},\n\t\t{left = 0b0100, right = 0b1011},\n      {left = 0b0111, right = 0b1000},\n\t\t{left = 0b0010, right = 0b1101},\n      {left = 0b0011, right = 0b1100},\n\t\t{left = 0b0000, right = 0b1111}]\n\nt1 = { left=0b0100, right=0b1011 }\nt2 = { left=0b0011, right=0b1100 }\nt3 = { left=0b1001, right=0b0110 }\nt4 = { left=0b1001, right=0b0111 }\nt5 = { left=0b1111, right=0b0000 }\nt6 = { left=0b0000, right=0b1111 }\nt7 = { left=0b1011, right=0b0100 }\nt8 = { left=0b1101, right=0b0010 }","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab2C\/warmup.cry","filetype":"cry","content":"parameter\n  type w : #\n  type constraint (fin w, w <= 64, 32 <= w)\n\ntype SHAState = { h : [8][64],\n                  block : [128][8],\n                  Nl : [64],\n\t\t\t\t\t\tNh : [64],\n                  num : [32],\n\t\t\t\t\t\tmd_len : [32]\n                }\n\nstateInit : SHAState\nstateInit = { h = [1,2,3,4,5,6,7,8],\n              block = zero,\n\t\t\t\t  Nl = 11,\n\t\t\t\t  Nh = 16,\n\t\t\t\t  num = 1,\n\t\t\t\t  md_len = 128 }\n\nstateManip : SHAState -> SHAState\nstateManip s = { h = s.h,\n                 block = s.block,\n\t\t\t\t\t  Nl = s.Nl,\n\t\t\t\t\t  Nh = s.Nh,\n\t\t\t\t\t  num = s.num,\n\t\t\t\t\t  md_len = 42 }\n\nH0 : [2][w]\nH0 = [100,101]\n\nv1 : [2][32]\nv1 = [23,34]\n\ntype v2 = [2][32]\nv2 = [23,34]\n","variant":"hybrid","set":"supervised"}
{"filename":"SAW-course\/src\/lab2C\/solutions.cry","filetype":"cry","content":"import Float\n\ntype Circle = { radius : Rational, left : Float16, top : Float16 }\ntype Displacement = { left : Float16, top : Float16 }\n\naCircle : Circle\naCircle = { radius=(ratio 5 2), left=20, top=16}\n\nareaCircle : Circle -> Rational\nareaCircle b = (b.radius * b.radius * (ratio 355 113))\n\nc = areaCircle { radius=(ratio 5 2), left=0, top=0 }\n\naCircleArea = areaCircle aCircle\n\nnudgeCircle : Circle -> Displacement -> Circle\nnudgeCircle circle d =\n   { radius = circle.radius, left = circle.left+d.left, top = circle.top+d.top }\n\ndisp : Displacement\ndisp = { left= 12, top=2 }\n\nnewDisp : Displacement \nnewDisp = { left = -32, top=2 }\n\nmovedaCircle = nudgeCircle aCircle disp\nsecondTry = nudgeCircle aCircle newDisp\n\ntype BMI = { weight : Float16, height : Float16 }\ntype BMIimp = { weight : Float16, feet : Float16, inches : Float16 }\n\ncalcBMI : BMI -> Float16\ncalcBMI bmi = bmi.weight \/. bmi.height \/. bmi.height * 10000\n\ncalcBMIimp : BMIimp -> Float16\ncalcBMIimp bmi = bmi.weight \/. (bmi.feet*12+bmi.inches) \/. (bmi.feet*12+bmi.inches) * 703\n\nt1 = { weight=80, height=174 }\nt2 = { weight=180.0, feet=5.0, inches=8.5 }\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab2D\/perm.cry","filetype":"cry","content":"\/\/ Determine if two input sequences are a permutation\n\/\/ See solution.pdf for an explanation\nremove lst n = drop `{2} [w.0 | w <- res]\n  where\n    res = [(-1,False)]#[ if (q.1 == False \/\\ ~(za == n)) then (za, q.1)\n                                                         else (zb, True)\n                       | za <- [-1]#lst | zb <- lst#[-1] | q <- res ]\n\/\/ instead of explanation I give three examples of progression of res:\n\/\/ res output on remove [2,5,3,7,3,2,0,3] 7\n\/\/ [(-1, False), (-1, False), (2, False), (5, False), (3, False),\n\/\/  (3, True), (2, True), (0, True), (3, True), (-1, True)\n\/\/\n\/\/ res output on remove [2,5,3,7,3,2,0,3] 9\n\/\/ [(-1, False), (-1, False), (2, False), (5, False), (3, False),\n\/\/  (7, False), (3, False), (2, False), (0, False), (3, False)]\n\/\/\n\/\/ res output on remove [2,5,3,7,3,2,0,3] 3 (only the 1st 3 is removed:\n\/\/ reason for Bit)\n\/\/ [(-1, False), (-1, False), (2, False), (5, False), (7, True),\n\/\/  (3, True), (2, True), (0, True), (3, True), (-1, True)]\n\n\/\/ See solution.pdf for an explanation\nmember lst n = (res ! 0)\n  where\n    res = [False]#[ ss \\\/ (p == n) | p <- lst | ss <- res ]\n\n\/\/ See solution.pdf for an explanation\nperm x y = if (length x) == 0 \/\\ (length y) == 0 then True else\n           if (length x) == (length y) then (res ! 0).1 else False\n  where\n    res = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n          | q <- [(y,True)]#res | p <- x ]\n\nres00 = perm [] []\nres01 = perm [] [1]\nres02 = perm [1] []\nres03 = perm [1] [0]\nres04 = perm [1] [1]\nres05 = perm [1,1,2] [2,1,2]\nres06 = perm [1,2,3] [1,2,3,3]\nres07 = perm [3,2,1] [1,3,2]\nres08 = perm [1,2,3,4] [1,2,3]\nres09 = perm [1,2,3,3] [1,2,3]\nres10 = perm [11,44,23,82,66,91,42,41,63,72,82,12,16,21,91,72,71]\n             [44,91,72,11,71,42,12,63,16,23,91,82,21,72,41,82,66]\nres11 = perm [11,44,23,82,66,91,42,41,63,72,82,12,16,21,91,72,71]\n             [44,71,72,11,71,42,12,63,16,23,91,82,21,72,41,82,66]\nres12 = perm [97] ['a']\n\n\/\/ Use :s base=2 to see the results\nresults = [res00, res01, res02, res03, res04, res05, res06, res07,\n           res08, res09, res10, res11, res12]\n","variant":"hybrid","set":"holdout"}
{"filename":"SAW-course\/src\/lab2D\/racetrack.cry","filetype":"cry","content":"\/\/ There are a number of fueling stations located at various points around\n\/\/ a race circuit. Suppose the amount of fuel at each fueling station is\n\/\/ different but that the total fuel around the circuit is exactly what is\n\/\/ needed by a race car to make one complete circuit.\n\/\/\n\/\/ Find the point on the circuit from which a race car with an empty tank\n\/\/ may make one complete circuit without running out of fuel by tanking\n\/\/ up at every fueling station in the circuit. Assume the tank is large\n\/\/ enough to hold enough fuel to complete the circuit.\n\n\/\/ location of fueling stations is the percentage of total circuit distance\n\/\/ from the 'starting line'.  Ratios are all less than (ratio 1 1) and\n\/\/ are progressively increasing.\nloc = [ (ratio 2 10), (ratio 3 10), (ratio 45 100), (ratio 49 100),\n        (ratio 71 100), (ratio 78 100), (ratio 81 100), (ratio 98 100)]\n\n\/\/ amount of fuel at each fueling station is a percentage of total fuel\n\/\/ in all fueling stations\ngas = [ (ratio 1 10), (ratio 13 100), (ratio 1 10), (ratio 15 100),\n        (ratio 23 100), (ratio 7 100), (ratio 17 100), (ratio 5 100)]\n\n\/\/ State: (fuel_seen, fuel_deficit, best_station_so_far)\ns = [(0,0,-1)]#[(if (ps-ss.0 > ss.1) then (ss.0+fs, ps-ss.0, i)\n                                     else (ss.0+fs,ss.1,ss.2))\n               | fs <- gas | ps <- loc | ss <- s | i <- [0 ...]]\n\nstation = (s ! 0).2\nstation_location = loc @ station\n\n\/\/ ps = % of track covered\n\/\/ ss.0 = % of fuel seen\n\/\/ ps-ss.0 is the fuel deficit \n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab2D\/comprehensions.cry","filetype":"cry","content":"\/\/ Simple example of a comprehension\nv01 = [x | x <- [1...] | y <- [1..10]]\n\/\/ v01 is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n\/\/ Note: x and y take values interactively and simultaneously.  x is\n\/\/ taken from an infinite list but the comprehension is controlled\n\/\/ by y as it runs out of tokens after receiving value 10.\n\nv02 = [ (x,y) | x <- [10..12] , y <- [1..4]]\n\/\/ v02 is [(10, 1), (10, 2), (10, 3), (10, 4), (11, 1), (11, 2),\n\/\/         (11, 3), (11, 4), (12, 1), (12, 2), (12, 3), (12, 4)]\n\/\/ Note: pairs are constructed from all possible combinations\n\/\/ of values of x between 10 and 12 and y between 1 and 4.\n\nv03 = [ (x,y,z) | x <- [10,11] , y <- [20,21], z <- [30,31]]\n\/\/ v03 is [(10, 20, 30), (10, 20, 31), (10, 21, 30), (10, 21, 31),\n\/\/         (11, 20, 30), (11, 20, 31), (11, 21, 30), (11, 21, 31)]\n\/\/ Note: all possible triples from values taken by x, y, and z\n\nv04 = [ (x,y,z) | x <- [10,11] , y <- [20,21] | z <- [30,31,32]]\n\/\/ v04 is [(10, 20, 30), (10, 21, 31), (11, 20, 32)]\n\/\/ Note: the rightmost | controls the number of triples output\n\nv05 = [1]#[ x+y | x <- v05 | y <- [1]#v05 ]\nv06 = take `{10} v05\n\/\/ v05 is an infinite sequence [1, 2, 3, 5, 8, ...] of Fibonaccis\n\/\/ v06 is a finite subsequence of 10 of the first 10 of those\n\/\/ Note: as v05 is being constructed, it is used inside the\n\/\/ comprehension to construct the next element of the sequence v05\n\n\/\/ Pigeon hole formulas - set base=10\nph = [1,1,1,0,1,2,2,1,1]  \/\/ shows number of pigeons in each of 9 holes\nv07 = [0]#[ x+y | x <- ph | y <- v07 ]  \/\/ sum all holes to get # pigeons\nv08 = v07 ! 0 \/\/ number of pigeons is last State\n\/\/ v07 is [0, 1, 2, 3, 3, 4, 6, 8, 9, 10]\n\/\/ v08 is 10\n\n\/\/ Condition that no hole has > 1 pigeon - set base=2\nv09 = [True]#[ (x <= 1) \/\\ y | x <- ph | y <- v09 ]\nv10 = v09 ! 0\n\/\/ v09 is 0b1111110000\n\/\/ v10 is False meaning at least one hole has more than one pigeon\n\n\/\/ The following reverses a sequence\nlst = [16,42,23,77]\nv11 = [lst] # [[b]#(tail (a >> 1)) | a <- v11 | b <- lst ]\nv12 = v11 ! 0\n\/\/ v11 is [[16, 42, 23, 77], [16, 16, 42, 23], [42, 16, 16, 42],\n\/\/         [23, 42, 16, 16], [77, 23, 42, 16]]\n\/\/ v12 is [77, 23, 42, 16]\n\n\/\/ Creates a list of 16 numbers, beginning with the first one, p,\n\/\/ as input, doubled, then followed by numbers that are double the\n\/\/ previous one.\np = 3\nv13 = [ 2*lr | lr <- [p] # v13 | k <- [1 .. 16]]\n\/\/ v13 is [6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144,\n\/\/         12288, 24576, 49152, 98304, 196608]\n\n\/\/ An infinite version of the above\nv14 = [2*lr | lr <- [p] # v14 | k <- [1...]]\nv15 = take `{12} v14\n\/\/ v14 is [6, 12, 24, 48, 96, ...]\n\/\/ v15 is [6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144, 12288]\n\n\/\/ Race course problem, location and fuel\n\/\/ loc: percentage of racetrack from a starting point for each\n\/\/      fueling station.  All ratios are less than 1\n\/\/ gas: percentage of total fuel needed to traverse course at\n\/\/      each station.  Sum of all ratios is 1\nloc = [(ratio 2 10),(ratio 3 10),(ratio 45 100),(ratio 49 100),\n       (ratio 71 100),(ratio 78 100),(ratio 81 100),(ratio 98 100)]\ngas = [(ratio 1 10),(ratio 13 100),(ratio 1 10),(ratio 15 100),\n       (ratio 23 100),(ratio 7 100),(ratio 17 100),(ratio 5 100)]\ngas_sum = sum gas\n\/\/ gas_sum is (ratio 1 1)\nv16 = [(0,0,-1)]#[(if (ps-ss.0 > ss.1) then (ss.0+fs, ps-ss.0, i)\n                                       else (ss.0+fs, ss.1, ss.2))\n                 | fs <- gas | ps <- loc | ss <- v16 | i <- [0 ...]]\nstation_to_start_from = (v16 ! 0).2\nlocation_of_station = loc @ station_to_start_from\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab2D\/solutions.cry","filetype":"cry","content":"\/\/ Find the maximum number in lst and return a tuple with that\n\/\/ number on the left and its first occurrence in lst from the\n\/\/ left on the right.  Note: fmax [] returns (-1,-1) as expected.\nfmax lst = (res ! 0).0\n  where\n    res = [(-1,-1)]#[ if (ss.0 < p) then (p,i) else ss\n                    | p <- lst | ss <- res | i <- [0...]]\n\n\/\/ Returns True if n is a member of sequence lst, otherwise\n\/\/ returns False.  member [] 4 returns False as expected.  \n\/\/ Elements of lst must be non-negative.\nmember lst n = (res ! 0)\n  where\n    res = [False]#[ s \\\/ (p == n) | p <- lst | s <- res ]\n\n\/\/ If n is a member of lst return lst with the first occurrence\n\/\/ of n in lst removed and -1 appended to the end of the output\n\/\/ sequence.  Without the -1 appended some output sequences would\n\/\/ be shorter than others and that constitutes a type mismatch\n\/\/ in Cryptol.  Note: remove [] 3 returns [] as expected.\nremove lst n = drop `{2} [w.0 | w <- res]\n  where\n    res = [(-1,False)]#[ if (q.1==False \/\\ ~(za == n)) then (za, q.1)\n                                                       else (zb, True)\n          | za <- [-1]#lst | zb <- lst#[-1] | q <- res ]\n\n\/\/ Returns True if x and y are permutations and False otherwise.\n\/\/ Note: in this version x and y are required to have the same\n\/\/ length which must be greater than 0.  Negative numbers are\n\/\/ permitted.\nperm x y = (res ! 0).1\n  where\n    res = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n          | q <- [(y,True)]#res | p <- x ]\n\n\/\/ Returns True iff input sequence is in non-decreasing order\n\/\/ Note: does not work on empty sequences\nnondecreasing lst = (res ! 0)\n  where \n    res = [True]#[ if (j1 <= j2) \/\\ k then True else False\n                 | k <- res | j1 <- lst | j2 <- drop `{1} lst]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab2E\/perm.cry","filetype":"cry","content":"module perm where\n\nremove : {n, a} (Eq a, Ring a, Literal 1 a, fin n) => [n]a -> a -> [n]a\nremove lst n = drop `{2} [w.0 | w <- res]\n  where\n    res = [(-1,False)]#[ if (q.1 == False \/\\ ~(za == n)) then (za, q.1)\n                                                         else (zb, True)\n                       | za <- [-1]#lst | zb <- lst#[-1] | q <- res ]\n\nmember : {n, a} (Eq a, fin n) => [n]a -> a -> Bit\nmember lst n = (res ! 0)\n  where\n    res = [False]#[ ss \\\/ (p == n) | p <- lst | ss <- res ]\n\nperm :\n  {n, m, a} (Literal 1 a, Ring a, Eq a, fin n, fin m) => [n]a -> [m]a -> Bit\nperm x y = if (length x) == 0 \/\\ (length y) == 0 then True else\n           if (length x) == (length y) then (res ! 0).1 else False\n  where\n    res = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n          | q <- [(y,True)]#res | p <- x ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab2E\/bsort.cry","filetype":"cry","content":"module bsort where\nimport perm\n\n\/\/ bbl takes a literal n and an ordered sequence seq and places n in seq\n\/\/ so that seq remains ordered.  If seq is empty [n] (plus padding) is\n\/\/ returned. If n is less than the first element of seq then n is added\n\/\/ to the beginning of seq.  Otherwise bbl is called recursively and\n\/\/ returns an ordered sequence whereupon the 1st literal of seq is\n\/\/ prepended to the result and returned.\n\/\/ bb takes a padded sequence as input and recursively calls bbl where\n\/\/ n is the first literal of the input sequence.  The recursion sets up\n\/\/ a stack of literals to add to the output list and begins to establish\n\/\/ an output list when the input to seq is only the padding.  Thus, when\n\/\/ the stacked literals are ready to be added to the output list, what\n\/\/ they are added to is ordered and will remain ordered as stacked\n\/\/ literals are added to seq.\n\/\/ bsort just calls bb on the padded input sequence.  The output of bb\n\/\/ is trimmed by take.\nbsort : {n, a} (Cmp a, Integral a, Literal 1 a, fin n) => [n]a -> [n]a\nbsort lst = take `{n} (bb (lst#[-1,-1...]))\n  where\n    bb seq = if (seq@0) == -1 then seq else (bbl (head seq) (bb (tail seq)))\n    bbl n seq =\n      if ((seq@0) == -1) then [n]#[-1,-1...]\n      else if (n < (seq@0)) then [n]#seq\n      else [(seq@0)]#(bbl n (tail seq))\n\nvalid lst = z ! 0\n  where\n    z = [True]#[~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [16][4] -> Bit\nproperty isAPerm lst = ~(valid lst) \\\/ (perm lst (bsort lst))\n\/\/property isAPerm lst = if (valid lst) then (perm lst (bsort lst)) else True\n\nres00 = bsort []\nres01 = bsort [1]\nres02 = bsort [2,1]\nres03 = bsort [1,2]\nres04 = bsort [7,3,2,8,1,9,2,3,4,1,8,9,4,2,3]\nres05 = bsort [0,0,0,0,1,1,1,1,2,2,2,2,3,3,3]\nres06 = bsort [3,3,3,2,2,2,2,1,1,1,1,0,0,0,0]\n\n","variant":"hybrid","set":"supervised"}
{"filename":"SAW-course\/src\/lab2E\/mrgsrt.cry","filetype":"cry","content":"module mrgsrt where\n\nremove lst n = drop `{2} [w.0 | w <- res]\n  where\n    res = [(-1,False)]#[ if (q.1 == False \/\\ ~(za == n)) \n                         then (za, q.1)\n                         else (zb, True)\n                       | za <- [-1]#lst | zb <- lst#[-1] | q <- res ]\n\nmember lst n = (res ! 0)\n  where\n    res = [False]#[ ss \\\/ (p == n) | p <- lst | ss <- res ]\n\nperm x y = if (length x) == 0 \/\\ (length y) == 0 then True else\n           if (length x) == (length y) then (res ! 0).1 else False\n  where\n    res = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n          | q <- [(y,True)]#res | p <- x ]\n\n\/************************************************************************\/\n\/*  The goal of this page:                                              *\/\n\/*    Show how a specification of an operation on finite lists          *\/\n\/*    can be expressed recursively by switching to infinite lists       *\/\n\/*    and back                                                          *\/\n\/*  Define mergesort on lists of positive numbers and prove correctness *\/\n\/************************************************************************\/\n\/* Mergesort - but only for positive numbers \n   subfunctions operate on infinite lists to allow for recursion\n   subfunctions are as follows:\n   splito: \n     Input - lst=finite list\n     Output - infinite list, padded with -1s after the split elements\n     Process: best described as [ lst@i | i <- [1,3...] ]\n   splite:\n     Input - lst=finite list\n     Output - infinite list, padded with -1s after the split elements\n     Process: best described as [ lst@i | i <- [0,2...] ]\n   merge:\n     Inputs: px, py - two infinite lists in nondecreasing order (padded with -1s)\n     Output: infinite list, nondecreasing, containing all of px & py, padded\n     Process: merge two padded infinite lists, up to the padding\n     if px@0 is -1 then return py, if py@0 is -1 then return px\n     otherwise if px@0 is less than py@0 concat px@0 with (merge (tail(px) py)\n     otherwise concat py@0 with (merge px (tail py))\n   mergesrt:\n     Input: p=infinite list (padded)\n     Output: padded, nondecreasing infinite list that is a permutation of x\n     Process: sort list p up to the padding\n     recursively merge the mergesrt of the even elements of p with the mergesrt\n     of the odd elements of p\n*\/\n\n\/\/  Input: lst - -1 padded finite sequence of numbers\n\/\/  Output: lst with only odd indexed elements followed by -1 padding\nsplito : {n,a} [n]a -> [inf]a\nsplito lst = [ lst@i | i <- [1,3...] ]\n\n\/\/  Input: lst - -1 padded finite sequence of numbers\n\/\/  Output: lst with only even indexed elements followed by -1 padding\nsplite : {n,a} [n]a -> [inf]a\nsplite lst = [ lst@i | i <- [0,2...] ]\n\n\/\/  Inputs: px, py: two infinite lists in nondecreasing order (padded with -1s)\n\/\/  Output: infinite list, nondecreasing, containing all of px and py, padded\nmerge : {a} (Literal 1 a, Ring a, Cmp a) => [inf]a -> [inf]a -> [inf]a\nmerge px py = \n      if px@0 == -1 then py\n      else if py@0 == -1 then px\n      else if px@0 < py@0 then [px@0]#(merge (tail px) py)\n      else [py@0]#(merge px (tail py))\n\n\/\/  Input: finite sequence lst of numbers\n\/\/  Output: finite nondecreasing sequence of numbers that is permutation of lst\nmergesort : {cnt, a} (fin cnt, fin a, a >= 1, cnt >= 0) => [cnt][a] -> [cnt][a]\nmergesort lst = take `{cnt} (mergesrt ax)\n  where\n    mergesrt p = \n      if (p@0 == -1) \\\/ (p@1 == -1) then p\n      else merge (mergesrt (splite p)) (mergesrt (splito p))\n    ax = lst#[-1,-1 ...]\n\nres00 = take `{3} (splite [1,2,3,4,5,6])\nres01 = take `{3} (splite [1,2,3,4,5,6,7])\nres02 = take `{4} (splite [1,2,3,4,5,6,7,8])\n\nres10 = take `{3} (splito [1,2,3,4,5,6])\nres11 = take `{4} (splito [1,2,3,4,5,6,7])\nres12 = take `{4} (splito [1,2,3,4,5,6,7,8])\n\nres20 = take `{8} (merge ([1,5,7,10]#[-1,-1 ...]) ([3,7,11,14]#[-1,-1 ...]))\n\nres30 = mergesort [6,7,8,2,3,4,1,11,23,5]\nres31 = mergesort [1]\nres32 = mergesort [2,2]\nres33 = mergesort [2,1]\nres34 = mergesort [9,8,7,6,5,4,3,2,1]\nres35 = mergesort [9,8,7,6,5,4,3,2,1,6]\nres36 = mergesort [9,8,7,6,5,4,3,2,1,6,10]\nres37 = mergesort [9,8,7,6,5,4,3,2,10,6,1]\nres38 = mergesort [1,9,8,7,6,5,4,3,2,1,6]\nres39 = mergesort [10,9,8,7,6,5,4,3,2,1,6]\n\nresults = [take `{11} (res30#[-1,-1...]),\n           take `{11} (res31#[-1,-1...]),\n\t\t\t  take `{11} (res32#[-1,-1...]),\n\t\t\t  take `{11} (res33#[-1,-1...]),\n\t\t\t  take `{11} (res34#[-1,-1...]),\n\t\t\t  take `{11} (res35#[-1,-1...]),\n\t\t\t  take `{11} (res36#[-1,-1...]),\n\t\t\t  take `{11} (res37#[-1,-1...]),\n\t\t\t  take `{11} (res38#[-1,-1...]),\n\t\t\t  take `{11} (res39#[-1,-1...])]\n\nvalid lst = z ! 0\n  where\n    z = [True]#[~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst = if valid lst then perm lst (mergesort lst) else True\n\nnondecreasing lst = (res ! 0)\n  where\n    res = [True]#[ if (j1 <= j2) \/\\ k then True else False\n                 | k <- res | j1 <- lst | j2 <- drop `{1} lst]\n\nmergesortIsOrdered : [6][32] -> Bit\nproperty mergesortIsOrdered lst =\n   if valid lst then nondecreasing (mergesort lst) else True\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab2E\/caesar.cry","filetype":"cry","content":"\/* A simple caesar cipher\n   Rotate the ascii table by a fixed amount (s) and index into the remapped\n   ascii table by the input character to compute the ciphertext\n   In this version the ascii table is shrunk to 95 printable characters\n   so to decrypt use 95-s *\/\n\/*\n  Rotate the ascii table from ' ' to '~'  by s positions\n  Examples: map 0 = [32,33,34,...,124,125,126]\n            map 1 = [33,34,35,...,125,126,32]\n            map 2 = [34,35,36,...,126,32,33]\n            map 64 = [96,97,98,...,93,94,95]\n*\/\nrot s = [' ' .. '~'] <<< s\n\nshift c key = (rot key) @ (c - ' ')\n\ncaesar key msg = [ shift c key | c <- msg ]\n\n\/\/ enc:[_][8]\nenc = caesar 11 \"How Now Brown Cow\"\nenc_ascii = show (enc)\n\n\/\/ dec:[_][8]\ndec = caesar 84 enc\ndec_ascii = show (caesar (95-11) enc)\n\nshow s = [ c:Char | c <- s]\n\n\/\/ Prove it works for messages up to 256 chracters long -\n\/\/ :s prover=abc\n\/\/ :prove itWorks\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 8.091s, using \"ABC\")\nitWorks : [512][8] -> [8] -> Bit\nproperty itWorks pt key = (caesar (95-key) (caesar key pt)) == pt\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab2E\/hamming.cry","filetype":"cry","content":"\/\/ Hammings problem - given primes list in increasing order, find all\n\/\/ numbers whose prime factors are all in the primes list.\n\n\/\/ multiply all integers of a stream by a scalar - input is a stream s\n\/\/ of integers and a number m.  Output is a stream such that each number\n\/\/ is m times its corresponding number in the input stream.\ntimes s m = [(s@0)*m]#times (tail s) m\n\n\/\/ merge two streams of integers - input is two integer streams in\n\/\/ increasing order.  Output is single stream in increasing order, all\n\/\/ output tokens exist in input streams.\nmerge x y = if (x@0) < (y@0) then [x@0]#merge (tail x) y\n                             else [y@0]#merge x (tail y)\n\n\/\/ compute the hamming sequence for a given set of prime numbers.  The\n\/\/ input list of primes is in increasing order.\nhamming primes = ham primes 0\n  where \n    ham p idx =\n      if ((length p) == 0) then [-1,-1...]\n      else if (length p)-1 == idx then\n           [p @ idx] # times (ham p idx) (p@idx)\n      else\n           [p @ idx] # merge (times (ham p idx) (p@idx)) (ham p (idx+1))\n\nhamGood : [64] -> [100][64] -> Bit  \/* no output number is multiple of 7 *\/\nproperty hamGood x y = \n  ~((x <= 99) \/\\ (y == (take `{100} (hamming [3,5,11])))) \\\/ ~((y@x)%7 == 0)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab2E\/coins.cry","filetype":"cry","content":"\/\/ The puzzle goes like this:\n\/\/ You've got n coins that add up to s cents - what are they?\n\/\/ Use currying - for this example #coins is 30, total sum is 109 cents\n\ncoinPuzzle : [10] -> [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinPuzzle n s a b c d =\n  (coinCount a b c d n) \/\\ (coinSum a b c d n s) \/\\ (n < 100) \/\/ avoid overflow\n\ncoinSum a b c d n s =\n  ((a + 5*b + 10*c + 25*d) == s) \/\\ (n <= s)\n\ncoinCount a b c d n =\n  (((a + b + c + d) == n) \/\\       \/\/ the coin count adds up to requested n\n                                   \/\/ number coins of any type doesn't exceed n\n   (a <= n \/\\ b <= n \/\\ c <= n \/\\ d <= n))  \n\ncheck a b c d = a*1 + b*5  + c*10 + d*25\n\n\/\/ run it like this:\n\/\/ Main> :set base=10\n\/\/ Main> :set satNum = all\n\/\/ Main> :sat coinPuzzle 30 109\n\/\/ Satisfiable\n\/\/ coinPuzzle 30 109 19 7 3 1 = True\n\/\/ coinPuzzle 30 109 24 1 3 2 = True\n\/\/ coinPuzzle 30 109 14 13 3 0 = True\n\/\/ coinPuzzle 30 109 19 4 7 0 = True\n\/\/ Models found: 4\n\/\/ (Total Elapsed Time: 0.055s, using \"Z3\")\n","variant":"hybrid","set":"unsupervised"}
{"filename":"SAW-course\/src\/lab2B\/tests.cry","filetype":"cry","content":"\/* a permutation *\/\ntes1 x = [ x@i | i <- [0,3,2,1,4] ]\nres00 = tes1 [1,2,3,4,5]\n\nallButLast : {a, b} [1 + b]a -> [b]a\nallButLast x = [ a | a <- x | i <- (tail x) ]\n\nres01 = allButLast [1,2,3,4,5]\n\n\/* reverse a sequence *\/\nrev : {a, b} (fin b) => [1 + b]a -> [1 + b]a\nrev x = (z!0)\n  where \n    z = [x]#[ [b]#(allButLast a) | b <- x | a <- z ]\n\nres02 = rev [1,2,3,4,5,6,7]\n\n\/* Create a list of 16 numbers, beginning with the first one as input\n   doubled, then followed by numbers that are double the previous one \n   in the list  *\/\nfunky_0: [32] -> [16][32]\nfunky_0 x = iv\n   where iv = [ 2*lr | lr <- [x] # iv | k  <- [1 .. 16] ]\n\nres03 = funky_0 2\n\n\/* Slight variation on the one above the first number is not doubled *\/\nfunky_1: [32] -> [16][32]\nfunky_1 x = [x]#iv\n   where iv = [ 2*lr | lr <- [x] # iv | k  <- [1 .. 15] ]\nres04 = funky_1 2\n\n\/* Infinite version of above *\/\nfunky_2: [32] -> [inf][32]\nfunky_2 (x) = [x]#iv\n  where iv  = [ 2*lr | lr <- [x] # iv | k  <- [1 ...] ]\n\nres05 = funky_2 2\n\n\/* The ith term in the output list is the sum of input terms from index 0 to\n   index i.  Hence [1 4 8 17] -> [1 5 13 30]  (superincreasing sequence) *\/\nsum_0 xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\nres06 = sum_0 [1,2,3,4,5]\n\nsum_1 xs = ys\n  where ys = [ x + y | x <- ys | y <- [0] # ys ]\n\nres07 = sum_1 [1,2,3,4,5]\n\n\/* Fibonnaci numbers *\/\n\/*   1 1 2 3  5  8 13 21 ...   y <- [1 1] # ys\n     1 2 3 5  8 13 21 ...      x <- [1] # ys\n    --------------------------------------------\nys = 2 3 5 8 13 21 34 ...      ys    *\/\n\nfib_1 = take `{100} ([1,1]#ys)\n  where \n    ys = [ x+y | x <- ([1]:[1][256])#ys | y <- ([1,1]:[2][256])#ys ]\n\n\n\/* Fibonnaci numbers - Wow! only n numbers are pulled!! *\/\nfib_2: [256]->[256]\nfib_2 n = (([1,1]#ys)@(n-1))\n  where \n    ys = [ x+y | x <- [1]#ys | y <- [1,1]#ys ]\n\nres08 = fib_2 100\n\n\/* split splits as needed!! *\/\nres09:[2][24]\nres09 = split(0x570248D00425)  \/* [0x48d00425,0x00005702]       *\/\nres10:[4][12]\nres10 = split(0x570248D00425)  \/* [0x0425,0x48d0,0x5702,0x0000] *\/\nres11:[8][6]\nres11 = split(0x570248D00425)  \/* [0x25,0x04,0xd0,0x48,0x02,0x57,0x00,0x00] *\/\nres12:[2][2][12]\nres12 = split(split(0x570248D00425))  \/* [[0x0425,0x48d0] [0x5702,0x0000]]  *\/\n\nsbox1 : [4][16][4]\nsbox1 = [[14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7],\n         [ 0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8],\n         [ 4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0],\n         [15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13]\n        ]\ns1 = sbox1 @ [True,True]   @ [True,True,True,True]\ns2 = sbox1 @ [True,True]   @ [False,True,True,True]\ns3 = sbox1 @ [True,True]   @ [True,False,True,True]\ns4 = sbox1 @ [True,True]   @ [False,False,True,True]\ns5 = sbox1 @ [False,True]  @ [True,True,True,True]\ns6 = sbox1 @ [True,False]  @ [True,True,True,True]\ns7 = sbox1 @ [False,False] @ [True,True,True,True]\ns8 = reverse(s7)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-demos\/cryptol-specs\/Common\/utils.cry","filetype":"cry","content":"module Common::utils where\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\nmul2 x = x + x\nmul3 x = x + mul2 x\nmul4 x = mul2(mul2 x)\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = if isEven (fromZ x) then x\/2 else (fromInteger ((fromZ x + `p) \/ 2))\n\nmp_mod_inv : {a} (fin a, a >= 1) => Z a -> Z a\nmp_mod_inv c = if c == 0 then error \"Zero does not have a multiplicative inverse\"\n               else fromInteger (if u'' == 1 then x1'' else x2'')\n  where\n    innercond (a, x) = isEven a\n    innerbody (a, x) = (a \/ 2, if isEven x then x \/ 2 else (x + `a) \/ 2)\n\n    outtercond (u, v, x1, x2) = (u != 1) \/\\ (v != 1)\n    outterbody (u, v, x1, x2) = if(u' >= v') then (u' - v', v', x1' - x2' % `a, x2')\n                                             else (u', v' - u', x1', x2' - x1' % `a)\n      where\n        (u', x1') = while innercond innerbody (u, x1)\n        (v', x2') = while innercond innerbody (v, x2)\n\n    (u'', _, x1'', x2'') = while outtercond outterbody (fromZ c, `a, 1, 0)\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES.cry","filetype":"cry","content":"\/\/ This is a fairly close implementation of the FIPS-197 standard:\n\/\/   http:\/\/csrc.nist.gov\/publications\/fips\/fips197\/fips-197.pdf\n\n\/\/ Nk: Number of blocks in the key\n\/\/ Must be one of 4 (AES128), 6 (AES192), or 8 (AES256)\n\/\/ Aside from this line, no other code below needs to change for\n\/\/ implementing AES128, AES192, or AES256\nmodule Primitive::Symmetric::Cipher::Block::AES where\n\ntype AES128 = 4\ntype AES192 = 6\ntype AES256 = 8\n\ntype Nk = AES128\n\n\/\/ For Cryptol 2.x | x > 0\n\/\/ NkValid: `Nk -> Bit\n\/\/ property NkValid k = (k == `AES128) || (k == `AES192) || (k == `AES256)\n\n\/\/ Number of blocks and Number of rounds\ntype Nb = 4\ntype Nr = 6 + Nk\n\ntype AESKeySize  = (Nk*32)\n\n\/\/ Helper type definitions\ntype GF28        = [8]\ntype State       = [4][Nb]GF28\ntype RoundKey    = State\ntype KeySchedule = (RoundKey, [Nr-1]RoundKey, RoundKey)\n\/\/ GF28 operations\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Mult : (GF28, GF28) -> GF28\ngf28Mult (x, y) = pmod(pmult x y) irreducible\n\ngf28Pow : (GF28, [8]) -> GF28\ngf28Pow (n, k) = pow k\n  where   sq x  = gf28Mult (x, x)\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult(n, sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow (x, 254)\n\ngf28DotProduct : {n} (fin n) => ([n]GF28, [n]GF28) -> GF28\ngf28DotProduct (xs, ys) = gf28Add [ gf28Mult (x, y) | x <- xs\n                                                    | y <- ys ]\n\ngf28VectorMult : {n, m} (fin n) => ([n]GF28, [m][n]GF28) -> [m]GF28\ngf28VectorMult (v, ms) = [ gf28DotProduct(v, m) | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => ([n][m]GF28, [m][k]GF28) -> [n][k]GF28\ngf28MatrixMult (xss, yss) = [ gf28VectorMult(xs, yss') | xs <- xss ]\n   where yss' = transpose yss\n\n\/\/ The affine transform and its inverse\nxformByte : GF28 -> GF28\nxformByte b = gf28Add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n   where c = 0x63\n\nxformByte' : GF28 -> GF28\nxformByte' b = gf28Add [(b >>> 2), (b >>> 5), (b >>> 7), d] where d = 0x05\n\/\/ The SubBytes transform and its inverse\nSubByte : GF28 -> GF28\nSubByte b = xformByte (gf28Inverse b)\n\nSubByte' : GF28 -> GF28\nSubByte' b = sbox@b\n\nSubBytes : State -> State\nSubBytes state = [ [ SubByte' b | b <- row ] | row <- state ]\n\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = gf28Inverse (xformByte' b)\n\nInvSubBytes : State -> State\nInvSubBytes state = [ [ InvSubByte b | b <- row ] | row <- state ]\n\n\/\/ The ShiftRows transform and its inverse\nShiftRows : State -> State\nShiftRows state = [ row <<< shiftAmount | row <- state\n                                        | shiftAmount <- [0 .. 3]\n                  ]\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> shiftAmount | row <- state\n                                           | shiftAmount <- [0 .. 3]\n                     ]\n\n\/\/ The MixColumns transform and its inverse\nMixColumns : State -> State\nMixColumns state = gf28MatrixMult (m, state)\n    where m = [[2, 3, 1, 1],\n               [1, 2, 3, 1],\n               [1, 1, 2, 3],\n               [3, 1, 1, 2]]\n\nInvMixColumns : State -> State\nInvMixColumns state = gf28MatrixMult (m, state)\n    where m = [[0x0e, 0x0b, 0x0d, 0x09],\n               [0x09, 0x0e, 0x0b, 0x0d],\n               [0x0d, 0x09, 0x0e, 0x0b],\n               [0x0b, 0x0d, 0x09, 0x0e]]\n\n\/\/ The AddRoundKey transform\nAddRoundKey : (RoundKey, State) -> State\nAddRoundKey (rk, s) = rk ^ s\n\/\/ Key expansion\nRcon : [8] -> [4]GF28\nRcon i = [(gf28Pow (<| x |>, i-1)), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte' b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nNextWord : ([8],[4][8],[4][8]) -> [4][8]\nNextWord(i, prev, old) = old ^ mask\n   where mask = if i % `Nk == 0\n                then SubWord(RotWord(prev)) ^ Rcon (i \/ `Nk)\n                else if (`Nk > 6) \/\\ (i % `Nk == 4)\n                     then SubWord(prev)\n                     else prev\n\n\nExpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nExpandKeyForever seed = [ transpose g | g <- groupBy`{4} (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord(i, prev, old)\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\nExpandKey : [AESKeySize] -> KeySchedule\nExpandKey key = (keys @ 0, keys @@ [1 .. (Nr - 1)], keys @ `Nr)\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = ExpandKeyForever seed\n\nfromKS : KeySchedule -> [Nr+1][4][32]\nfromKS (f, ms, l) = [ formKeyWords (transpose k) | k <- [f] # ms # [l] ]\n    where formKeyWords bbs = [ join bs | bs <- bbs ]\n\n\/\/ AES rounds and inverses\nAESRound : (RoundKey, State) -> State\nAESRound (rk, s) = AddRoundKey (rk, MixColumns (ShiftRows (SubBytes s)))\n\nAESFinalRound : (RoundKey, State) -> State\nAESFinalRound (rk, s) = AddRoundKey (rk, ShiftRows (SubBytes s))\n\nAESInvRound : (RoundKey, State) -> State\nAESInvRound (rk, s) =\n      InvMixColumns (AddRoundKey (rk, InvSubBytes (InvShiftRows s)))\nAESFinalInvRound : (RoundKey, State) -> State\nAESFinalInvRound (rk, s) = AddRoundKey (rk, InvSubBytes (InvShiftRows s))\n\n\/\/ Converting a 128 bit message to a State and back\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\n\/\/ AES Encryption\naesEncrypt : ([128], [AESKeySize]) -> [128]\naesEncrypt (pt, key) = stateToMsg (AESFinalRound (kFinal, rounds ! 0))\n  where   (kInit, ks, kFinal) = ExpandKey key\n          state0 = AddRoundKey(kInit, msgToState pt)\n          rounds = [state0] # [ AESRound (rk, s) | rk <- ks\n                                                 | s <- rounds\n                              ]\n\n\/\/ AES Decryption\naesDecrypt : ([128], [AESKeySize]) -> [128]\naesDecrypt (ct, key) = stateToMsg (AESFinalInvRound (kFinal, rounds ! 0))\n  where   (kFinal, ks, kInit) = ExpandKey key\n          state0 = AddRoundKey(kInit, msgToState ct)\n          rounds = [state0] # [ AESInvRound (rk, s)\n                              | rk <- reverse ks\n                              | s  <- rounds\n                              ]\n\nsbox : [256]GF28\nsbox = [\n 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n 0x54, 0xbb, 0x16]\n\n\/\/ Test runs:\n\n\/\/ cryptol> aesEncrypt (0x3243f6a8885a308d313198a2e0370734,   \\\n\/\/                      0x2b7e151628aed2a6abf7158809cf4f3c)\n\/\/ 0x3925841d02dc09fbdc118597196a0b32\n\/\/ cryptol> aesEncrypt (0x00112233445566778899aabbccddeeff,   \\\n\/\/                      0x000102030405060708090a0b0c0d0e0f)\n\/\/ 0x69c4e0d86a7b0430d8cdb78070b4c55a\nproperty AESCorrect msg key = aesDecrypt (aesEncrypt (msg, key), key) == msg\n\ntestmsgs = [0x6bc1bee22e409f96e93d7e117393172a\n           ,0xae2d8a571e03ac9c9eb76fac45af8e51\n           ,0x30c81c46a35ce411e5fbc1191a0a52ef\n           ,0xf69f2445df4f9b17ad2b417be66c3710]\n\n\n\/\/ AES128 tests\n\ntestkey128 = 0x2b7e151628aed2a6abf7158809cf4f3c\n\ntestct128 = [0x3ad77bb40d7a3660a89ecaf32466ef97\n            ,0xf5d3d58503b9699de785895a96fdbaaf\n            ,0x43b1cd7f598ece23881b00e3ed030688\n            ,0x7b0c785e27e8ad3f8223207104725dd4]\n\nproperty testsPass = and [ aesEncrypt (msg, testkey128) == ct\n                         | msg <- testmsgs | ct <- testct128 ]\n\n\n\/\/ AES192 tests\n\n\/\/ testkey192 = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n\n\/\/ testct192 = [0xbd334f1d6e45f25ff712a214571fa5cc \n\/\/             ,0x974104846d0ad3ad7734ecb3ecee4eef \n\/\/             ,0xef7afd2270e2e60adce0ba2face6444e \n\/\/             ,0x9a4b41ba738d6c72fb16691603c18e0e]\n\n\/\/ property testsPass = and [ aesEncrypt (msg, testkey192) == ct\n\/\/                          | msg <- testmsgs | ct <- testct192 ]\n\n\n\/\/ AES256 tests\n\n\/\/ testkey256 = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4 \n\/\/ testct256 = [0xf3eed1bdb5d2a03c064b5a7e3db181f8 \n\/\/             ,0x591ccb10d410ed26dc5ba74a31362870 \n\/\/             ,0xb6ed21b99ca6f4f9f153e7b1beafed1d \n\/\/             ,0x23304b7a39f9f3ff067d8d8f9e24ecc7]\n\n\/\/ property testsPass = and [ aesEncrypt (msg, testkey256) == ct\n\/\/                          | msg <- testmsgs | ct <- testct256 ]\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Keyless\/Hash\/SHA.cry","filetype":"cry","content":"module Primitive::Keyless::Hash::SHA where\n\nsha : {L} (2 * w >= width L) => [L] -> [digest_size]\nsha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))\n\nparameter\n\n  \/** Word size\n    Specifications are based on word size w, rather than digest size (8 * w)\n    or block size (m == 16 * w), in order to avoid confusing Cryptol's type\n    constraint verifier with integer division.\n  *\/\n\n  type w : #\n  type constraint (fin w, w >= 1)\n\n  type digest_size : #\n  type constraint (fin digest_size, 8*w >= digest_size)\n\n  \/** The number of iterations in the hash computation\n  (i.e. the number of words in K) *\/\n\n  type j : #\n  type constraint (fin j, j >= 17)\n\n  H0 : [8][w]\n  K  : [j][w]\n\n  \/* FIPS 180-4 defines lowercase and uppercase\n      (respective to the Greek alphabet) sigma functions for SHA-256 and SHA-512.\n      (4.4)-(4.7) SHA-224, SHA-256 (w==32)\n      (4.10)-(4.13) SHA-384, SHA-512, SHA-512\/224, SHA-512\/256 (w==64) *\/\n\n  SIGMA_0 : [w] -> [w]\n  SIGMA_1 : [w] -> [w]\n  sigma_0 : [w] -> [w]\n  sigma_1 : [w] -> [w]\n\nprivate\n\n  \/** block size corresponding to word size for all SHA algorithms in\n      FIPS 180-4 *\/\n  type block_size = 16 * w\n\n  type num_blocks L     = (L+1+2*w) \/^ block_size\n  type padded_size L    = num_blocks L * block_size\n\n\n  \/** (4.1) (w==32), (4.2) (w==32), (4.8) (w==64) *\/\n  Ch : [w] -> [w] -> [w] -> [w]\n  Ch x y z = (x && y) ^ (~x && z)\n\n\n  \/** (4.1) (w==32), (4.3) (w==32), (4.9) (w==64) *\/\n  Maj : [w] -> [w] -> [w] -> [w]\n  Maj x y z = (x && y) ^ (x && z) ^ (y && z)\n\n\n  \/**\n    5.1 Padding the Message\n    5.1.1 SHA-1, SHA-224 and SHA-256 (w==32)\n    5.1.2 SHA-384, SHA-512, SHA-512\/224 and SHA-512\/256 (w==64)\n\n  The constraint ensure that the message size, `L`, fits within a\n  (2 * w)-bit word (consistent w\/ Figure 1)\n  *\/\n  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]\n  pad M = M # 0b1 # zero # (`L : [2*w])\n\n  \/**\n    5.2 Parsing the Message\n    5.2.1 SHA-1, SHA-224 and SHA-256 (w==32)\n    5.2.2 SHA-384, SHA-512, SHA-512\/224 and SHA-512\/256 (w==64)\n  *\/\n  parse : {m} [m * block_size] -> [m][block_size]\n  parse = split\n\n  \/**\n  SHA-256 and SHA-512 (and their respective derivatives) use a similar\n  message schedule that can be expressed in the same way relative to their\n  respective sigma functions.\n\n    6.2.2 SHA-256 Hash Computation (w==32, j=64)\n    6.4.2 SHA-512 Hash Computation (w==64, j=80)\n  *\/\n  messageSchedule_Common : [16][w] -> [j][w]\n  messageSchedule_Common Mi = take W\n    where\n    W : [inf][_]\n    W = Mi # [ w1 + sigma_0 w2 + w3 + sigma_1 w4\n             | w1 <- W\n             | w2 <- drop`{1} W\n             | w3 <- drop`{9} W\n             | w4 <- drop`{14} W\n             ]\n\n\n  \/**\n  Amazon S2N's SHA-256 specification includes a compression routine intended\n  to reflect typical implementations.  This same compression routine applies\n  to SHA-512, modulo respective constants, sigma functions,\n  and message schedules.\n  *\/\n\n  compress_Common : [8][w] -> [j][w] -> [8][w]\n  compress_Common H W =\n        [ (as ! 0) + (H @ 0),\n      (bs ! 0) + (H @ 1),\n      (cs ! 0) + (H @ 2),\n      (ds ! 0) + (H @ 3),\n      (es ! 0) + (H @ 4),\n      (fs ! 0) + (H @ 5),\n      (gs ! 0) + (H @ 6),\n      (hs ! 0) + (H @ 7)\n    ]\n    where\n      T1 = [h + SIGMA_1 e + Ch e f g + k_t + w_t\n                | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]\n      T2 = [ SIGMA_0 a + Maj a b c | a <- as | b <- bs | c <- cs]\n      hs = take`{j + 1}([H @ 7] # gs)\n      gs = take`{j + 1}([H @ 6] # fs)\n      fs = take`{j + 1}([H @ 5] # es)\n      es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])\n      ds = take`{j + 1}([H @ 3] # cs)\n      cs = take`{j + 1}([H @ 2] # bs)\n      bs = take`{j + 1}([H @ 1] # as)\n      as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n\n  processBlock_Common : [8][w] -> [16][w] -> [8][w]\n  processBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)\n\n\n  SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]\n  SHA_2_Common' blocks = hash ! 0\n    where\n    hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DilithiumR2BV.cry","filetype":"cry","content":"\/*Fixes to comply with the round2 submission to NIST*\/\n\/\/1. Randombytes size changed from SEEDBYTES to 3*SEEDBYTES from\n\/\/2. Expand Mat definition changes\n\n\nmodule Primitive::Asymmetric::Signature::DilithiumR2BV where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Common::mod_arith\nimport Primitive::Asymmetric::Cipher::RSA\nimport Primitive::Asymmetric::Signature::testDilithium\nimport Primitive::Asymmetric::Signature::test_latest\n\n\n\/\/ These parameters are fixed for all four recommended implementations\ntype qbits = 23\ntype uint32_t = 32\ntype q = 0x7fe001 type n = 0x100 type d = 0xe\nwc= 0x3c gamma1 = ((`q) - 1) \/ 16:[_]\ngamma2 = ( gamma1 \/ 2 ):[_]\nalpha = (2*gamma2):[_]\nqinv  = 0x00000000fc7fdfff\ntype POLT1_SIZE_PACKED = 288\n\n\/\/ Parameters for Number Theoretic Transform (NTT)\nrootOfUnity    = 1753 : [qbits]\nrootOfUnityInv = 731434 : [qbits]\nninv           = 8347681 : [qbits]\n\n\/\/ Parameterize the types based on the following implemenations\n\/* Weak, Medium, Recommended, and VeryHigh*\/\n\/*parameter\n    type k : #\n    type constraint (fin k, k>=3, k<=6)\n    type l : #\n    type constraint (fin l, l>=2, l<=5)\n    eta : [4]\n    beta : [12]\n    omega : [8]*\/\ntype k = 4\ntype l = 3\n\neta = 6\nbeta = 325\ntype omega = 80\n\n\/\/ Integer polynomials; a superset of ring R referenced in specification\ntype intPoly        = [n][qbits]\ntype intPolyVec dim = [dim]intPoly\n\n\/\/ Polynomials; a superset of ring R_q referenced in specification\ntype poly        = [n][qbits] \/\/ This is R_q, actually defines a super set of R_q\ntype polyVec dim = [dim]poly\n\n\/\/ Polynomials in NTT representation\ntype nttPoly          = [n][qbits]\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k}\ntype SecretKey = {rho : [256]\n                    , K  : [256]\n                    , tr : [384]\n                    , s1 : polyVec l\n                    , s2 : polyVec k\n                    , t0 : intPolyVec k}\ntype SEEDBYTES = 32\ntype CRYPTO_PUBLICKEYBYTES = SEEDBYTES + (POLT1_SIZE_PACKED * k)\n\n\/* Generate public and private keys *\/\nGen : [3*SEEDBYTES*8] -> (PublicKey,SecretKey)\nGen s = (pk, sk)\n    where\n      [rho, rho', K] = split`{3} s \/\/rho <- {0, 1}^256, K <- {0,1}^256\n      A       = ExpandA (split rho) \/\/A \u2208 R^(k\u00d7l)_q := ExpandA(rho)\n      s1      = PolyUniformEtaV`{dim=l} rho' zero \/\/ s1<-s^l_\u03b7\n      s2      = PolyUniformEtaV`{dim=k} rho' `l \/\/ s2<-s^k_\u03b7\n      s1ntt   = map ntt s1\n      As1     = map nttinv (nttMatMul A s1ntt)\n      t       = paddV As1 s2     \/\/t:= As1 + s2\n      (t1,t0) = Power2RoundV t  \/\/(t1, t0):= Power2Round_q(t, d=4)\n      tr      = CRH (rho#(pack_t1 t1)) \/\/tr \u2208 {0,1}^384 := CRH(rho||t1)\n      pk      = { rho = rho, t1 = t1}\n      sk      = { rho = rho, K = K, tr = tr, s1 = s1, s2 = s2, t0 = t0}\n\n\/\/ Known Answer Test\n\/\/ To check this property, it is necessary to import testDilithium\n\ntest_key_gen = (pk.rho#(pack_t1 pk.t1) == testCase1.pk) \/\\\n    ((sk.rho#sk.K#sk.tr#(pack_polyeta sk.s1)#(pack_polyeta sk.s2)#(pack_t0 sk.t0)) == testCase1.sk)\n    where\n    (pk, sk) = Gen (join testCase1.seed)\n\n\/* Generate signature for message M *\/\nSign : {mbytes} (fin mbytes, mbytes>=1) => SecretKey -> [mbytes*8] -> (polyVec l, polyVec k, poly)\nSign sk M = (final_state.z, h, nttinv final_state.c')\n     where\n      A     = ExpandA (split sk.rho) \/\/ A \u2208 R^(k\u00d7l)_q := ExpandA(\u03c1)\n      mu    = CRH`{b=48+mbytes} (sk.tr#M) \/\/ \u03bc \u2208{0,1}^384 := CRH(tr||M)\n      kappa = zero \/\/ \u03ba := 0\n      s1'   = map ntt sk.s1\n      s2'   = map ntt sk.s2\n      t0'   = map ntt (sk.t0)\n            init : sign_var_types\n      init = {z=zero,r0=zero,r1=zero,t0'=t0',c'=zero,w=zero,w1=zero\n             ,s1'=s1',s2'=s2',cs2=zero,K=sk.K,mu=mu,A=A,kappa=kappa}\n\n      final_state = dowhile sign_condition sign_body init\n      ct0         = map nttinv (nttVecConstMul final_state.c' final_state.t0')\n      h           = MakeHintV (psubV zero ct0\n                              ,paddV (psubV final_state.w final_state.cs2) (ct0))\n\n\n\n\n\n\ntype sign_var_types = { z : polyVec l\n                          , r0  : intPolyVec k\n                          , r1  : intPolyVec k\n                          , t0' : nttVec k\n                          , c'  : nttPoly\n                          , w   : polyVec k\n                          , w1  : intPolyVec k\n                          , s1' : nttVec l\n                          , s2' : nttVec k\n                          , cs2 : polyVec k\n                          , K   : [256]\n                          , mu  : [384]\n                          , A   : nttMat k l\n                          , kappa: [16]}\n\n\nsign_condition : sign_var_types -> Bit\nsign_condition sv = fail1 \\\/ fail2\n                   where\n                    fail1 = ((infNormPolyVec (sv.z)) >= (gamma1-beta)) \/\/ ||z||_\u221e \u2265 \u03b31 - \u03b2\n                            \\\/ ((infNormPolyVec sv.r0) >= (gamma2-beta)) \/\/ ||r0||_\u221e \u2265 \u03b32 - \u03b2\n                            \\\/ (sv.r1 != sv.w1) \/\/ r1 \u2242\u0338 w1\n                    fail2 = ((infNormPolyVec (ct0)) >= gamma2) \/\/ ||ct0||_\u221e \u2265 \u03b32\n                            \\\/ ( (foldl (+) 0 cones) > `omega ) \/\/ number of ones in h > \u03c9\n                    cones = sum (map (\\x -> (map onesBV x)) h)\n                    ct0   = map nttinv (nttVecConstMul sv.c' sv.t0')\n                    h     = MakeHintV (psubV zero ct0\n                                      ,paddV (psubV sv.w sv.cs2) (ct0))\n                                      \/\/ h := MakeHintV(-ct0, w-cs2+ct0, 2\u03b32)\n\n\nsign_body : sign_var_types -> sign_var_types\nsign_body sv = {z=z,r0=r0,r1=r1,t0'=sv.t0',c'=c',w=w,w1=w1,s1'=sv.s1',s2'=sv.s2',\n                   cs2=cs2,K=sv.K,mu=sv.mu,A=sv.A,kappa=(sv.kappa+1)}\n              where\n                \u03c1'  = CRH`{b=48+32} (sv.K#sv.mu) \/\/ \u03c1' \u2208 {0,1}^384 := CRH(K||\u03bc) (or \u03c1' <- {0,1}^384 for randomized signing)\n                y   = ExpandMask((split \u03c1'), sv.kappa)\/\/ y \u2208 S^l_(\u03b31-1) := ExpandMask(\u03c1',\u03ba)\n                y'  = map ntt y \/\/ checked\n                w   = map nttinv (nttMatMul sv.A y') \/\/ w := Ay\n                w1  = HighBitsV w \/\/ w1 := HighBitsV(w, 2\u03b32)\n                c'  = ntt ( H (sv.mu,w1) ) \/\/ c \u2208 B_(60) := H(\u03bc||w1)\n                cs1 = map nttinv (nttVecConstMul c' sv.s1') \/\/ cs1 := c'.s1'\n                cs2 = map nttinv (nttVecConstMul c' sv.s2') \/\/ cs2 := c'.s2'\n                z   = paddV y cs1 \/\/ z:= y+cs1\n                (r1, r0) = DecomposeV (psubV w cs2) \/\/ Decompose_q(w-cs2, 2\u03b32)\n\n\n\n\nVerify : {mbytes} (fin mbytes, mbytes>=1) => PublicKey -> [mbytes*8] -> (polyVec l, polyVec k, poly) -> Bit\nVerify pk M (z, h, c) = crit1 && crit2 && crit3\n       where\n        A        = ExpandA (split pk.rho) \/\/ A \u2208 R^(k\u00d7l)_q := ExpandA(\u03c1)\n        mu       = CRH`{b=48+mbytes} ((CRH (pk.rho#(pack_t1 pk.t1)))#M) \/\/ \u03bc \u2208{0,1}^384 := CRH(CRH(\u03c1||t1)||M)\n        zntt     = map ntt z \/\/ NTT(z)\n        t1dot2d  = map ntt (map (\\p -> map (\\x ->  mod_mul(`q, x, (2^^14))) p) pk.t1) \/\/ t1.2^^d where d=14\n        nttt1dot2d = map ntt t1dot2d\n        ct1ntt   = nttVecConstMul (psub zero c) nttt1dot2d   \/\/ -ct1\n        Az       = nttMatMul A zntt\n        w1'      = UseHintV (h, paddV Az ct1ntt)\n        zint     = z\n        zinf     = infNormPolyVec zint \/\/ ||z||_\u221e\n        crit1    = zinf < gamma1 - beta\n        crit2    = c == H(mu,w1')\n        cones    = sum (map (\\x -> (map onesBV x)) h)\n        crit3    = ( (foldl (+) 0 cones) > `omega ) \/\/ number of 1's in h \u2264 \u03c9 \/\/ TODO: fix this\n\n\nonesBV : {n} (fin n, n>=1)=> [n] -> [n]\nonesBV xs =  l!0\n    where l = [0]#[ (if (xs@i) then j+1 else j):[n] | i <- [0..n-1] | j<- l]\n\n\/\/:prove (\\x -> (onesBV x) == fromInteger (ones x)):[23]-> Bit\n\npack_w : intPolyVec k -> [4*n*k]\npack_w w = join [pack_poly p | p <- wBV ]\n    where\n    wBV = map (\\p -> map (\\x -> drop`{15} x:[8]) p) w\n    pack2 : [2][8] -> [8]\n    pack2 xs = xs@0 || (xs@1 << 4)\n    pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\npack_polyeta : {m} (fin m, m >= 1) =>  polyVec m -> [4*n*m]\npack_polyeta s = join [ join [elt p i | i <- [0..(n\/2)-1]:[_][8] ] | p <- s ]\n    where\n    elt : poly -> [8] -> [8]\n    elt p i = (c (((p@(2*i+0))) % `q)) || ((c (((p@(2*i+1))) % `q)) << 4)\n    c : [qbits] -> [8]\n    c num = drop (if num > eta then `q + eta - num else eta - num)\n\n\/\/unpack_polyeta\ntype POLETA_SIZE_PACKED = 128\nunpack_polyeta :  {m} (fin m, m>=1) => [POLETA_SIZE_PACKED*m][8] -> polyVec m\nunpack_polyeta t = [ elt a | a <- (split t):[m][128][8]]\n      where\n      elt : [128][8] -> poly\n      elt a = (join coeffs)\n            where coeffs = [ [ (`q+eta)- (zext (a@i&&0x0F)), (`q+eta)- (zext (a@(i+1)>>4))] |i <- [0..(n\/2)-1]:[_][8] ]\n\n\n\n\npack_t0 : intPolyVec k -> [k*3584]\npack_t0 t0 = join [ polyt0_pack p | p <- t0 ]\n\npolyt0_pack : intPoly -> [3584]\npolyt0_pack p = join [ join [drop`{15} (tmp p i 0),\n                       drop`{15} (((tmp p i 0) >> 8) || ((tmp p i 1) << 6)),\n                       drop`{15} ((tmp p i 1) >> 2),\n                       drop`{15} (((tmp p i 1) >> 10) || ((tmp p i 2) << 4)),\n                       drop`{15} ((tmp p i 2) >> 4),\n                       drop`{15} (((tmp p i 2) >> 12) || ((tmp p i 3) << 2)),\n                       drop`{15} ((tmp p i 3) >> 6)\n                     ] | i <- [0..(n\/4-1)] ]\n        where\n          tmp : intPoly -> [8] -> [8] -> [23]\n          tmp p i j =  (2^^13 - p@(4*i+j))\ntype POLT0_SIZE_PACKED = 448\npolyt0_unpack : [POLT0_SIZE_PACKED][8] -> intPoly\npolyt0_unpack p = join[ [ (tmp p i 0) || (zext ((tmp p i 1) && zext 0x3F)) << 8,\n                          (zext ((tmp p i 1) >> 6)) || (zext (tmp p i 2)) << 2 || (zext ((tmp p i 3) && zext 0x0F)) << 10,\n                          (zext ((tmp p i 3) >> 4)) || (zext (tmp p i 4)) << 4 || (zext ((tmp p i 5) && zext 0x03)) << 12,\n                          (zext ((tmp p i 5) >> 2)) || (zext (tmp p i 6)) << 6\n                        ] | i <- [0..(n\/4-1)]\n                      ]\n          where\n            tmp :[POLT0_SIZE_PACKED][8] -> [8] -> [8] -> [23]\n            tmp p i j =  zext (2^^13 - p@(7*i+j))\n\n\nunpack_t0 : [k][POLT0_SIZE_PACKED][8] -> intPolyVec k\nunpack_t0 pv = [ (polyt0_unpack pv') | pv' <- pv]\n\n\n\/\/ d must be 14 for this to work, and n must be 256\n\n\/\/ polyt1_pack\n\npoly_pack : poly -> [POLT1_SIZE_PACKED*8]\npoly_pack p = join [ join (pack8 xs) | xs <- split (map (drop`{14}) p) : [32][8][_]]\n\npack8 : [8][9] -> [9][8]\npack8 xs = map drop`{1} [ xs@0\n                        , xs@0 >> 8 || xs@1 << 1\n                        , xs@1 >> 7 || xs@2 << 2\n                        , xs@2 >> 6 || xs@3 << 3\n                        , xs@3 >> 5 || xs@4 << 4\n                        , xs@4 >> 4 || xs@5 << 5\n                        , xs@5 >> 3 || xs@6 << 6\n                        , xs@6 >> 2 || xs@7 << 7\n                        , xs@7 >> 1\n                        ]\n\npack_t1 : polyVec k -> [k*POLT1_SIZE_PACKED*8]\npack_t1 pvk = (join [ poly_pack p | p <- pvk])\n\n\/\/ polyt1_unpack\n\npolyt1_unpack : [POLT1_SIZE_PACKED][8] -> poly\npolyt1_unpack p = map (\\x -> zero#x) (join [unpack8 xs | xs <- (split p): [32][9][_] ])\n    where unpack8: [9][8] -> [8][12]\n          unpack8 xs = [ zero#xs@0 || ((zero#xs@1 << 8) && 0x1FF)\n                        , zero#xs@1 >> 1 || ((zero#xs@2 << 7) && 0x1FF)\n                        , zero#xs@2 >> 2 || ((zero#xs@3 << 6) && 0x1FF)\n                        , zero#xs@3 >> 3 || ((zero#xs@4 << 5) && 0x1FF)\n                        , zero#xs@4 >> 4 || ((zero#xs@5 << 4) && 0x1FF)\n                        , zero#xs@5 >> 5 || ((zero#xs@6 << 3) && 0x1FF)\n                        , zero#xs@6 >> 6 || ((zero#xs@7 << 2) && 0x1FF)\n                        , zero#xs@7 >> 7 || ((zero#xs@8 << 1) && 0x1FF)\n                        ]\n\n\nunpack_t1 : [k][POLT1_SIZE_PACKED][8] -> polyVec k\nunpack_t1  pv = [ (polyt1_unpack p) |  p <- pv]\n\n\/\/pack_pk\n\npack_pk :  [32][8] -> polyVec k -> [CRYPTO_PUBLICKEYBYTES*8]\npack_pk rho t1 = (join rho) # (pack_t1 t1)\n\n\/\/unpack_pk\n\nunpack_pk : [CRYPTO_PUBLICKEYBYTES][8] -> ([SEEDBYTES][8], polyVec k)\nunpack_pk pk = (take`{32} pk, [polyt1_unpack p | p <- (split (drop`{32} pk):[k][288][_])])\n\n\/****Packing SK *********\/\n\ntype CRHBYTES = 48\ntype CRYPTO_SECRETKEYBYTES = 2800\n\n\n\n\/\/pack_sk\n\npack_sk : [SEEDBYTES][8] -> [SEEDBYTES][8] -> [CRHBYTES][8] -> polyVec l -> polyVec k -> polyVec k -> [CRYPTO_SECRETKEYBYTES*8]\npack_sk rho key tr s1 s2 t0 = (join rho) # (join key) # (join tr)# (pack_polyeta s1)#(pack_polyeta s2) # (pack_t0 t0)\n\nunpack_sk : [CRYPTO_SECRETKEYBYTES][8] -> ([SEEDBYTES][8], [SEEDBYTES][8], [CRHBYTES][8], polyVec l, polyVec k, intPolyVec k)\nunpack_sk sk = (rho, key, tr, s1, s2, t0)\n        where rho = (take`{32} sk)\n              key = (take`{32}(drop`{32} sk))\n              tr = (take`{48}(drop`{32} sk))\n              s1 = unpack_polyeta`{m=l} (take`{128*l}(drop`{48} sk))\n              s2 = unpack_polyeta`{m=k} (take`{128*k}(drop`{48+(128*l)} sk))\n              t0 = unpack_t0 (split (drop`{48+(128*l)+(128*k)+64} sk):[k][POLT0_SIZE_PACKED][8])\n\ntype POLZ_SIZE_PACKED = 640\n\npolyz_pack : poly -> [POLZ_SIZE_PACKED][8]\npolyz_pack p =  join [ (tmp p i) | i<- [0..(n\/2)-1]]\n      where tmp: poly -> [8] -> [5][8]\n            tmp p i  = [r0, r1, r2, r3, r4]\n              where\n                    t x = gamma1-1-p@(2*i+x)\n                    t0 = (t 0) + ((zext (t 0))>>31) && `q\n                    t1 = (t 1) + ((zext (t 1))>>31) && `q\n                    r0 = drop t0\n                    r1 = drop (t0>>8)\n                    r2 = drop (t0>>16) || drop (t1 << 4)\n                    r3 = drop (t1 >> 4)\n                    r4 = drop (t1 >> 12)\n\npolyz_unpack : [POLZ_SIZE_PACKED][8] -> poly\npolyz_unpack pp =  (join [ (tmp pp i) | i<-[0..(n\/2)-1]])\n    where tmp : [POLZ_SIZE_PACKED][8] -> [8]-> [2][23]\n          tmp pp i = [rcoeff0, rcoeff1]\n                where\n                  coeff0 = (zero#pp@(5*i+0):[32]) || (((zero#pp@(5*i+1)):[32]) << 8) || (zero#(((zero#pp@(5*i+2)):[8]) && 0x0F):[32]) << 16\n                  coeff1 = ((zero#(pp@(5*i+2) >> 4)):[32]) || ((zero#pp@(5*i+3):[32]) << 4) || ((zero#pp@(5*i+4):[32]) << 12)\n                  rcoeff0 = drop`{9}((gamma1 - 1 - coeff0) + ((zext coeff0:[32]) >> 31) && `q):[23]\n                  rcoeff1 = drop`{9}((gamma1 - 1 - coeff1) + ((zext coeff1:[32]) >> 31) && `q):[23]\n\ntype SIG_SIZE_PACKED = l*POLZ_SIZE_PACKED+omega+k+n\/8+8\n\nencodec : poly -> [(n\/8+8)*8]\nencodec p = (join [ [ p@(8*i+j)!=0 | j <- [0..7] ] | i<- [0..(n\/8)-1]])# (join sigSigns)\n      where\n        signs =[0]# [(if (join qm1coeffsIndcs)@i then s||m else s) | s <- signs | m<- masks| i<-[0..255]]\n        masks = [1]# [(if (join nzcoeffsIndcs)@i then (m << 1) else m) | m<-masks | i<-[0..255] ]\n        nzcoeffsIndcs =  [ [ p@(8*i+j)!=0 | j <- [0..7] ] | i<- [0..(n\/8)-1]]\n        qm1coeffsIndcs = [ [ p@(8*i+j)==(`q-1) | j <- [0..7] ] | i<- [0..(n\/8)-1]]\n        sig = zero:[n\/8+8][8]\n        sigSigns = [ (signs!0) >>(8*i) | i<-[0..7]]:[8][8]\n\npack_sig : (polyVec l, polyVec k, poly) -> [SIG_SIZE_PACKED*8]\npack_sig (z, h, c) = s0#s1#s2\n        where s0 = join [join (polyz_pack z') | z' <- z ]\n              s2 = encodec c\n              s1 = encodeh h\n                where\n                encodeh : polyVec k -> [(omega+k)*8]\n                encodeh h = join omegaUpdates\n                  where nzcoeffsIndcs = [ [ (p@j)!=0 | j<-[0..255]]| p<- h]\n                        cones = sum (map onesBV nzcoeffsIndcs)\n                        sig = zero:[84][8]\n                        kUpdates0=[sig]#[(if (nzcoeffsIndcs@0)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates0]\n                        kUpdates1=[kUpdates0!0]#[(if (nzcoeffsIndcs@1)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates1]\n                        kUpdates2=[kUpdates1!0]#[(if (nzcoeffsIndcs@2)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates2]\n                        kUpdates3=[kUpdates2!0]#[(if (nzcoeffsIndcs@3)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates3]\n                        omegaUpdates = (updates (kUpdates3!0) [`omega+0, `omega+1, `omega+2, `omega+3] [0, 1, 2, 3])\n\ndecodec : [(n\/8+8)][8] -> poly\ndecodec xs = coeffs'!0\n  where coeffs = zero:poly\n        signs = [0]#[ ((sext s) || ((sext (xs@(`n\/8+i))):[64]) << (8*i)) | i<-[0..7] | s<-signs] :[9][64]\n        signs' = [signs!0]#[ (if ((((xs@i) >> j) && 0x01) == 1) then (s >> 1) else s) | j<- [0..255] | s <- signs' | i<- [0..3]]\n        coeffs' = [coeffs]#[(if ((((xs@i) >> j) && 0x01)==1) then (update coeff (8*i+j) (1^(-((drop s)&&1))&&(1^(`q-1)))) else coeff) | i<- [0..7] | j<- [0..255] | s <- signs' | coeff <-coeffs' ]\n\ndecodeh: [(omega+k)][8] -> polyVec k\ndecodeh xs = pv \/\/ it is supposed to be pv'!0\n      where\n        pv = zero : polyVec k\n        ks = [0]#[xs@(`omega+i) | i<- [0..3]]\n        unpack_sig : [SIG_SIZE_PACKED][8] -> (polyVec l, polyVec k, poly)\nunpack_sig sig = (z, h, c)\n        where z = [ (polyz_unpack p) | p<- (split (take`{l*POLZ_SIZE_PACKED} sig):[l][_][_])]\n              c = decodec sig'' \/\/ decodec(c) : [(n\/8+8)*8] -> poly\n              sig' = take`{84}(drop`{l*POLZ_SIZE_PACKED} sig)\n              sig'' = drop`{84}(drop`{l*POLZ_SIZE_PACKED} sig)\n              h = decodeh sig'\n\nupdateCoeffs :  polyVec n -> [k] -> [8] -> [qbits] -> polyVec n\nupdateCoeffs pv i j a =  upv\n      where  upv = (update pv i up)\n             up = (update p j a)\n             p = pv@i\n\n\n\/\/ Only works when n=256\n\n\/\/ This function has been modified in round2\n\/\/PolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [8] -> polyVec dim \/\/ round1\nPolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [16] -> polyVec dim\nPolyUniformEtaV r nonce = [PolyUniformEta (split r) (nonce + j) | j <- [0..(dim-1)]:[dim][16]]\n\ngenS : [8] -> [2][4]\ngenS byte = [t0, t1]\n    where\n    t0 = drop`{4} (byte && 0x0F)\n    t1 = drop`{4} (byte >> 4)\n\n\/\/ This function has been modified in round2\n\/\/(uint8_t) D means taking 8 LSBs from D\n\/\/PolyUniformEta : [SEEDBYTES*8] -> [8] -> poly\nPolyUniformEta : [SEEDBYTES][8] -> [16] -> poly\nPolyUniformEta rho nonce = map (\\x -> if ((toInteger eta) - (toInteger x)) < 0 then (fromInteger  (((toInteger eta) - (toInteger x))+`q):[23]) else (fromInteger ((toInteger eta) - (toInteger x)):[23])) (take`{n} withinEta)\n    where\n        seed = (join rho)#(drop`{8} nonce)# (take`{8} nonce)\n        randoms = ((join (SHA3::toBytes (take`{2*8*168} (SHA3::SHAKE128 (join (SHA3::toBytes seed))))))#zero)\n        withinEta = randomsInRangeDouble genS (2*eta) randoms\n\n\nH : ([384],intPolyVec k) -> poly\nH (mu,w) = (SampleInBall ss samples)\n  where\n    w_packed = pack_w w\n    randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n    ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n    extByte : [8] -> [8]\n    extByte x = x\n\n    samples : [60][8]\n    samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\n\nSampleInBall : [60] -> [60][8] -> [256][qbits]\nSampleInBall signs jsamples = ys ! 0\n              where\n              ys = [ zero:[256][qbits]]\n                    # [ if i==j then (if [s]==1 then (update y i (`q-1)) else (update y i 1))                          else (if [s]==1 then (updates y [j,i] [`q-1,y@j]) else (updates y [j,i] [1,y@j]))  | i <- [196..255]\n                                                                  | j <- jsamples\n                                                                  | s <- signs\n                                                                  | y <- ys\n                      ]\n\n\nExpandMask : ([CRHBYTES][8], [16]) -> polyVec l\nExpandMask  ( \u03c1', kappa) = [samplePoly \u03c1' kappa i `l | i <- [0..(l-1)] ]\n\n\nsamplePoly : [CRHBYTES][8] -> [16] -> [2] -> [2] -> poly\nsamplePoly \u03c1' kappa i dim = (map (\\x -> mod_sub(`q, mod_sub(`q, gamma1, 1), zero#x)) coeffs)\n    where\n        (upper:[20])      =  drop`{4}(2*gamma1-2):[20]\n        kappaBytes = join (reverse (split ((zext dim)*kappa+(zext i)):[2][8])) \/\/ LEB order\n        s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes ((join \u03c1')#kappaBytes)))))) \/\/ checked\n        (coeffs:[n][20])   = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\n\nextractPolyElt : [40] -> [2][20]\nextractPolyElt bits = [zero#int1, zero#int2]\n                where\n                [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n                int1 = b2'*2^^16 + b1*2^^8 +  b0\n                int2 = b4*2^^12 + b3*2^^4 +  b2''\n                b2'  = b2 && 15\n                \/\/b2'' = b2\/(16:[20])\n                b2'' = b2\/16\n\/\/ seed should be in little endian byte order\nCRH : {b} (fin b, b>=1) => [b*8] -> [384]\nCRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\nExpandA : [SEEDBYTES][8] -> [k][l]nttPoly\nExpandA rho = [ [ (matrixPoly (join rho) i j) | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n\nmatrixPoly : [SEEDBYTES*8] -> [width k] -> [width l] -> nttPoly\nmatrixPoly rho i j = take`{n} [drop`{1} elt | elt <- randomElts ]\n            where\n            randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n            s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n            \/\/b        = 2^^4*(zero#j:[8])+(zero#i:[8])\n            b          =  drop`{16}(((zero#j:[32]) << 8) + (zero#i:[32]))\n\n\nextractMatElt : [24] -> [24]\nextractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n                where\n                  [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n                  b2' = (2^^23-1) && b2 \/\/ Typo in paper; following C implementation\n\n\n\/*\n\n  Supporting Algorithms; see Figure 3\n\n*\/\n\nPower2Round : [qbits] -> ([qbits],[qbits]) -> ([qbits],[qbits])\nPower2Round q (r,d') = ((r'-r0)\/2^^d',r0)\n            where r' = mod_pow (zero#q, r, 1)\n                  r0 = centered_mod r' (2^^d')\n\npolyPower2Round : {m} [m][qbits] -> ([m][qbits], [m][qbits])\npolyPower2Round p = unzip [ Power2Round `q (zero#r, zero#0xe)\n                          | r <- p\n                          ]\n\nPower2RoundV : {dim} (fin dim, dim >= 1) => polyVec dim -> ([dim]intPoly,[dim]intPoly)\nPower2RoundV v = unzip (map polyPower2Round v)\n\nALPHA = 2*gamma2\n\nDecompose : [qbits] -> ([qbits],[qbits])\nDecompose r = if (r' - r0) == (`q - 1) then (0, r0 - 1)\n                    else ((r' - r0) \/ ALPHA, r0)\n          where r' =  mod_pow (`q, r, 1)\n                r0 = centered_mod r' ALPHA\n\nDecomposePoly : {m} [m][qbits] -> ([m][qbits], [m][qbits])\nDecomposePoly p = unzip [Decompose (zero#x) | x <- p]\n\nDecomposeV : {n} (fin n, n>=1) => polyVec n  -> (polyVec n, polyVec n)\nDecomposeV r = unzip [ DecomposePoly p | p <- r ]\n\nHighBits : [qbits] -> [qbits]\nHighBits r = (Decompose r).0\n\nHighBitsV : {n} (fin n, n>=1) => polyVec n  -> polyVec n\nHighBitsV rv = r1\n          where\n            (r1,r0) = DecomposeV rv\n\n\nLowBits : [qbits] -> [qbits]\nLowBits r = (Decompose r).1\n\n\nMakeHint : ([qbits],[qbits]) -> [qbits]\nMakeHint (z,r) = zero#[r1 != v1]\n          where r1 = HighBits r\n                v1 = HighBits r+z\nMakeHintP: (poly, poly) -> poly\nMakeHintP (zp, rp) = [MakeHint (z, r) | z <- zp | r <- rp]\n\nMakeHintV : {k} (fin k, k>=1) => (polyVec k, polyVec k) -> polyVec k\nMakeHintV (zv, rv) =  [MakeHintP (zp, rp) | zp <- zv | rp <- rv ]\n\n\n\nUseHint : ([qbits],[qbits]) -> [qbits]\nUseHint  (r,h) = (if h==1 then r1' else r1):[23]\n        where\n          m = ((`q - 1) \/ ALPHA)\n          (r1, r0) = Decompose r\n          r1'      = if (r0 > 0) then mod_pow (m, (r1 + 1), 1) else mod_pow (m, (r1 - 1), 1)\nUseHintPoly : poly -> poly -> poly\nUseHintPoly rp hp = [ UseHint (r, h) | r <- rp | h <- hp ]\n\nUseHintV : {k}(fin k, k>=1) => (polyVec k, polyVec k) -> polyVec k\nUseHintV (rv, hv) = [UseHintPoly hpoly rpoly\n                              | hpoly <- hv\n                              | rpoly <- rv\n                              ]\n\n\/*\n\n  Utility functions\n\n*\/\n\n\nones : {a} (fin a, a >= 1) => [a] -> Integer\nones bv = foldl (+) 0 bva\n      where\n      bva = map toInteger (split bv:[_][1])\n\ncentered_mod : [qbits] -> [qbits] -> [qbits]\ncentered_mod x n = if r > (n\/2) then r - n\n                    else r\n              where r = x % n\n\n\nrandomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\nrandomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                else randomsInRange createElt upperCrit randomTail\n                                where\n                                elt        = createElt (take`{a} randoms)\n                                randomTail = drop`{a} randoms\n\nrandomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\nrandomsInRanges createElt uppers randoms =\n                if elt <= head uppers\n                then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                else randomsInRanges createElt uppers randomTail\n                where\n                  elt          = createElt (take`{a} randoms)\n                  randomTail   = drop`{a} randoms\n                  uppersRotate = uppers <<< 1\n\n\nrandomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\nrandomsInRangeDouble createElt upper randoms =\n                if (elts@0 <= upper) \/\\ (elts@1 <= upper)\n                then  elts#(randomsInRangeDouble createElt upper randomTail)\n                else\n                  if (elts@0 <= upper)\n                  then [ elts@0 ]#(randomsInRangeDouble createElt upper randomTail)\n                  else\n                    if (elts@1 <= upper)\n                    then [ elts@1 ]#(randomsInRangeDouble createElt upper randomTail)\n                    else randomsInRangeDouble createElt upper randomTail\n                where\n                  elts       = createElt (take`{2*a} randoms)\n                  randomTail = drop`{2*a} randoms\n\/*\n  Supporting polynomial and polynomial vector functions\n*\/\n\nmod_sum : {s, m} (fin s, fin m) => ([s], [m][s]) -> [s]\nmod_sum (p, l) = sums!0\n    where\n    sums = [zero]#[mod_add`{s}(p, x, y) | x <- l | y <- sums]\n\nntt : poly -> nttPoly\nntt p = nttp\n    where\n    r k = mod_pow(`q, rootOfUnity, k)\n    exponents = join [ [zext i, (256+(zext i))] | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n    nttp = [(mod_sum (`q, [ (mod_mul(`q, (p@idx), (mod_pow (`q, (r k), i)))) | idx<-[0..(n-1)]:[n][width n] | i<-[0..(n-1)]:[n][23]]))\n           | k <- exponents\n           ]\n\nnttinv : nttPoly -> poly\nnttinv p' = p\n    where\n        pu = reorder p'\n        r' i = mod_pow (`q, rootOfUnityInv, (i*2))\n        p = [ mod_mul(`q, ninv, mod_mul(`q, mod_pow(`q, rootOfUnityInv, i), (mod_sum (`q, [mod_mul(`q, (pu@jdx), (r' ((i*j))))\n            | jdx<-[0..(n-1)]:[n][width n]\n            | j<-[0..(n-1)]:[n][qbits]\n            ]))))\n            | i <- [0..255]:[n][qbits]\n            ]\n\n\n\n\n\/\/ Dilithium uses a non-standard ordering of elements in the NTT domain; this function reorders the elements.\nreorder : nttPoly -> nttPoly\nreorder a = join [ [a1 @ i, a2 @ i] | i <- [0..127]:[_][8] ]\n        where\n          a1 = a @@ [ (i-1)\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n          a2 = reverse (a @@ [ (511 - (zero#i):[9])\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ])\n\n\n\n\/\/ Operations on NTT polynomials\n\nnttMatMul : {dim1,dim2} (fin dim1,fin dim2) => nttMat dim1 dim2 -> nttVec dim2 -> nttVec dim1\nnttMatMul mat vec = [ nttDotProduct v vec | v <- mat ]\n\nnttDotProduct : {dim} (fin dim) => nttVec dim -> nttVec dim -> nttPoly\nnttDotProduct v1 v2 = foldl padd (zero:nttPoly) [ nttPolyMult p1 p2 | p1 <- v1 | p2 <- v2 ]\n\nnttPolyMult : nttPoly -> nttPoly -> nttPoly\nnttPolyMult p1 p2 = [ mod_mul(`q, x, y) | x <- p1 | y <- p2]\n\nnttVecConstMul : {dim} (fin dim) => nttPoly -> nttVec dim -> nttVec dim\nnttVecConstMul c v = map (nttPolyMult c) v\n\npolyVecSum :  {dim} (fin dim) => polyVec dim -> polyVec dim -> polyVec dim\npolyVecSum v1 v2 = map nttinv (paddV v1' v2')\n        where\n        v1' = map ntt v1\n        v2' = map ntt v2\n\n\/\/ Polynomial addition and subtraction\npadd : [n][qbits] -> [n][qbits] -> [n][qbits]\npadd p1 p2 = [ mod_add(`q, x, y) | x <- p1 | y <- p2 ]\n\npsub : [n][qbits] -> [n][qbits] -> [n][qbits]\npsub p1 p2 = [ mod_sub(`q, x, y) | x <- p1 | y <- p2 ]\n\npsubV : {dim} (fin dim) => [dim][n][qbits] -> [dim][n][qbits] -> [dim][n][qbits]\npsubV v1 v2 = zipWith psub v1 v2\n\n\npaddV : {dim} (fin dim) => [dim][n][qbits] -> [dim][n][qbits] -> [dim][n][qbits]\npaddV v1 v2 = zipWith padd v1 v2\n\n\/\/ Aux functions\n\ninfNorm : [qbits] -> [qbits]\ninfNorm x =  (centered_mod x `q)\n\ninfNormPoly : intPoly -> [qbits]\ninfNormPoly p = foldl max 0 p_centered\n            where\n              p_centered = map infNorm p\n\ninfNormPolyVec : {dim} (fin dim, dim>=1) => intPolyVec dim -> [qbits]\ninfNormPolyVec v = foldl max 0 (map infNormPoly v)\n\n\/************************************\/\n\/* Conversion functions helpful in Testing *\/\n\/************************************\/\n\n\/\/Bit-Vector to Integer type\n\nBVtoIntPoly : poly -> [n]Integer\nBVtoIntPoly p = map (\\x -> toInteger x) p\n\nBVtoIntPolyVec : {dim} (fin dim, dim >= 1) => polyVec dim -> [dim][n]Integer\nBVtoIntPolyVec pvec = map (\\x -> BVtoIntPoly x) pvec\n\nBVtoIntNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => nttMat dim1 dim2 -> [dim1][dim2][n]Integer\nBVtoIntNttMat nttmat = map (\\x -> BVtoIntPolyVec x) nttmat\n\n\/\/Bit-Vector to (Z q) type\n\nBVtoZPoly : poly -> [n](Z q)\nBVtoZPoly p = map (\\x -> BVtoZ`{q} x) p\n\nBVtoZPolyVec : {dim} (fin dim, dim >= 1) => polyVec dim -> [dim][n](Z q)\nBVtoZPolyVec pvec = map (\\x -> BVtoZPoly x) pvec\n\nBVtoZNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => nttMat dim1 dim2 -> [dim1][dim2][n](Z q)\nBVtoZNttMat nttmat = map (\\x -> BVtoZPolyVec x) nttmat\n\n\/\/ Integer to Bit-Vector type\n\nInttoZPoly : [n]Integer -> [n](Z q)\nInttoZPoly p = map (\\x -> fromInteger x:(Z q)) p\n\nInttoZPolyVec : {dim} (fin dim, dim >= 1) => [dim][n]Integer -> [dim][n](Z q)\nInttoZPolyVec pvec = map (\\x -> InttoZPoly x) pvec\n\nInttoZNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => [dim1][dim2][n]Integer -> [dim1][dim2][n](Z q)\nInttoZNttMat nttmat = map (\\x -> InttoZPolyVec x) nttmat\n\n\/\/ (Z q) to Integer type\n\nfromZPoly : [n](Z q) -> [n]Integer\nfromZPoly p = map (\\x -> fromZ x) p\n\nfromZPolyVec : {dim} (fin dim, dim >= 1) => [dim][n](Z q) -> [dim][n]Integer\nfromZPolyVec pvec = map (\\x -> fromZPoly x) pvec\n\nfromZNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => [dim1][dim2][n](Z q) -> [dim1][dim2][n]Integer\nfromZNttMat nttmat = map (\\x -> fromZPolyVec x) nttmat\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ecdsa.cry","filetype":"cry","content":"\/* Reference ECDSA signature algorithm as formalized from [ANSI X9.62-2005, pg 8]\n   Reference ECDSA signature verification algorithm as formalized from [ANSI X9.62-2005, pg 9]\n   \n   Copyright (c) 2018, Galois Inc.\n   www.cryptol.net\n   You can freely use this source code for educational purposes.\n*\/\n\nmodule Primitive::Asymmetric::Signature::ecdsa where\n\nimport Common::bv\nimport Common::mod_arith\nimport Common::mul_java\n\nimport Common::Field \/* Defines Field type and generic operations *\/\nimport Common::EC::ec_point_ops\nimport Common::EC::ref_ec_mul\nimport Common::EC::p384_field\nimport Common::EC::p384_ec_point_ops\nimport Common::EC::p384_ec_mul\n\n\/* Scalar multiply operations {{{1 *\/\n\n\ntest_params : ([384], AffinePoint [384], [384], AffinePoint [384])\ntest_params =\n\/\/  (0x7b52dc21312701d79a2465bb9fdf6fd30c4f76cf74787e44348f8217e6ffd5e02ee8c55a7c5d91b452825b1026d26893, {x=0xdf1c86a62d76090308a0d4c371704b36f3bfa41f0dbf8185d297b8a2c811756f0f4be19871cde079c5d43cfd0fab7fe8; y=0x70521fdd9165b0d33e948be941c590f2fbe7e2754ba110ae24089d41773acfdd34701acaafa669a884d3eefbf557d98b}, 0x211bb4730ad83e31aedbd66a5a750e800cf4de096495323ea94a73f25e9bcb5068a9dcc93e98efecb136eb057e6f41a4, {x=0x6bdf86d8f4cdf5b63a6a1e93a75457c0816fa2f3f69bc706ab69a7b5a63d4956d83cc4ca551f6aaf7653b8dd0991a6af; y=0xa8ce019e78abd658350e5885c8fddb172117a24bf157dfdbe8a1831e03758e630784470287c8e25908d931f22581bf97});\n\/\/  (0x6250471849e0c0eb47e9cf2c8e04c9ad0745e358d1cf11fb53e178a3c5b301b5f9e7f62e61c8f2113615cc4ff9927f9b, {x=0x005255b811499293ea986c66b4698e0748284d391130afd3f9febbc71ef3b39fe13a3deaa1489d817b885edf270b1bf6; y=0xc9a1dcdb74a4ae432edea47750d754d918b2f1fd8d9ee612b4f0cf2bebcb0eeef43ef5d0ce90cb75362bd2cfe69bffad}, 0xd9e8d87abffb84c0c06fe47396aa84871f08420561a7d8cc64fef7796fc0ca9a5406a37a054cc8cd57e26a3a7249fdb3, {x=0x8da95367d9e731f86adda9bfae6ff170cf090be5223f3b33c0d7c6c585bfc1330137d237fdc16bd432797a1da1dfa331; y=0x114d8b24d75d0149603aa6eab6ccec1cd83f5baaca7898dd6edd7c2ca91176893102b9fe129a09f9fdb208e18be46d16});\n  (0xe74872524f90425d832a4f264e1f7b9209ec7456e9b4c467d8eac6c68f973ea7fea24f4d3fa8498bb1e26f933eaa261b\n  , { x=0xbbab93c429707b2afe9ac285314d7b40c4ee31531b13291aa9058307cdd038b572fdf2f3a84dc912804fa426fe531a3c\n    , y=0x4c2cffaa333bfd82b575918bb979bf51480c836082c097a03fed5454877b37d2f44f0401d212c16b05052bd383047b31\n    }\n  , 0xd4356773f2b311955542c5835696b9dca9d0e59197d5746bbf7dc079a666d955f74114662e38d31196bf94b060cc0c80\n  , { x=0xd40c63c65b413d0741c56e884f0dca63b822a6f6879d36f9261d9b4a270d5d79a9be790fdfb871b5d6ae9204da692663\n    , y=0x4d6b2b937c85b3c0c3cd2df85e9307cc89e0093f336af3b4531aa126bbdbec466562d8aa0dc1cf360fc1f1d0951e3ad1\n    })\n\n\/* ECDSA Operations {{{1 *\/\n\n\/** Operations for ECDSA abstraction layer *\/\ntype Curve fv gv = {\n    point_ops : PointOps fv gv\n  , base : AffinePoint fv\n  , affinify : JacobianPoint fv -> AffinePoint fv\n  , mul : (gv, AffinePoint fv) -> JacobianPoint fv\n  , twin_mul : (gv, AffinePoint fv, gv, AffinePoint fv) -> JacobianPoint fv\n  }\n\n\/* Create a public key from a private key *\/\ninitialize_public_key : {fv} (Curve [fv] [fv], [fv]) -> AffinePoint [fv]\ninitialize_public_key(c, k) = c.affinify(c.mul(k, c.base))\n\n\/**\n * Reference ECDSA signature algorithm as formalized from [ANSI X9.62-2005, pg 8]\n * Parameters:\n *  Curve c\n *  Private key d of signatory.\n *  Integer e obtained after hashing message on step e)\n *  Ephemeral EC private key in range [1 .. c.curve)\n *\/\necdsa_sign : {fv} (fin fv, fv >= 1) => (Curve [fv] [fv], [fv], [fv], [fv]) -> ([fv], [fv])\necdsa_sign(c,d,e,k) = if is_zero(r) || is_zero(s) then (0,0) else (r, s)\n  where\n    g = c.point_ops.group_field\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    \/* Compute x coordinate of public key. *\/\n    j = (c.affinify(c.mul(k, c.base))).x\n    \/* c) Set r = j mod n *\/\n    r = g.norm(j)\n    s = g.div(g.add(g.norm(e), g.mul(d, r)), k)\n\n\/**\n * Reference ECDSA signature verification algorithm as formalized from [ANSI X9.62-2005, pg 9]\n * Parameters\n *  Curve c\n *  Integer e' obtained after hashing message on  step \"c\".\n *  Pair returned by ref_ecdsa_sign algorithm.\n *  Public key of key signatory.\n * Result:\n *  Bit that is True if verification suceeds, and false otherwise.\n *\/\necdsa_public_verify : {fv} (fin fv, fv >= 1)\n   => (Curve [fv] [fv], [fv], ([fv], [fv]), AffinePoint [fv]) -> Bit\necdsa_public_verify(c, e, (r, s), q)\n    \/* h) Compare v and r' if v = r', output \"valid\"; otherwise output \"invalid\". *\/\n   = in_range(s) && (v == r)\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(e, s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n    \/* f) Convert the field element x_r to an integer j as described in A.5 *\/\n    j = f.mul(r2.x, f.sq(f.div(f.field_unit, r2.z)))\n    \/* g) v = j mod n *\/\n    v = g.norm(j)\n\n\/* This version performs a cheaper sequence of operations, and matches\n * the Java implementation. Correspondence between the reference and\n * implementation versions of ecdsa_public_verify is probably best proved\n * independent of the Java code.\n *\/\necdsa_public_verify_imp :\n  (Curve [384] [384], [384], ([384], [384]), AffinePoint [384]) -> Bit\necdsa_public_verify_imp(c, e, (r, s), q)\n   = in_range(r) && in_range(s) &&\n     ~is_zero(r2.z) &&\n     (g.is_equal(j, r2.x) || ((carrybits == False) && (g.is_equal(k, r2.x))))\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(g.norm(e), s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n    r2zsq = f.sq(r2.z)\n    j = f.mul(r, r2zsq)\n    summ = r + p384_group_size\n    carrybits = (summ < r) && (summ < p384_group_size)\n    k = f.mul(summ, r2zsq)\n\ntype RsltWithCarry a b = { carrybits : a , rslt : b }\n\np384_incFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_incFieldPrime x = { carrybits = zero # [(bs @ 0)]\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_add(x, p384_prime)\n\np384_decFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_decFieldPrime x = { carrybits = if (bs @ 0) then -1 else 0\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_sub(x, p384_prime)\n\np384_field_cube(x)       = p384_field_mul(x, p384_field_sq(x))\n\n\/** P384 curve operations {{{2 *\/\n\np384_base : AffinePoint [384]\np384_base = nzAffinePoint(\n  join [0xaa87ca22, 0xbe8b0537, 0x8eb1c71e, 0xf320ad74, 0x6e1d3b62, 0x8ba79b98\n       ,0x59f741e0, 0x82542a38, 0x5502f25d, 0xbf55296c, 0x3a545e38, 0x72760ab7],\n  join [0x3617de4a, 0x96262c6f, 0x5d9e98bf, 0x9292dc29, 0xf8f41dbd, 0x289a147c\n       ,0xe9da3113, 0xb5f0b8c0, 0x0a60b1ce, 0x1d7e819d, 0x7a431d7c, 0x90ea0e5f])\n\n\n\np384_group_add : ([384],[384]) -> [384]\np384_group_add = p384_group_field.add\n\np384_curve : Curve [384] [384]\np384_curve =\n  { point_ops = p384_point_ops\n  , base = p384_base\n  , affinify = \\x -> ec_affinify(p384_field, x)\n  , mul = p384_ec_mul\n  , twin_mul = p384_ec_twin_mul\n  }\n\np384_ecdsa_sign : ([384], [384], [384]) -> { r:[384], s:[384] }\np384_ecdsa_sign(d,e,k) = { r = rr, s = ss }\n  where (rr, ss) = ecdsa_sign(p384_curve,d,e,k)\n\np384_ecdsa_public_verify : ([384], [384], [384], AffinePoint [384]) -> Bit\np384_ecdsa_public_verify(e,pr,ps,q) =\n  ecdsa_public_verify_imp(p384_curve,e,(pr,ps),q)\n\n\/* Curve \"a\" parameter, defined in [FIPS-186-3, page 87] to be -3 *\/\np384_a : [384]\np384_a = p384_prime - 3\n\n\/* Curve \"b\" parameter, defined in [FIPS-186-3, page 89] *\/\np384_b : [384]\np384_b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\n\n\n\/* Convert a p384 Jacobian point to an affine point *\/\n\/\/ p384_affinify : JacobianPoint [384] -> AffinePoint [384]\n\/\/ p384_affinify p = ec_affinify(p384_field, p)\n\n\/* Convert a p384 affine point to a Jacobian point *\/\np384_jacobify : AffinePoint [384] -> JacobianPoint [384]\np384_jacobify p = { x = p.x, y = p.y, z = 1 }\n\np384_base4 : JacobianPoint [384]\np384_base4 = p384_ec_double(p384_ec_double(p384_jacobify(p384_base)))\n\np384_base3 : AffinePoint [384]\np384_base3 = p384_affinify(p384_ec_full_sub(p384_base4, p384_base))\n\np384_base5 : AffinePoint [384]\np384_base5 = p384_affinify(p384_ec_full_add(p384_base4, p384_base))\n\n\n\/* Does an affine point lie on the curve? *\/\np384_is_affine_point : AffinePoint [384] -> Bit\np384_is_affine_point p =\n  p384_field_sq(p.y) ==\n  p384_field_add(p384_field_cube(p.x),\n                 p384_field_add(p384_field_mul(p384_a, p.x), p384_b))\n\n\/* Tests for p384 *\/\n\n\/* Point \"S\" defined in [NSA 2008, Section 4.4.2] *\/\np384_s : AffinePoint [384]\np384_s = nzAffinePoint(\n  join [0xfba203b8, 0x1bbd23f2, 0xb3be971c, 0xc23997e1, 0xae4d89e6, 0x9cb6f923,\n        0x85dda827, 0x68ada415, 0xebab4167, 0x459da98e, 0x62b1332d, 0x1e73cb0e],\n  join [0x5ffedbae, 0xfdeba603, 0xe7923e06, 0xcdb5d0c6, 0x5b223014, 0x29293376,\n        0xd5c6944e, 0x3fa6259f, 0x162b4788, 0xde6987fd, 0x59aed5e4, 0xb5285e45])\n\n\/* Point \"T\" defined in [NSA 2008, Section 4.4.2] *\/\np384_t : AffinePoint [384]\np384_t = nzAffinePoint(\n  join [0xaacc0520, 0x2e7fda6f, 0xc73d82f0, 0xa6622052, 0x7da8117e, 0xe8f8330e,\n        0xad7d20ee, 0x6f255f58, 0x2d8bd38c, 0x5a7f2b40, 0xbcdb68ba, 0x13d81051],\n  join [0x84009a26, 0x3fefba7c, 0x2c57cffa, 0x5db3634d, 0x286131af, 0xc0fca8d2,\n        0x5afa22a7, 0xb5dce0d9, 0x470da892, 0x33cee178, 0x592f49b6, 0xfecb5092])\n\n\/* Multiple \"D\" defined in [NSA 2008, Section 4.4.2] *\/\np384_d =\n  join [0xa4ebcae5, 0xa6659834, 0x93ab3e62, 0x6085a24c, 0x104311a7, 0x61b5a8fd,\n        0xac052ed1, 0xf111a5c4, 0x4f76f456, 0x59d2d111, 0xa61b5fdd, 0x97583480]\n\n\/* Multiple \"E\" defined in [NSA 2008, Section 4.4.2] *\/\np384_e =\n  join [0xafcf8811, 0x9a3a76c8, 0x7acbd600, 0x8e1349b2, 0x9f4ba9aa, 0x0e12ce89,\n        0xbcfcae21, 0x80b38d81, 0xab8cf150, 0x95301a18, 0x2afbc689, 0x3e75385d]\n\np384_projectify : AffinePoint [384] -> JacobianPoint [384]\np384_projectify(p) = ec_projectify(f,p)\n  where f = p384_curve.point_ops.field\n\np384_affinify : JacobianPoint [384] -> AffinePoint [384]\np384_affinify(p) = ec_affinify(f,p)\n  where f = p384_curve.point_ops.field\n\ntest_p384_s_plus_t : AffinePoint [384]\ntest_p384_s_plus_t = p384_affinify(add(p384_projectify(s),t))\n  where s = p384_s\n        t = p384_t\n        add = p384_curve.point_ops.add\n\nexpected_p384_s_plus_t : AffinePoint [384]\nexpected_p384_s_plus_t =\n  { x = join [0x12dc5ce7, 0xacdfc584, 0x4d939f40, 0xb4df012e, 0x68f865b8, 0x9c3213ba,\n              0x97090a24, 0x7a2fc009, 0x075cf471, 0xcd2e85c4, 0x89979b65, 0xee0b5eed]\n  , y = join [0x167312e5, 0x8fe0c0af, 0xa248f285, 0x4e3cddcb, 0x557f983b, 0x3189b67f,\n              0x21eee013, 0x41e7e9fe, 0x67f6ee81, 0xb36988ef, 0xa406945c, 0x8804a4b0]\n  }\n\ntest_p384_s_minus_t : AffinePoint [384]\ntest_p384_s_minus_t = p384_affinify(sub(p384_projectify(s),t))\n  where s = p384_s\n        t = p384_t\n        sub = p384_curve.point_ops.sub\n\nexpected_p384_s_minus_t : AffinePoint [384]\nexpected_p384_s_minus_t =\n  { x = join [0x6afdaf8d, 0xa8b11c98, 0x4cf177e5, 0x51cee542, 0xcda4ac2f, 0x25cd522d,\n              0x0cd710f8, 0x8059c656, 0x5aef78f6, 0xb5ed6cc0, 0x5a6666de, 0xf2a2fb59]\n  , y = join [0x7bed0e15, 0x8ae8cc70, 0xe847a603, 0x47ca1548, 0xc348decc, 0x6309f48b,\n              0x59bd5afc, 0x9a9b804e, 0x7f787617, 0x8cb5a7eb, 0x4f6940a9, 0xc73e8e5e]\n  }\n\ntest_p384_double_s : AffinePoint [384]\ntest_p384_double_s = p384_affinify(dbl(p384_projectify(s)))\n  where s = p384_s\n        dbl = p384_curve.point_ops.double\n\nexpected_p384_double_s : AffinePoint [384]\nexpected_p384_double_s =\n  { x = join [0x2a2111b1, 0xe0aa8b2f, 0xc5a19755, 0x16bc4d58, 0x017ff96b, 0x25e1bdff,\n              0x3c229d5f, 0xac3bacc3, 0x19dcbec2, 0x9f9478f4, 0x2dee597b, 0x4641504c]\n  , y = join [0xfa2e3d9d, 0xc84db895, 0x4ce8085e, 0xf28d7184, 0xfddfd134, 0x4b4d4797,\n              0x343af9b5, 0xf9d83752, 0x0b450f72, 0x6443e411, 0x4bd4e5bd, 0xb2f65ddd]\n  }\n\ntest_p384_ds : AffinePoint [384]\ntest_p384_ds = p384_affinify(mul(p384_d, p384_s))\n  where mul = p384_curve.mul\n\nexpected_p384_ds : AffinePoint [384]\nexpected_p384_ds =\n  { x = join [0xe4f77e7f, 0xfeb7f095, 0x8910e3a6, 0x80d677a4, 0x77191df1, 0x66160ff7,\n              0xef6bb526, 0x1f791aa7, 0xb45e3e65, 0x3d151b95, 0xdad3d93c, 0xa0290ef2]\n  , y = join [0xac7dee41, 0xd8c5f4a7, 0xd5836960, 0xa773cfc1, 0x376289d3, 0x373f8cf7,\n              0x417b0c62, 0x07ac32e9, 0x13856612, 0xfc9ff2e3, 0x57eb2ee0, 0x5cf9667f]\n  }\n\ntest_p384_ds_et : AffinePoint [384]\ntest_p384_ds_et = p384_affinify(twin_mul(p384_d, p384_s, p384_e, p384_t))\n  where twin_mul = p384_curve.twin_mul\n\nexpected_p384_ds_et : AffinePoint [384]\nexpected_p384_ds_et =\n  { x = join [0x917ea28b, 0xcd641741, 0xae5d18c2, 0xf1bd917b, 0xa68d34f0, 0xf0577387,\n              0xdc812604, 0x62aea60e, 0x2417b8bd, 0xc5d954fc, 0x729d211d, 0xb23a02dc]\n  , y = join [0x1a29f7ce, 0x6d074654, 0xd77b4088, 0x8c73e925, 0x46c8f16a, 0x5ff6bcbd,\n              0x307f758d, 0x4aee684b, 0xeff26f67, 0x42f597e2, 0x585c86da, 0x908f7186]\n  }\n\nproperty test_plus =\n  test_p384_s_plus_t  == expected_p384_s_plus_t\n\nproperty test_minus =\n  test_p384_s_minus_t == expected_p384_s_minus_t\n\nproperty test_double =\n  test_p384_double_s  == expected_p384_double_s\n\nproperty test_ds =\n  test_p384_ds    == expected_p384_ds\n\nproperty test_ds_et =\n  test_p384_ds_et == expected_p384_ds_et","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-demos\/cryptol-specs\/Common\/EC\/ec_point_ops.cry","filetype":"cry","content":"module Common::EC::ec_point_ops where\n\nimport Common::Field\nimport Common::Set\n\ntype AffinePoint fv = { x : fv, y : fv }\n\n\/* Return an affine point. *\/\nnzAffinePoint : {fv} (fv,fv) -> AffinePoint fv\nnzAffinePoint (ax,ay) = { x = ax, y = ay }\n\n\/* Define Jacobian points *\/\ntype JacobianPoint fv = { x : fv, y : fv, z : fv }\n\n\/* Create affine point from Jacobian (only well-defined if z coordinate is non-zero). *\/\nec_affinify : {fv} (Field fv, JacobianPoint fv) -> AffinePoint fv\nec_affinify(f,s) = { x = f.mul(g2, s.x), y = f.mul(g3, s.y) }\n  where g = f.div(f.field_unit, s.z)\n        g2 = f.sq(g)\n        g3 = f.mul(g, g2)\n\n\/* Create projective value from affine. *\/\n\/* Routine 2.2.1 in [NSA 2008] *\/\nec_projectify : {fv} (Field fv, AffinePoint fv) -> JacobianPoint fv\nec_projectify(f,s) = { x = s.x, y = s.y, z = f.field_unit }\n\n\/* Returns zero point. *\/\nec_zero_point : {fv} Field fv -> JacobianPoint fv\nec_zero_point(f) = { x = f.field_unit, y = f.field_unit, z = f.field_zero }\n\n\/* Checks to see if point is zero. *\/\nec_is_zero_point : {fv} (Field fv, JacobianPoint fv) -> Bit\nec_is_zero_point(f,s) = f.is_equal(s.z, f.field_zero)\n\n\/* Is the Jacobian point well-formed? Here we assume\n** the only valid zero-point is the unit zero point.\n** NOTE: The output of ECC operations in this file always\n**   satisfies this assumption. However, they are more\n**   permissive in their inputs, i.e. they still do the\n**   right thing when given a non-unit zero point.\n*\/\nis_JacobianPoint : {fv} (Cmp fv) => Field fv -> Set (JacobianPoint fv)\nis_JacobianPoint f s =\n  (  f.is_val ((s:JacobianPoint fv).x)\n  && f.is_val (s.y)\n  && f.is_val (s.z)\n  && implies (ec_is_zero_point (f,s))\n             (s == ec_zero_point f)\n  )\n\ntype PointOps fv gv = {\n       field : Field fv\n     , double : JacobianPoint fv -> JacobianPoint fv\n     , add : (JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\n     , sub : (JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\n     , group_field : Field gv\n     }\n\n\/* Double a Jacobian point *\/\n\/* Line numbers taken from Routine 2.2.6 in [NSA 2008] *\/\n\/* This version uses 4 multiplies and 4 squarings (4M + 4S).  The paper\n   \"A software implementation of NIST P-224\" by Bernstein 2001 has a\n   version that uses 3M + 5S.\n   In that version, there are the following correspondances\n     r7  = delta\n     r11 = alpha\n     r14 = gamma\n     r15 = beta\n     r16 = 4*beta\n     r17 = alpha^2\n     r18 = x3 = alpha^2 - 8*beta\n     r12 = y1 * z1\n   The key difference is to replace the computation of r13\n    with \"r13 = (s.y + s.z)^2 - s.y^2 - s.z^2\".\n   *\/\nec_double : {fv} (Field fv, JacobianPoint fv) -> JacobianPoint fv\nec_double(f,s) =\n  if is_zero(s.z) then\n    { x = f.field_unit, y = f.field_unit, z = f.field_zero } \/* 5: r <- (1,1,0) and return *\/\n  else\n    { x = r18, y = r23, z = r13 }\n where\n   add = f.add\n   sub = f.sub\n   mul = f.mul\n   is_zero(x) = f.is_equal(x, f.field_zero)\n   dbl(x) = f.add(x, x)\n   mul3(x) = f.add(x, f.add(x, x))\n   mul4(x) = dbl(dbl(x))\n   mul8(x) = dbl(mul4(x))\n\n   r7  = f.sq(s.z)               \/*  7: t4 <- (t3)^2 *\/\n   r8  = f.sub(s.x, r7)          \/*  8: t5 <- t1 - t4 *\/\n   r9  = add(s.x, r7)            \/*  9: t4 <- t1 + t4 *\/\n   r10 = mul(r9, r8)             \/* 10: t5 <- t4 * t5 *\/\n   r11 = mul3(r10)               \/* 11: t4 <- 3 * t5 *\/\n   r12 = mul(s.z, s.y)           \/* 12: t3 <- t3 * t2 *\/\n   r13 = dbl(r12)                \/* 13: t3 <- 2 * t3 *\/\n   r14 = f.sq(s.y)               \/* 14: t2 <- (t2)^2 *\/\n   r15 = mul(s.x, r14)           \/* 15: t5 <- t1 * t2 *\/\n   r16 = mul4(r15)               \/* 16: t5 <- 4 * t5 *\/\n   r17 = f.sq(r11)               \/* 17: t1 <- (t4)^2 *\/\n   r18 = sub(sub(r17, r16), r16) \/* 18: t1 <- t1 - 2 * t5 *\/\n   r19 = f.sq(r14)               \/* 19: t2 <- (t2)^2 *\/\n   r20 = mul8(r19)                  r21 = sub(r16, r18)              r22 = mul(r11, r21)              r23 = sub(r22, r20)           \/**\n * Add a Jacobian point to an affine point over the given field.\n * Note: Will return { 0, 0, 0 } if points are equivalent, and double should be\n *       called.\n * Algorithm comes from Routine 2.2.7 in [NSA 2008].\n *\/\nec_add : {fv, gv} (PointOps fv [gv], JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\nec_add(p,s,t) =\n  if is_zero(r13) then\n    if is_zero(r14) then\n      p.double(s)     else\n      { x = p.field.field_unit\n      , y = p.field.field_unit\n      , z = p.field.field_zero\n      }   else\n    { x = r32, y = r37, z = r27 }\n  where\n   add = p.field.add\n   sub = p.field.sub\n   mul = p.field.mul\n   sq  = p.field.sq\n   is_zero(x) = p.field.is_equal(x, p.field.field_zero)\n   dbl(x) = add(x, x)\n   dbl_dec(x, y) = sub(sub(x, y), y)\n   \/* Line numbers from Routine 2.2.7 definition. *\/\n\n   r9 = sq(s.z)             \/*  9: t7 <- (t3)^2 *\/\n   r10 = mul(t.x, r9)       \/* 10: t4 <- t4 * t7 *\/\n   r11 = mul(s.z, r9)       \/* 11: t7 <- t3 * t7 *\/\n   r12 = mul(t.y, r11)         r13 = sub(s.x, r10)         r14 = sub(s.y, r12)         r22 = sub(dbl(s.x), r13)    r23 = sub(dbl(s.y), r14)    r27 = mul(s.z, r13)         r28 = sq(r13)               r29 = mul(r13, r28)      \/* 29: t4 <- t4 * t7 *\/\n   r30 = mul(r22, r28)      \/* 30: t7 <- t1 * t7 *\/\n   r31 = sq(r14)            \/* 31: t1 <- (t1)^2 *\/\n   r32 = sub(r31, r30)      \/* 32: t1 <- t1 - t7 *\/\n   \/*r33 = sub(r30, dbl(r32))*\/ \/* 33: t7 <- t7 - 2*t1 *\/\n   \/* The following is a better match for the Java implementation. *\/\n   r33 = dbl_dec(r30, r32)  \/* 33: t7 <- t7 - 2*t1 *\/\n   r34 = mul(r14, r33)      \/* 34: t5 <- t5 * t7 *\/\n   r35 = mul(r23, r29)      \/* 35: t4 <- t2 * t4 *\/\n   r36 = sub(r34, r35)      \/* 36: t2 <- t5 - t4 *\/\n   r37 = p.field.half(r36)  \/* Add Jacobian point to an affine point over the given field. *\/\n\/* Algorithm comes from Routine 2.2.8 in [NSA 2008] *\/\nec_full_add : {fv, gv} (fin gv) => (PointOps fv [gv], JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\nec_full_add(p, s, t) =\n  if is_zero(s.z) then\n    { x = t.x, y = t.y, z = p.field.field_unit }\n  else\n    ec_add(p, s, t)\n where\n   is_zero(x) = p.field.is_equal(x, p.field.field_zero)\n\n\/* Subtract affine point from Jacobian point over the given field. *\/\n\/* Algorithm comes from Routine 2.2.9 in [NSA 2008] *\/\nec_full_sub : {fv, gv} (PointOps fv [gv], JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\nec_full_sub(p, s, t) = p.add(s, { x = t.x, y = p.field.neg(t.y) })\n","variant":"hybrid","set":"unsupervised"}
{"filename":"saw-demos\/cryptol-specs\/Common\/EC\/p384_field.cry","filetype":"cry","content":"module Common::EC::p384_field where\n\nimport Common::bv\nimport Common::mod_arith\nimport Common::mul_java\nimport Common::Field\n\np384_prime : [384]\np384_prime = - (2 ^^ 384 + 2 ^^ 128 + 2 ^^ 96 - 2 ^^ 32 + 1)\n\n\/\/ Give explicit names to these finite field operators, so SBV\n\/\/  can uninterpret them.\np384_is_field_val : [384] -> Bit\np384_is_field_val = is_normal p384_prime\n\np384_is_group_val : [384] -> Bit\np384_is_group_val  = is_normal p384_group_size\n\np384_mod_add : ([384],[384],[384]) -> [384]\np384_mod_add = mod_add\n\np384_mod_sub : ([384],[384],[384]) -> [384]\np384_mod_sub = mod_sub\n\np384_mod_neg : ([384], [384]) -> [384]\np384_mod_neg = mod_neg\n\np384_safe_product : ([384], [384]) -> [768]\np384_safe_product (x, y) = safe_product(x, y)\n\np384_field_add(x,y) = p384_mod_add(p384_prime, x, y)\np384_field_sub(x,y) = p384_mod_sub(p384_prime, x, y)\n\/* p384_field_neg(x) returns -x mod p384_prime. *\/\np384_field_neg(x)        = if x == 0 then 0 else (p384_prime - x)\n\np384_field_mul : ([384],[384]) -> [384]\np384_field_mul(x,y)      = p384_field_mod(p384_safe_product(x, y))\n\np384_field_sq(x)         = p384_field_mul(x, x)\n\np384_mod_half : ([384],[384]) -> [384]\np384_mod_half = mod_half\n\np384_mod_mul : ([384],[384],[384]) -> [384]\np384_mod_mul = mod_mul\n\np384_mod_div : ([384],[384],[384]) -> [384]\np384_mod_div = mod_div\n\n\/\/ P384 field reference modulus.\np384_field_mod : [768] -> [384]\np384_field_mod(a)\n    = drop(if b1 then r0\n           else if b2 then r1\n           else if b3 then r2\n           else if b4 then r3\n           else r4)\n  where\n    [  a23, a22, a21, a20, a19, a18, a17, a16, a15, a14, a13, a12,\n       a11, a10,  a9,  a8,  a7,  a6,  a5,  a4,  a3,  a2,  a1,  a0]\n              = [ zext x | (x : [32]) <- split a ] : [24][64]\n\n    chop : [64] -> ([64],[32])\n    chop x = (sext(take(x):[32]), drop(x))\n\n    (d0, z0)  = chop(    a0          +a12+a21        +a20-a23)\n    (d1, z1)  = chop(d0 +a1          +a13+a22+a23        -a12-a20)\n    (d2, z2)  = chop(d1 +a2          +a14+a23            -a13-a21)\n    (d3, z3)  = chop(d2 +a3          +a15+a12+a20    +a21-a14-a22-a23)\n    (d4, z4)  = chop(d3 +a4 +(a21<<1)+a16+a13+a12+a20+a22-a15-(a23<<1))\n    (d5, z5)  = chop(d4 +a5 +(a22<<1)+a17+a14+a13+a21+a23-a16)\n    (d6, z6)  = chop(d5 +a6 +(a23<<1)+a18+a15+a14+a22    -a17)\n    (d7, z7)  = chop(d6 +a7          +a19+a16+a15+a23    -a18)\n    (d8, z8)  = chop(d7 +a8          +a20+a17+a16        -a19)\n    (d9, z9)  = chop(d8 +a9          +a21+a18+a17        -a20)\n    (d10,z10) = chop(d9 +a10         +a22+a19+a18        -a21)\n    (d11,z11) = chop(d10+a11         +a23+a20+a19        -a22)\n\n    r : [13*32]\n    r = (drop(d11):[32])\n      # z11 # z10 #  z9 #  z8 #  z7 #  z6\n      #  z5 #  z4 #  z3 #  z2 #  z1 #  z0\n\n    p  = zext(p384_prime) : [13*32]\n    \/\/ Fix potential underflow\n    r0 = if (d11@0) then r + p else r\n    \/\/ Fix potential overflow\n    (r1,b1)   = sbb(r0, p)\n    (r2,b2)   = sbb(r1, p)\n    (r3,b3)   = sbb(r2, p)\n    (r4,b4)   = sbb(r3, p)\n\n\/* Defines a reference prime field that uses normalized numbers and\n   large word bit operations. *\/\np384_field :  Field [384]\np384_field = {\n    is_val     = p384_is_field_val\n  , norm       = \\x -> if x < p384_prime then x else x - p384_prime\n  , add        = p384_field_add\n  , sub        = p384_field_sub\n  , neg        = p384_field_neg\n  , mul        = p384_field_mul\n  , sq         = p384_field_sq\n  , half       = \\x -> p384_mod_half(p384_prime, x)\n  , div        = \\(x,y) -> p384_mod_div(p384_prime, x, y)\n  , field_zero = 0\n  , field_unit = 1\n  , is_equal   = \\(x,y) -> x == y\n  }\n\np384_group_size : [384]\np384_group_size =\n  join\n    [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n     0xc7634d81, 0xf4372ddf, 0x581a0db2, 0x48b0a77a, 0xecec196a, 0xccc52973]\n\n\/* Defines a reference prime field that uses normalized numbers and\n   large word bit operations. *\/\np384_group_field :  Field [384]\np384_group_field =\n  { is_val     = p384_is_group_val\n  , norm       = \\x -> if x < p384_group_size then x else x - p384_group_size\n  , add        = \\(x,y) -> p384_mod_add(p384_group_size, x, y)\n  , sub        = \\(x,y) -> p384_mod_sub(p384_group_size, x, y)\n  , neg        = \\x     -> p384_mod_neg(p384_group_size, x)\n  , mul        = \\(x,y) -> p384_group_mul(p384_group_size, x, y)\n  , sq         = \\x     -> p384_mod_mul(p384_group_size, x, x)\n  , half       = \\x     -> p384_mod_half(p384_group_size, x)\n  , div        = \\(x,y) -> p384_mod_div(p384_group_size, x, y)\n  , field_zero = 0\n  , field_unit = 1\n  , is_equal   = \\(x,y) -> x == y\n  }\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-demos\/templates\/c\/dotprod.cry","filetype":"cry","content":"dotprod : {n, a} (fin n, Eq a, Ring a) => [n]a -> [n]a -> a\ndotprod xs ys = sum (zipWith (*) xs ys)\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-demos\/demos\/xxhash\/xxhash.cry","filetype":"cry","content":"module xxhash where\n\n\/**\n * The 32-bit variant of xxHash. The first argument is the sequence\n * of L bytes to hash. The second argument is a seed value.\n *\/\nXXH32 : {L} (fin L) => [L][8] -> [32] -> [32]\nXXH32 input seed = XXH32_avalanche acc1\n  where (stripes16 # stripes4 # stripes1) = input\n        accR = foldl XXH32_rounds (XXH32_init seed) (split stripes16 : [L\/16][16][8])\n        accL = `(L % 2^^32) + if (`L:Integer) < 16\n                              then seed + PRIME32_5\n                              else XXH32_converge accR\n        acc4 = foldl XXH32_digest4 accL (split stripes4 : [(L%16)\/4][4][8])\n        acc1 = foldl XXH32_digest1 acc4 (stripes1 : [L%4][8])\n\n\/**\n * The 64-bit variant of xxHash. The first argument is the sequence\n * of L bytes to hash. The second argument is a seed value.\n *\/\nXXH64 : {L} (fin L) => [L][8] -> [64] -> [64]\nXXH64 input seed = XXH64_avalanche acc1\n  where (stripes32 # stripes8 # stripes4 # stripes1) = input\n        accR = foldl XXH64_rounds (XXH64_init seed) (split stripes32 : [L\/32][32][8])\n        accL = `(L % 2^^64) + if (`L:Integer) < 32\n                              then seed + PRIME64_5\n                              else XXH64_converge accR\n        acc8 = foldl XXH64_digest8 accL (split stripes8 : [(L%32)\/8][8][8])\n        acc4 = foldl XXH64_digest4 acc8 (split stripes4 : [(L%8)\/4][4][8])\n        acc1 = foldl XXH64_digest1 acc4 (stripes1 : [L%4][8])\n\nprivate\n\n  \/\/Utility functions\n\n  \/**\n   * Combines a sequence of bytes into a word using the little-endian\n   * convention.\n   *\/\n  toLE bytes = join (reverse bytes)\n\n  \/\/32-bit xxHash helper functions\n\n  \/\/32-bit prime number constants\n  PRIME32_1 = 0x9E3779B1 : [32]\n  PRIME32_2 = 0x85EBCA77 : [32]\n  PRIME32_3 = 0xC2B2AE3D : [32]\n  PRIME32_4 = 0x27D4EB2F : [32]\n  PRIME32_5 = 0x165667B1 : [32]\n\n  \/**\n   * The property shows that the hexadecimal representation of the\n   * PRIME32 constants is the same as the binary representation.\n   *\/\n  property PRIME32s_as_bits_correct =\n    (PRIME32_1 == 0b10011110001101110111100110110001) \/\\\n    (PRIME32_2 == 0b10000101111010111100101001110111) \/\\\n    (PRIME32_3 == 0b11000010101100101010111000111101) \/\\\n    (PRIME32_4 == 0b00100111110101001110101100101111) \/\\\n    (PRIME32_5 == 0b00010110010101100110011110110001)\n\n  \/**\n   * This function initializes the four internal accumulators of XXH32.\n   *\/\n  XXH32_init : [32] -> [4][32]\n  XXH32_init seed = [acc1, acc2, acc3, acc4]\n    where acc1 = seed + PRIME32_1 + PRIME32_2\n          acc2 = seed + PRIME32_2\n          acc3 = seed + 0\n          acc4 = seed - PRIME32_1\n\n  \/**\n   * This processes a single lane of the main round function of XXH32.\n   *\/\n  XXH32_round : [32] -> [32] -> [32]\n  XXH32_round accN laneN = ((accN + laneN * PRIME32_2) <<< 13) * PRIME32_1\n\n  \/**\n   * This is the main round function of XXH32 and processes a stripe,\n   * i.e. 4 lanes with 4 bytes each.\n   *\/\n  XXH32_rounds : [4][32] -> [16][8] -> [4][32]\n  XXH32_rounds accs stripe =\n    [ XXH32_round accN (toLE laneN) | accN <- accs | laneN <- split stripe ]\n\n  \/**\n   * This function combines the four lane accumulators into a single\n   * 32-bit value.\n   *\/\n  XXH32_converge : [4][32] -> [32]\n  XXH32_converge [acc1, acc2, acc3, acc4] =\n    (acc1 <<< 1) + (acc2 <<< 7) + (acc3 <<< 12) + (acc4 <<< 18)\n\n  \/**\n   * This function digests a four byte lane\n   *\/\n  XXH32_digest4 : [32] -> [4][8] -> [32]\n  XXH32_digest4 acc lane = ((acc + toLE lane * PRIME32_3) <<< 17) * PRIME32_4\n\n  \/**\n   * This function digests a single byte lane\n   *\/\n  XXH32_digest1 : [32] -> [8] -> [32]\n  XXH32_digest1 acc lane = ((acc + (0 # lane) * PRIME32_5) <<< 11) * PRIME32_1\n\n  \/**\n   * This function ensures that all input bits have a chance to impact\n   * any bit in the output digest, resulting in an unbiased\n   * distribution.\n   *\/\n  XXH32_avalanche : [32] -> [32]\n  XXH32_avalanche acc0 = acc5\n    where acc1 = acc0 ^ (acc0 >> 15)\n          acc2 = acc1 * PRIME32_2\n          acc3 = acc2 ^ (acc2 >> 13)\n          acc4 = acc3 * PRIME32_3\n          acc5 = acc4 ^ (acc4 >> 16)\n\n  \/\/64-bit xxHash helper functions\n\n  \/\/64-bit prime number constants\n  PRIME64_1 = 0x9E3779B185EBCA87 : [64]\n  PRIME64_2 = 0xC2B2AE3D27D4EB4F : [64]\n  PRIME64_3 = 0x165667B19E3779F9 : [64]\n  PRIME64_4 = 0x85EBCA77C2B2AE63 : [64]\n  PRIME64_5 = 0x27D4EB2F165667C5 : [64]\n\n  \/**\n   * The property shows that the hexadecimal representation of the\n   * PRIME64 constants is the same as the binary representation.\n   *\/\n  property PRIME64s_as_bits_correct =\n    (PRIME64_1 == 0b1001111000110111011110011011000110000101111010111100101010000111) \/\\\n    (PRIME64_2 == 0b1100001010110010101011100011110100100111110101001110101101001111) \/\\\n    (PRIME64_3 == 0b0001011001010110011001111011000110011110001101110111100111111001) \/\\\n    (PRIME64_4 == 0b1000010111101011110010100111011111000010101100101010111001100011) \/\\\n    (PRIME64_5 == 0b0010011111010100111010110010111100010110010101100110011111000101)\n\n  \/**\n   * This function initializes the four internal accumulators of XXH64.\n   *\/\n  XXH64_init : [64] -> [4][64]\n  XXH64_init seed = [acc1, acc2, acc3, acc4]\n    where acc1 = seed + PRIME64_1 + PRIME64_2\n          acc2 = seed + PRIME64_2\n          acc3 = seed + 0\n          acc4 = seed - PRIME64_1\n\n  \/**\n   * This processes a single lane of the main round function of XXH64.\n   *\/\n  XXH64_round : [64] -> [64] -> [64]\n  XXH64_round accN laneN = ((accN + laneN * PRIME64_2) <<< 31) * PRIME64_1\n\n  \/**\n   * This is the main round function of XXH64 and processes a stripe,\n   * i.e. 4 lanes with 8 bytes each.\n   *\/\n  XXH64_rounds : [4][64] -> [32][8] -> [4][64]\n  XXH64_rounds accs stripe =\n    [ XXH64_round accN (toLE laneN) | accN <- accs | laneN <- split stripe ]\n\n  \/**\n   * This is a helper function, used to merge the four lane accumulators.\n   *\/\n  mergeAccumulator : [64] -> [64] -> [64]\n  mergeAccumulator acc accN = (acc ^ XXH64_round 0 accN) * PRIME64_1 + PRIME64_4\n\n  \/**\n   * This function combines the four lane accumulators into a single\n   * 64-bit value.\n   *\/\n  XXH64_converge : [4][64] -> [64]\n  XXH64_converge [acc1, acc2, acc3, acc4] =\n    foldl mergeAccumulator ((acc1 <<< 1) + (acc2 <<< 7) + (acc3 <<< 12) + (acc4 <<< 18)) [acc1, acc2, acc3, acc4]\n\n  \/**\n   * This function digests an eight byte lane\n   *\/\n  XXH64_digest8 : [64] -> [8][8] -> [64]\n  XXH64_digest8 acc lane = ((acc ^ XXH64_round 0 (toLE lane)) <<< 27) * PRIME64_1 + PRIME64_4\n\n  \/**\n   * This function digests a four byte lane\n   *\/\n  XXH64_digest4 : [64] -> [4][8] -> [64]\n  XXH64_digest4 acc lane = ((acc ^ (0 # toLE lane) * PRIME64_1) <<< 23) * PRIME64_2 + PRIME64_3\n\n  \/**\n   * This function digests a single byte lane\n   *\/\n  XXH64_digest1 : [64] -> [8] -> [64]\n  XXH64_digest1 acc lane = ((acc ^ (0 # lane) * PRIME64_5) <<< 11) * PRIME64_1\n\n  \/**\n   * This function ensures that all input bits have a chance to impact\n   * any bit in the output digest, resulting in an unbiased\n   * distribution.\n   *\/\n  XXH64_avalanche : [64] -> [64]\n  XXH64_avalanche acc0 = acc5\n    where acc1 = acc0 ^ (acc0 >> 33)\n          acc2 = acc1 * PRIME64_2\n          acc3 = acc2 ^ (acc2 >> 29)\n          acc4 = acc3 * PRIME64_3\n          acc5 = acc4 ^ (acc4 >> 32)\n","variant":"hybrid","set":"supervised"}
{"filename":"saw-demos\/demos\/signal-protocol\/cryptol\/HMAC.cry","filetype":"cry","content":"type HMAC_CONTEXT_LENGTH = 1\ntype HMACContext = [HMAC_CONTEXT_LENGTH][8]\n\ntype SIGNAL_MESSAGE_MAC_LENGTH = 8\n\nhmac_init : {n} [n][8] -> \/\/ Key\n            HMACContext\nhmac_init = undefined\n\nhmac_update : {n} [n][8] -> \/\/ Data\n              HMACContext -> HMACContext\nhmac_update = undefined\n\nhmac_final : HMACContext ->\n             [SIGNAL_MESSAGE_MAC_LENGTH][8] \/\/ Signal buffer\nhmac_final = undefined\n","variant":"hybrid","set":"unsupervised"}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/AES.cry","filetype":"cry","content":"module AES where\n\nimport `Common::AES\n\ntype constraint ValidKey k m = (k == 128 + m * 64, 2 >= m)\n\ntype ExpandedKey m = KeySchedule m\n\nencrypt : {k,m} ValidKey k m => [k] -> [128] -> [128]\nencrypt = aesEncrypt`{Mode = m}\n\nexpandKey : {k,m} ValidKey k m => [k] -> ExpandedKey m\nexpandKey = ExpandKey`{Mode = m}\n\nencryptWithSchedule : {k,m} ValidKey k m => ExpandedKey m -> [128] -> [128]\nencryptWithSchedule = aesEncryptWithSchedule`{Mode = m}\n\nproperty test k pt = encrypt k pt == encryptWithSchedule (expandKey k) pt\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/AES128.cry","filetype":"cry","content":"\/\/ 128-bit AES\nmodule AES128 where\n\nimport `Common::AES\nimport `Common::AES as AES\nimport AES as AES\n\ntype State         = AES::State 0  \/* 0 is unused *\/\ntype KeySchedule   = AES::KeySchedule 0\ntype RoundKey      = AES::RoundKey 0\n\nsub_bytes128 : State -> State\nsub_bytes128 = SubBytes`{0}\n\nshift_rows128 : State -> State\nshift_rows128 = ShiftRows`{0}\n\nexpand_key128 : [128] -> KeySchedule\nexpand_key128 = AES::expandKey\n\naes_round128 : RoundKey -> State -> State\naes_round128 = AES::aes_round`{0}\n\naes_final_round128 : RoundKey -> State -> State\naes_final_round128 = AES::aes_final_round`{0}\n\nencryptState128 : KeySchedule -> State -> State\nencryptState128 = AES::encryptState`{0}\n\n","variant":"hybrid","set":"supervised"}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/intrinsics.cry","filetype":"cry","content":"module Intrinsics where\n\nimport `Common::AES_GCM_SIV as AES_GCM_SIV\n\n_mm_setr_epi32 : [32] -> [32] -> [32] -> [32] -> [128]\n_mm_setr_epi32 a b c d = join [a, b, c, d]\n\n_mm_loadu_si128 : [128] -> [4][32]\n_mm_loadu_si128 v = split v\n\nselect_from_128 : [128] -> Bit -> [128]\nselect_from_128 n b = res\n  where\n    [l,r] = split n\n    res = (if b then l else r) # zero\n\n\n_mm_clmulepi64_si128 : [128] -> [128] -> [2] -> [128 ]\n_mm_clmulepi64_si128 a b s = AES_GCM_SIV::mult`{0}`{0} l r\n  where\n  l = select_from_128 a (s @ 0)\n  r = select_from_128 b (s @ 1)\n\n_mm_xor_si128 : [128] -> [128] -> [128]\n_mm_xor_si128 a b = a ^ b\n\n\/\/this is a word rotation\n_mm_shuffle_epi32_78 : [4][32] -> [4][32]\n_mm_shuffle_epi32_78 l = l >>> 2\n\n\/\/flatten and concat a and b, shifting them right by ralign bytes\n_mm_alignr_epi8 : [16][8] -> [16][8] -> [8] -> [128]\n_mm_alignr_epi8 a b ralign = take ((join (a # b)) >> (ralign * 8))\n\nINIT_Htable : {n} (fin n, n>=2) => [128] -> [n][128]\nINIT_Htable H = hs\n  where\n  hs = [H] # [ AES_GCM_SIV::dot`{0}`{0} hn H\n                | hn <- hs\n                | (j : [width n]) <- [0..n-2]]\n\npolyval_Htable : {n} (fin n, n>=2) => [128] -> [n][128] -> [128]\npolyval_Htable H X = sums ! 0\n  where\n    htable = INIT_Htable`{n} H\n    sums = [zero] # [ (AES_GCM_SIV::dot`{0}`{0} (X@i) (htable!i)) ^ sum\n                    | sum <- sums\n                    | (i : [width n]) <- [0..n-1] ]\n\nproperty polyval_equiv H (xs : [4][128]) =\n  AES_GCM_SIV::polyvalFrom`{0}`{0} H xs zero ==\n  polyval_Htable H xs","variant":"hybrid","set":"unsupervised"}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/AES256.cry","filetype":"cry","content":"module AES256 where\n\nimport `Common::AES\nimport `Common::AES as AES\nimport AES as AES\n\ntype State         = AES::State 2\ntype KeySchedule   = AES::KeySchedule 2\ntype RoundKey      = AES::RoundKey 2\n\nsub_bytes256 : State -> State\nsub_bytes256 = SubBytes`{2}\n\nshift_rows256 : State -> State\nshift_rows256 = ShiftRows`{2}\n\nexpand_key256 : [256] -> KeySchedule\nexpand_key256 = AES::expandKey\n\naes_round256 : RoundKey -> State -> State\naes_round256 = AES::aes_round`{2}\n\naes_final_round256 : RoundKey -> State -> State\naes_final_round256 = AES::aes_final_round`{2}\n\nencryptState256 : KeySchedule -> State -> State\nencryptState256 = AES::encryptState`{2}\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/TBox.cry","filetype":"cry","content":"type Nb         = 4\ntype State      = [4][Nb]GF28\ntype RoundKey   = State\n\n\/** Convert a block into the internal state of AES *\/\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\n\/** Convert an AES internal state back to a block. *\/\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\n\n\n\n\n\ntype GF28        = [8]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y  = pmod (pmult x y) irreducible\n\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k = pow k\n  where   sq x  = gf28Mult x x\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult n (sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow x 254\n\ngf28DotProduct : {n} (fin n) => [n]GF28 -> [n]GF28 -> GF28\ngf28DotProduct xs ys = gf28Add [ gf28Mult x y | x <- xs | y <- ys ]\n\ngf28VectorMult : {n, m} (fin n) => [n]GF28 -> [m][n]GF28 -> [m]GF28\ngf28VectorMult v ms = [ gf28DotProduct v m | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => [n][m]GF28 -> [m][k]GF28 -> [n][k]GF28\ngf28MatrixMult xss yss = [ gf28VectorMult xs yss' | xs <- xss ]\n   where yss' = transpose yss\n\n\n\nsbox : [256]GF28\nsbox = [\n 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n 0x54, 0xbb, 0x16]\n\n\nsbox_inverse : [256] GF28\nsbox_inverse = [\n    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,\n    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,\n    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,\n    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,\n    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,\n    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,\n    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,\n    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,\n    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,\n    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,\n    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,\n    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,\n    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,\n    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,\n    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,\n    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,\n    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D]\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/Common\/AES.cry","filetype":"cry","content":"\/\/ This is a fairly close implementation of the FIPS-197 standard:\n\/\/   http:\/\/csrc.nist.gov\/publications\/fips\/fips197\/fips-197.pdf\n\nmodule Common::AES where\n\nparameter\n  type Mode : #\n  type constraint (2 >= Mode)\n\n\ntype AESKeySize  = 32 * Nk\n\n\/\/ AES Encryption\naesEncrypt : [AESKeySize] -> [128] -> [128]\naesEncrypt key pt = aesEncryptWithSchedule (ExpandKey key) pt\n\n\naes_round : RoundKey -> State -> State\naes_round k s =\n  k ^ transpose\n        [ t 0 ^ t 1 ^ t 2 ^ t 3 where t n = tbox n (s @ n @ (j + n))\n        | j <- [ 0 .. 3 ]\n        ]\n\ntbox : [2] -> GF28 -> [4]GF28\ntbox n x = (T0_table @ x) >>> n\n\nT0_table : [256][4] GF28\nT0_table = [ [gf28Mult (2, s), s, s, gf28Mult (3, s) ] | s <- sbox ]\n\naes_final_round : RoundKey -> State -> State\naes_final_round k s = AESFinalRound (k,s)\n\nencryptState : KeySchedule -> State -> State\nencryptState (kInit, ks, kFinal) pt = aes_final_round kFinal (rounds ! 0)\n  where\n  state0 = AddRoundKey (kInit, pt)\n  rounds = [state0] # [ aes_round rk s | rk <- ks | s <- rounds ]\n\n\n\/** AES Encryption with an expanded key.\nThis is useful if many things will be encrypted with the same key. *\/\naesEncryptWithSchedule : KeySchedule -> [128] -> [128]\naesEncryptWithSchedule ks pt = stateToMsg (encryptState ks (msgToState pt))\n\n\/\/ Number of blocks and Number of rounds\ntype Nk = 4 + 2 * Mode\ntype Nb = 4\ntype Nr = 6 + Nk\n\n\/\/ Helper type definitions\ntype GF28        = [8]\ntype State       = [4][Nb]GF28\ntype RoundKey    = State\ntype KeySchedule = (RoundKey, [Nr-1]RoundKey, RoundKey)\n\n\/\/ GF28 operations\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Mult : (GF28, GF28) -> GF28\ngf28Mult (x, y) = pmod(pmult x y) irreducible\n\ngf28Pow : (GF28, [8]) -> GF28\ngf28Pow (n, k) = pow k\n  where   sq x  = gf28Mult (x, x)\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult(n, sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow (x, 254)\n\ngf28DotProduct : {n} (fin n) => ([n]GF28, [n]GF28) -> GF28\ngf28DotProduct (xs, ys) = gf28Add [ gf28Mult (x, y) | x <- xs\n                                                    | y <- ys ]\ngf28VectorMult : {n, m} (fin n) => ([n]GF28, [m][n]GF28) -> [m]GF28\ngf28VectorMult (v, ms) = [ gf28DotProduct(v, m) | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => ([n][m]GF28, [m][k]GF28) -> [n][k]GF28\ngf28MatrixMult (xss, yss) = [ gf28VectorMult(xs, yss') | xs <- xss ]\n   where yss' = transpose yss\n\n\/\/ The affine transform and its inverse\nxformByte : GF28 -> GF28\nxformByte b = gf28Add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n   where c = 0x63\n\nxformByte' : GF28 -> GF28\nxformByte' b = gf28Add [(b >>> 2), (b >>> 5), (b >>> 7), d] where d = 0x05\n\/\/ The SubBytes transform and its inverse\nSubByte : GF28 -> GF28\nSubByte b = xformByte (gf28Inverse b)\n\nSubByte' : GF28 -> GF28\nSubByte' b = sbox@b\n\nSubBytes : State -> State\nSubBytes state = [ [ SubByte' b | b <- row ] | row <- state ]\n\n\/\/ The ShiftRows transform and its inverse\nShiftRows : State -> State\nShiftRows state = [ row <<< shiftAmount | row <- state\n                                        | shiftAmount : [2] <- [0 .. 3]\n                  ]\n\n\/\/ The MixColumns transform and its inverse\nMixColumns : State -> State\nMixColumns state = gf28MatrixMult (m, state)\n    where m = [[2, 3, 1, 1],\n               [1, 2, 3, 1],\n               [1, 1, 2, 3],\n               [3, 1, 1, 2]]\n\n\/\/ The AddRoundKey transform\nAddRoundKey : (RoundKey, State) -> State\nAddRoundKey (rk, s) = rk ^ s\n\n\/\/ Key expansion\nRcon : [8] -> [4]GF28\nRcon i = [(gf28Pow (<| x |>, i-1)), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte' b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nNextWord : ([8],[4][8],[4][8]) -> [4][8]\nNextWord(i, prev, old) = old ^ mask\n   where mask = if i % nk == 0\n                then SubWord(RotWord(prev)) ^ Rcon (i \/ `Nk)\n                else if (nk > 6) && (i % nk == 4)\n                     then SubWord(prev)\n                     else prev\n\n         nk = `Nk : [8]\n\nExpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nExpandKeyForever seed = [ transpose g | g <- groupBy`{4} (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord(i, prev, old)\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\nExpandKey : [AESKeySize] -> KeySchedule\nExpandKey key = ( keys @ 0\n                , keys @@ ([1 .. (Nr - 1)] : [_][8])\n                , keys @ (`Nr : [8])\n                )\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = ExpandKeyForever seed\n\nfromKS : KeySchedule -> [Nr+1][4][32]\nfromKS (f, ms, l) = [ formKeyWords (transpose k) | k <- [f] # ms # [l] ]\n    where formKeyWords bbs = [ join bs | bs <- bbs ]\n\n\/\/ AES rounds and inverses\nAESRound : (RoundKey, State) -> State\nAESRound (rk, s) = AddRoundKey (rk, MixColumns (ShiftRows (SubBytes s)))\n\nAESFinalRound : (RoundKey, State) -> State\nAESFinalRound (rk, s) = AddRoundKey (rk, ShiftRows (SubBytes s))\n\n\/\/ Converting a 128 bit message to a State and back\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\nsbox : [256]GF28\nsbox = [\n 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n 0x54, 0xbb, 0x16]\n\n","variant":"hybrid","set":"supervised"}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/cryptol\/Asm128.cry","filetype":"cry","content":"module GenAsm128 where\n\nimport X86\nimport AES128\nimport AES128_GCM_SIV\nimport Sizes\n\ndot256 : [256] -> [256] -> [256]\ndot256 (_ # res) (_ # h) = 0 # dot res h\n\ndot512 : [512] -> [512] -> [512]\ndot512 (_ # res) (_ # h) = 0 # dot res h\n\nPolyval_Horner_gen_def :\n  {n} fin n => [1][128] -> [n][8] -> [1][128] -> [1][128]\nPolyval_Horner_gen_def [h] i [t] = [ polyvalFrom h (leLoadBlocks i) t ]\n\nPolyval_Horner_AAD_def : [1][128] -> [AAD_Size][8] -> [1][128] -> [1][128]\nPolyval_Horner_AAD_def = Polyval_Horner_gen_def\n\nPolyval_Horner_MSG_def : [1][128] -> [MSG_Size][8] -> [1][128] -> [1][128]\nPolyval_Horner_MSG_def = Polyval_Horner_gen_def\n\nPolyval_Horner_BLK_def : [1][128] -> [16][8] -> [1][128] -> [1][128]\nPolyval_Horner_BLK_def = Polyval_Horner_gen_def\n\nPolyval_Horner_AAD_MSG_def :\n  [16][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [2][64] -> [16][8] -> [1][128]\nPolyval_Horner_AAD_MSG_def h aad pt lblk t =\n  [ polyvalFrom (leLoad h) work (leLoad t) ]\n  where\n  work = leLoadBlocks aad\n       # leLoadBlocks pt\n       # leLoadBlocks [ b | qword <- lblk, b <- leStore qword ]\n\nINIT_Htable_def: [1][128] -> [8][128]\nINIT_Htable_def [h] = INIT_Htable h\n\nPolyval_HTable_gen_def :\n  {n} (fin n) => [8][128] -> [n][8] -> [1][128] -> [1][128]\nPolyval_HTable_gen_def tbl data [t] =\n  [ polyvalHtableNH tbl (leLoadBlocks data) t ]\n\nPolyval_HTable_AAD_def : [8][128] -> [AAD_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_AAD_def = Polyval_HTable_gen_def\n\nPolyval_HTable_MSG_def : [8][128] -> [MSG_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_MSG_def = Polyval_HTable_gen_def\n\nPolyval_HTable_BLK_def : [8][128] -> [16][8] -> [1][128] -> [1][128]\nPolyval_HTable_BLK_def = Polyval_HTable_gen_def\n\n\nPolyval_HTable_call_AAD_def : [8][128] -> [AAD_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_call_AAD_def hs = Polyval_Horner_AAD_def (take hs)\n\nPolyval_HTable_call_MSG_def : [8][128] -> [MSG_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_call_MSG_def hs = Polyval_Horner_MSG_def (take hs)\n\nPolyval_HTable_call_BLK_def : [8][128] -> [16][8] -> [1][128] -> [1][128]\nPolyval_HTable_call_BLK_def hs = Polyval_Horner_BLK_def (take hs)\n\npolyProp :\n  {x,y} (fin x, fin y) => [128] -> [x][128] -> [y][128] -> [128] -> Bool\npolyProp h xs ys t =\n  polyvalFrom h ys (polyvalFrom h xs t) == polyvalFrom h (xs # ys) t\n\n\n\/\/ See `derive_key` in the spec.\nAES_128_ENC_x4_def : [16][8] -> [11][128] -> [4][128]\nAES_128_ENC_x4_def iv' keys = [ aesWithKeys keys (iv # i) | i <- [ 0 .. 3 ] ]\n  where\n  _ # (iv : [96]) = leLoad iv'\n\n\n\/* Encrypt the pt with the given key, expanding it as you go.\nThe result it the encrypted text and the expanded key *\/\nAES_KS_ENC_x1_def1 : [16][8]  -> [11][128]\nAES_KS_ENC_x1_def1 ikey =\n  aesKeyToBits (ExpandKey (beLoad ikey))\n  \/\/ NOTE the BIG ENDIAN load on the key\n\nAES_KS_ENC_x1_def2 : [11][128] -> [16][8] -> [1][128]\nAES_KS_ENC_x1_def2 keys pt = [ aesWithKeys keys (leLoad pt) ]\n\nENC_MSG_def :\n  [11][128] -> [16][8] -> [MSG_Size][8] -> [MSG_Size][8]\nENC_MSG_def keys tag pt =\n  leStoreBlocks (counter_mode K2 (0b1 # tUpper, tLower) M)\n  where\n  K2 = aesKeysFromBits keys\n  M  = leLoadBlocks pt\n  _ # tUpper # tLower = leLoad tag\n\n\n\/\/ NOTE the BIG ENDIAN loads on the AAD and the Message\nAES_GMC_SIV_Encrypt_pair :\n  [11][128] -> [12][8] -> [AAD_Size][8] -> [MSG_Size][8] ->\n                                                    ([8 * MSG_Size], [128])\nAES_GMC_SIV_Encrypt_pair keys iv aad pt =\n  gcm_siv_plus ks nonce (beLoad aad) (beLoad pt)\n  where\n  ks    = derive_key_expanded (aesKeysFromBits keys) nonce\n  nonce = leLoad iv\n\nAES_GMC_SIV_Encrypt_TAG_def :\n  [11][128] -> [12][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [1][128]\nAES_GMC_SIV_Encrypt_TAG_def keys iv add pt = [ tag ]\n  where (_,tag) = AES_GMC_SIV_Encrypt_pair keys iv add pt\n\nAES_GMC_SIV_Encrypt_CT_def :\n  [11][128] -> [12][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [MSG_Size][8]\nAES_GMC_SIV_Encrypt_CT_def keys iv add pt = beStore ct\n  where (ct,_) = AES_GMC_SIV_Encrypt_pair keys iv add pt\n\n\n\n\n\naesWithKeys : [11][128] -> [128] -> [128]\naesWithKeys ks pt = aes (aesKeysFromBits ks) pt\n\naesKeysFromBits : [11][128] -> KeySchedule\naesKeysFromBits ks = (k1,kRest,kLast)\n  where [k1] # kRest # [kLast] = [ aesStateFromBits m | m <- ks ]\n\naesKeyToBits : KeySchedule -> [11][128]\naesKeyToBits (k1,kRest,kLast) =\n  [ aesStateToBits k1 ] #\n  [ aesStateToBits x | x <- kRest ] #\n  [ aesStateToBits kLast ]\n\nleLoadBlocks : {n} (fin n) => [n][8] -> [n \/^ 16][128]\nleLoadBlocks bytes = leLoadArray (bytes # zero)\n\nleStoreBlocks : {n} (fin n) => [n \/^ 16][128] -> [n][8]\nleStoreBlocks arr = take (leStoreArray arr)\n\n","variant":"hybrid","set":"supervised"}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/cryptol\/AES128_GCM_SIV.cry","filetype":"cry","content":"\/* This module implements that AES-GCM-SIV mode of operations\nas desribed in:\n\n\"AES-GCM-SIV: Specification and Analysis\"\nby Shay Gueron, Adam Langley, and Yehuda Lindell\n\nSee also:\nhttps:\/\/tools.ietf.org\/html\/draft-irtf-cfrg-gcmsiv-06\n*\/\n\nmodule AES128_GCM_SIV where\n\nimport AES128 as AES\nimport Sizes\n\ntype AAD  = 8 * AAD_Size\n\ntype K  = 128\ntype KS = AES::KeySchedule\n\n\n\/** Note the weird byte-swapping business (also in `blockify` and `unblockify`)\nIt is not quite clear in what format we want the inputs\/outputs, but we\ndo the swapping so that inputs\/ouputs match the test vectors at\nhttps:\/\/tools.ietf.org\/html\/draft-irtf-cfrg-gcmsiv-06\n*\/\naes_gcm_siv :\n  {n} ((36 + 8) >= width n) =>\n      { key   : [K]\n      , nonce : [96]\n      , aad   : [AAD]\n      , msg   : [n]\n      } -> [n + 128]\naes_gcm_siv input = c # byteSwap t\n  where\n  (c,t) = gcm_siv_plus (derive_key k' n') n' input.aad input.msg\n  k'    = byteSwap input.key\n  n'    = byteSwap input.nonce\n\naes : KS -> [128] -> [128]\naes ks v = byteSwap (AES::aesEncryptWithSchedule ks (byteSwap v))\n\nexpandKey1 : [K] -> KS\nexpandKey1 k = AES::ExpandKey (byteSwap k)\n\n\/** See Figure 2 in Section 4 *\/\nderive_key : [K] -> [96] -> ([128], KS)\nderive_key K N = derive_key_expanded (expandKey1 1) N\n\n\/** See Figure 2 in Section 4 *\/\nderive_key_expanded : KS -> [96] -> ([128], KS)\nderive_key_expanded ks N = (mkKey parts1, expandKey1 (mkKey parts2))\n  where\n  parts1 # parts2 = [ drop (aes ks (N # i)) | i <- take [ 0 ... ]  ]\n\n  mkKey : {n} (fin n) => [n][64] -> [64 * n]\n  mkKey xs = join (reverse xs)\n\n\n\n\n\/** See Figure 1 in Section 3 *\/\ngcm_siv_plus :\n  {n} (64 >= width n) => ([128], KS) -> [96] -> [AAD] -> [n] -> ([n],[128])\ngcm_siv_plus (K1,K2) N AAD MSG = (unblockify Cs,TAG)\n  where\n\n  TAG     = aes K2 (0b0 # drop (T ^ (0 # N)))\n  T       = polyvalFrom K1 (A # M # [msg_len # aad_len]) 0\n  A       = blockify AAD\n  M       = blockify MSG\n  aad_len = `AAD : [64]\n  msg_len = `n   : [64]\n\n  _ # tUpper # tLower = TAG\n\n  Cs = counter_mode K2 (0b1 # tUpper, tLower) M\n\ncounter_mode : {n} KS -> ([96],[32]) -> [n][128] -> [n][128]\ncounter_mode K2 (tUpper,tLower) M =\n            [ aes K2 (tUpper # lower32 i) ^ m | m <- M | i <- [ 0 ... ] ]\n  where\n  lower32 i = tLower + i\n\n\n\/** See Section 2.2 *\/\npolyvalFrom : {n} (fin n) => [128] -> [n][128] -> [128] -> [128]\npolyvalFrom H Xs start = psums ! 0\n  where psums = [start] # [ dot (s ^ x) H | s <- psums | x <- Xs ]\n\n\/\/1 is not the identity for dot forcing it in next function instead\npolyvalFromNH : {n, hs} (fin n, fin hs, hs >=n) => [hs][128] -> [n][128] -> [128] -> [128]\npolyvalFromNH Hs Xs start = (sums ! 0) ^ (dot (([1] # Hs) @ (`n : [width n])) start)\n  where sums = [zero] # [ (dot X H) ^ sum'\n                        | sum' <- sums\n                        | X <- reverse Xs\n                        | H <- Hs ]\n\n\npolyvalHtableNH :\n  {n, hs} (fin n, fin hs, hs >=1) => [hs][128] -> [n][128] -> [128] -> [128]\npolyvalHtableNH Hs Xs start  = result\n  where sums = [start]\n             # [ polyvalFromNH Hs Xchunk sum'\n               | sum'   <- sums\n               | Xchunk <- split (take Xs): [n\/hs][hs][128]\n               ]\n        type W = n % hs\n        remainder = drop Xs : [W][128]\n        result =\n          if `W == (0 : [width (n % hs)]) then\n            sums ! 0\n          else\n            polyvalFromNH Hs remainder (sums!0)\n\n\npht : {a,size} (fin a,fin size,size>=2) => [128] -> [a][128] -> [128] -> Bit\npht H Xs start =\n  polyvalHtableNH (INIT_Htable`{size} H) Xs start == polyvalFrom H Xs start\n\ndot : [128] -> [128] -> [128]\ndot x y = mult x (mult y x_neg_128)\n  where x_neg_128 = <| 1 + x^^114 + x^^121 + x^^124 + x^^127 |>\n        \/\/ This is x^(-128)\n\n\nmult : [128] -> [128] -> [128]\nmult x y = pmod (pmult x y) irred\n  where\n  irred = <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\nINIT_Htable : {n} (fin n, n>=2) => [128] -> [n][128]\nINIT_Htable H = take hs\n  where\n  hs = [H] # [ dot hn H\n                | hn <- hs]\n\n\/*polyval_Htable : {n} (fin n, n>=1) => [128] -> [n][128] -> [128]\npolyval_Htable H X = polyvalHtableNH`{hs=8} htable X\n  where\n    htable = INIT_Htable H\n\n\n\/\/ -----------------------------------------------------------------------------\n\nprop_poly : {a} (a >= 1, fin a) => [128] -> [a][128] -> Bit\nprop_poly H X = polyval_Htable H X == polyvalFrom H X zero\n*\/\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify x = [ byteSwap b | b <- split (x # zero) ]\n\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify xs = take (join [ byteSwap b | b <- xs ])\n\n\/\/ The spec uses byte-oriented little-endian representations.\n\/\/ This function changes back and forth.\nbyteSwap : {n} (fin n) => [8 * n] -> [8 * n]\nbyteSwap xs = join (reverse (split`{each=8} xs))\n\npolnhest1 = polyvalHtableNH`{hs=8,n=1}\n              ([0x551d5202e5be771d5964fbbd1dac89db]#zero)\n              \/\/(INIT_Htable 0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e)\n              [0x189308235800d2810a80a422032144fd]\n              (0x38020aa08800d28bf2fb37d447e1c479)\n\npolnhest2 = polyvalFrom\n                0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e\n                [0x189308235800d2810a80a422032144fd]\n                (0x38020aa08800d28bf2fb37d447e1c479)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/cryptol\/X86.cry","filetype":"cry","content":"module X86 where\n\nimport AES128\n\naesenc : [128] -> [128] -> [128]\naesenc pt key =\n  aesStateToBits (aes_round (aesStateFromBits key)\n                            (aesStateFromBits pt))\n\naesenclast : [128] -> [128] -> [128]\naesenclast pt key =\n  aesStateToBits (aes_final_round (aesStateFromBits key)\n                                  (aesStateFromBits pt))\n\n\n\/\/ Carryles mulitplication\nclmul : [64] -> [64] -> [128]\nclmul x y = 0b0 # pmult x y\n\n\n\/\/ Store a bit-value as bytes\nleStore : {n} (fin n) => [n * 8] -> [n][8]\nleStore bits = reverse (split bits)\n\n\/\/ Load a bit-value from bytes\nleLoad : {n} (fin n) => [n][8] -> [n*8]\nleLoad bytes = join (reverse bytes)\n\nbeLoad : {n} (fin n) => [n][8] -> [n*8]\nbeLoad bytes = join bytes\n\nbeStore : {n} (fin n) => [n*8] -> [n][8]\nbeStore bits = split bits\n\n\/\/ Load an array from bytes\nleLoadArray : {l,w} (fin l,fin w) => [l * w][8] -> [l][w * 8]\nleLoadArray bytes = [ leLoad mem | mem <- split bytes ]\n\nleStoreArray : {l,w} (fin l,fin w) => [l][w * 8] -> [l * w][8]\nleStoreArray arr = join [ leStore a | a <- arr ]\n\naesStateFromBytes : [16][8] -> State\naesStateFromBytes xs = transpose (split xs)\n\naesStateToBytes : State -> [16][8]\naesStateToBytes s = join (transpose s)\n\naesStateFromBits : [128] -> State\naesStateFromBits xs = aesStateFromBytes (leStore xs)\n\naesStateToBits : State -> [128]\naesStateToBits s = leLoad (aesStateToBytes s)\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/intTests\/test_profiling\/dotprod.cry","filetype":"cry","content":"zip : {n, a} (fin n, Arith a) => (a -> a -> a) -> [n]a -> [n]a -> [n]a\nzip f xs ys = [ f x y | x <- xs | y <- ys ]\n\nsum : {n, a} (fin n, fin a) => [n][a] -> [a]\nsum xs = ys!0\n  where ys = [0] # [ x + y | x <- xs | y <- ys ]\n\ndotprod : {n, a} (fin n, fin a) => [n][a] -> [n][a] -> [a]\ndotprod xs ys = sum (zip (*) xs ys)\n","variant":"hybrid","set":"unsupervised"}
{"filename":"https:\/\/saw.galois.com\/intro\/IntroToSAW.html","filetype":"txt","content":"## First Example: Counting Set Bits\n\nMost developers are used to techniques like testing, continuous integration, and thoughtful documentation that can help prevent mistakes from being introduced into a system during its development and evolution. These techniques can be relatively effective, but they risk missing certain classes of bugs. For the most important systems, like those that protect human life or information security, it can make sense to also use formal verification, in which a program is mathematically proved to be correct for all inputs.\n\nTesting takes the actual binary executable and runs it on a subset of the possible inputs to check for expected outputs. The downside of this approach is that tests may miss some critical case. Compared to testing, verification is the process of building a mathematical model of the software and proving properties of that model for all possible inputs.\n\nIn this lesson you\u2019ll learn how to use a system called SAW, the Software Analysis Workbench, to build models of functions written in C. You\u2019ll learn how to specify what those functions are supposed to do, and how to write a program in SAWScript that orchestrates the proof that the functions meet their specifications.\n\n## The Code\n\nThe first program to be verified is pop_count. This function takes a 32-bit integer and returns the number of bits that are set (\u201cpopulated\u201d). For example pop_count(0) is 0, pop_count(3) is 2, and pop_count(8) is 1. This description is an English language specification of the pop_count function. A specification can be written in a number of formats, including English sentences, but also in machine-readable forms. The advantage of machine-readable specifications is that they can be used as part of an automated workflow.\n\n**Note**\n\nThe pop_count function has uses in many kinds of algorithms and has an interesting folklore.  \nHere is a sophisticated implementation of pop_count from the book Hacker\u2019s Delight by Henry S. Warren Jr.:\n\n```c\nint pop_count(uint32_t x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0F0F0F0F;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x0000003F;\n}\n```\n\n## Exercise: A Safe and a Broken pop_count\n\nWrite a version of pop_count that you believe to be correct, and also a version that includes the kind of error that could be made by accident (perhaps by adding a typo to the optimized version). Add them as pop_count_ok and pop_count_broken1 to popcount.c in the examples\/intro directory.\n\n## Testing Programs\n\nYou\u2019re not likely to be able to convince yourself that the optimized pop_count function is correct just by inspection. A unit test, like the following pop_check can help:\n\n```c\n\/* Test pop_count on a few values to make sure it's at least sometimes correct *\/\nbool pop_check() {\n    return (pop_count(0x0) == 0) &&\n           (pop_count(0x3) == 2) &&\n           (pop_count(0xFFFFFFFF) == 32) &&\n           (pop_count(0xAAAAAAAA) == 16) &&\n           (pop_count(0x55555555) == 16);\n}\n```\n\nThere are some downsides to testing only with chosen values, however. First off, these tests are usually selected by the author of the code, and there is a risk that important values are not tested. This can be ameliorated by a systematic, disciplined approach to choosing test values, but it can never be completely eliminated. This particular unit test is likely to catch egregiously buggy versions of popcount, but not subtle or tricky bugs.\n\nA second approach to testing is to choose many random values at each execution. This approach may eventually find subtle or tricky mistakes, but not reliably or in a predictable amount of time.\n\nTesting with random values requires an executable specification. This specification may just describe some properties of the output (e.g. that the length of two appended lists is the sum of the lengths of the input lists, or that the output of a sorting function is sorted), or it may be a simpler, more straightforward version of the code that uses an easier algorithm. An executable specification for popcount can loop over the bits in the word, masking them off one at a time. While this implementation is straightforward, it is also slow.\n\n```c\nint pop_spec(uint32_t x) {\n    uint32_t pop = 0;\n    uint32_t mask = 1;\n    for (int i = 0; i < 32; i++) {\n        if (x & mask) { pop++; }\n        mask = mask << 1;\n    }\n    return pop;\n}\n```\n\nThe function random_value_test performs randomized testing of a provided population count function, comparing its output to that of pop_spec. When they are not identical, it prints the offending input, which can aid in debugging.\n\n```c\nvoid random_value_test(int (*fun)(uint32_t), char *name) {\n    srand(time(NULL));\n\n    int failures = 0;\n    for (int i = 0; i < 100000; i++) {\n        uint32_t x = rand();\n        int test = (*fun)(x);\n        int check = pop_spec(x);\n        if (test != check) {\n            printf(\"Test failure: %s(%u) was %u, != %u\\n\",\n                    name, x, test, check);\n            failures++;\n        }\n    }\n    if (failures == 0) {\n        printf(\"Testing %s succeeded!\\n\", name);\n    }\n}\n```\n\nFinally, one could attempt to exhaustively check the values by enumerating and testing all possible combinations. In the simple case of pop_count, which only takes one 32-bit integer, this will take about 20 seconds. With a 64-bit version of the program, however, the test would take longer than a normal human lifetime, so this technique is not practical for ongoing software development.\n\nThe way formal verification addresses this is by reasoning about mathematical models of a program, which allows it to eliminate huge regions of the state space with single steps. There are many tools and techniques for performing full formal verification, each suitable to different classes of problem. SAW is particularly suited to imperative programs that don\u2019t contain potentially-unbounded loops. In general, the cost of verification is that it requires specialized knowledge and developing mathematical proofs can take much longer than writing test cases. However, for many programs, automated tools like SAW can be used with similar levels of effort to testing, but resulting in much stronger guarantees. At the same time, re-checking a proof can sometimes be much faster than testing large parts of the input space, leading to quicker feedback during development.\n\n## Exercise: Testing popcount\n\nWrite a test that detects the defects in your pop_count_broken1 function, and also check that your pop_count_ok and the optimized pop_count function have no defects by using manual and random testing. How much confidence do those techniques provide?\n\nFinally, consider pop_count_broken2, which is only incorrect for exactly one input value. Check how often the randomized test detects the one buggy input.\n\n```c\nint pop_count_broken2(uint32_t x) {\n    if (x == 0xDEADBEEF) return 22;\n    return pop_count(x);\n}\n```\n\n## Symbolic Execution\n\nThe way SAW can prove properties about programs is by converting them into an internal representation that is much closer to a pure mathematical function. For instance, pop_count might be converted to a function like:\n\n\\[\npop\\_count(bit\\_string) = \\sum_{i=0}^{32} bit\\_string_i\n\\]\n\nIn this version, the details of the call stack, registers vs. memory and the specific execution model of the CPU have been removed. The technique for doing this conversion is called symbolic execution or symbolic simulation. It works by first replacing some of the inputs to a program with symbolic values, which are akin to mathematical variables. The term concrete values is used to describe honest-to-goodness bits and bytes. As the program runs, operations on symbolic values result in descriptions of operations rather than actual values. Just as adding 1 to the concrete value 5 yields the concrete value 6, adding 1 to the symbolic value \\(x\\) yields the symbolic value \\(x+1\\). Incrementing the values again yields 7 and \\(x+2\\), respectively. By simulating the entire function this way, SAW creates a mathematical function out of the C function you provide.\n\nThere are complications, of course, such as what to do with conditional branches, but as a user of the tool you won\u2019t have to worry about them except when they introduce limitations to what you can reason about. The main such limitation is that symbolic simulation can\u2019t effectively deal with loops whose termination depends on a symbolic value. For example, this simple implementation of add would not be easily analyzed:\n\n```c\nunsigned int add(unsigned int x, unsigned int y) {\n    for (unsigned int i = 0; i < y; i++) {\n        x++;\n    }\n    return x;\n}\n```\n\nThe problem is that the loop termination depends on the symbolic value \\(y\\), rather than on some pre-determined concrete number. This means that each time through the for loop two new branches must be explored: one in which the present concrete value of i is less than the symbolic value of \\(y\\), and one in which it is not. The key thing to remember is that symbolic execution is most applicable to programs that \u201cobviously\u201d terminate, or programs in which the number of loop iterations do not depend on which specific input is provided.\n\n## Running SAW\n\n**Note**\n\nThis section uses a library of SAW helpers, in the file helpers.saw. If you\u2019re comparing this text to the SAW manual, you may notice that a few operations have been abbreviated.\n\nSAW is a tool for extracting models from compiled programs and then applying both automatic and manual reasoning to compare them against a specification of some kind. SAW builds models of programs by symbolically executing them, and is capable of building models from LLVM bitcode, JVM bytecode, x86 machine code, Rust\u2019s MIR internal representation, and a number of other formats.\n\nThe first step to verifying pop_count with SAW is to use clang to construct its representation in LLVM bitcode. It is important to pass clang the -O1 flag, because important symbols are stripped at higher optimization levels, while lower optimization levels yield code that is less amenable to symbolic execution. The -g flag leaves symbols in the output which helps SAW produce helpful messages when verification fails. It can be convenient to include this rule in a Makefile:\n\n```makefile\n.SUFFIXES: .c .bc\n\n%.bc : %.c\n\tclang -g -O1 -c -emit-llvm $< -o $@\n```\n\nAfter building the LLVM bitcode file (by typing `make popcount.bc`), the next step is to use SAW to verify that the program meets its specification. SAW is controlled using a language called SAWScript. SAWScript contains commands for loading code artifacts, for describing program specifications, for comparing code artifacts to specifications, and for helping SAW in situations when fully automatic proofs are impossible.\n\nThe specific fact to be verified using SAW is that pop_count and pop_spec always return the same answer, no matter their input. For any particular input, this can be checked using pop_spec_check:\n\n```c\nbool pop_spec_check(uint32_t x) {\n    return (pop_spec(x) == pop_count(x));\n}\n```\n\nThe SAWScript to verify pop_count is really checking that pop_spec_check always returns true.\n\n```saw\ninclude \"helpers.saw\";\npopmod <- llvm_load_module \"popcount.bc\";\n\nlet pop_is_ok = do {\n     x <- symbolic_variable uint32_t \"x\";\n     execute [x];\n     returns TRUE;\n};\n\nllvm_verify popmod \"pop_spec_check\" [] pop_is_ok;\n```\n\nTo execute the verification, we invoke saw on the SAWScript file:\n\n```bash\n$ saw pop.saw\n[20:24:45.159] Loading file \"\/...\/pop.saw\"\n[20:24:45.160] Loading file \"\/...\/helpers.saw\"\n[20:24:45.282] Verifying pop_spec ...\n[20:24:45.282] Simulating pop_spec ...\n[20:24:45.291] Checking proof obligations pop_spec ...\n[20:24:46.212] Proof succeeded! pop_spec\n```\n\nThe \"Proof succeeded!\" message indicates to us that our pop_spec_check function returns True for all possible inputs. Hooray!\n\nReturning to the SAWScript we used, it has three parts:\n\n- Lines 1\u20132 load helper functions and the LLVM module to be verified. This step builds the model from your code.  \n- Lines 4\u20138 define the pop_is_ok SAWScript specification, which sets up the symbolic inputs to the pop_spec function, calls the function on those symbolic inputs, and asserts that the return value is True.  \n- Line 10 instructs SAW to verify that pop_is_ok is true for all possible input values.\n\nThe LLVM module is loaded using the llvm_load_module command. This command takes a string that contains the filename as an argument, and returns the module itself. In SAWScript, the results of a command are saved using the <- operator; here, the name popmod is made to refer to the module.\n\nSAW specifications have three main parts:\n\n- Preconditions which state what the code being verified may assume to be true when it is called,  \n- Instructions for executing the code,  \n- Postconditions which state what the code must ensure to be true after it is called.\n\nHere, the precondition consists of creating one symbolic variable. Internally, symbolic variables are represented in the internal language SAWCore. `symbolic_variable` takes two arguments: the new variable\u2019s type and a string that names the symbolic variable (which may show up in error messages). After the precondition, the SAWScript variable `x` is bound to the respective symbolic value \\(x\\). In more complicated verifications the preconditions are more interesting, as we\u2019ll see soon.\n\nThe function is invoked using the `execute` command, which takes an array of SAWScript variables that correspond to the function\u2019s arguments. The function being executed is the one named by the string argument in the call to `llvm_verify`.\n\nIn the postcondition, the expected return value of the function is specified using `returns`. In this example, the function is expected to return TRUE.\n\nTranslated to English, `pop_is_ok` says:\n\nLet \\(x\\) be a 32-bit integer. The result of calling pop_spec_check on \\(x\\) is TRUE.\n\nIf verification reports success, we know that this is the case for all possible values of \\(x\\).\n\nIn other words, pop_is_ok wraps the C function pop_spec_check. This C function computes the believed-correct result (by calling pop_spec), calls the pop_count function we are analyzing and returns TRUE if the results agree. The SAW wrapper creates the symbolic input variable, executes the function on its input, and ensures that the return value is TRUE.\n\n**Note**\n\nSAWScript distinguishes between defining a name and saving the result of a command. Use `let` to define a name, which may refer to a command or a value, and `<-` to run a command and save the result under the given name. Defining a command with `let` is analogous to defining a C function, and invoking commands with `<-` is analogous to calling it.\n\nThe arguments to `llvm_verify` (on line 10 above) are `popmod`, which specifies the LLVM module that contains the code to be verified; `\"pop_spec_check\"`, the C function to be symbolically executed; and `pop_is_ok`, the SAW specification to check `\"pop_spec_check\"` against. The empty list (`[]`) is an optional list of previously proven statements, which is used in larger verification projects as described later in this tutorial. This verification script provides the same level of assurance that exhaustive testing would provide, but it completes in a tiny fraction of the time, fast enough to be part of a standard CI (continuous integration) workflow.\n\n## Exercise: Verifying Clever Versions of popcount\n\nThe following versions of popcount are quite different from the preceding implementations, but they should always return the same value. For both `pop_count_mul` and `pop_count_sparse`, do the following:\n\n- Write a C function, analogous to pop_spec_check, that relates pop_spec to the new implementation.  \n- Use pop_is_ok in pop.saw together with additional calls to llvm_verify to assert that the modified versions pop_spec_check also always return true. The string argument to llvm_verify states the name of the C function being verified - modify it to point to your new specification.  \n- Use SAW to verify the implementation. Remember to rebuild the bitcode file after modifying the C sources.\n\n```c\n\/* A version of popcount that uses multiplication *\/\nint pop_count_mul(uint32_t x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = ((x + (x >> 4)) & 0x0F0F0F0F);\n    return (x * 0x01010101) >> 24;\n}\n\n\/* A version of popcount that uses an indefinite while loop(!) *\/\nint pop_count_sparse(uint32_t x) {\n    int n;\n    n = 0;\n    while (x != 0) {\n        n = n + 1;\n        x = x & (x - 1);\n    }\n    return n;\n}\n```\n\n## Exercise: Verifying Your pop_count Implementations\n\nVerification is useful for more than just carefully-chosen examples. This exercise is about your programs.\n\nStart with your solutions pop_count_ok and pop_count_broken1 from the first exercise. Repeat the tasks from the previous exercise, creating specifications and extending pop.saw to attempt to verify the functions.\n\n```bash\n$ make popcount.bc\n$ saw pop.saw\n...\n[19:27:38.518] Proof succeeded! pop_ok_check\n[19:27:38.520] Verifying pop_broken1_check ...\n... many lines deleted\n[19:27:38.856] ----------Counterexample----------\n[19:27:38.856]   x: 3735928559\n[19:27:38.856] ----------------------------------\n```\n\nAs in the output above, you should see one successful verification (for the wrapper corresponding to pop_count_ok) and one failed one (for pop_count_broken1). SAW\u2019s messages for failed verifications are quite verbose, but the most important part is the counterexample, which is a concrete input value for which the program fails to return TRUE. Next apply verification popcount_broken2 from the exercise above, which is only incorrect for exactly one input value, you will see SAW comes up with exactly that counterexample without any guidance from you.","variant":null,"set":"holdout"}
{"filename":"https:\/\/saw.galois.com\/intro\/Pointers.html","filetype":"txt","content":"## Specifying Memory Layout\n\nPrograms are about more than just numeric values. First Example: Counting Set Bits describes a program that works on integer values, but most C programs involve changes to values in memory. In addition to describing the return value, specifying most C programs involves describing an initial state of the heap and then relating it to the state of the heap after the program has run. SAW supports specifying programs that involve heaps and pointers.\n\nThe specification for popcount could get away with talking only about the integer values of arguments to a function and its return value. This section introduces minmax, which swaps two pointers if the first pointer\u2019s target is greater than the second pointer\u2019s target. The return value is -1 if the first pointer\u2019s original target was less than the second\u2019s, 0 if they were equal, and 1 if the second pointer\u2019s original target was greater than the first\u2019s.\n\nA reference implementation of minmax follows the English specification closely:\n\n```c\nint8_t minmax(int64_t *x, int64_t *y) {\n    if (*x > *y) {\n        int64_t tmp = *x;\n        *x = *y;\n        *y = tmp;\n        return 1;\n    }\n    else {\n        return -(*x != *y);\n    }\n}\n```\n\nHowever, the ordering of the modifications to memory and the comparisons of values can be tricky to get right in C. Instead of using a C program as the specification, this section will use a specification written in a language called Cryptol.\n\n## Cryptol\n\nSAWScript has good facilities for describing memory layouts and pre- and postconditions, but not for specifying algorithms. It is often used together with Cryptol, a domain-specific language for implementing low-level cryptographic algorithms or DSP transforms that reads much like a mathematical description. This helps bridge the gap between formal descriptions and real implementations.\n\nA Cryptol specification for minmax looks like this:\n\n```cryptol\nmodule MinMax where\n\nminmax : ([64], [64]) -> ([64], [64])\nminmax (x, y) =\n  if x >$ y\n  then (y, x)\n  else (x, y)\n\nminmax_return : ([64], [64]) -> [8]\nminmax_return (x, y) =\n  if x <$ y then -1\n   | x == y then 0\n   else 1\n```\n\nThe first line of the file is a module header. It states that the current module is named MinMax. In this module, there are two definitions: minmax, which specifies the values expected in the pointers\u2019 targets after running minmax, and minmax_return, which specifies the value to be returned from minmax.\n\nEach definition begins with a type declaration. These are optional: Cryptol always type checks code, but it can usually infer types on its own. Nevertheless, they make the specification easier to understand. Also, Cryptol\u2019s type system is very general, and some of the types that it finds on its own may be complicated. The type of minmax can be read as \u201ca function that takes a pair of 64-bit values as an argument, and returns a pair of 64-bit values\u201d (the arrow -> separates the argument type from the return type). The type of minmax_return can be read as \u201ca function that takes a pair of 64-bit values as an argument, and returns a single 8-bit value\u201d.\n\nThe Cryptol definition of minmax uses pattern matching to name the first and second elements of the incoming pair as x and y, respectively. The right side of the = specifies that the return value is the pair (y, x) if x is greater than y, or the original argument pair (x, y) otherwise. Because Cryptol\u2019s type system doesn\u2019t distinguish between signed and unsigned integers, the operator >$ is used for signed comparison, while > is used for unsigned comparison.\n\nAlternatively, the definition could be written without pattern matching. In this case, the first and second elements of the pair are accessed using the .0 and .1 operators. Pairs can be seen as analogous to structs whose fields are named by numbers.\n\n```cryptol\nminmax : ([64], [64]) -> ([64], [64])\nminmax pair =\n  if pair.0 >$ pair.1\n  then (pair.1, pair.0)\n  else (pair.0, pair.1)\n```\n\nCryptol is useful in two different ways in SAW: it is used as a standalone specification language, and it also provides a syntax for explicit expressions in SAWScript specification, in which case it occurs in double braces (`{{ }}`).\n\nHere is the complete SAWScript for verifying our minmax function.\n\n```saw\ninclude \"helpers.saw\";\nimport \"MinMax.cry\";\n\nminmax_mod <- llvm_load_module \"minmax.bc\";\n\nlet minmax_ok = do {\n     \/\/ 1. Establish the symbolic integers and pointers to them\n     (x, xp) <- pointer_to_fresh int64_t \"x\";\n     (y, yp) <- pointer_to_fresh int64_t \"y\";\n\n     \/\/ 2. Call the function being verified with the two pointers\n     execute [xp, yp];\n\n     \/\/ 3. Use Cryptol to specify the desired values at the pointers' new targets\n     let result_spec = {{ minmax (x, y) }};\n     points_to xp (from_cryptol {{ result_spec.0 }});\n     points_to yp (from_cryptol {{ result_spec.1 }});\n\n     \/\/ 4. Use Cryptol to specify the desired return value\n     let return_spec = {{ minmax_return (x, y) }};\n     returns (from_cryptol return_spec);\n};\n\n\/\/ 5. Verify C function minmax using minmax_ok\nllvm_verify minmax_mod \"minmax\" [] minmax_ok;\n```\n\nAfter including `helpers.saw`, the first step in using a Cryptol specification for minmax is to load the Cryptol module.\n\n> **Note**  \n> In SAWScript, `include` is used to include the contents of a SAWScript file, while `import` is used for Cryptol files.\n\nThe SAWScript definition `minmax_ok` specifies the following:\n\n- Symbolic integers and pointers to them in the heap are established. `pointer_to_fresh` returns a tuple\u2014the first element is a symbolic variable that\u2019s accessible from Cryptol, the second element is a pointer to allocated memory of some type (in this case, `int64_t`). The pointer\u2019s value is set to point at the allocated memory. This is done twice, once for each argument.\n\n- The arguments to be provided to minmax are specified using `execute`. In this case, the function will be called on the two pointers.\n\n- The desired targets of the pointers (that is, the values that they should point to after the function call) are specified using `points_to` after `execute`. In this case, the Cryptol `minmax` function is called, and the resulting pair is saved in `result_spec`, which is then used to provide the pointers\u2019 targets.\n\n- The return value is specified in the same manner as that of popcount, by using `returns`. In this case, rather than specifying the constant `TRUE`, the result is also given by a Cryptol specification.\n\n> **Note**  \n> Cryptol snippets in double braces can refer to both `minmax` and to `x` and `y`. The Cryptol snippets can refer to anything imported from a Cryptol module with `import`, and also to any name in scope that refers to a SAWCore term. In other words, the SAWScript name `x` can also be used as a Cryptol name to point at a SAWCore term.\n\nFinally, verification is invoked just as in popcount, using `llvm_verify`.\n\n## Exercises: Getting Started with SAW and Pointers\n\nThis exercise does not require the use of Cryptol.\n\nWrite a C function that zeroes out the target of a pointer. It should have the following prototype:\n\n```c\nvoid zero(uint32_t* x);\n```\n\nWrite a C function `zero_spec` that returns true when zero is correct for some input. It should have the following prototype:\n\n```c\nbool zero_spec(uint32_t x);\n```\n\nUse SAW to verify that `zero_spec` always returns true for your implementation of `zero`.\n\n## Exercise: Unsigned Arithmetic\n\nCreate a version of minmax that specifies its arguments as `uint64_t` instead of `int64_t`, and attempt to verify it using `minmax_ok`. What does the counterexample tell you about the bug that is introduced?\n\n## Exercise: Alternative Implementations\n\nThis version of minmax avoids conditional statements, relying heavily on C\u2019s ternary operator. Verify that it fulfills the specification.\n\n```c\nint8_t minmax_ternary(int64_t *x, int64_t *y) {\n    int64_t xv = *x, yv = *y;\n    *x = xv < yv ? xv : yv;\n    *y = xv < yv ? yv : xv;\n    return xv < yv ? -1 : xv == yv ? 0 : 1;\n}\n```\n\nNow, implement a version of minmax that uses the XOR swap trick to move the values instead of a temporary variable. Verify it.\n\n## Exercise: Swapping and Rotating\n\nUsing SAW, write a specification for a C function that unconditionally swaps the targets of two pointers. Implement the function in C, and verify that it fulfills the specification. Both the specification and the implementation are simpler versions of minmax, and the specification for swap can be written without a Cryptol specification.\n\nIn the course of ordinary software development, requirements change over time. As requirements change, both programs and their specifications must evolve. A verification-oriented workflow can help maintain a correspondence between updated specifications and code.\n\nModify the specification so that it describes a function `rotr3`. After invoking `rotr3` on pointers `x`, `y`, and `z`, `x` points to the previous target of `y`, `y` points to the previous target of `z`, and `z` points to the previous target of `x`. Note the error message that occurs when using this specification for swap.\n\nImplement `rotr3`, and verify it using the new specification.\n\n## Exercise: Arrays\n\nIn SAW, a C array type can be referred to using `llvm_array`, which takes the number of elements and their type as arguments. For instance, `uint32[3]` can be represented as `llvm_array 3 (llvm_int 32)`. Similarly, the setup value that corresponds to an index in an array can be referred to using `element`. For instance, if `arr` refers to an array allocated using `alloc`, then `element arr 0` is the first element in `arr`. These can be used with `points_to`.\n\nWrite a version of `rotr3` that expects its argument to be an array of three integers. Verify it using SAW.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/saw.galois.com\/intro\/Salsa20.html","filetype":"txt","content":"## Compositional Verification and Salsa20\n\nFirst Example: Counting Set Bits demonstrates verification and maintenance for a small standalone function. Most interesting programs are not just single functions, however. Good software engineering practice entails splitting programs into smaller functions, each of which can be understood and tested independently. Compositional verification in SAW allows this structure to be reflected in proofs as well, so that each function can be verified independently. In addition to being more maintainable, this can greatly increase the performance of a verification script.\n\nThis section describes the verification of an implementation of the Salsa20 encryption algorithm. Complete example code can be found in the examples\/salsa20 directory of the example code.\n\n## Salsa20 Verification Overview\n\nSalsa20 is a stream cipher developed in 2005 by Daniel J. Bernstein, built on a pseudorandom function utilizing add-rotate-XOR (ARX) operations on 32-bit words. The original specification can be found here.\n\nThe specification for this task is a trusted implementation written in Cryptol. This is analogous to what is covered in Cryptol in the minmax example, but for a larger system. Some examples from this specification are explored below for the sake of showing what larger Cryptol programs look like.\n\nThe implementation to be verified is written in C. This implementation is shown in part alongside the specification for comparison purposes.\n\nA SAWScript containing the specifications of memory layouts and orchestration of the verification itself ties everything together. This will be covered last, including some performance comparisons between compositional and non-compositional verification.\n\n## A Cryptol Specification\n\nThe Cryptol specification in examples\/salsa20\/salsa20.cry directly implements the functions defined in Bernstein\u2019s specification. Because there is so much code, this section will only go through some of the functions in detail, in order to highlight some features of Cryptol.\n\nThe first example function is quarterround. Its type is [4][32] -> [4][32], which means that it is a function that maps sequences of four 32-bit words into sequences of four 32-bit words. The [y0, y1, y2, y3] notation is pattern matching that pulls apart the four elements of the input sequence, naming each 32-bit word. The Cryptol operator <<< performs a left rotation on a sequence.\n\n```cryptol\nquarterround : [4][32] -> [4][32]\nquarterround [y0, y1, y2, y3] = [z0, z1, z2, z3]\n  where\n    z1 = y1 ^ ((y0 + y3) <<< 0x7)\n    z2 = y2 ^ ((z1 + y0) <<< 0x9)\n    z3 = y3 ^ ((z2 + z1) <<< 0xd)\n    z0 = y0 ^ ((z3 + z2) <<< 0x12)\n```\n\nThis Cryptol code closely resembles the definition in Section 3 of the specification. The definition reads:\n\nIf \ud835\udc66=(\ud835\udc660,\ud835\udc661,\ud835\udc662,\ud835\udc663) then quarterround(y)=(z0,z1,z2,z3) where\n\n\ud835\udc671 = \ud835\udc661 \u2295 ((\ud835\udc660 + \ud835\udc663) <<< 7)  \n\ud835\udc672 = \ud835\udc662 \u2295 ((\ud835\udc671 + \ud835\udc660) <<< 9)  \n\ud835\udc673 = \ud835\udc663 \u2295 ((\ud835\udc672 + \ud835\udc671) <<< 13)  \n\ud835\udc670 = \ud835\udc660 \u2295 ((\ud835\udc673 + \ud835\udc672) <<< 18)\n\nContrast this with the C implementation of s20_quarterround, which makes heavy use of in-place mutation rather than the functional paradigm of building and returning a new sequence:\n\n```c\nstatic void s20_quarterround(uint32_t *y0, uint32_t *y1, uint32_t *y2, uint32_t *y3)\n{\n  *y1 = *y1 ^ rotl(*y0 + *y3, 7);\n  *y2 = *y2 ^ rotl(*y1 + *y0, 9);\n  *y3 = *y3 ^ rotl(*y2 + *y1, 13);\n  *y0 = *y0 ^ rotl(*y3 + *y2, 18);\n}\n```\n\nThis function directly modifies the targets of its argument pointers, a shift in paradigm that will be highlighted by the SAW specification since that is where the memory management of the C is connected to the pure computation of the Cryptol.\n\nquarterround is used in the definition of two other functions, rowround and columnround, which perform the operation on the rows and columns of a particular matrix, represented as a flat sequence of 16 32-bit words.\n\nThese two operations are composed (rowround after columnround) to form the doubleround operation. The Cryptol code for this composition closely resembles the definition in the specification:\n\n```cryptol\ndoubleround : [16][32] -> [16][32]\ndoubleround(xs) = rowround(columnround(xs))\n```\n\nCombined with some utility functions for mapping sequences of four bytes to and from little-endian 32-bit words, doubleround gives us the Salsa20 hash function:\n\n```cryptol\nSalsa20 : [64][8] -> [64][8]\nSalsa20 xs = join ar\n  where\n    ar = [ littleendian_inverse words | words <- xw + zs@10 ]\n    xw = [ littleendian xi | xi <- split xs ]\n    zs = [xw] # [ doubleround zi | zi <- zs ]\n```\n\nAll three definitions in the where clause are sequence comprehensions, which are similar to Python\u2019s generator expressions or C#\u2019s LINQ. A sequence comprehension consists of square brackets that contain an expression, and then one or more branches. Branches begin with a vertical bar, and they contain one or more comma-separated bindings. Each binding is a name, an arrow, and another sequence.\n\nThe value of a comprehension with one branch is found by evaluating the expression for each element of the sequence in the branch, with the name to the left of the arrow set to the current element. The value of `[x + 1 | x <- [1,2,3]]` is `[2, 3, 4]`. If there are multiple bindings in the branch, later bindings are repeated for each earlier value. So the value of `[(x + 1, y - 1) | x <- [1,2], y <- [11, 12]]` is `[(2, 10), (2, 11), (3, 10), (3, 11)]`. The value of a comprehension with multiple branches is found by evaluating each branch in parallel; thus, the value of `[(x + 1, y - 1) | x <- [1,2] | y <- [11,12]]` is `[(2, 10), (3, 11)]`.\n\nIn the where clause, the definition of xw can be read as \u201cFirst split xs into 4-byte words, then combine them in a little-endian manner to obtain 32-bit words.\u201d The specific sizes are automatically found by Cryptol\u2019s type checker.\n\nThe definition of zs is an infinite sequence. It begins with xw, the little-endian reorganization of xs from the previous paragraph. The `#` operator appends sequences. The rest of the sequence consists of doubleround applied to each element of zs itself. In other words, the second element is found by applying doubleround to xw, the third by applying doubleround to the second, and so forth. Stepping through the evaluation yields this sequence:\n\n```cryptol\n[xw] # [ doubleround zi | zi <- zs ]\n\n[xw] # [ doubleround zi | zi <- [xw] # [doubleround zi | zi <- zs] ]\n\n[xw] # [doubleround xw] # [ doubleround zi | zi <- [doubleround zi | zi <- zs] ]\n\n[xw] # [doubleround xw] # [ doubleround zi | zi <- [doubleround xw] # [doubleround zi | zi <- zs] ]\n\n[xw] # [doubleround xw] # [ doubleround zi | zi <- [doubleround xw] # [doubleround zi | zi <- [doubleround zi | zi <- zs]] ]\n\n[xw] # [doubleround xw] # [doubleround (doubleround xw)] # [ doubleround zi | zi <- [doubleround zi | zi <- [doubleround zi | zi <- zs]] ]\n```\n\nThe resulting sequence consists of doubleround applied \ud835\udc5b times to xw at position \ud835\udc5b. This process could, in principle, continue forever. In Cryptol, however, sequences are computed lazily, so as long as nothing ever asks for the last element, the program will still terminate.\n\nThe final definition is ar, which adds xw to the tenth element of zs, which is the result of applying doubleround ten times to xw. In Cryptol, `+` is extended over sequences so that adding two sequences adds their elements. The final result of Salsa20 is computed by re-joining the split words into the appropriate-sized sequence.\n\nThe C implementation uses in-place mutation and an explicit loop. Due to the use of mutation, it must be careful to copy data that will be used again later.\n\n```c\n\/\/ The core function of Salsa20\nstatic void s20_hash(uint8_t seq[static 64])\n{\n  int i;\n  uint32_t x[16];\n  uint32_t z[16];\n\n  \/\/ Create two copies of the state in little-endian format\n  \/\/ First copy is hashed together\n  \/\/ Second copy is added to first, word-by-word\n  for (i = 0; i < 16; ++i)\n    x[i] = z[i] = s20_littleendian(seq + (4 * i));\n\n  for (i = 0; i < 10; ++i)\n    s20_doubleround(z);\n\n  for (i = 0; i < 16; ++i) {\n    z[i] += x[i];\n    s20_rev_littleendian(seq + (4 * i), z[i]);\n  }\n}\n```\n\nNote again the pervasive use of in-place mutation - as with s20_quarterround, the connection between this and the functionally pure Cryptol specification will be made clear through the SAW specification.\n\nSalsa20 supports two key sizes: 16 and 32 bytes. Rather than writing two separate implementations, Salsa20_expansion uses two unique features of Cryptol\u2019s type system to implement both at once. These features are numbers in types and arithmetic predicates. Numbers in types, seen earlier, are used for the lengths of sequences, and it is possible to write functions that work on any length.\n\nIn Cryptol, some types accept arguments, which are written at the beginning of the type in curly braces. For instance, the most general type signature for a swap function on pairs is `swap : {a, b} (a, b) -> (b, a)`. This is equivalent to the Java signature `Pair<B, A> swap<A, B> (Pair<A, B> x)`. The `{a, b}` corresponds to the `<A,B>` immediately after swap. Arguments to types can be both ordinary types, like `[8]` or `([16][8], [8])`, or numbers.\n\nType arguments can additionally be constrained. This means that a type or number argument must satisfy certain properties in order to be used. These constraints are written in parentheses and followed by a double arrow. For instance, the type of a function that takes the first element of a sequence is `{n, a} (n > 0) => [n]a -> a`, where n must be greater than zero (because empty sequences have no first element).\n\nThe beginning of the type signature for Salsa20_expansion reads `{a} (a >= 1, 2 >= a) => ...`, which says that a can only be 1 or 2. Later on in the type, `[16*a][8]` is used for the key length, resulting in a length of either 16 or 32 8-bit bytes. The back-tick operator allows a program to inspect the value of a length from a type, which is used in the if expression to select the appropriate input to Salsa20. Cryptol strings, like C string literals, represent sequences of ASCII byte values. The specific strings used here come from the Salsa20 specification.\n\n```cryptol\n\/\/ Salsa 20 supports two key sizes, [16][8] and [32][8]\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(k, n) = z\n  where\n    [s0, s1, s2, s3] = split \"expand 32-byte k\" : [4][4][8]\n    [t0, t1, t2, t3] = split \"expand 16-byte k\" : [4][4][8]\n    x = if(`a == 2) then s0 # k0 # s1 # n # s2 # k1 # s3\n                    else t0 # k0 # t1 # n # t2 # k0 # t3\n    z = Salsa20(x)\n    [k0, k1] = (split(k#zero)):[2][16][8]\n```\n\nThe encryption function takes a tuple of three parameters: a key k, an eight-byte nonce v, and a message m of at most 270 bytes. In accordance with Section 10 of the specification, it computes the Salsa20_expansion of the nonce and sufficient subsequent numbers, and truncates it to the desired length. The message is combined with this sequence, yielding the result.\n\n```cryptol\nSalsa20_encrypt : {a, l} (a >= 1, 2 >= a, l <= 2^^70) => ([16*a][8], [8][8], [l][8]) -> [l][8]\nSalsa20_encrypt(k, v, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(k, v#(reverse (split i))) | i <- [0, 1 ... ] ])\n    c = m ^ salsa\n```\n\n## SAW Specification and Verification\n\nThe SAW specification for this Salsa20 implementation is comprised of a couple of convenient helper functions, a specification for each of the interesting functions in the Salsa20 specification (i.e. the functions detailed in Bernstein\u2019s specification document), and a defined command main that performs the actual verification.\n\nOne big difference between the Cryptol specification and the C implementation is that Cryptol, a functional language, returns new values, while programs in C, an imperative language, tend to write new values to a pointer\u2019s target. In this case, the C version of the program overwrites an argument with the value that the Cryptol version returns. This pattern is abstracted over in `oneptr_update_func`, a SAWScript command that describes this relationship between the C and Cryptol versions of a function. The arguments are `type : LLVMType` that describes the parameter type, `name : String` that names the parameter for pretty-printing, and the function `f : Term` to apply to the parameter.\n\n```saw\nlet oneptr_update_func (type : LLVMType) (name : String) (f : Term) = do {\n    (x, p) <- pointer_to_fresh type name;\n    crucible_execute_func [p];\n    crucible_points_to p (crucible_term {{ f x }});\n};\n```\n\n**Note**\n\nIf you haven\u2019t already, look at the file `helpers.saw` - it defines a number of SAW functions that factor out common patterns as in `oneptr_update_func`, but also give more user-friendly names to various functions. Feel free to use, modify or ignore `helpers.saw` in SAW programs you write, and be on the lookout for new helpful functions when you work with SAW programs written by others. Good choice of names can make SAW programs much more readable.\n\nAll of Salsa20 depends on s20_quarterround. Here is its specification:\n\n```saw\nlet quarterround_setup : CrucibleSetup () = do {\n    (y0, p0) <- pointer_to_fresh (llvm_int 32) \"y0\";\n    (y1, p1) <- pointer_to_fresh (llvm_int 32) \"y1\";\n    (y2, p2) <- pointer_to_fresh (llvm_int 32) \"y2\";\n    (y3, p3) <- pointer_to_fresh (llvm_int 32) \"y3\";\n\n    crucible_execute_func [p0, p1, p2, p3];\n\n    let zs = {{ quarterround [y0,y1,y2,y3] }};\n    crucible_points_to p0 (crucible_term {{ zs@0 }});\n    crucible_points_to p1 (crucible_term {{ zs@1 }});\n    crucible_points_to p2 (crucible_term {{ zs@2 }});\n    crucible_points_to p3 (crucible_term {{ zs@3 }});\n};\n```\n\nThe helper `pointer_to_fresh` is the same as the one in Specifying Memory Layout. It allocates space for a new symbolic variable of the given type, returning both the symbolic value and the pointer to it. The symbolic values are passed to the Cryptol function `quarterround` to compute the expected result values. Because the function\u2019s inputs are symbolic, the outputs are also mathematical expressions that reflect the function\u2019s behavior. These expected result values are then used as the expected targets of the pointers in the post-condition of the SAW specification.\n\nThe specification for s20_hash is an example of one for which `oneptr_update_func` is useful.\n\n```saw\nlet salsa20_setup =\n  oneptr_update_func (llvm_array 64 (llvm_int 8)) \"seq\" {{ Salsa20 }};\n```\n\nPutting everything together, `main` verifies the implementation functions according to these specifications. `main` has the type `TopLevel ()` \u2014 this is the type of commands that can be run at the top level of a SAWScript program. In First Example: Counting Set Bits, `crucible_llvm_verify` was used on its own, and its return value was discarded. However, verification actually returns a useful result: it returns an association between a specification and the fact that the given function has been verified to fulfill it. In SAWScript, this association has the type `CrucibleMethodSpec`. Because `crucible_llvm_verify` is a command, the returned value is saved using the `<-` operator.\n\nThe third argument to `crucible_llvm_verify` is a list of `CrucibleMethodSpec` objects. While performing verification, the work that was done to construct a `CrucibleMethodSpec` is re-used. Specifically, instead of recursively symbolically executing a verified function, the prior specification is used as an axiomatization of its behavior. In the definition of main, the results of earlier verifications are passed along:\n\n```saw\nlet main : TopLevel () = do {\n    m      <- llvm_load_module \"salsa20.bc\";\n    qr     <- crucible_llvm_verify m \"s20_quarterround\" []      false quarterround_setup   z3;\n    rr     <- crucible_llvm_verify m \"s20_rowround\"     [qr]    false rowround_setup       z3;\n    cr     <- crucible_llvm_verify m \"s20_columnround\"  [qr]    false columnround_setup    z3;\n    dr     <- crucible_llvm_verify m \"s20_doubleround\"  [cr,rr] false doubleround_setup    z3;\n    s20    <- crucible_llvm_verify m \"s20_hash\"         [dr]    false salsa20_setup        z3;\n    s20e32 <- crucible_llvm_verify m \"s20_expand32\"     [s20]   true  salsa20_expansion_32 z3;\n    s20encrypt_63 <- crucible_llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 63) z3;\n    s20encrypt_64 <- crucible_llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 64) z3;\n    s20encrypt_65 <- crucible_llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 65) z3;\n\n    print \"Done!\";\n};\n```\n\nThis example also uses the fourth argument to `crucible_llvm_verify`. During symbolic execution, conditionals require that both branches be explored. If the fourth argument is true, then an SMT solver is used to rule out impossible branches. For some problems, the overhead of the solver exceeds the time saved on exploring branches; for others, a short time spent in the solver saves a long time spent in the symbolic execution engine. Ruling out impossible branches can also allow termination of programs in which the number of iterations can depend on a symbolic value. This is called path satisfiability checking.\n\nThe 16-byte version of Salsa20 is not verified, because the C program does not implement it. Also, Salsa20 is verified only with respect to some particular message lengths, because SAW is not yet capable of verifying infinite programs. This is why main verifies multiple lengths, in the hope that this is sufficient to increase our confidence.\n\n## Comparing Compositional and Non-compositional Verification\n\nIn examples\/salsa20, there are two SAW specifications: `salsa20_compositional.saw`, which contains main as presented above, and `salsa20_noncompositional.saw`, which replaces the `CrucibleMethodSpec` list parameter in each call to `crucible_llvm_verify` with the empty list, effectively disabling compositional verification. The one exception to this is in the verification of s20_hash; not using compositional verification for this function did not terminate in a reasonable amount of time.\n\nThese two verification tasks were run on a 2019 15-inch MacBook Pro, 2.4 GHz 8-Core Intel i9 processor, 32 GB DDR4 RAM. The values shown are the average over five runs:\n\n| Verification Type   | Average Time (s) |\n|---------------------|------------------|\n| Compositional       | 2.64             |\n| Non-Compositional   | 5.39             |\n\nEven with this limited data set, the benefits of using compositional verification are clear: There\u2019s effectively a 2x increase in speed in this example, even accounting for the fact that the verification of s20_hash is still treated compositionally.\n\n## Exercise: Rot13\n\nRot13 is a Caesar cipher that is its own inverse. In it, each letter is mapped to the letter that is 13 places greater than it in the alphabet, modulo 26. Non-letters are untouched, and case is preserved. For instance, \u201cabc\u201d becomes \u201cnop\u201d, and \u201cSAW is fun!\u201d becomes \u201cFNJ vf sha!\u201d.\n\nYour task is to implement rot13 in C, and verify it using SAW.\n\nStart by writing a function that performs a single character of rot13, assuming 7-bit ASCII encoding. Verify it using SAW and Cryptol.\n\nThen, write a function that uses your single-character rot13 to perform rot13 on a string with precisely 20 characters in it. Verify this using SAW and Cryptol with compositional verification.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/saw.galois.com\/intro\/HMACProblem.html","filetype":"txt","content":"## Proof Maintenance Exercises: s2n HMAC\n\nThe evolution of a program is accompanied by the evolution of its specifications. A key part of using SAW and Cryptol to verify a software system is the ongoing maintenance of proof artifacts through the software development lifecycle.\n\nProof maintenance is the process of preserving the correspondence between a program, its specification, and its proof of correctness as requirements change over time. This section poses as an exercise an extended proof-maintenance task, adapted from these changes to the HMAC implementation in Amazon\u2019s s2n. The code\u2019s file structure has been reorganized slightly, but the code itself is untouched.\n\nThis task will be approached as if the changes to the implementation are given, and the goal will be to evolve the relevant specifications to match. While completing the exercises, take note of the correspondences between the changes to the code and the changes to the specifications.\n\n## Background: The Updates to the Implementation\n\nThis section provides an overview of the changes to the implementation that form the basis of the proof maintenance task to be completed.\n\nThe s2n HMAC implementation needed to be updated to make use of an additional piece of hashing state, `outer_just_key`, for the implementation of TLS. At its core, this change is captured by the addition of a new field to the `s2n_hmac_state` structure as it is defined in `s2n_hmac_old.h`. The resulting structure looks like this:\n\n```c\nstruct s2n_hmac_state {\n    s2n_hmac_algorithm alg;\n\n    uint16_t hash_block_size;\n    uint32_t currently_in_hash_block;\n    uint16_t xor_pad_size;\n    uint8_t digest_size;\n\n    struct s2n_hash_state inner;\n    struct s2n_hash_state inner_just_key;\n    struct s2n_hash_state outer;\n    struct s2n_hash_state outer_just_key;\n\n    \/* key needs to be as large as the biggest block size *\/\n    uint8_t xor_pad[128];\n\n    \/* For storing the inner digest *\/\n    uint8_t digest_pad[SHA512_DIGEST_LENGTH];\n};\n```\n\nThe addition of this new field saw corresponding changes to the implementation code, which can be found in `s2n_hmac_new.c`. These changes included memory allocations, initializations, updates, and frees. The following code sample gives a good sense of the types of changes involved:\n\n```c\nstatic int s2n_tls_hmac_init(struct s2n_hmac_state *state, s2n_hmac_algorithm alg, const void *key, uint32_t klen)\n{\n    s2n_hash_algorithm hash_alg;\n    GUARD(s2n_hmac_hash_alg(alg, &hash_alg));\n\n    GUARD(s2n_hash_init(&state->inner, hash_alg));\n    GUARD(s2n_hash_init(&state->inner_just_key, hash_alg));\n    GUARD(s2n_hash_init(&state->outer, hash_alg));\n    GUARD(s2n_hash_init(&state->outer_just_key, hash_alg));\n\n    uint32_t copied = klen;\n    if (klen > state->xor_pad_size) {\n        GUARD(s2n_hash_update(&state->outer, key, klen));\n        GUARD(s2n_hash_digest(&state->outer, state->digest_pad, state->digest_size));\n\n        memcpy_check(state->xor_pad, state->digest_pad, state->digest_size);\n        copied = state->digest_size;\n    } else {\n        memcpy_check(state->xor_pad, key, klen);\n    }\n\n    for (int i = 0; i < copied; i++) {\n        state->xor_pad[i] ^= 0x36;\n    }\n    for (int i = copied; i < state->xor_pad_size; i++) {\n        state->xor_pad[i] = 0x36;\n    }\n\n    GUARD(s2n_hash_update(&state->inner_just_key, state->xor_pad, state->xor_pad_size));\n\n    \/* 0x36 xor 0x5c == 0x6a *\/\n    for (int i = 0; i < state->xor_pad_size; i++) {\n        state->xor_pad[i] ^= 0x6a;\n    }\n\n    GUARD(s2n_hash_update(&state->outer_just_key, state->xor_pad, state->xor_pad_size));\n    memset(&state->xor_pad, 0, sizeof(state->xor_pad));\n\n    return s2n_hmac_reset(state);\n}\n```\n\nThe complete diff between `s2n_hmac_old.c` and `s2n_hmac_new.c` shows a number of updates similar to that above:\n\n```diff\n--- \/Users\/atomb\/galois\/saw-training\/downloads\/examples\/hmac\/s2n_hmac_old.c\n+++ \/Users\/atomb\/galois\/saw-training\/downloads\/examples\/hmac\/s2n_hmac_new.c\n@@ -18,7 +18,7 @@\n\n #include \"s2n_errno.h\"\n\n-#include \"s2n_hmac_old.h\"\n+#include \"s2n_hmac_new.h\"\n #include \"s2n_hash.h\"\n #include \"s2n_fips.h\"\n\n@@ -94,11 +94,15 @@\n         hash_alg = S2N_HASH_SHA1;\n     }\n\n+    GUARD(s2n_hash_init(&state->inner, hash_alg));\n+    GUARD(s2n_hash_init(&state->inner_just_key, hash_alg));\n+    GUARD(s2n_hash_init(&state->outer, hash_alg));\n+    GUARD(s2n_hash_init(&state->outer_just_key, hash_alg));\n+\n     for (int i = 0; i < state->xor_pad_size; i++) {\n         state->xor_pad[i] = 0x36;\n     }\n\n-    GUARD(s2n_hash_init(&state->inner_just_key, hash_alg));\n     GUARD(s2n_hash_update(&state->inner_just_key, key, klen));\n     GUARD(s2n_hash_update(&state->inner_just_key, state->xor_pad, state->xor_pad_size));\n\n@@ -106,9 +110,9 @@\n         state->xor_pad[i] = 0x5c;\n     }\n\n-    GUARD(s2n_hash_init(&state->outer, hash_alg));\n     GUARD(s2n_hash_update(&state->outer, key, klen));\n     GUARD(s2n_hash_update(&state->outer, state->xor_pad, state->xor_pad_size));\n+    memset(&state->xor_pad, 0, sizeof(state->xor_pad));\n\n     \/* Copy inner_just_key to inner *\/\n     return s2n_hmac_reset(state);\n@@ -123,14 +127,15 @@\n     return s2n_hash_digest(&state->inner, out, size);\n }\n\n-\n static int s2n_tls_hmac_init(struct s2n_hmac_state *state, s2n_hmac_algorithm alg, const void *key, uint32_t klen)\n {\n     s2n_hash_algorithm hash_alg;\n     GUARD(s2n_hmac_hash_alg(alg, &hash_alg));\n\n+    GUARD(s2n_hash_init(&state->inner, hash_alg));\n     GUARD(s2n_hash_init(&state->inner_just_key, hash_alg));\n     GUARD(s2n_hash_init(&state->outer, hash_alg));\n+    GUARD(s2n_hash_init(&state->outer_just_key, hash_alg));\n\n     uint32_t copied = klen;\n     if (klen > state->xor_pad_size) {\n@@ -156,6 +161,9 @@\n     for (int i = 0; i < state->xor_pad_size; i++) {\n         state->xor_pad[i] ^= 0x6a;\n     }\n+\n+    GUARD(s2n_hash_update(&state->outer_just_key, state->xor_pad, state->xor_pad_size));\n+    memset(&state->xor_pad, 0, sizeof(state->xor_pad));\n\n     return s2n_hmac_reset(state);\n }\n@@ -201,6 +209,7 @@\n     GUARD(s2n_hash_new(&state->inner));\n     GUARD(s2n_hash_new(&state->inner_just_key));\n     GUARD(s2n_hash_new(&state->outer));\n+    GUARD(s2n_hash_new(&state->outer_just_key));\n\n     return 0;\n }\n@@ -269,8 +278,7 @@\n     }\n\n     GUARD(s2n_hash_digest(&state->inner, state->digest_pad, state->digest_size));\n-    GUARD(s2n_hash_reset(&state->outer));\n-    GUARD(s2n_hash_update(&state->outer, state->xor_pad, state->xor_pad_size));\n+    GUARD(s2n_hash_copy(&state->outer, &state->outer_just_key));\n     GUARD(s2n_hash_update(&state->outer, state->digest_pad, state->digest_size));\n\n     return s2n_hash_digest(&state->outer, out, size);\n@@ -303,6 +311,7 @@\n     GUARD(s2n_hash_free(&state->inner));\n     GUARD(s2n_hash_free(&state->inner_just_key));\n     GUARD(s2n_hash_free(&state->outer));\n+    GUARD(s2n_hash_free(&state->outer_just_key));\n\n     return 0;\n }\n@@ -333,6 +342,8 @@\n     GUARD(s2n_hash_copy(&to->inner, &from->inner));\n     GUARD(s2n_hash_copy(&to->inner_just_key, &from->inner_just_key));\n     GUARD(s2n_hash_copy(&to->outer, &from->outer));\n+    GUARD(s2n_hash_copy(&to->outer_just_key, &from->outer_just_key));\n+\n     memcpy_check(to->xor_pad, from->xor_pad, sizeof(to->xor_pad));\n     memcpy_check(to->digest_pad, from->digest_pad, sizeof(to->digest_pad));\n```\n\nFrom these changes alone, the work needed to keep the proofs up-to-date with the implementation can be very reasonably estimated. In this case, it will be necessary to complete the following tasks:\n\n- Add the new field to the correct type(s) in the Cryptol reference implementation\n- Add the relevant implementation details to the function(s) using the changed type\n- Update the SAWScript to reflect new memory layouts, initializations, etc. implied by the updated type\n\nTake note of the similarities to the rotr3 example in Exercise: Swapping and Rotating; these kinds of updates are ubiquitous when working on proof maintenance tasks. It will help to review that section before completing these exercises.\n\n## Exercise: Update the Cryptol Specification\n\nIn order for verification to go through, the Cryptol specification (that is, the implementation trusted to be correct) must be updated to reflect the existence of the new state field introduced above.\n\nYour task is to perform these updates in `HMAC_iterative_old.cry`. Use the bullet points above as a rough guide, and if you get stuck, there is a complete solution presented on the next page.\n\n## Exercise: Update the SAW Specifications\n\nThe final step to proof maintenance is updating the SAW portion of the specification. This can range in difficulty from simply updating memory layouts to changing what the specification actually asserts about the program.\n\nFor the HMAC updates, the necessary changes are closer to the former rather than the latter, since the implementation change was the addition of a data field rather than overall changes to the control flow.\n\nIn this exercise, you will edit the file `HMAC_old.saw` to add the memory layout information for the state field added to the C implementation. Hint: A reliable strategy for updating `HMAC_old.saw` to account for `outer_just_key` is a simple search for the names of other fields already present in the structure; these will likely appear where memory layouts and initializations that need to be augmented are specified.\n\n### Note\n\n`HMAC_old.saw` does not use the `helpers.saw` file as the previous examples did. Feel free to consult `helpers.saw` to help understand what the various functions do, and perhaps even rewrite `HMAC_old.saw` to use the helper functions.\n\nAs before, if you get stuck, there is a complete solution presented on the next page.","variant":null,"set":"holdout"}
{"filename":"https:\/\/saw.galois.com\/intro\/HMACSolution.html","filetype":"txt","content":"## Proof Maintenance Exercises: Solutions\n\nThis section provides a detailed solution to the two exercises in Proof Maintenance Exercises: s2n HMAC.\n\n## Updating the Cryptol Specification\n\nThe Cryptol type corresponding to the updated state container must, like the C structure, be augmented with an outer_just_key field that has the appropriate type, like so:\n\n```cryptol\ntype HMAC_c_state =\n  { alg                     : [32]\n  , hash_block_size         : [16]\n  , currently_in_hash_block : [32]\n  , block_size              : [16]\n  , digest_size             : [8]\n  , inner                   : SHA512_c_state\n  , inner_just_key          : SHA512_c_state\n  , outer                   : SHA512_c_state\n  , outer_just_key          : SHA512_c_state\n  , xor_pad                 : [128][8]\n  , digest_pad              : [SHA512_DIGEST_LENGTH][8]\n  }\n```\n\nThis very clearly corresponds to the change to the s2n_hmac_state structure in the C implementation, other than the specialization to SHA512. In the C implementation, the code is abstracted over the chosen hashing algorithm.\n\nHere is a sample of how the functions that use the HMAC_c_state type must change:\n\n```cryptol\nhmac_init_c_state :\n     { key_size, block_size, hash_block_size, digest_size }\n     ( fin key_size\n     , 64 >= width (8*key_size)\n     , 16 >= width hash_block_size\n     , 16 >= width block_size\n     , 8 >= width digest_size\n     , 128 >= block_size\n     , 64 >= digest_size )\n  => HMAC_c_state\n  -> [32]\n  -> [key_size][8]\n  -> HMAC_c_state\nhmac_init_c_state st0 alg key =\n  { alg                     = alg\n  , hash_block_size         = `hash_block_size\n  , currently_in_hash_block = currently_in_hash_block\n  , block_size              = `block_size\n  , digest_size             = `digest_size\n\n  , inner                   = inner\n  , inner_just_key          = inner_just_key\n  , outer                   = outer\n  , outer_just_key          = outer_just_key\n  , xor_pad                 = xor_pad\n  , digest_pad              = digest_pad\n  }\n  where\n    currently_in_hash_block = 0\n\n    k0 : [block_size][8]\n    (outer, digest_pad, k0) =\n      key_init_c_state `{digest_size=digest_size} st0.outer st0.digest_pad key\n    ikey = [ k ^ 0x36 | k <- k0 ]\n    okey = [ k ^ 0x6a | k <- ikey ]\n\n    inner_just_key = hash_update_c_state\n      (hash_init_c_state st0.inner_just_key) ikey\n    inner          = inner_just_key\n    outer_just_key = hash_update_c_state\n      (hash_init_c_state st0.outer_just_key) okey\n    xor_pad = zero \/\/okey # drop st0.xor_pad\n```\n\nTake note of how similar these changes are to those in the analogous C code; this is true more generally, as can be seen in the complete diff between HMAC_iterative_old.cry and HMAC_iterative_new.cry:\n\n```diff\n--- HMAC_iterative_old.cry\n+++ HMAC_iterative_new.cry\n@@ -81,6 +81,7 @@\n   , inner                   : SHA512_c_state\n   , inner_just_key          : SHA512_c_state\n   , outer                   : SHA512_c_state\n+  , outer_just_key          : SHA512_c_state\n   , xor_pad                 : [128][8]\n   , digest_pad              : [SHA512_DIGEST_LENGTH][8]\n   }\n@@ -193,7 +194,7 @@\n   , inner                   = inner\n   , inner_just_key          = inner_just_key\n   , outer                   = outer\n-\n+  , outer_just_key          = outer_just_key\n   , xor_pad                 = xor_pad\n   , digest_pad              = digest_pad\n   }\n@@ -209,8 +210,9 @@\n     inner_just_key = hash_update_c_state\n       (hash_init_c_state st0.inner_just_key) ikey\n     inner          = inner_just_key\n-\n-    xor_pad = okey # drop st0.xor_pad\n+    outer_just_key = hash_update_c_state\n+      (hash_init_c_state st0.outer_just_key) okey\n+    xor_pad = zero \/\/okey # drop st0.xor_pad\n@@ -277,9 +280,7 @@\n     \/\/outer = SHA256Update SHA256Init (okey # hin)\n     \/\/\n     \/\/ with:\n-    outer = hash_update_c_state\n-      (hash_update_c_state (hash_init_c_state s.outer) okey)\n-      hin\n+    outer = hash_update_c_state s.outer_just_key hin\n     inner = s.inner\n \n     out = join (hash_digest_c_state outer)\n@@ -287,7 +288,7 @@\n     sout : HMAC_c_state\n     sout =\n       { inner      = inner\n-      , outer      = outer\n+      , outer      = s.outer_just_key\n       , digest_pad = digest_pad\n \n       \/\/ Rest unchanged.\n```\n\n## Updating the SAW Specifications\n\nUsing the hint given in the exercise, a search for the term \u201couter\u201d in HMAC_old.saw reveals not only where memory layouts are specified, but embedded Cryptol terms of the type adjusted in the previous section. One of the memory layout specifications found through this search looks like this:\n\n```saw\n\/\/ ...\ncrucible_points_to (crucible_elem pstate 0) (crucible_term alg0);\ncrucible_points_to (crucible_elem pstate 1) (crucible_term hash_block_size0);\ncrucible_points_to (crucible_elem pstate 2) (crucible_term currently_in_hash_block0);\ncrucible_points_to (crucible_elem pstate 3) (crucible_term block_size0);\ncrucible_points_to (crucible_elem pstate 4) (crucible_term digest_size0);\ninner0 <- setup_hash_state (crucible_elem pstate 5);\ninner_just_key0 <- setup_hash_state (crucible_elem pstate 6);\nouter0 <- setup_hash_state (crucible_elem pstate 7);\ncrucible_points_to (crucible_elem pstate 8) (crucible_term xor_pad0);\ncrucible_points_to (crucible_elem pstate 9) (crucible_term digest_pad0);\n\/\/ ...\n```\n\nAnother improvement that can be made to this code is to use the crucible_field primitive instead of crucible_elem, which allows reference to structure fields by name rather than by index. This, and the necessary change to memory layout, appear below.\n\n```saw\n\/\/ ...\ncrucible_points_to (crucible_field pstate \"alg\") (crucible_term alg0);\ncrucible_points_to (crucible_field pstate \"hash_block_size\") (crucible_term hash_block_size0);\ncrucible_points_to (crucible_field pstate \"currently_in_hash_block\") (crucible_term currently_in_hash_block0);\ncrucible_points_to (crucible_field pstate \"xor_pad_size\") (crucible_term block_size0);\ncrucible_points_to (crucible_field pstate \"digest_size\") (crucible_term digest_size0);\ninner0 <- setup_hash_state (crucible_field pstate \"inner\");\ninner_just_key0 <- setup_hash_state (crucible_field pstate \"inner_just_key\");\nouter_just_key0 <- setup_hash_state (crucible_field pstate \"outer_just_key\");\nouter0 <- setup_hash_state (crucible_field pstate \"outer\");\ncrucible_points_to (crucible_field pstate \"xor_pad\") (crucible_term xor_pad0);\ncrucible_points_to (crucible_field pstate \"digest_pad\") (crucible_term digest_pad0);\n\/\/ ...\n```\n\nThe other change necessary is the aforementioned update to embedded Cryptol terms using the HMAC_c_state type augmented in the previous section. The original code found by searching looks like this:\n\n```saw\n\/\/ ...\nlet st0 = {{\n    { alg                     = alg0\n    , hash_block_size         = hash_block_size0\n    , currently_in_hash_block = currently_in_hash_block0\n    , block_size              = block_size0\n    , digest_size             = digest_size0\n    , inner                   = inner0\n    , inner_just_key          = inner_just_key0\n    , outer                   = outer0\n    , xor_pad                 = xor_pad0\n    , digest_pad              = digest_pad0\n    }\n  }};\n\/\/ ...\n```\n\nAnd the update corresponds exactly to the one in the Cryptol specification:\n\n```saw\n\/\/ ...\nlet st0 = {{\n    { alg                     = alg0\n    , hash_block_size         = hash_block_size0\n    , currently_in_hash_block = currently_in_hash_block0\n    , block_size              = block_size0\n    , digest_size             = digest_size0\n    , inner                   = inner0\n    , inner_just_key          = inner_just_key0\n    , outer                   = outer0\n    , outer_just_key          = outer_just_key0\n    , xor_pad                 = xor_pad0\n    , digest_pad              = digest_pad0\n    }\n  }};\n\/\/ ...\n```\n\nThe complete set of changes to the SAW specification can be seen in the diff between HMAC_old.saw and HMAC_new.saw:\n\n```diff\n--- HMAC_old.saw\n+++ HMAC_new.saw\n@@ -3,7 +3,7 @@\n\/\/\n-\/\/  Nathan Collins : conathan@galois.com\n+\/\/\tNathan Collins : conathan@galois.com\n@@ -19,7 +19,7 @@\n-import \"HMAC_iterative_old.cry\";\n+import \"HMAC_iterative_new.cry\";\n@@ -162,16 +162,17 @@\n     digest_pad0 <- crucible_fresh_var \"digest_pad\" (llvm_array digest_size (llvm_int 8));\n \n-    crucible_points_to (crucible_elem pstate 0) (crucible_term alg0);\n-    crucible_points_to (crucible_elem pstate 1) (crucible_term hash_block_size0);\n-    crucible_points_to (crucible_elem pstate 2) (crucible_term currently_in_hash_block0);\n-    crucible_points_to (crucible_elem pstate 3) (crucible_term block_size0);\n-    crucible_points_to (crucible_elem pstate 4) (crucible_term digest_size0);\n-    inner0 <- setup_hash_state (crucible_elem pstate 5);\n-    inner_just_key0 <- setup_hash_state (crucible_elem pstate 6);\n-    outer0 <- setup_hash_state (crucible_elem pstate 7);\n-    crucible_points_to (crucible_elem pstate 8) (crucible_term xor_pad0);\n-    crucible_points_to (crucible_elem pstate 9) (crucible_term digest_pad0);\n+    crucible_points_to (crucible_field pstate \"alg\") (crucible_term alg0);\n+    crucible_points_to (crucible_field pstate \"hash_block_size\") (crucible_term hash_block_size0);\n+    crucible_points_to (crucible_field pstate \"currently_in_hash_block\") (crucible_term currently_in_hash_block0);\n+    crucible_points_to (crucible_field pstate \"xor_pad_size\") (crucible_term block_size0);\n+    crucible_points_to (crucible_field pstate \"digest_size\") (crucible_term digest_size0);\n+    inner0 <- setup_hash_state (crucible_field pstate \"inner\");\n+    inner_just_key0 <- setup_hash_state (crucible_field pstate \"inner_just_key\");\n+    outer_just_key0 <- setup_hash_state (crucible_field pstate \"outer_just_key\");\n+    outer0 <- setup_hash_state (crucible_field pstate \"outer\");\n+    crucible_points_to (crucible_field pstate \"xor_pad\") (crucible_term xor_pad0);\n+    crucible_points_to (crucible_field pstate \"digest_pad\") (crucible_term digest_pad0);\n@@ -184,6 +185,7 @@\n         , inner                   = inner0\n         , inner_just_key          = inner_just_key0\n         , outer                   = outer0\n+        , outer_just_key          = outer_just_key0\n         , xor_pad                 = xor_pad0\n         , digest_pad              = digest_pad0\n         }\n@@ -193,19 +195,20 @@\n };\n \n let check_hmac_state pstate st = do {\n-    crucible_points_to (crucible_elem pstate 0) (crucible_term {{ st.alg }});\n-    crucible_points_to (crucible_elem pstate 1) (crucible_term {{ st.hash_block_size }});\n-    crucible_points_to (crucible_elem pstate 2) (crucible_term {{ st.currently_in_hash_block }});\n-    crucible_points_to (crucible_elem pstate 3) (crucible_term {{ st.block_size }});\n-    crucible_points_to (crucible_elem pstate 4) (crucible_term {{ st.digest_size }});\n-    update_hash_state (crucible_elem pstate 5) {{ st.inner }};\n-    update_hash_state (crucible_elem pstate 6) {{ st.inner_just_key }};\n+    crucible_points_to (crucible_field pstate \"alg\") (crucible_term {{ st.alg }});\n+    crucible_points_to (crucible_field pstate \"hash_block_size\") (crucible_term {{ st.hash_block_size }});\n+    crucible_points_to (crucible_field pstate \"currently_in_hash_block\") (crucible_term {{ st.currently_in_hash_block }});\n+    crucible_points_to (crucible_field pstate \"xor_pad_size\") (crucible_term {{ st.block_size }});\n+    crucible_points_to (crucible_field pstate \"digest_size\") (crucible_term {{ st.digest_size }});\n+    update_hash_state (crucible_field pstate \"inner\") {{ st.inner }};\n+    update_hash_state (crucible_field pstate \"inner_just_key\") {{ st.inner_just_key }};\n \n     \/\/ XXX: Don't care about 'outer' because it gets overwritten by\n     \/\/ 's2n_hash_reset' before use in 's2n_hmac_digest'.\n     \/\/\n     \/\/update_hash_state (crucible_elem pstate 7) {{ st.outer }};\n-    crucible_points_to (crucible_elem pstate 8) (crucible_term {{ st.xor_pad }});\n+    update_hash_state (crucible_field pstate \"outer_just_key\") ({{ st.outer_just_key }});\n+    crucible_points_to (crucible_field pstate \"xor_pad\") (crucible_term {{ st.xor_pad }});\n \n     \/\/ Don't care about 'digest_pad', because it gets overwritten\n     \/\/ using 's2n_hash_digest' before use in 's2n_hmac_digest'.\n```\n\nWith this, the specifications have been updated to account for the changes to the implementation, and verification via SAW will go through as intended.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/cryptol\/master\/BasicSyntax.html","filetype":"txt","content":"## Basic Syntax\n\n## Declarations\n\n```cryptol\nf x = x + y + z\n```\n\n## Type Signatures\n\n```cryptol\nf,g : {a,b} (fin a) => [a] b\n```\n\n## Numeric Constraint Guards\n\nA declaration with a signature can use numeric constraint guards, which are used to change the behavior of a function depending on its numeric type parameters. For example:\n\n```cryptol\nlen : {n} (fin n) => [n]a -> Integer\nlen xs | n == 0 => 0\n       | n >  0 => 1 + len (drop `{1} xs)\n```\n\nEach behavior starts with `|` and lists some constraints on the numeric parameters to a declaration. When applied, the function will use the first definition that satisfies the provided numeric parameters.\n\nNumeric constraint guards are quite similar to an if expression, except that decisions are based on types rather than values. There is also an important difference to simply using demotion and an actual if statement:\n\n```cryptol\nlen' : {n} (fin n) => [n]a -> Integer\nlen' xs = if `n == 0 => 0\n           | `n >  0 => 1 + len (drop `{1} xs)\n```\n\nThe definition of `len'` is rejected, because the value-based if expression does not provide the type-based fact `n >= 1` which is required by `drop `{1} xs`, while in `len`, the type-checker locally assumes the constraint `n > 0` in that constraint-guarded branch and so it can determine that `n >= 1`.\n\n**Requirements:**\n\n- Numeric constraint guards only support constraints over numeric literals, such as `fin`, `<=`, `==`, etc. Type constraint aliases can also be used as long as they only constrain numeric literals.\n- The numeric constraint guards of a declaration should be exhaustive. The type-checker will attempt to prove that the set of constraint guards is exhaustive, but if it can\u2019t then it will issue a non-exhaustive constraint guards warning. This warning is controlled by the environmental option `warnNonExhaustiveConstraintGuards`.\n- Each constraint guard is checked independently of the others, and there are no implicit assumptions that the previous behaviors do not match\u2014instead the programmer needs to specify all constraints explicitly in the guard.\n\n## Layout\n\nGroups of declarations are organized based on indentation. Declarations with the same indentation belong to the same group. Lines of text that are indented more than the beginning of a declaration belong to that declaration, while lines of text that are indented less terminate a group of declarations. Consider, for example, the following Cryptol declarations:\n\n```cryptol\nf x = x + y + z\n  where\n  y = x * x\n  z = x + y\n\ng y = y\n```\n\nThis group has two declarations, one for `f` and one for `g`. All the lines between `f` and `g` that are indented more than `f` belong to `f`. The same principle applies to the declarations in the `where` block of `f`, which defines two more local names, `y` and `z`.\n\n## Comments\n\nCryptol supports block comments, which start with `\/*` and end with `*\/`, and line comments, which start with `\/\/` and terminate at the end of the line. Block comments may be nested arbitrarily.\n\n```cryptol\n\/* This is a block comment *\/\n\/\/ This is a line comment\n\/* This is a \/* Nested *\/ block comment *\/\n```\n\n## Documentation Comments\n\nDeclarations in Cryptol can have documentation attached to them using special docstring comments. These attached comments are accessible in the REPL using the `:help` command.\n\nSyntactically, docstring comments are block comments that start with exactly two `*` characters: `\/** ... *\/`. For lines after the first line, a common prefix of whitespace and asterisks will be stripped in order to support stylistic blocks. Whitespace between the last asterisk on a line and the end-of-line can be dropped without affecting prefix detection.\n\n## Examples of docstrings\n\n```cryptol\n\/** Example documentation for x *\/\nx = 1\n\n\/**\n  Example documentation for y\n *\/\ny = 1\n\n\/**\n * Example documentation\n * for z\n *\/\nz = 1\n```\n\nTest cases can be included in docstring comments that will be checked by the `:check-docstrings` command in the form of code blocks that are unlabeled or labeled with the `repl` language. These cases should be in the form of REPL commands. Success of the test is defined as the success of all the REPL commands.\n\n## Example docstring with checked test\n\n```cryptol\n\/** This function\n *\n * ```repl\n * :check f 10 == 20\n * ```\n *\n * Also checked\n * ```\n * :safe f\n * ```\n *\n * Not checked\n * ```cpp\n * int main() {}\n * ```\n *\/\nf : [8] -> [8]\nf x = 2 * x\n```\n\nWhen you define a property `p` of type `Bit`, there is special behavior for docstring checks.\n\nIf no docstring is provided, or if the provided docstring contains no code blocks that would be checked with `:check-docstrings`, then `:check-docstrings` will implicitly run `:exhaust p`.\n\n## Identifiers\n\nCryptol identifiers consist of one or more characters. The first character must be either an English letter or underscore (`_`). The following characters may be an English letter, a decimal digit, underscore (`_`), or a prime (`'`). Some identifiers have special meaning in the language, so they may not be used in programmer-defined names (see Keywords and Built-in Operators).\n\n## Examples of identifiers\n\n```cryptol\nname    name1    name'    longer_name\nName    Name2    Name''   longerName\n```\n\n## Keywords and Built-in Operators\n\nThe following identifiers have special meanings in Cryptol, and may not be used for programmer-defined names:\n\n## Keywords\n\n```\nas              extern      include      interface      parameter      property      where\nby              hiding      infix        let            pragma         submodule     else\nconstraint      if          infixl       module         primitive      then\ndown            import      infixr       newtype        private        type\n```\n\nThe following table contains Cryptol\u2019s operators and their associativity with lowest precedence operators first, and highest precedence last.\n\n## Operator precedences\n\n| Operator                      | Associativity   |\n|-------------------------------|----------------|\n| ==>                           | right          |\n| \\\/                            | right          |\n| \/\\                            | right          |\n| == != === !==                 | not associative|\n| > < <= >= <$ >$ <=$ >=$       | not associative|\n| ||                            | right          |\n| ^                             | left           |\n| &&                            | right          |\n| #                             | right          |\n| >> << >>> <<< >>$             | left           |\n| + -                           | left           |\n| * \/ % \/$ %$                   | left           |\n| ^^                            | right          |\n| @ @@ ! !!                     | left           |\n| (unary) - ~                   | right          |\n\n## Built-in Type-level Operators\n\nCryptol includes a variety of operators that allow computations on the numeric types used to specify the sizes of sequences.\n\n## Type-level operators\n\n| Operator | Meaning              |\n|----------|----------------------|\n| +        | Addition             |\n| -        | Subtraction          |\n| *        | Multiplication       |\n| \/        | Division             |\n| \/^       | Ceiling division     |\n| %        | Modulus              |\n| %^       | Ceiling modulus      |\n| ^^       | Exponentiation       |\n| lg2      | Ceiling logarithm (base 2) |\n| width    | Bit width (equal to lg2(n+1)) |\n| max      | Maximum              |\n| min      | Minimum              |\n\n## Numeric Literals\n\nNumeric literals may be written in binary, octal, decimal, or hexadecimal notation. The base of a literal is determined by its prefix: `0b` for binary, `0o` for octal, no special prefix for decimal, and `0x` for hexadecimal.\n\n## Examples of literals\n\n```cryptol\n254                 \/\/ Decimal literal\n0254                \/\/ Decimal literal\n0b11111110          \/\/ Binary literal\n0o376               \/\/ Octal literal\n0xFE                \/\/ Hexadecimal literal\n0xfe                \/\/ Hexadecimal literal\n```\n\nNumeric literals in binary, octal, or hexadecimal notation result in bit sequences of a fixed length (i.e., they have type `[n]` for some `n`). The length is determined by the base and the number of digits in the literal. Decimal literals are overloaded, so the type is inferred from the context in which the literal is used. Examples:\n\n## Literals and their types\n\n```cryptol\n0b1010              \/\/ : [4],   1 * number of digits\n0o1234              \/\/ : [12],  3 * number of digits\n0x1234              \/\/ : [16],  4 * number of digits\n\n10                  \/\/ : {a}. (Literal 10 a) => a\n                    \/\/ a = Integer or [n] where n >= width 10\n```\n\nNumeric literals may also be written as polynomials by writing a polynomial expression in terms of `x` between an opening `<|` and a closing `|>`. Numeric literals in polynomial notation result in bit sequences of length one more than the degree of the polynomial. Examples:\n\n## Polynomial literals\n\n```cryptol\n<| x^^6 + x^^4 + x^^2 + x^^1 + 1 |>  \/\/ : [7], equal to 0b1010111\n<| x^^4 + x^^3 + x |>                \/\/ : [5], equal to 0b11010\n```\n\nCryptol also supports fractional literals using binary (prefix `0b`), octal (prefix `0o`), decimal (no prefix), and hexadecimal (prefix `0x`) digits. A fractional literal must contain a `.` and may optionally have an exponent. The base of the exponent for binary, octal, and hexadecimal literals is 2 and the exponent is marked using the symbol `p`. Decimal fractional literals use exponent base 10, and the symbol `e`. Examples:\n\n## Fractional literals\n\n```cryptol\n10.2\n10.2e3            \/\/ 10.2 * 10^3\n0x30.1            \/\/ 3 * 64 + 1\/16\n0x30.1p4          \/\/ (3 * 64 + 1\/16) * 2^4\n```\n\nAll fractional literals are overloaded and may be used with types that support fractional numbers (e.g., `Rational`, and the `Float` family of types).\n\nSome types (e.g., the `Float` family) cannot represent all fractional literals precisely. Such literals are rejected statically when using binary, octal, or hexadecimal notation. When using decimal notation, the literal is rounded to the closest representable even number.\n\nAll numeric literals may also include `_`, which has no effect on the literal value but may be used to improve readability. Here are some examples:\n\n## Using _\n\n```cryptol\n0b_0000_0010\n0x_FFFF_FFEA  \n```","variant":null,"set":"supervised"}
{"filename":"https:\/\/galoisinc.github.io\/cryptol\/master\/Expressions.html","filetype":"txt","content":"## Expressions\n\nThis section provides an overview of Cryptol\u2019s expression syntax.\n\n## Calling Functions\n\n```cryptol\nf 2             \/\/ call `f` with parameter `2`\ng x y           \/\/ call `g` with two parameters: `x` and `y`\nh (x,y)         \/\/ call `h` with one parameter, the pair `(x,y)`\n```\n\n## Prefix Operators\n\n```cryptol\n-2              \/\/ call unary `-` with parameter `2`\n- 2             \/\/ call unary `-` with parameter `2`\nf (-2)          \/\/ call `f` with one argument: `-2`, parens are important\n-f 2            \/\/ call unary `-` with parameter `f 2`\n- f 2           \/\/ call unary `-` with parameter `f 2`\n```\n\n## Infix Functions\n\n```cryptol\n2 + 3           \/\/ call `+` with two parameters: `2` and `3`\n2 + 3 * 5       \/\/ call `+` with two parameters: `2` and `3 * 5`\n(+) 2 3         \/\/ call `+` with two parameters: `2` and `3`\nf 2 + g 3       \/\/ call `+` with two parameters: `f 2` and `g 3`\n- 2 + - 3       \/\/ call `+` with two parameters: `-2` and `-3`\n- f 2 + - g 3\n```\n\n## Type Annotations\n\nExplicit type annotations may be added on expressions, patterns, and in argument definitions.\n\n```cryptol\nx : Bit         \/\/ specify that `x` has type `Bit`\nf x : Bit       \/\/ specify that `f x` has type `Bit`\n- f x : [8]     \/\/ specify that `- f x` has type `[8]`\n2 + 3 : [8]     \/\/ specify that `2 + 3` has type `[8]`\n\\x -> x : [8]   \/\/ type annotation is on `x`, not the function\nif x\n  then y\n  else z : Bit  \/\/ the type annotation is on `z`, not the whole `if`\n[1..9 : [8]]    \/\/ specify that elements in `[1..9]` have type `[8]`\n\nf (x : [8]) = x + 1   \/\/ type annotation on patterns\n```\n\n## Explicit Type Instantiation\n\nIf `f` is a polymorphic value with type:\n\n```cryptol\nf : { tyParam } tyParam\nf = zero\n```\n\nYou can evaluate `f` passing it a type parameter:\n\n```cryptol\nf `{ tyParam = 13 }\n```\n\n## Local Declarations\n\nLocal declarations have the weakest precedence of all expressions.\n\n```cryptol\n2 + x : [T]\n  where\n  type T = 8\n  x      = 2          \/\/ `T` and `x` are in scope of `2 + x : [T]`\n\nif x then 1 else 2\n  where x = 2         \/\/ `x` is in scope in the whole `if`\n\n\\y -> x + y\n  where x = 2         \/\/ `y` is not in scope in the definition of `x`\n```\n\n## Block Arguments\n\nWhen used as the last argument to a function call, `if` and lambda expressions do not need parentheses:\n\n```cryptol\nf \\x -> x       \/\/ call `f` with one argument `\\x -> x`\n2 + if x\n      then y\n      else z    \/\/ call `+` with two arguments: `2` and `if ...`\n```\n\n## Conditionals\n\nThe `if ... then ... else` construct can be used with multiple branches. For example:\n\n```cryptol\nx = if y % 2 == 0 then 22 else 33\n\nx = if y % 2 == 0 then 1\n     | y % 3 == 0 then 2\n     | y % 5 == 0 then 3\n     else 7\n```\n\n## Demoting Numeric Types to Values\n\nThe value corresponding to a numeric type may be accessed using the following notation:\n\n```cryptol\n`t\n```\n\nHere `t` should be a finite type expression with numeric kind. The resulting expression will be of a numeric base type, which is sufficiently large to accommodate the value of the type:\n\n```cryptol\n`t : {a} (Literal t a) => a\n```\n\nThis backtick notation is syntax sugar for an application of the number primitive, so the above may be written as:\n\n```cryptol\nnumber`{t} : {a} (Literal t a) => a\n```\n\nIf a type cannot be inferred from context, a suitable type will be automatically chosen if possible, usually `Integer`.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/cryptol\/master\/BasicTypes.html","filetype":"txt","content":"## Basic Types\n\n## Tuples and Records\n\nTuples and records are used for packaging multiple values together. Tuples are enclosed in parentheses, while records are enclosed in curly braces. The components of both tuples and records are separated by commas. The components of tuples are expressions, while the components of records are a label and a value separated by an equal sign. Examples:\n\n```cryptol\n(1,2,3)           \/\/ A tuple with 3 components\n()                \/\/ A tuple with no components\n\n{ x = 1, y = 2 }  \/\/ A record with two fields, `x` and `y`\n{}                \/\/ A record with no fields\n```\n\nThe components of tuples are identified by position, while the components of records are identified by their label, and so the ordering of record components is not important for most purposes. Examples:\n\n```cryptol\n(1,2) == (1,2)                 \/\/ True\n(1,2) == (2,1)                 \/\/ False\n\n{ x = 1, y = 2 } == { x = 1, y = 2 }    \/\/ True\n{ x = 1, y = 2 } == { y = 2, x = 1 }    \/\/ True\n```\n\nOrdering on tuples and records is defined lexicographically. Tuple components are compared in the order they appear, whereas record fields are compared in alphabetical order of field names.\n\n## Accessing Fields\n\nThe components of a record or a tuple may be accessed in two ways: via pattern matching or by using explicit component selectors. Explicit component selectors are written as follows:\n\n```cryptol\n(15, 20).0           == 15\n(15, 20).1           == 20\n\n{ x = 15, y = 20 }.x == 15\n```\n\nExplicit record selectors may be used only if the program contains sufficient type information to determine the shape of the tuple or record. For example:\n\n```cryptol\ntype T = { sign : Bit, number : [15] }\n\n\/\/ Valid definition:\n\/\/ the type of the record is known.\nisPositive : T -> Bit\nisPositive x = x.sign\n\n\/\/ Invalid definition:\n\/\/ insufficient type information.\nbadDef x = x.f\n```\n\nThe components of a tuple or a record may also be accessed using pattern matching. Patterns for tuples and records mirror the syntax for constructing values: tuple patterns use parentheses, while record patterns use braces. Examples:\n\n```cryptol\ngetFst (x,_) = x\n\ndistance2 { x = xPos, y = yPos } = xPos ^^ 2 + yPos ^^ 2\n\nf p = x + y where\n    (x, y) = p\n```\n\nSelectors are also lifted through sequence and function types, point-wise, so that the following equations hold:\n\n```cryptol\nxs.l == [ x.l | x <- xs ]     \/\/ sequences\nf.l  == \\x -> (f x).l         \/\/ functions\n```\n\nThus, if we have a sequence of tuples, `xs`, then we can quickly obtain a sequence with only the tuples\u2019 first components by writing `xs.0`.\n\nSimilarly, if we have a function, `f`, that computes a tuple of results, then we can write `f.0` to get a function that computes only the first entry in the tuple.\n\nThis behavior is quite handy when examining complex data at the REPL.\n\n## Updating Fields\n\nThe components of a record or a tuple may be updated using the following notation:\n\n```cryptol\n\/\/ Example values\nr = { x = 15, y = 20 }      \/\/ a record\nt = (True,True)             \/\/ a tuple\nn = { pt = r, size = 100 }  \/\/ nested record\n\n\/\/ Setting fields\n{ r | x = 30 }          == { x = 30, y = 20 }\n{ t | 0 = False }       == (False,True)\n\n\/\/ Update relative to the old value\n{ r | x -> x + 5 }      == { x = 20, y = 20 }\n\n\/\/ Update a nested field\n{ n | pt.x = 10 }       == { pt = { x = 10, y = 20 }, size = 100 }\n{ n | pt.x -> x + 10 }  == { pt = { x = 25, y = 20 }, size = 100 }\n```\n\n## Sequences\n\nA sequence is a fixed-length collection of elements of the same type. The type of a finite sequence of length `n`, with elements of type `a` is `[n] a`. Often, a finite sequence of bits, `[n] Bit`, is called a word. We may abbreviate the type `[n] Bit` as `[n]`. An infinite sequence with elements of type `a` has type `[inf] a`, and `[inf]` is an infinite stream of bits.\n\n```cryptol\n[e1,e2,e3]            \/\/ A sequence with three elements\n\n[t1 .. t2]            \/\/ Enumeration\n[t1 .. <t2]           \/\/ Enumeration (exclusive bound)\n[t1 .. t2 by n]       \/\/ Enumeration (stride)\n[t1 .. <t2 by n]      \/\/ Enumeration (stride, exclusive bound)\n[t1 .. t2 down by n]  \/\/ Enumeration (downward stride)\n[t1 .. >t2 down by n] \/\/ Enumeration (downward stride, exclusive bound)\n[t1, t2 .. t3]        \/\/ Enumeration (step by t2 - t1)\n\n[e1 ...]              \/\/ Infinite sequence starting at e1\n[e1, e2 ...]          \/\/ Infinite sequence stepping by e2 - e1\n\n[ e | p11 <- e11, p12 <- e12    \/\/ Sequence comprehensions\n    | p21 <- e21, p22 <- e22 ]\n\nx = generate (\\i -> e)    \/\/ Sequence from generating function\nx @ i = e                 \/\/ Sequence with index binding\narr @ i @ j = e           \/\/ Two-dimensional sequence\n```\n\nNote: the bounds in finite sequences (those with `..`) are type expressions, while the bounds in infinite sequences are value expressions.\n\n## Sequence Operations\n\n| Operator | Description                           |\n|----------|-------------------------------------|\n| `#`      | Sequence concatenation               |\n| `>>` `<<`| Shift (right, left)                  |\n| `>>>` `<<<`| Rotate (right, left)               |\n| `>>$`    | Arithmetic right shift (on bitvectors only) |\n| `@` `!`  | Access elements (front, back)       |\n| `@@` `!!`| Access sub-sequence (front, back)  |\n| `update` `updateEnd` | Update the value of a sequence at a location (front, back) |\n| `updates` `updatesEnd` | Update multiple values of a sequence (front, back) |\n\nThere are also lifted pointwise operations.\n\n```cryptol\n[p1, p2, p3, p4]          \/\/ Sequence pattern\np1 # p2                   \/\/ Split sequence pattern\n```\n\n## Functions\n\n```cryptol\n\\p1 p2 -> e              \/\/ Lambda expression\nf p1 p2 = e              \/\/ Function definition  \n```","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/cryptol\/master\/OverloadedOperations.html","filetype":"txt","content":"## Overloaded Operations\n\n## Equality\n\nEq\n  (==)        : {a}    (Eq a) => a -> a -> Bit\n  (!=)        : {a}    (Eq a) => a -> a -> Bit\n  (===)       : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\n  (!==)       : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\n\n## Instances\n\nType  \nCondition  \nBit  \nInteger  \nRational  \nZ n  \nfin n, n >= 1  \nFloat e p  \nValidFloat e p  \n[n] a  \nfin n, Eq a  \n(a,b)  \nEq a, Eq b  \n\n## Comparisons\n\nCmp\n  (<)         : {a} (Cmp a) => a -> a -> Bit\n  (>)         : {a} (Cmp a) => a -> a -> Bit\n  (<=)        : {a} (Cmp a) => a -> a -> Bit\n  (>=)        : {a} (Cmp a) => a -> a -> Bit\n  min         : {a} (Cmp a) => a -> a -> a\n  max         : {a} (Cmp a) => a -> a -> a\n  abs         : {a} (Cmp a, Ring a) => a -> a\n\n## Instances\n\nType  \nCondition  \nBit  \nInteger  \nRational  \nFloat e p  \nValidFloat e p  \n[n] a  \nfin n, Cmp a  \n(a,b)  \nCmp a, Cmp b  \n\n## Signed Comparisons\n\nSignedCmp\n  (<$)        : {a} (SignedCmp a) => a -> a -> Bit\n  (>$)        : {a} (SignedCmp a) => a -> a -> Bit\n  (<=$)       : {a} (SignedCmp a) => a -> a -> Bit\n  (>=$)       : {a} (SignedCmp a) => a -> a -> Bit\n\n## Instances\n\nType  \nCondition  \n[n] Bit  \nfin n, n >= 1  \n[n] a  \nfin n, SignedCmp a, a \/= Bit  \n(a,b)  \nSignedCmp a, SignedCmp b  \n\n## Zero\n\nZero\n  zero        : {a} (Zero a) => a\n\n## Instances\n\nType  \nCondition  \nBit  \nInteger  \nRational  \nZ n  \nfin n, n >= 1  \nFloat e p  \nValidFloat e p  \n[n] a  \nZero a  \na -> b  \nZero b  \n(a,b)  \nZero a, Zero b  \n\n## Logical Operations\n\nLogic\n  (&&)        : {a} (Logic a) => a -> a -> a\n  (||)        : {a} (Logic a) => a -> a -> a\n  (^)         : {a} (Logic a) => a -> a -> a\n  complement  : {a} (Logic a) => a -> a\n\n## Instances\n\nType  \nCondition  \nBit  \n[n] a  \nLogic a  \na -> b  \nLogic b  \n(a,b)  \nLogic a, Logic b  \n\n## Basic Arithmetic\n\nRing\n  fromInteger : {a} (Ring a) => Integer -> a\n  (+)         : {a} (Ring a) => a -> a -> a\n  (-)         : {a} (Ring a) => a -> a -> a\n  (*)         : {a} (Ring a) => a -> a -> a\n  negate      : {a} (Ring a) => a -> a\n  (^^)        : {a, e} (Ring a, Integral e) => a -> e -> a\n\n## Instances\n\nType  \nCondition  \nInteger  \nRational  \nZ n  \nfin n, n >= 1  \nFloat e p  \nValidFloat e p  \n[n] Bit  \nfin n  \n[n] a  \nRing a, a \/= Bit  \na -> b  \nRing b  \n(a,b)  \nRing a, Ring b  \n\n## Integral Operations\n\nIntegral\n  (\/)         : {a} (Integral a) => a -> a -> a\n  (%)         : {a} (Integral a) => a -> a -> a\n  (^^)        : {a, e} (Ring a, Integral e) => a -> e -> a\n  toInteger   : {a} (Integral a) => a -> Integer\n  infFrom     : {a} (Integral a) => a -> [inf] a\n  infFromThen : {a} (Integral a) => a -> a -> [inf] a\n\n## Instances\n\nType  \nCondition  \nInteger  \n[n] Bit  \nfin n  \n\n## Division\n\nField\n  recip       : {a} (Field a) => a -> a\n  (\/.)        : {a} (Field a) => a -> a -> a\n\n## Instances\n\nType  \nCondition  \nRational  \nZ n  \nprime n  \nFloat e p  \nValidFloat e p  \n\n## Rounding\n\nRound\n  ceiling     : {a} (Round a) => a -> Integer\n  floor       : {a} (Round a) => a -> Integer\n  trunc       : {a} (Round a) => a -> Integer\n  roundAway   : {a} (Round a) => a -> Integer\n  roundToEven : {a} (Round a) => a -> Integer\n\n## Instances\n\nType  \nCondition  \nFloat e p  \nValidFloat e p","variant":null,"set":"supervised"}
{"filename":"https:\/\/galoisinc.github.io\/cryptol\/master\/TypeDeclarations.html","filetype":"txt","content":"## Type Declarations\n\n## Type Synonyms\n\n```cryptol\ntype T a b = [a] b\n```\nA type declaration creates a synonym for a pre-existing type expression, which may optionally have arguments. A type synonym is transparently unfolded at use sites and is treated as though the user had instead written the body of the type synonym in line. Type synonyms may mention other synonyms, but it is not allowed to create a recursive collection of type synonyms.\n\n## Newtypes\n\n```cryptol\nnewtype NewT a b = { seq : [a]b }\n```\nA newtype declaration declares a new named type which is defined by a record body. Unlike type synonyms, each named newtype is treated as a distinct type by the type checker, even if they have the same bodies. Moreover, types created by a newtype declaration will not be members of any typeclasses, even if the record defining their body would be. For the purposes of typechecking, two newtypes are considered equal only if all their arguments are equal, even if the arguments do not appear in the body of the newtype, or are otherwise irrelevant. Just like type synonyms, newtypes are not allowed to form recursive groups.\n\nEvery newtype declaration brings into scope a new function with the same name as the type which can be used to create values of the newtype.\n\n```cryptol\nx : NewT 3 Integer\nx = NewT { seq = [1,2,3] }\n```\n\nJust as with records, field projections can be used directly on values of newtypes to extract the values in the body of the type.\n\n```text\n> sum x.seq\n6\n```\n\n## Enums\n\n```cryptol\nenum Maybe a = Nothing | Just a\n```\nAn enum declaration introduces a new named type, which is defined by a collection of constructors. Enum declarations correspond to the notion of algebraic data types, which are commonly found in other programming languages. Each named enum type is treated like a separate type, even if it has the exact same constructors as another enum type\u2014in this way enum is similar to newtype and unlike type synonyms.\n\n### Constructors\nThe only way to create a value of an enum type is to use one of its constructors. When used in an expression, the constructors behave like ordinary functions, which have one parameter for each field of the constructor. For example, the constructor `Just` has a type like this:\n\n```cryptol\nJust: {a} a -> Maybe a\n```\n\nConstructors may have 0 or multiple fields, and values created with different constructors are always distinct.\n\n### Case Expressions\nThe only way to examine a value of an enum type is with a case expression, which is similar to an if expression:\n\n```cryptol\ncase e of\n  Nothing -> 0\n  Just a  -> a + 1\n```\n\nIn this example, `e` is an expression of type `Maybe`:\n\n- If it was created with the `Nothing` constructor, then the first branch of the case expression is used, and the result is `0`.\n- If `e` was created by applying the `Just` constructor to some value (e.g., `Just 2`), then the second branch is used; the variable `a` is bound to the value of the field (e.g., `2`), and the whole expression evaluates to `a + 1` (e.g., `3`).\n\nIt is also possible to use a variable (or `_`) in a case expression to define a catch-all clause\u2014if a value does not match any of the previous cases, then this branch will be used:\n\n```cryptol\nisNothing x =\n  case x of\n    Nothing -> True\n    _       -> False\n```\n\n### `Option` and `Result`\nCurrently, Cryptol defines two enum declarations in the Cryptol standard library: `Option` and `Result`:\n\n```cryptol\nenum Option a = None | Some a\n\nenum Result t e = Ok t | Err e\n```\n\nThe `Option a` type represents an optional value, which can either be a value of type `a` (`Some`) or no value at all (`None`). A value of type `Result t e` can either be a successful value of type `t` (`Ok`) or an error value of type `e` (`Err`).\n\n`Option` and `Result` values are commonly used to model the return type of partial functions, i.e., functions that are not defined for all inputs. For instance, if a function `f` is not defined on the input `42`, then one could model this with `Option`:\n\n```cryptol\nf : [8] -> Option [8]\nf x =\n  if x == 42\n     then None\n     else Some (x+1)\n```\n\nOne could also model this with `Result`:\n\n```cryptol\nf : [8] -> Result [8] (String [8])\nf x =\n  if x == 42\n     then Err \"`f 42` not defined\"\n     else Ok (x+1)\n```\n\nWith either result type, one can gracefully recover from the `f 42` error by matching on `None` or `Err` in a case expression.\n\n### Upper Case Restriction\nThe names of the constructors in enum declarations need to start with an upper-case letter. This restriction makes it possible to distinguish between constructors and variable bindings in case patterns (e.g., between `Just` and `a` in the previous example).\n\n### Non Recursive\nThe fields in a constructor may be of any value type, as long as this type does not depend on the type to which the constructor belongs. This means that recursive types, such as linked lists, are not supported.\n\n### No Nested Constructor Patterns\nFor simplicity, only non-constructor patterns may be used in the fields of a constructor pattern. For example, `Just (a,b)` and `Just (a # b)` are allowed; however, `Just (Just a)` will be rejected. This is a restriction that may be lifted in the future.\n\n### No Overlapping Patterns\nFor simplicity, all patterns in a case expression must be disjoint. In particular:\n\n- No two patterns in a case expression may match the same constructor. For example, the following is rejected:\n\n```cryptol\nisNothing x =\n  case x of\n    Nothing -> True\n    Nothing -> False\n```\n\n- If a case expression uses a catch-all clause, that clause must occur last. For example, the following is rejected:\n\n```cryptol\nisNothing x =\n  case x of\n    Just _  -> False\n    _       -> True\n    Nothing -> False\n```\n\n### Patterns Must Be Exhaustive\nThe patterns in a case expression must cover all constructors in the enum type being matched. For example, the following is rejected as it does not cover the `Just` constructor:\n\n```cryptol\nisNothing x =\n  case x of\n    Nothing -> True\n```\n\n### The Matched Expression Must Have a Known Enum Type\nCryptol will reject the following, where no type signature exists and the pattern is a catch-all alone:\n\n```cryptol\nf x =\n  case x of\n    _ -> ()\n```\n\nThis is because it's not clear what the type of `x` should be. The only pattern is a catch-all case, which does not reveal any information about the type, so `f` cannot be polymorphic.\n\nCryptol will also reject this, where the matched type is not an enum:\n\n```cryptol\ng : Integer -> ()\ng x =\n  case x of\n    _ -> ()\n```","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/cryptol\/master\/Modules.html","filetype":"txt","content":"## Modules\n\nA module is used to group related definitions. Each file may contain at most one top-level module.\n\n```cryptol\nmodule M where\n\ntype T = [8]\n\nf : [8]\nf = 10\n```\nModule names should avoid using two consecutive underscores, because those are used to generate names for various anonymous modules.\n\n## Hierarchical Module Names\n\nModules may have either simple or hierarchical names. Hierarchical names are constructed by gluing together ordinary identifiers using the symbol ::.\n\n```cryptol\nmodule Hash::SHA256 where\n\nsha256 = ...\n```\nThe structure in the name may be used to group together related modules. The Cryptol implementation uses the structure of the name to locate the file containing the module definition. For example, when searching for module Hash::SHA256, Cryptol will look for a file named SHA256.cry in a directory called Hash, contained in one of the directories specified by CRYPTOLPATH.\n\n## Module Imports\n\nTo use the definitions from one module in another module, we use import declarations:\n\n```cryptol\nmodule M where\n\nf : [8]\nf = 2\n\nmodule N where\n\nimport M  \/\/ import all definitions from `M`\n\ng = f   \/\/ `f` was imported from `M`\n```\n\n## Import Lists\n\nSometimes, we may want to import only some of the definitions from a module. To do so, we use an import declaration with an import list.\n\n```cryptol\nmodule M where\n\nf = 0x02\ng = 0x03\nh = 0x04\n\nmodule N where\n\nimport M(f,g)  \/\/ Imports only `f` and `g`, but not `h`\n\nx = f + g\n```\nUsing explicit import lists helps reduce name collisions. It also tends to make code easier to understand, because it makes it easy to see the source of definitions.\n\n## Hiding Imports\n\nSometimes a module may provide many definitions, and we want to use most of them but with a few exceptions (e.g., because those would result in a name clash). In such situations it is convenient to use a hiding import:\n\n```cryptol\nmodule M where\n\nf = 0x02\ng = 0x03\nh = 0x04\n\nmodule N where\n\nimport M hiding (h) \/\/ Import everything but `h`\n\nx = f + g\n```\n\n## Qualified Module Imports\n\nAnother way to avoid name collisions is by using a qualified import.\n\n```cryptol\nmodule M where\n\nf : [8]\nf = 2\n\nmodule N where\n\nimport M as P\n\ng = P::f\n\/\/ `f` was imported from `M`\n\/\/ but when used it needs to be prefixed by the qualifier `P`\n```\nQualified imports make it possible to work with definitions that happen to have the same name but are defined in different modules.\n\nQualified imports may be combined with import lists or hiding clauses:\n\n```cryptol\nimport A as B (f)         \/\/ introduces B::f\nimport X as Y hiding (f)  \/\/ introduces everything but `f` from X using the prefix `Y`\n```\nIt is also possible to use the same qualifier prefix for imports from different modules. For example:\n\n```cryptol\nimport A as B\nimport X as B\n```\nSuch declarations will introduce all definitions from A and X but to use them, you would have to qualify using the prefix B::.\n\n## Private Blocks\n\nIn some cases, definitions in a module might use helper functions that are not intended to be used outside the module. It is good practice to place such declarations in private blocks:\n\n```cryptol\nmodule M where\n\nf : [8]\nf = 0x01 + helper1 + helper2\n\nprivate\n\n  helper1 : [8]\n  helper1 = 2\n\n  helper2 : [8]\n  helper2 = 3\n```\nThe private block only needs to be indented if it might be followed by additional public declarations. If all remaining declarations are to be private then no additional indentation is needed as the private block will extend to the end of the module.\n\nThe keyword `private` introduces a new layout scope, and all declarations in the block are considered to be private to the module. A single module may contain multiple private blocks. For example, the following module is equivalent to the previous one:\n\n```cryptol\nmodule M where\n\nf : [8]\nf = 0x01 + helper1 + helper2\n\nprivate\n  helper1 : [8]\n  helper1 = 2\n\nprivate\n  helper2 : [8]\n  helper2 = 3\n```\n\n## Nested Modules\n\nModules may be declared within other modules, using the `submodule` keyword.\n\n### Declaring a nested module called N\n\n```cryptol\nmodule M where\n\n  x = 0x02\n\n  submodule N where\n    y = x + 2\n```\nSubmodules may refer to names in their enclosing scope. Declarations in a submodule will shadow names in the outer scope.\n\nDeclarations in a submodule may be imported with `import submodule`, which works just like an ordinary import except that X refers to the name of a submodule.\n\n### Using declarations from a submodule.\n\n```cryptol\nmodule M where\n\n  x = 0x02\n\n  submodule N where\n    y = x + 2\n\n  import submodule N as P\n\n  z = 2 * P::y\n```\nNote that recursive definitions across modules are not allowed. So, in the previous example, it would be an error if `y` were to try to use `z` in its definition.\n\n## Implicit Imports\n\nFor convenience, we add an implicit qualified submodule import for each locally defined submodule.\n\n### Making use of the implicit import for a submodule.\n\n```cryptol\nmodule M where\n\n  x = 0x02\n\n  submodule N where\n    y = x + 2\n\n  z = 2 * N::y\n```\n`N::y` works in the previous example because Cryptol added an implicit import `import submodule N as N`.\n\n## Managing Module Names\n\nThe names of nested modules are managed by the module system just like the name of any other declaration in Cryptol. Thus, nested modules may be declared in the public or private sections of their containing module, and must be imported before they can be used. Thus, to use a submodule defined in top-level module A into another top-level module B requires two steps:\n\n1. First we need to import A to bring the name of the submodule in scope,\n2. Then we need to import the submodule to bring the names defined in it in scope.\n\n### Using a nested module from a different top-level module.\n\n```cryptol\nmodule A where\n\n  x = 0x02\n\n  submodule N where\n    y = x + 2\n\nmodule B where\n\n  import A            \/\/ Brings `N` in scope\n  import submodule N  \/\/ Brings `y` in scope\n  z = 2 * y\n```\n\n## Parameterized Modules\n\n## Interface Modules\n\nAn interface module describes the content of a module without providing a concrete implementation.\n\n### An interface module.\n\n```cryptol\ninterface module I where\n\n  type n : #      \/\/ `n` is a numeric type\n\n  type constraint (fin n, n >= 1)\n                  \/\/ Assumptions about the declared numeric type\n\n  x : [n]         \/\/ A declaration of a constant\n```\nLike other modules, interface modules may be nested in other modules:\n\n### A nested interface module\n\n```cryptol\nmodule M where\n\n  interface submodule I where\n\n    type n : #      \/\/ `n` is a numeric type\n\n    type constraint (fin n, n >= 1)\n                    \/\/ Assumptions about the declared numeric type\n\n    x : [n]         \/\/ A declaration of a constant\n```\n\nInterface modules may contain type or type constraint synonyms:\n\n### A nested interface module with type synonyms\n\n```cryptol\ninterface module I where\n\n  type n : #      \/\/ `n` is a numeric type\n\n  type W = [n]    \/\/ A type synonym, available when the interface is imported\n\n  type constraint (fin n, n >= 1)\n                  \/\/ Assumptions about the declared numeric type\n\n  x : W           \/\/ A declaration of a constant; uses type synonym.\n```\n\n## Importing an Interface Module\n\nA module may be parameterized by importing an interface, instead of a concrete module.\n\n### A parameterized module\n\n```cryptol\n\/\/ The interface describes the parameters\ninterface module I where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\n\n\/\/ This module is parameterized\nmodule F where\n  import interface I\n\n  y : [n]\n  y = x + 1\n```\nTo import a nested interface use `import interface submodule I` and make sure that `I` is in scope.\n\nIt is also possible to import multiple interface modules, or the same interface module more than once. Each import of an interface module may be linked to a different concrete module, as described in Instantiating a Parameterized Module.\n\n### Multiple interface parameters\n\n```cryptol\ninterface module I where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\n\nmodule F where\n  import interface I as I\n  import interface I as J\n\n  y : [I::n]\n  y = I::x + 1\n\n  z : [J::n]\n  z = J::x + 1\n```\nA parameterized module is also called a functor, in the tradition of module parameterization in languages like Standard ML and OCaml.\n\n## Interface Constraints\n\nWhen working with multiple interfaces, it is useful to be able to impose additional constraints on the types imported from the interface.\n\n### Adding constraints to interface parameters\n\n```cryptol\ninterface module I where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\n\nmodule F where\n  import interface I as I\n  import interface I as J\n\n  interface constraint (I::n == J::n)\n\n  y : [I::n]\n  y = I::x + J::x\n```\nIn this example we impose the constraint that `n` (the width of `x`) in both interfaces must be the same. Note that, of course, the two instantiations may provide different values for `x`.\n\n## Instantiating a Parameterized Module\n\nTo use a parameterized module we need to provide concrete implementations for the interfaces that it uses, and provide a name for the resulting module. This is done as follows:\n\n### Instantiating a parameterized module using a single interface.\n\n```cryptol\ninterface module I where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nmodule F where\n  import interface I\n\n  y : [n]\n  y = x + 1\n\nmodule Impl where\n  type n = 8\n  x = 26\n\nmodule MyF = F { Impl }\n```\nHere we defined a new module called `MyF` which is obtained by filling in module `Impl` for the interface used by `F`.\n\nIf a module is parameterized by multiple interfaces we need to provide an implementation module for each interface, using a slight variation on the previous notation.\n\n### Instantiating a parameterized module by name\n\n```cryptol\n\/\/ I is defined as above\n\nmodule F where\n  import interface I as I\n  import interface I as J\n\n  interface constraint (I::n == J::n)\n\n  y : [I::n]\n  y = I::x + J::x\n\nmodule Impl1 where\n  type n = 8\n  x = 26\n\nmodule Impl2 where\n  type n = 8\n  x = 30\n\nmodule MyF = F { I = Impl1, J = Impl2 }\n```\nEach interface import is identified by its name, which is derived from the `as` clause on the interface import. If there is no `as` clause, then the name of the parameter is derived from the name of the interface itself.\n\nSince interfaces are identified by name, the order in which they are provided is not important.\n\nModules defined by instantiation may be nested, just like any other module:\n\n### Nested module instantiation\n\n```cryptol\nmodule M where\n\n  import Somewhere \/\/ defines G\n\n  submodule F = submodule G { I }\n```\nIn this example, submodule `F` is defined by instantiating some other parameterized module `G`, presumably imported from `Somewhere`. Note that in this case the argument to the instantiation `I` is a top-level module, because it is not preceded by the `submodule` keyword.\n\nTo pass a nested module as the argument of a function, use `submodule I` like this:\n\n```cryptol\nmodule M where\n\n  import Somewhere \/\/ defines G and I\n\n  submodule F = submodule G { submodule I }\n```\n\n## Anonymous Interface Modules\n\nIf we need to just parameterize a module by a couple of types\/values, it is quite cumbersome to have to define a whole separate interface module. To make this more convenient we provide the following notation for defining an anonymous interface and using it straight away:\n\n### Simple parameterized module\n\n```cryptol\nmodule M where\n\n  parameter\n    type n : #\n    type constraint (fin n, n >= 1)\n    x : [n]\n\n  f : [n]\n  f = 1 + x\n```\nThe parameter block defines an interface module and uses it. Note that the parameters may not use things defined in M as the interface is declared outside of M. The parameter may contain the same sort of declarations that may appear in interfaces.\n\nFor external tools interacting with Cryptol, the name of the anonymous parameter interface for module M is `M__parameter` (note that there are 2 underscores after the name).\n\n## Anonymous Instantiation Arguments\n\nSometimes it is also a bit cumbersome to have to define a whole separate module just to pass it as an argument to some parameterized module. To make this more convenient we support the following notation for instantiating a module:\n\n```cryptol\n\/\/ A parameterized module\nmodule M where\n\n  parameter\n    type n : #\n    x      : [n]\n    y      : [n]\n\n  f : [n]\n  f = x + y\n\n\n\/\/ A module instantiation\nmodule N = M\n  where\n  type n = 32\n  x      = 11\n  y      = helper\n\n  helper = 12\n```\nThe declarations in the where block are treated as the definition of an anonymous module which is passed as the argument to parameterized module `M`.\n\nFor external tools interacting with Cryptol, the name of the anonymous module actually passed to the functor is as follows:\n\n- `N__where`, if `N` is a top-level module\n- `where__at_l_c`, if `N` is a submodule\n\nIn the second form, `l` and `c` are the line and column of `N`. If `c` is 1, then it is omitted, and the name will be just `where__at_l`. Note that in both cases the anonymous name contains two underscores next to each other.\n\n## Anonymous Import Instantiations\n\nWe provide syntactic sugar for importing and instantiating a functor at the same time:\n\n```cryptol\nsubmodule F where\n  parameter\n    x : [8]\n  y = x + 1\n\nimport submodule F where\n  x = 2\n```\nThe where block is the same as the where block in expressions: you may define type synonyms and values, but nothing else (e.g., no newtype).\n\nIt is also possible to import and instantiate a functor with an existing module like this:\n\n```cryptol\nsubmodule F where\n  parameter\n    x : [8]\n  y = x + 1\n\nsubmodule G where\n  x = 7\n\nimport submodule F { submodule G }\n```\nSemantically, instantiating imports declare a local nested module and import it. For example, the where import above is equivalent to the following declarations:\n\n```cryptol\nsubmodule F where\n\n  parameter\n    x : [8]\n\n  y = x + 1\n\n\nsubmodule M where\n  x = 2\n\n\nsubmodule N = submodule F { submodule M }\n\n\nimport submodule N\n```\nFor external tools interacting with Cryptol, the name of the anonymous module used in the import (the `N` in the above example) is of the form `import_at__l_c`, where `l` and `c` are the line and column of the `import` keyword. If the column is 1, then it is omitted, and the name is of the form `import_at__l`. Note that the name contains two underscores next to each other.\n\n## Passing Through Module Parameters\n\nOccasionally it is useful to define a functor that instantiates another functor using the same parameters as the functor being defined (i.e., a functor parameter is passed on to another functor). This can be done by using the keyword `interface` followed by the name of a parameter in an instantiation. Here is an example:\n\n```cryptol\ninterface submodule S where\n  x : [8]\n\n\/\/ A functor, parameterized on S\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\n\/\/ Another functor, also parameterized on S\nsubmodule F where\n  import interface submodule S as A\n\n  \/\/ Instantiate `G` using parameter `A` of `F`\n  import submodule G { interface A }    \/\/ Brings `y` in scope\n\n  z = A::x + y\n\n\/\/ Brings `z` into scope: z = A::x + y\n\/\/                          = 5    + (5 + 1)\n\/\/                          = 11\nimport submodule F where\n  x = 5\n```\n\n## Instantiation by Parametrizing Declarations\n\nIt is also possible to instantiate a functor parameter without providing an implementation module. Instead, the declarations in the instantiated module all get additional parameters corresponding to the functor\u2019s parameters. This is done by providing `_` as the parameter to a functor:\n\n```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    x : [n]\n\n  f : (fin n) => [n] -> [n]\n  f v = v + x\n\nsubmodule M = submodule F { _ }\nimport submodule M as M\n```\nThis example defines module `M` by instantiating `F` without a parameter. Here is the resulting type of `f`:\n\n```\nMain> :t M::f\nM::f : {n} (fin n) => {x : [n]} -> [n] -> [n]\n```\nNote that `f` has a new type parameter `n`, and a new value parameter of a record type. The type parameter `n` corresponds to the functor\u2019s type parameter while the record parameter has one field for each value parameter of the functor.\n\nThe order in which type parameters are added to a declaration is not specified, so you\u2019d have to use a named type application to apply a type explicitly.\n\nFunctors with multiple parameters may use `_` as argument for more than one parameter, and may also provide implementations for some of the parameters and use `_` for others.\n\n### [Parameter Names]\n\nThe names of the parameters in the declarations are the same as the names that are in scope, unless a parameter came in through a qualified interface import (i.e., the interface import uses the `as` clause). In that case, the name of the parameter is computed by replacing the `::` with `'` because `::` may not appear in type parameters or record fields. For example, if a module had a parameter `I::x`, then its `_` instantiation will use a record with a field named `I'x`.\n\n### [Restrictions]\n\nThere are some restrictions on functor parameters that can be defined with `_`:\n\n- The functor should not contain other functors nested in it. This is because it is unclear how to parameterize the parameters of nested functors.\n- All values coming through `_` parameters should have simple (i.e., non-polymorphic) types. This is because Cryptol does not support records with polymorphic fields.\n- All types and values coming through `_` parameters should have distinct names. This is because the fields in the record and type names use labels derived. Generally this should not be a problem unless a functor defined some parameters that have `'` in the middle.\n\n### [Backtick Imports]\n\nFor backward compatibility, we also provide syntactic sugar for importing a functor with a single interface parameter and instantiating it:\n\n```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    x : [n]\n\n  f : (fin n) => [n] -> [n]\n  f v = v + x\n\nimport submodule `F\n```\nThis is equivalent to writing:\n\n```cryptol\nimport submodule F { _ }\n```\nThis, in turn, is syntactic sugar for creating an anonymous module:\n\n```cryptol\nsubmodule M = F { _ }\nimport submodule M  \n```","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/cryptol\/master\/FFI.html","filetype":"txt","content":"## Foreign Function Interface\n\nThe foreign function interface (FFI) allows Cryptol to call functions written in other programming languages. This includes the C programming language as well as other languages that can implement the same calling conventions (e.g., Rust).\n\n## Platform support\n\nThe FFI is built on top of the C libffi library, and as such, it should be portable across many operating systems. We have tested it to work on Linux, macOS, and Windows.\n\n## Basic usage\n\nSuppose we want to implement the following function in C:\n\n```cryptol\nadd : [32] -> [32] -> [32]\n```\n\nIn our Cryptol file, we declare it as a foreign function with no body:\n\n```cryptol\nforeign add : [32] -> [32] -> [32]\n```\n\nNote that this uses Cryptol\u2019s C calling convention. (For more about the specifics of the Cryptol FFI\u2019s calling conventions, see the calling conventions section.)\n\nNext, we write the following C function:\n\n```c\nuint32_t add(uint32_t x, uint32_t y) {\n  return x + y;\n}\n```\n\nCryptol can generate a C header file containing the appropriate function prototypes given the corresponding Cryptol foreign declarations with the `:generate-foreign-header` command. You can then `#include` the generated header file in your C file to help write the C implementation.\n\n```\nCryptol> :generate-foreign-header Example.cry\nLoading module Example\nWriting header to Example.h\n```\n\nThe C code must first be compiled into a dynamically loaded shared library. When Cryptol loads the module containing the foreign declaration, it will look for a shared library in the same directory as the Cryptol module, with the same name as the Cryptol file but with a different file extension. The exact extension it uses is platform-specific:\n\n- On Linux, it looks for the extension `.so`.\n- On macOS, it looks for the extension `.dylib`.\n- On Windows, it looks for the extension `.dll`.\n\nFor example, if you are on Linux and your foreign declaration is in `Foo.cry`, Cryptol will dynamically load `Foo.so`. Then for each foreign declaration it will look for a symbol with the same name in the shared library. So in this case the function we want to call must be bound to the symbol `add` in the shared library.\n\nOnce the module is loaded, the foreign `add` function can be called like any other Cryptol function. Cryptol automatically converts between Cryptol `[32]` values and C `uint32_t` values.\n\nThe whole process would look something like this:\n\n```bash\n$ cc -fPIC -shared Example.c -o Example.so\n$ cryptol\nLoading module Cryptol\nCryptol> :l Example.cry\nLoading module Cryptol\nLoading module Main\nMain> add 1 2\n0x00000003\n```\n\n**Note:** Since Cryptol currently only accesses the compiled binary and not the C source, it has no way of checking that the Cryptol function type you declare in your Cryptol code actually matches the type of the C function. It can generate the correct C headers but if the actual implementation does not match it there may be undefined behavior.\n\n## Compiling C code\n\nCryptol currently does not handle compilation of C code to shared libraries. For simple usages, you can do this manually with the following commands:\n\n- Linux: `cc -fPIC -shared Foo.c -o Foo.so`\n- macOS: `cc -dynamiclib Foo.c -o Foo.dylib`\n- Windows: `cc -fPIC -shared Foo.c -o Foo.dll`\n\n## Calling conventions\n\nThe Cryptol FFI supports two different calling conventions:\n\n- The C calling convention, where Cryptol values are marshalled to and from C values of equivalent types. You can specify the C calling convention by writing:\n\n  ```cryptol\n  foreign c example : [32] -> [32] -> [32]\n  ```\n\n  This is the default calling convention, so you can also omit the `c` keyword above to achieve the same effect:\n\n  ```cryptol\n  foreign example : [32] -> [32] -> [32]\n  ```\n\n- The abstract calling convention, where Cryptol values are marshalled using an abstract interface. You can specify the abstract calling convention by writing:\n\n  ```cryptol\n  foreign abstract example : [32] -> [32] -> [32]\n  ```\n\n## The C calling convention\n\nForeign functions that use the C calling convention marshal Cryptol values to and from C values of equivalent types. This section describes how a given Cryptol function signature maps to a C function prototype. The C calling convention only supports a limited set of Cryptol types which have a clear translation into C.\n\nThis mapping can now be done automatically with the `:generate-foreign-header` command mentioned above; however, this section is still worth reading to understand the supported types and what the resulting C parameters mean.\n\n### Overall structure\n\nCryptol foreign bindings must be functions. These functions may have multiple (curried) arguments; they may also be polymorphic, with certain limitations. That is, the general structure of a foreign declaration would look something like this:\n\n```cryptol\nforeign f : {a1, ..., ak} (c1, ..., cn) => T1 -> ... -> Tm -> Tr\n```\n\nEach type argument to the Cryptol function (`a1, ..., ak` above) corresponds to a value argument to the C function. These arguments are passed first, in the order of the type variables declared in the Cryptol signature, before any Cryptol value arguments.\n\nEach value argument to the Cryptol function (`T1, ..., Tm` above) corresponds to a number of value arguments to the C function. That is, a Cryptol value argument could correspond to zero, one, or many C arguments. The C arguments for each Cryptol value argument are passed in the order of the Cryptol value arguments, after any C arguments corresponding to Cryptol type arguments.\n\nThe return value of the Cryptol function (`Tr` above) is either obtained by directly returning from the C function or by passing output arguments to the C function, depending on the return type. Output arguments are pointers to memory which can be modified by the C function to store its output values. If output arguments are used, they are passed last, after the C arguments corresponding to Cryptol arguments.\n\nThe following tables list the C type(s) that each Cryptol type (or kind) corresponds to.\n\n### Type parameters\n\n| Cryptol kind | C type |\n|--------------|---------|\n| #            | size_t  |\n\nOnly numeric type parameters are allowed in polymorphic foreign functions. Furthermore, each type parameter `n` must satisfy `fin n`. This has to be explicitly declared in the Cryptol signature.\n\nNote that if a polymorphic foreign function is called with a type argument that does not fit in a `size_t`, there will be a runtime error. (While we could check this statically by requiring that all type variables in foreign functions satisfy `< 2^^64` instead of just `fin`, in practice this would be too cumbersome.)\n\n### Bit\n\n| Cryptol type | C type   |\n|--------------|----------|\n| Bit          | uint8_t  |\n\nWhen converting to C, `True` is converted to 1 and `False` to 0. When converting to Cryptol, any nonzero number is converted to `True` and 0 is converted to `False`.\n\n### Bit Vector Types\n\nLet `K : #` be a Cryptol type. Note `K` must be an actual fixed numeric type and not a type variable.\n\n| Cryptol type         | C type    |\n|----------------------|-----------|\n| [K]Bit where 0 <= K <= 8  | uint8_t   |\n| [K]Bit where 8 < K <= 16  | uint16_t  |\n| [K]Bit where 16 < K <= 32 | uint32_t  |\n| [K]Bit where 32 < K <= 64 | uint64_t  |\n\nIf the Cryptol type is smaller than the C type, then when converting to C the value is padded with zero bits, and when converting to Cryptol the extra bits are ignored. For instance, for the Cryptol type `[4]`, the Cryptol value `0xf : [4]` is converted to the C value `uint8_t 0x0f`, and the C `uint8_t 0xaf` is converted to the Cryptol value `0xf : [4]`.\n\nNote that bit vectors larger than 64 bits are not supported, since there is no standard C integral type for that. You can split it into a sequence of smaller words first in Cryptol, then use the FFI conversion for sequences of words to handle it in C as an array.\n\n### Floating point types\n\n| Cryptol type | C type |\n|--------------|---------|\n| Float32      | float   |\n| Float64      | double  |\n\nNote: the Cryptol Float types are defined in the built-in module `Float`. Other sizes of floating points are not supported.\n\n### Math Types\n\nValues of high precision types and `Z` are represented using the GMP library.\n\n| Cryptol type | C type |\n|--------------|---------|\n| Integer      | mpz_t   |\n| Rational     | mpq_t   |\n| Z n          | mpz_t   |\n\nResults of these types are returned in output parameters, but since both `mpz_t` and `mpq_t` are already reference types there is no need for an extra pointer in the result. For example, a Cryptol function `f : Integer -> Rational` would correspond to a C function `f(mpz_t in, mpq_t out)`.\n\nAll parameters passed to the C function (no matter if input or output) are managed by Cryptol, which takes care to call `init` before their use and `clear` after.\n\n### Sequences\n\nLet `n1, n2, ..., nk : #` be Cryptol types (with `k >= 1`), possibly containing type variables, that satisfy `fin n1, fin n2, ..., fin nk`, and `T` be one of the above Cryptol bit vector types, floating point types, or math types. Let `U` be the C type that `T` corresponds to.\n\n| Cryptol type         | C type |\n|----------------------|---------|\n| [n1][n2]...[nk]T     | U*      |\n\nThe C pointer points to an array of `n1 * n2 * ... * nk` elements of type `U`. If the sequence is multidimensional, it is flattened and stored contiguously, similar to the representation of multidimensional arrays in C. Note that, while the dimensions of the array itself are not explicitly passed along with the pointer, any type arguments contained in the size are passed as C `size_t`s earlier, so the C code can always know the dimensions of the array.\n\n### Tuples and records\n\nLet `T1, T2, ..., Tn` be Cryptol types supported by the C calling convention (which may be any of the types mentioned above, or tuples and records themselves). Let `U1, U2, ..., Un` be the C types that `T1, T2, ..., Tn` respectively correspond to. Let `f1, f2, ..., fn` be arbitrary field names.\n\n| Cryptol type               | C types         |\n|----------------------------|-----------------|\n| (T1, T2, ..., Tn)          | U1, U2, ..., Un |\n| {f1: T1, f2: T2, ..., fn: Tn} | U1, U2, ..., Un |\n\nIn this case, each Cryptol tuple or record is flattened out; passing a tuple as an argument behaves the same as if you passed its components individually. This flattening is applied recursively for nested tuples and records. Note that this means empty tuples don\u2019t map to any C values at all.\n\n### Type synonyms\n\nAll type synonyms are expanded before applying the above rules, so you can use type synonyms in foreign declarations to improve readability.\n\n### Return values\n\nIf the Cryptol return type is `Bit` or one of the above bit vector types or floating point types, the value is returned directly from the C function. In that case, the return type of the C function will be the C type corresponding to the Cryptol type, and no extra arguments are added.\n\nIf the Cryptol return type is one of the math types, a sequence, tuple, or record, then the value is returned using output arguments, and the return type of the C function will be `void`. For tuples and records, each component is recursively returned as output arguments. When treated as an output argument, each C type `U` will be a pointer `U*` instead, except in the case of math types and sequences, where the output and input versions are the same type, because it is already a pointer.\n\n### Quick reference\n\n| Cryptol type (or kind)       | C argument type(s) | C return type | C output argument type(s) |\n|-----------------------------|--------------------|---------------|---------------------------|\n| #                           | size_t             | N\/A           | N\/A                       |\n| Bit                         | uint8_t            | uint8_t       | uint8_t*                  |\n| [K]Bit where 0 <= K <= 8    | uint8_t            | uint8_t       | uint8_t*                  |\n| [K]Bit where 8 < K <= 16    | uint16_t           | uint16_t      | uint16_t*                 |\n| [K]Bit where 16 < K <= 32   | uint32_t           | uint32_t      | uint32_t*                 |\n| [K]Bit where 32 < K <= 64   | uint64_t           | uint64_t      | uint64_t*                 |\n| Float32                     | float              | float         | float*                    |\n| Float64                     | double             | double        | double*                   |\n| Integer                     | mpz_t              | N\/A           | mpz_t                     |\n| Rational                    | mpq_t              | N\/A           | mpq_t                     |\n| Z n                         | mpz_t              | N\/A           | mpz_t                     |\n| [n1][n2]...[nk]T            | U*                 | N\/A           | U*                        |\n| (T1, T2, ..., Tn)           | U1, U2, ..., Un    | N\/A           | V1, V2, ..., Vn           |\n| {f1: T1, f2: T2, ..., fn: Tn} | U1, U2, ..., Un | N\/A           | V1, V2, ..., Vn           |\n\nwhere `K` is a constant number, `ni` are variable numbers, `Ti` is a type, `Ui` is its C argument type, and `Vi` is its C output argument type.\n\n### Example\n\nThe Cryptol signature\n\n```cryptol\nforeign c fun : {n} (fin n) => [n][10] -> {a : Bit, b : [64]}\n                               -> (Float64, [n + 1][20])\n```\n\ncorresponds to the C signature\n\n```c\nvoid fun(size_t n, uint16_t *in0, uint8_t in1_a, uint64_t in1_b,\n         double *out_0, uint32_t *out_1);\n```\n\n### Memory\n\nWhen pointers are involved, namely in the cases of sequences and output arguments, they point to memory. This memory is always allocated and deallocated by Cryptol; the C code does not need to manage this memory.\n\nFor GMP types, Cryptol will call `init` and `clear` as needed.\n\nIn the case of sequences, the pointer will point to an array. In the case of an output argument for a non-sequence type, the pointer will point to a piece of memory large enough to hold the given C type, and you should not try to access any adjacent memory.\n\nFor input sequence arguments, the array will already be set to the values corresponding to the Cryptol values in the sequence. For output arguments, the memory may be uninitialized when passed to C, and the C code should not read from it. It must write to the memory the value it is returning.\n\n## The abstract calling convention\n\nForeign functions that use the abstract calling convention marshal Cryptol values using an abstract interface. One can opt into the abstract calling convention by writing\n\n```cryptol\nforeign abstract fun : ...\n```\n\nAny abstract foreign function will correspond to a C function with the following type signature:\n\n```c\nvoid fun(const struct CryValExporter *args, const struct CryValImporter *res);\n```\n\nUnlike the C calling convention, where each Cryptol argument or return type directly corresponds to an equivalent C type, the abstract calling convention intentionally leaves these details opaque. Instead, all Cryptol function arguments are marshalled to the foreign environment using an abstract `CryValExporter` object, and the C return value is marshalled to Cryptol using an abstract `CryValImporter` object. All the details of how marshalling works are encapsulated by the methods of these objects, which are managed on the Cryptol side.\n\nAs a specific example, suppose we have the following abstract foreign function:\n\n```cryptol\nforeign abstract fun : Option [8] -> ([64], [8])\n```\n\nWe can write a corresponding function like so:\n\n```c\n#include <assert.h>\n#include <inttypes.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"cry_ffi.h\"\n\nvoid fun(const struct CryValExporter *args, const struct CryValImporter *res) {\n  uint64_t tag;\n  uint8_t v;\n\n  \/\/ Receive the tag indicating which Option constructor was exported.\n  assert(CRY_FFI(args,recv_u64,&tag) == 0);\n\n  \/\/ Depending on which Option constructor was exported, we may need to\n  \/\/ receive an additional piece of data corresponding to the Some\n  \/\/ constructor's field.\n  switch (tag) {\n  case 0: \/\/ None\n    printf(\"received None\\n\");\n    break;\n  case 1: \/\/ Some v\n    assert(CRY_FFI(args,recv_u8,&v) == 0);\n    printf(\"received (Some %u)\\n\",v);\n    break;\n  default: \/\/ This case should be unreachable\n    printf(\"unexpected tag for Option: %\" PRIu64 \"\\n\", tag);\n    abort();\n  }\n\n  \/\/ Now import a return value back into Cryptol. The return type is a pair,\n  \/\/ so we send the first element of the pair followed by the second.\n  CRY_FFI(res,send_small_uint,tag);\n  CRY_FFI(res,send_small_uint,(uint64_t)(v));\n}\n```\n\n(This example uses C as the implementation language, but one could write a similar function in other languages as well.)\n\nNote that the arguments are exported to the foreign environment using the `recv_u64` and `recv_u8` methods of the `args` object, and the return value is imported into Cryptol using the `send_small_uint` method of the `res` object. The author of the foreign code needs to know which methods to call\u2014for instance, they would need to know that importing a pair type requires importing its first element followed by its second. On the other hand, the author of the foreign code does not need to know how the methods work under the hood (hence the name \u201cabstract\u201d).\n\nWhen compared to the C calling convention, the abstract calling convention has the advantage that it does not have to assume a fixed data layout for compound types such as arrays, tuples, or enums. As such, languages that export functions to use with the abstract calling convention do not have to manually convert their in-memory representations of these compound data types into the representations that the C calling convention expects, which can be expensive.\n\nFor more details on how the methods of the `CryValExporter` and `CryValImporter` structs work, refer to the `cry_ffi.h` header file included in your Cryptol installation. This file documents the conventions for how each Cryptol type is marshalled to and from foreign code.\n\nNote that the abstract calling convention still assumes some details of the C ABI. In particular, it assumes that the foreign code\u2019s arguments have the same memory representation as the `CryValExporter` and `CryValImporter` structs have in C.\n\n## Evaluation\n\nAll Cryptol arguments are fully evaluated when a foreign function is called.\n\nThe FFI is intended to be used with pure functions that do not perform side effects such as mutating global state, printing to the screen, interacting with the file system, etc. Cryptol does not enforce this convention, however, so it is possible to use impure functions from the FFI if you wish. Cryptol does not make any guarantees about the order in which side effects will be executed, nor does it make any guarantees about preserving any global state between invocations of impure FFI functions.\n\n## Cryptol implementation of foreign functions\n\nForeign declarations can have an optional Cryptol implementation, which by default will be called when the foreign implementation cannot be found, or when the FFI cannot be used, such as during symbolic evaluation, evaluation with the reference interpreter, or if Cryptol was built with FFI support disabled.\n\n```cryptol\nforeign add : [32] -> [32] -> [32]\nadd x y = x + y\n```\n\nThe `:set evalForeign` REPL option controls which implementation is used; see `:help :set evalForeign` for more details.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/cryptol\/master\/Project.html","filetype":"txt","content":"## Project Files\n\nCryptol supports specifying a project file that can accelerate the repeated loading and testing of a large, interconnected set of source files. Cryptol will remember the hashes of the files previously checked and use this to avoid type-checking and testing files that are unchanged since the previous loading of the project.\n\nTo use this feature, a `cryproject.toml` should be created in the root directory of the Cryptol source files that lists all of the top-level modules of the project. The dependencies of these modules will implicitly be added to the project.\n\nTo check a whole project, Cryptol can be invoked with the `--project` or `-p` flag using the directory containing the project as an argument. This will type-check all of the modules in the project and check the docstrings for all modules in the project.\n\nAll errors are reported to stdout. When all modules load and all tests pass, Cryptol\u2019s exit code will be 0. When the project does not load successfully, the exit code is 1.\n\nFor each module processed, we report a line like this:\n\n```\nSuccesses: X, No fences: Y, Failures: Z\n```\n\nwhere:\n- X is the number of docstring tests which completed successfully,\n- Y is the number of declarations that have no docstring tests,\n- Z is the number of docstring tests which resulted in an error.\n\nNote that these are only reported for modules that are actually checked (i.e., either they were not checked before, or something changed).\n\nAfter all modules are processed, we also report a summary of the form:\n\n```\nPassing: X, Failing: Y, Missing: Z\n```\n\nwhere:\n- X is the number of modules that have no failing tests,\n- Y is the number of modules with at least one failing test,\n- Z is the number of modules for which we did not run tests.\n\nAt present, we do not run tests for built-in modules (e.g., Cryptol or Float), so almost always there will be at least 1 \u201cmissing\u201d module.\n\nAfter loading a project, the cache information is saved into a Cryptol-managed file in the project root directory `.cryproject\/loadcache.toml`.\n\nExample:\n\n```\ncryptol -p myproject\/\n```\n\nTo discard the previous cached results and reload a whole project, use `--refresh-project`. This can be useful when versions of external tools have changed or simply to get confidence that everything is still in a working state.\n\nExample:\n\n```\ncryptol -p myproject\/ --refresh-project\n```\n\n## cryproject.toml Format\n\nProject files are described by a TOML file using the following top-level key-value assignments:\n\n- `root` - optional - string - can optionally be specified to override the directory that Cryptol files are located in. Otherwise, modules are loaded relative to the directory containing the `cryproject.toml`.\n- `modules` - required - list of strings - is a list of filename patterns matching the top-level modules in a project. These modules, and all of their dependencies, will be loaded when the project is loaded. These patterns match using the common `*`, `?`, and character class matching of `fnmatch` extended with `**` matching for multiple directories as found in the Git format for `.gitignore`.\n\nExample directory structure:\n\n```\nproject\n\u251c\u2500\u2500 Id.c\n\u251c\u2500\u2500 Id.cry\n\u251c\u2500\u2500 Id.dylib\n\u251c\u2500\u2500 Main.cry\n\u2514\u2500\u2500 cryproject.toml\n```\n\nExample `cryproject.toml`:\n\n```toml\nmodules = [\n    \"Id.cry\",\n    \"Main.cry\",\n]\n```\n\n## loadcache.toml Format\n\nAfter loading a project, a cache file is generated and stored in `.cryproject\/loadcache.toml`. This file contains a version number to allow caches to automatically invalidate when the project subsystem updates. Modules that fail to load at all are not listed in the cache file and will be reprocessed on subsequent project loads even if unchanged.\n\nKeys include:\n\n- `version` - integer - specifies the cache file format version to allow old caches to be invalidated when Cryptol changes the meaning of this file.\n- `file` - string - specifies the absolute path to a Cryptol module for those stored in files.\n- `memory` - string - specifies the module name of a primitive module built into Cryptol.\n- `fingerprint` - string - specifies a SHA2-256 hash of the source file which is used to detect when the source file has changed from the previous run.\n- `foreign_fingerprints` - list of string - a list of SHA2-256 hashes of dynamic libraries that this Cryptol file directly loads.\n- `include_fingerprints` - list of string - a list of SHA2-256 hashes of pre-processor included files that this Cryptol file directly includes.\n- `docstring_result` - boolean - true when `:check-docstrings` previously succeeded for this module and false when it previously failed. It will be missing if tests were never run on this module.\n\nExample:\n\n```toml\nversion = 1\n\n[[modules]]\nfingerprint = \"2f671b21f2933a006b6a843c7f281388e6b8227f9944b111f87711dc9ca8448f\"\nforeign_fingerprints = []\ninclude_fingerprints = []\nmemory = \"Cryptol\"\n\n[[modules]]\ndocstring_result = true\nfile = \"\/path\/to\/project\/Id.cry\"\nfingerprint = \"a9e6f7a4b65ead6bd8e27442717d6b0dc54afc73e34b18c32f005ceb7a8f3c34\"\nforeign_fingerprints = [ \"c7767a13281a56631c72b9b6f69a17746dc02213e7f2b24a8a4a6fe7afd9ee0a\" ]\ninclude_fingerprints = []\n\n[[modules]]\ndocstring_result = true\nfile = \"\/path\/to\/project\/Main.cry\"\nfingerprint = \"6b36f965ebb1a68cf76d689a966806ec879540aa6576a76c1aaa7705a4af09d5\"\nforeign_fingerprints = []\ninclude_fingerprints = []\n```","variant":null,"set":"holdout"}
{"filename":"https:\/\/galoisinc.github.io\/cryptol\/master\/REPLCommands.html","filetype":"txt","content":"## REPL Commands\n\n## Commands\n\n:! COMMAND  \nExecute a command in the shell  \n\n:? TOPIC, :help TOPIC  \nDisplay a brief description of a function, type, or command. (e.g. :help :help)  \n\nTOPIC can be any of:  \n- Specific REPL colon-commands (e.g. :help :prove)  \n- Functions (e.g. :help join)  \n- Infix operators (e.g. :help +)  \n- Type constructors (e.g. :help Z)  \n- Type constraints (e.g. :help fin)  \n- :set-able options (e.g. :help :set base)  \n\n:ast EXPR  \nPrint out the pre-typechecked AST of a given term.  \n\n:b MODULE, :browse MODULE  \nDisplay information about loaded modules.  \nWith no argument, :browse shows information about the names in scope. With an argument M, shows information about the names exported from M.  \n\n:cd DIR  \nSet the current working directory.  \n\n:check [EXPR]  \nUse random testing to check that the argument always returns true. (If no argument, check all properties.)  \nBy default, this will check up to 100 test cases, or until the possible inputs are exhausted. This value can be changed with :set tests=[NEW VAL].  \n\n:debug_specialize EXPR  \nDo type specialization on a closed expression.  \n\n:dumptests FILE EXPR  \nDump a tab-separated collection of tests for the given expression into a file. The first column in each line is the expected output, and the remainder are the inputs. The number of tests is determined by the tests option.  \n\n:e FILE, :edit FILE  \nEdit FILE or the currently loaded module.  \n\n:eval EXPR  \nEvaluate an expression with the reference evaluator.  \n\n:exhaust [EXPR]  \nUse exhaustive testing to prove that the argument always returns true. (If no argument, check all properties.)  \n\n:extract-coq  \nPrint out the post-typechecked AST of all currently defined terms, in a Coq-parseable format.  \n\n:file-deps FILE  \nShow information about the dependencies of a file.  \n\n:generate-foreign-header FILE  \nGenerate a C header file from foreign declarations in a Cryptol file.  \nConverts all foreign declarations in the given Cryptol file into C function declarations, and writes them to a file with the same name but with a .h extension.  \n\n:l FILE, :load FILE  \nLoad a module by filename.  \n\n:m [MODULE], :module [MODULE]  \nLoad a module by its name.  \n\n:module-deps MODULE  \nShow information about the dependencies of a module.  \n\n:new-seed  \nRandomly generate and set a new seed for the random number generator.  \n\n:prove [EXPR]  \nUse an external solver to prove that the argument always returns true. (If no argument, check all properties.)  \nIf the expression is successfully proven, the screen will display Q.E.D. If not, the screen will display a counterexample that returns false.  \n\n:q, :quit  \nExit the REPL.  \n\n:r, :reload  \nReload the currently loaded module.  \n\n:readByteArray FILE  \nRead data from a file as type fin n => [n][8], binding the value to variable it.  \n\n:s [OPTION=[VALUE]], :set [OPTION=[VALUE]]  \nSet an environmental option (:set on its own displays current values).  \n\n:safe [EXPR]  \nUses an external solver to prove that an expression is safe (does not encounter run-time errors) for all inputs.  \n\n:sat [EXPR]  \nUses a solver to find a satisfying assignment for which the argument returns true. (If no argument, find an assignment for all properties.)  \nBy default, this will return one assignment, but that can be updated with :set satNum=VAL  \n\n:set-seed SEED  \nSeed the random number generator for operations using randomness.  \nA seed takes the form of either a single integer or a 4-tuple of unsigned 64-bit integers. Examples of commands using randomness are :dumpTests and :check.  \n\n:t EXPR, :type EXPR  \nCheck the type of an expression.  \n\n:time EXPR  \nMeasure the time it takes to evaluate the given expression.  \nThe expression will be evaluated many times to get accurate results. Note that the first evaluation of a binding may take longer due to laziness, and this may affect the reported time. If this is not desired then make sure to evaluate the expression once first before running :time.  \nThe amount of time to spend collecting measurements can be changed with the timeMeasurementPeriod option.  \nReports the average wall clock time, CPU time, and cycles. (Cycles are in unspecified units that may be CPU cycles.)  \nBinds the result to  \n```\nit : { avgTime : Float64\n     , avgCpuTime : Float64\n     , avgCycles : Integer }\n```\n\n:version  \nDisplays the version of the Cryptol executable.  \n\n:w FILE EXPR, :writeByteArray FILE EXPR  \nWrite data of type fin n => [n][8] to a file.  \n\n## :set Options\n\n:set base  \nDefault value: 16  \nValid values: 2, 8, 10, 16  \nThe base to display words at  \n\n:set debug  \nDefault value: off  \nValid values: off, on, false, true  \nEnable debugging output  \n\n:set ascii  \nDefault value: off  \nValid values: off, on, false, true  \nWhether to display 7- or 8-bit words using ASCII notation  \n\n:set infLength  \nDefault value: 5  \nValid values: any positive integer  \nThe number of elements to display for infinite sequences  \n\n:set tests  \nDefault value: 100  \nValid values: any positive integer  \nThe number of random tests to try with :check  \n\n:set satNum  \nDefault value: 1  \nValid values: any positive integer, all  \nThe maximum number of :sat solutions to display (\u201call\u201d for no limits)  \n\n:set prover  \nDefault value: z3  \nValid values: cvc4, cvc5, yices, z3, boolector, mathsat, abc, bitwuzla, offline, any, sbv-cvc4, sbv-cvc5, sbv-yices, sbv-z3, sbv-boolector, sbv-mathsat, sbv-abc, sbv-bitwuzla, sbv-offline, sbv-any, w4-cvc4, w4-cvc5, w4-yices, w4-z3, w4-boolector, w4-abc, w4-bitwuzla, w4-offline, w4-any  \nThe external SMT solver for :prove and :sat  \n\n:set warnDefaulting  \nDefault value: off  \nValid values: off, on, false, true  \nChoose whether to display warnings when defaulting  \n\n:set warnShadowing  \nDefault value: on  \nValid values: off, on, false, true  \nChoose whether to display warnings when shadowing symbols  \n\n:set warnPrefixAssoc  \nDefault value: on  \nValid values: off, on, false, true  \nChoose whether to display warnings when expression association has changed due to new prefix operator fixities  \n\n:set warnUninterp  \nDefault value: on  \nValid values: off, on, false, true  \nChoose whether to issue a warning when uninterpreted functions are used to implement primitives in the symbolic simulator  \n\n:set warnNonExhaustiveConstraintGuards  \nDefault value: on  \nValid values: off, on, false, true  \nChoose whether to issue a warning when a use of constraint guards is not determined to be exhaustive  \n\n:set smtFile  \nDefault value: -  \nValid values: Any file path, -  \nThe file to use for SMT-Lib scripts (for debugging or offline proving). Use - for stdout  \n\n:set path  \nDefault value:  \nValid values: Any file path, empty  \nThe search path for finding named Cryptol modules  \n\n:set monoBinds  \nDefault value: on  \nValid values: off, on, false, true  \nWhether or not to generalize bindings in a where clause  \n\n:set tcSolver  \nDefault value: z3 -smt2 -in  \nValid values: a valid executable  \nThe solver that will be used by the type checker  \n\n:set tcDebug  \nDefault value: 0  \nValid values: 0, any positive integer  \nEnable type-checker debugging output:  \n0 no debug output  \n1 show type-checker debug info  \n>1 show type-checker debug info and interactions with SMT solver  \n\n:set coreLint  \nDefault value: off  \nValid values: off, on, false, true  \nEnable sanity checking of type-checker  \n\n:set hashConsing  \nDefault value: on  \nValid values: off, on, false, true  \nEnable hash-consing in the What4 symbolic backends  \n\n:set proverStats  \nDefault value: on  \nValid values: off, on, false, true  \nEnable prover timing statistics  \n\n:set proverValidate  \nDefault value: off  \nValid values: off, on, false, true  \nValidate :sat examples and :prove counter-examples for correctness  \n\n:set showExamples  \nDefault value: on  \nValid values: off, on, false, true  \nPrint the (counter) examples after :sat or :prove  \n\n:set fpBase  \nDefault value: 16  \nValid values: 2, 8, 10, 16  \nThe base to display floating point numbers at  \n\n:set fpFormat  \nDefault value: free  \nValid values: free, free+exp, .NUM, NUM, NUM+exp  \nSpecifies the format to use when displaying floating point numbers:  \n- free show using as many digits as needed  \n- free+exp like free but always show exponent  \n- .NUM show NUM (\u22651) digits after floating point  \n- NUM show using NUM (\u22651) significant digits  \n- NUM+exp like NUM but always show exponent  \n\n:set ignoreSafety  \nDefault value: off  \nValid values: off, on, false, true  \nIgnore safety predicates when performing :sat or :prove checks  \n\n:set fieldOrder  \nDefault value: display  \nValid values: display, canonical  \nThe order that record fields are displayed in:  \n- display try to match the order they were written in the source code  \n- canonical use a predictable, canonical order  \n\n:set timeMeasurementPeriod  \nDefault value: 10  \nValid values: any positive integer  \nThe period of time in seconds to spend collecting measurements when running :time.  \nThis is a lower bound and the actual time taken may be higher if the evaluation takes a long time.  \n\n:set timeQuiet  \nDefault value: off  \nValid values: off, on, false, true  \nSuppress output of :time command and only bind result to it","variant":null,"set":"supervised"}
{"filename":"https:\/\/weaversa.github.io\/cryptol-course\/labs\/Overview\/Overview.html","filetype":"txt","content":"## Cryptol in the Wild\n\nCryptol has been used in the development and evaluation of high assurance cryptographic systems that enjoy wide use. Notable examples where Cryptol has been successfully applied by industry leaders to add assurance to cryptographic implementations include Amazon s2n and Microsoft\u2019s ElectionGuard.\n\nFurther examples are distributed with the Cryptol software source or are available for review on other projects hosted on the Galois Github Page.\n\n## Amazon s2n Continuous Integration\n\nAmazon s2n is \u201ca C99 implementation of the TLS\/SSL protocols that is designed to be simple, small, fast, and with security as a priority.\u201d TLS\/SSL is a suite of cryptographic protocols and algorithms used to provide integrity, confidentiality, and other familiar security services. Amazon s2n is an implementation of this suite used to protect communications on Amazon\u2019s cloud infrastructure platforms such as Amazon Web Services (AWS) and Amazon Simple Storage Service (S3).\n\nThese security property tests are performed as part of a continuous integration pipeline using the Travis Continuous Integration Service. Whenever changes are made \u2013 no matter how small \u2013 to the C implementations, Cryptol and SAW evaluations are automatically run to ensure that no security properties of the system have been disrupted by the proposed updates.\n\nA thorough description of the research, design decisions, and application of Cryptol to evaluating cryptographic implementations in Amazon\u2019s s2n system can be found in the paper *Continuous Formal Verification of Amazon s2n*. This paper was selected by NSA\u2019s Science of Security group for honorable mention in the 7th Annual Best Scientific Cybersecurity Paper Competition.\n\nYou can review the code for yourself on Amazon\u2019s s2n Github Repository. The code relevant to the specification and evaluation of the HMAC routines can be found in the `tests\/saw\/` directory.\n\nFurther exposition on the development of these integration tests can be found in a three-part series on the Galois Inc. Blog:\n\n- Part 1 - Verifying s2n HMAC with SAW  \n- Part 2 - Specifying HMAC in Cryptol  \n- Part 3 - Proving Program Equivalence with SAW  \n\n## Verifying Cryptographic Implementations: The xxhash Algorithm\n\nThe tools that Cryptol provides access to allow users to bring together cryptographic implementations from other languages like Java or C and prove that they are equivalent to \u201cgold standard\u201d specifications one can create in Cryptol. This allows users to iteratively optimize code in performance-centric or system languages while maintaining a single trusted specification in Cryptol.\n\nTake a look through the saw-demos repository by GaloisInc hosted on GitHub which highlights several of these applications. We will do a brief survey of the xxhash example which you can find in the `demos\/xxhash` directory of this repository. This is a demo of using Cryptol algorithm specifications (along with SAW).\n\nThis directory contains the following files:\n\n```\n.\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 output\n\u251c\u2500\u2500 xxhash32-ref.c\n\u251c\u2500\u2500 xxhash32-ref.saw\n\u251c\u2500\u2500 xxhash64-ref.c\n\u251c\u2500\u2500 xxhash64-ref.saw\n\u2514\u2500\u2500 xxhash.cry\n```\n\n`xxhash.cry` contains Cryptol specifications for 32- and 64-bit variants of the xxhash algorithm along with related subroutines. The 32-bit variant has the following definition:\n\n```cryptol\nXXH32 : {L} (fin L) => [L][8] -> [32] -> [32]\nXXH32 input seed = XXH32_avalanche acc1\n  where (stripes16 # stripes4 # stripes1) = input\n        accR = foldl XXH32_rounds (XXH32_init seed) (split stripes16 : [L\/16][16][8])\n        accL = `(L % 2^^32) + if (`L:Integer) < 16\n                              then seed + PRIME32_5\n                              else XXH32_converge accR\n        acc4 = foldl XXH32_digest4 accL (split stripes4 : [(L%16)\/4][4][8])\n        acc1 = foldl XXH32_digest1 acc4 (stripes1 : [L%4][8])\n```\n\nThis function depends on other components defined in this file, such as `XXH32_avalanche`, `XXH32_rounds`, and `XXH32_init` which you can take a look at as well. At a glance, we see that this function has the type signature `{L} (fin L) => [L][8] -> [32] -> [32]` which indicates that this function takes a finite sequence of bytes and a 32-bit seed, and produces a 32-bit result (the hash).\n\n`xxhash32-ref.c` and `xxhash64-ref.c` contain C implementations of the xxhash algorithm which might commonly be seen in a real-world system implementation where performance was critical. Here is a snippet containing the C implementation of the hash function called `XXH32`:\n\n```c\n\/* The XXH32 hash function.\n * input:   The data to hash.\n * length:  The length of input. It is undefined behavior to have length larger than the\n *          capacity of input.\n * seed:    A 32-bit value to seed the hash with.\n * returns: The 32-bit calculated hash value. *\/\nuint32_t XXH32(void const *const input, size_t const length, uint32_t const seed)\n{\n    uint8_t const *const data = (uint8_t const *) input;\n    uint32_t hash;\n    size_t remaining = length;\n    size_t offset = 0;\n\n    \/* Don't dereference a null pointer. The reference implementation notably doesn't\n     * check for this by default. *\/\n    if (input == NULL) {\n        return XXH32_avalanche(seed + PRIME32_5);\n    }\n\n    if (remaining >= 16) {\n        \/* Initialize our accumulators *\/\n        uint32_t acc1 = seed + PRIME32_1 + PRIME32_2;\n        uint32_t acc2 = seed + PRIME32_2;\n        uint32_t acc3 = seed + 0;\n        uint32_t acc4 = seed - PRIME32_1;\n\n        while (remaining >= 16) {\n            acc1 = XXH32_round(acc1, XXH_read32(data, offset)); offset += 4;\n            acc2 = XXH32_round(acc2, XXH_read32(data, offset)); offset += 4;\n            acc3 = XXH32_round(acc3, XXH_read32(data, offset)); offset += 4;\n            acc4 = XXH32_round(acc4, XXH_read32(data, offset)); offset += 4;\n            remaining -= 16;\n        }\n\n        hash = XXH_rotl32(acc1, 1) + XXH_rotl32(acc2, 7) + XXH_rotl32(acc3, 12) + XXH_rotl32(acc4, 18);\n    } else {\n        \/* Not enough data for the main loop, put something in there instead. *\/\n        hash = seed + PRIME32_5;\n    }\n\n    hash += (uint32_t) length;\n\n    \/* Process the remaining data. *\/\n    while (remaining >= 4) {\n        hash += XXH_read32(data, offset) * PRIME32_3;\n        hash  = XXH_rotl32(hash, 17);\n        hash *= PRIME32_4;\n        offset += 4;\n        remaining -= 4;\n    }\n\n    while (remaining != 0) {\n        hash += (uint32_t) data[offset] * PRIME32_5;\n        hash  = XXH_rotl32(hash, 11);\n        hash *= PRIME32_1;\n        --remaining;\n        ++offset;\n    }\n    return XXH32_avalanche(hash);\n}\n```\n\nFinally, the files `xxhash32-ref.saw` and `xxhash64-ref.saw` contain SAW scripts which drive the verification that this C code is equivalent to the specification found in this Cryptol specification of xxhash.\n\nThe xxHash proofs are included in the Cryptol course materials. Changing to the cryptol-course\/labs\/Demos\/SAW\/xxHash directory and running `make` will initiate the verification for both the 32- and 64-bit implementations, producing the following output:\n\n```\n[cryptol-course\/labs\/Demos\/SAW\/xxHash]$ make\nclang xxhash32-ref.c -o xxhash32-ref.bc -c -emit-llvm -O0 -std=c90\nclang xxhash64-ref.c -o xxhash64-ref.bc -c -emit-llvm -O0 -std=c90\nsaw xxhash32-ref.saw\n[17:48:43.283] Loading file \"cryptol-course\/labs\/Demos\/SAW\/xxHash\/xxhash32-ref.saw\"\n[17:48:43.285] Loading file \"cryptol-course\/labs\/Demos\/SAW\/xxHash\/llvm.saw\"\n[17:48:43.613] Verifying XXH_rotl32 ...\n[17:48:43.615] Simulating XXH_rotl32 ...\n[17:48:43.617] Checking proof obligations XXH_rotl32 ...\n[17:48:43.778] Proof succeeded! XXH_rotl32\n\n... output omitted ...\n\n[17:48:54.220] Checking proof obligations XXH64 ...\n[17:48:54.311] Proof succeeded! XXH64\n```\n\nThese scripts will check that the C implementations match the Cryptol specification for every possible input for the hash lengths specified. This is important to highlight because this is far beyond the capability of unit testing to detect errors. For instance, for inputs of length 128 bits, there are 2^160 input\/seed combinations to check. Unit tests \u2013 even random unit tests \u2013 may only typically cover a few hundred or thousand cases. Cryptol and SAW are able to provide confidence on a space many orders of magnitude larger.\n\n## Verifying Properties about Algorithms\n\nCryptol provides an easy interface for using powerful tools such as SMT solvers for verifying properties about algorithms we care about. Throughout this course, we will introduce examples and explain how to take advantage of these tools in your own designs and evaluations. Here is an example packaged with the Cryptol source that demonstrates a simple but important property about an encryption algorithm which only uses the XOR operation:\n\n```cryptol\nencrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\nencrypt key plaintext = [ pt ^ key | pt <- plaintext ]\n\ndecrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\ndecrypt key ciphertext = [ ct ^ key | ct <- ciphertext ]\n\nproperty roundtrip key plaintext = decrypt key (encrypt key plaintext) == plaintext\n```\n\nThis file defines an `encrypt` operation, a `decrypt` operation, and a property called `roundtrip` which checks for all keys `key` and all input plaintexts `plaintext` that `decrypt key (encrypt key plaintext) == plaintext` (i.e. that these operations are the inverse of each other).\n\nWe can see the effect of encrypting the particular input `\"attack at dawn\"` with the key `0xff`:\n\n```\nlabs::Overview::Overview> :s ascii=on\nlabs::Overview::Overview> encrypt 0xff \"attack at dawn\"\n\"\\158\\139\\139\\158\\156\\148\\223\\158\\139\\223\\155\\158\\136\\145\"\nlabs::Overview::Overview> decrypt 0xff it\n\"attack at dawn\"\n```\n\nCryptol interprets the string `\"attack at dawn\"` as a sequence of bytes suitable for the encrypt operations. (We will introduce Cryptol types later in this lab and discuss them in detail throughout this course.)\n\nWe can prove the `roundtrip` property holds in the interpreter using the `:prove` command and the currently configured SMT solver (Z3 by default):\n\n```\nlabs::Overview::Overview> :prove roundtrip : [8] -> [16][8] -> Bit\nQ.E.D.\n(Total Elapsed Time: 0.010s, using \"Z3\")\n```\n\nCryptol reports Q.E.D., indicating that our property is indeed true for all keys and all 16-character inputs. Cryptol currently only supports proofs of total monomorphic properties with a finite domain. Here we must specify the length of the messages that we want to check this property for. This example checks the property for 16 character messages, but we could check this for any (reasonable) length.\n\n## Language Features\n\nSo what makes Cryptol special compared to other languages?\n\nCryptol is a language designed with Cryptography specifically in mind \u2013 much of the syntax and language was designed to align with the way that real cryptographers think about and design systems. This allows the Cryptol user to create formal algorithm specifications that closely imitate the style used to describe these algorithms mathematically.\n\nFurthermore, Cryptol provides direct access to and easily integrates with powerful tools such as SMT solvers and the Software Analysis Workbench (SAW). These tools allow the user to prove facts and demonstrate properties about their code which can provide assurance guarantees that go far beyond simple unit testing.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/weaversa.github.io\/cryptol-course\/labs\/Interpreter\/Interpreter.html","filetype":"txt","content":"## A Cryptol module\n\nA Cryptol module is a named codeblock within a file. The module name is used when importing code into a larger Cryptol project, or for interactively incorporating the code in the interpreter via the `:module` command. A file can only contain one module, and the name of the module must match the filename. Additionally, the module can have namespace characteristics, separated by `::` delimiters. The namespace values directly correlate with directory structure surrounding the file.\n\nIn this file, we start by defining a new module for this lab:\n\n```cryptol\nmodule labs::Interpreter::Interpreter where\n```\n\nThat indicates that this file `Interpreter.md` will be found in the directory `labs\/Interpreter`.\n\n(Note: you do not need to enter the module instruction into the interpreter; the previous `:m ...` command loaded this literate Cryptol file automatically. In general, you should run Xcryptol-session commands in the interpreter and leave Cryptol code alone to be parsed by `:m ...`.)\n\n## Using the Cryptol interpreter\n\n### Interpreter State\n\nThe interpreter has a number of configuration settings. To view them type `:set`.\n\n```\nlabs::Interpreter::Interpreter> :set\nascii = off\nbase = 16\ncore-lint = off\ndebug = off\nfp-base = 16\nfp-format = free\nhash-consing = on\nignore-safety = off\ninfLength = 5\nmono-binds = on\npath = ...\nprover = z3\nprover-stats = on\nprover-validate = off\nsatNum = 1\nshow-examples = on\nsmtfile = -\ntc-debug = 0\ntc-solver = z3 -smt2 -in\ntests = 100\nwarnDefaulting = off\nwarnShadowing = on\nwarnUninterp = on\n```\n\nThe most common setting to change is `base`. The default is `base = 16`, which means the interpreter will display bitvectors by printing their hexadecimal representations. For example,\n\n```\nlabs::Interpreter::Interpreter> 0xa\n0xa\nlabs::Interpreter::Interpreter> 10 : [4]\n0xa\n```\n\nTo make the interpreter display bitvectors in decimal (base 10), type `:set base=10`. To change back to hexadecimal, type `:set base=16`.\n\n```\nlabs::Interpreter::Interpreter> :set base=10\nlabs::Interpreter::Interpreter> 0xa\n10\nlabs::Interpreter::Interpreter> 10 : [4]\n10\nlabs::Interpreter::Interpreter> :set base=16\nlabs::Interpreter::Interpreter> 10 : [4]\n0xa\n```\n\nFeel free to change this setting to what is most comfortable for you.\n\nYou\u2019ll notice there are many different things to configure. Most of these are set to an appropriate default, but there are a few we will touch on later.\n\n### Interpreter Help\n\nCryptol\u2019s interpreter has a built-in help command. To invoke it, type `:h` followed by the command you\u2019d like to know more about. For example, to learn about the `:set base` command, type:\n\n```\nlabs::Interpreter::Interpreter> :h :set base\n\n    base = 16\n\nDefault value: 16\n\nThe base to display words at (2, 8, 10, or 16).\n```\n\nCryptol has a built-in command to reverse a list, called `reverse`. Let\u2019s look at the help for this command.\n\n```\nlabs::Interpreter::Interpreter> :h reverse\n\n    reverse : {n, a} (fin n) => [n]a -> [n]a\n\nReverses the elements in a sequence.\n```\n\n### Colon commands\n\nCommands starting with a colon (`:`) are commands outside of the Cryptol language and only exist in the interpreter. You can see a full list of these commands by typing `:h`.\n\n```\nlabs::Interpreter::Interpreter> :h\n  :t, :type                 Check the type of an expression.\n  :b, :browse               Display information about loaded modules.\n  :version                  Display the version of this Cryptol executable\n  :?, :help                 Display a brief description of a function, type, or command. (e.g. :help :help)\n  :s, :set                  Set an environmental option (:set on its own displays current values).\n  :check                    Use random testing to check that the argument always returns true.\n                            (If no argument, check all properties.)\n  :exhaust                  Use exhaustive testing to prove that the argument always returns\n                            true. (If no argument, check all properties.)\n  :prove                    Use an external solver to prove that the argument always returns\n                            true. (If no argument, check all properties.)\n  :sat                      Use a solver to find a satisfying assignment for which the argument\n                            returns true. (If no argument, find an assignment for all properties.)\n  :safe                     Use an external solver to prove that an expression is safe\n                            (does not encounter run-time errors) for all inputs.\n  :debug_specialize         Do type specialization on a closed expression.\n  :eval                     Evaluate an expression with the reference evaluator.\n  :ast                      Print out the pre-typechecked AST of a given term.\n  :extract-coq              Print out the post-typechecked AST of all currently defined terms,\n                            in a Coq-parseable format.\n  :time                     Measure the time it takes to evaluate the given expression.\n  :set-seed                 Seed the random number generator for operations using randomness\n  :new-seed                 Randomly generate and set a new seed for the random number generator\n  :check-docstrings         Run the REPL code blocks in the module's docstring comments\n  :q, :quit                 Exit the REPL.\n  :l, :load                 Load a module by filename.\n  :r, :reload               Reload the currently loaded module.\n  :e, :edit                 Edit FILE or the currently loaded module.\n  :!                        Execute a command in the shell.\n  :cd                       Set the current working directory.\n  :m, :module               Load a module by its name.\n  :f, :focus                Focus name scope inside a loaded module.\n  :w, :writeByteArray       Write data of type 'fin n => [n][8]' to a file.\n  :readByteArray            Read data from a file as type 'fin n => [n][8]', binding\n                            the value to variable 'it'.\n  :dumptests                Dump a tab-separated collection of tests for the given\n                            expression into a file. The first column in each line is\n                            the expected output, and the remainder are the inputs. The\n                            number of tests is determined by the \"tests\" option.\n                            Use filename \"-\" to write tests to stdout.\n  :generate-foreign-header  Generate a C header file from foreign declarations in a Cryptol file.\n  :file-deps                Show information about the dependencies of a file\n  :module-deps              Show information about the dependencies of a module\n```\n\nThe most used commands have to do with files (loading with `:m` and reloading with `:r`), quitting the interpreter (`:q`), and asking for the type of an expression (`:t`). Many commands have single-character shortcuts for convenience.\n\n## Browsing the Environment\n\nThe `:browse` command lists all type synonyms, constraint synonyms, primitive types, and symbols currently loaded into the interpreter. Upon startup, the interpreter preloads a prelude containing the Cryptol language. This prelude can be modified, but doing so may make your Cryptol specifications incompatible with other code, so modifying the prelude is discouraged.\n\n### About `:browse`\n\nIf you enter `:b` into the interpreter you will first see:\n\n```\nlabs::Interpreter::Interpreter> :b\nType Synonyms\n=============\n\n  From Cryptol\n  ------------\n\n    type Bool = Bit\n    type Char = [8]\n    type lg2 n = width (max 1 n - 1)\n    type String n = [n]Char\n    type Word n = [n]\n\n  From labs::Interpreter::Interpreter\n  -----------------------------------\n       \n    type uint32_t = [32]\n```\n\nType synonyms are helper functions to express the type of some data. For example, the number 10 can be expressed as a 32-bit word via:\n\n```\nlabs::Interpreter::Interpreter> 10 : Word 32\n0x0000000a\n```\n\nNext, constraint synonyms help express type constraints and unify different comparison operators under `>=`.\n\nPrimitive types include comparison and arithmetic operators, type classes, basic types, and type constraints useful for cryptographic typing. For example, the size of a bitvector can be represented in terms of the width of a number:\n\n```\nlabs::Interpreter::Interpreter> :t 10 : [width 32]\n(10 : [width 32]) : [6]\n```\n\nCryptol\u2019s symbols appear in the last section provided by `:browse`. These are value operators used when defining functions or variables. For example, `reverse` can be used to reverse the order of a sequence of bitvectors:\n\n```\nlabs::Interpreter::Interpreter> reverse [1, 2, 3] : [3][2]\n[0x3, 0x2, 0x1]\n```\n\nEach of these items in the environment can be queried using `:help` (or `:h`).\n\n## Tab Completion and Scrolling\n\nThe interpreter supports TAB completion; pressing TAB will display all available symbols. If you start typing a symbol and then press TAB, the interpreter will attempt to complete it.\n\nThe interpreter also records a history of commands issued, stored in `.cryptol_commandHistory` in your user directory. Pressing the up and down arrows scrolls through this history.\n\n## Chaining Commands \u2014 it and let\n\nThe Cryptol interpreter supports chaining commands. The special symbol `it` is bound to the result of the last evaluated command. For example,\n\n```\nlabs::Interpreter::Interpreter> :s base=10\nlabs::Interpreter::Interpreter> reverse [1, 2, 3] : [3][2]\n[3, 2, 1]\nlabs::Interpreter::Interpreter> reverse it\n[1, 2, 3]\n```\n\nNow `it` holds `[1, 2, 3]`. To bind a value to a name for later use, use the `let` command:\n\n```\nlabs::Interpreter::Interpreter> let r = reverse [1, 2, 3] : [3][2]\nlabs::Interpreter::Interpreter> r\n[3, 2, 1]\nlabs::Interpreter::Interpreter> reverse r\n[1, 2, 3]\nlabs::Interpreter::Interpreter> r\n[3, 2, 1]\n```\n\n`let` is useful for debugging and understanding programs but can cause confusion and inconsistent bindings if definitions are overwritten. Thus, industrial use of `let` is discouraged. For example,\n\n```\nlabs::Interpreter::Interpreter> let x = 0\nlabs::Interpreter::Interpreter> let y = x + 1\nlabs::Interpreter::Interpreter> let x = 1\n```\n\nAfter running this, the value of `y` depends on the interpreter state.\n\n## Loading and Reloading Files\n\nThis lab can be loaded directly into the interpreter using `:module` or `:load`. `:module` takes a module name, and `:load` takes a filename.\n\n```\nlabs::Interpreter::Interpreter> :l labs\/Interpreter\/Interpreter.md\nLoading module Cryptol\nLoading module labs::Interpreter::Interpreter\nlabs::Interpreter::Interpreter>\n```\n\nHere we see that the file contains a module named `labs::Interpreter::Interpreter`, which corresponds to the filename and directory path.\n\nWe can browse the currently loaded module to see its symbols. The interpreter supports TAB completion, so typing `:b l` and pressing TAB will fill in the rest.\n\n```\nlabs::Interpreter::Interpreter> :b labs::Interpreter::Interpreter\nType Synonyms\n=============\n\n  type uint32_t = [32]\n\nSymbols\n=======\n\n  f : uint32_t -> uint32_t\n  x : uint32_t\n  y : uint32_t\n```\n\nIf the result does not match, try reloading the module.\n\n## Loading Modules\n\nTo load a module by its name (instead of filename), use the `:module` (or `:m`) command. Namespace elements of a module name correspond to directory structure; for example, `labs::Interpreter::Interpreter` maps to `labs\/Interpreter\/Interpreter.md`.\n\nTo find the module:\n\n1. Start the Cryptol interpreter at the base directory of the module, or\n2. Include the base directory of the module in the `CRYPTOLPATH` environment variable.\n\nThe `CRYPTOLPATH` approach is more robust and works regardless of the current directory.\n\nTo set `CRYPTOLPATH` in Linux:\n\n```\n$ export CRYPTOLPATH=<path-to-cryptol-course>\n$ cryptol\n\u250f\u2501\u2578\u250f\u2501\u2513\u257b \u257b\u250f\u2501\u2513\u257a\u2533\u2578\u250f\u2501\u2513\u257b\n\u2503  \u2523\u2533\u251b\u2517\u2533\u251b\u2523\u2501\u251b \u2503 \u2503 \u2503\u2503\n\u2517\u2501\u2578\u2579\u2517\u2578 \u2579 \u2579   \u2579 \u2517\u2501\u251b\u2517\u2501\u2578\nversion 3.2.0.99\nhttps:\/\/cryptol.net  :? for help\nLoading module Cryptol\nCryptol> :m labs::Interpreter::Interpreter\nLoading module Cryptol\nLoading module labs::Interpreter::Interpreter\nlabs::Interpreter::Interpreter>\n```\n\n## Editing\n\nThe Cryptol interpreter supports editing the currently loaded file or module via `:e`. If no file or module is loaded, `:e` will open the Cryptol prelude file, which is risky.\n\nTyping `:e` opens the current file or module in a text editor, then reloads the file into the interpreter upon closing the editor. The default editor is `vim` but can be changed by setting the `EDITOR` environment variable. For example, to use Emacs in a Linux environment:\n\n```\n$ export EDITOR=\"emacs -nw\"\n```\n\n## Batch Commands\n\nInterpreter commands can be issued directly from the command line or from a batch file. For example, running commands from the command line using `-c`:\n\n```\n$ cryptol -c \":m labs::Interpreter::Interpreter\" -c \":s base=10\" -c \"x + 2\"\nLoading module Cryptol\nLoading module labs::Interpreter::Interpreter\n3\n```\n\nRunning commands from a batch file `labs\/Interpreter\/test.sry` with `-b`:\n\n```\n$ cat labs\/Interpreter\/test.sry\n:m labs::Interpreter::Interpreter\n:s base=10\nx + 2\n$ cryptol -b labs\/Interpreter\/test.sry\nLoading module Cryptol\nLoading module labs::Interpreter::Interpreter\n3\n```\n\n## Usage options\n\nMany usage options can be found with:\n\n```\n$ cryptol --help\nUsage: cryptol [OPTIONS]\n  -b FILE     --batch=FILE             run the script provided and exit\n  -e          --stop-on-error          stop script execution as soon as an error occurs.\n  -c COMMAND  --command=COMMAND        run the given command and then exit; if multiple --command arguments are given, run them in order\n              --color=MODE             control color output ('auto', 'none' or 'always', default: 'auto')\n  -v          --version                display version number\n  -h          --help                   display this message\n              --no-unicode-logo        don't use unicode characters in the REPL logo\n              --ignore-cryptolrc       disable reading of .cryptolrc files\n              --cryptolrc-script=FILE  read additional .cryptolrc files\n              --cryptolpath-only       only look for .cry files in CRYPTOLPATH; don't use built-in locations\n\nInfluential environment variables:\n    CRYPTOLPATH\n        A `:`-separated list of directories to be searched for Cryptol\n        modules in addition to the default locations\n    SBV_{ABC,BOOLECTOR,CVC4,MATHSAT,YICES,Z3}_OPTIONS\n        Command-line arguments to be passed to the solver invoked for `:sat` and `:prove`\n```","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/weaversa.github.io\/cryptol-course\/labs\/Language\/Basics.html","filetype":"txt","content":"## Basic Use of the Cryptol Language\n\nIf you\u2019ve programmed in a variety of languages (not just different procedural languages descending from C), you\u2019ll find that, for the most part, Cryptol is just another language with a different vocabulary and a funky type system. After a little study you\u2019ll be able to do most anything computationally that you could otherwise, especially in the cryptographic realm. But once you are accustomed to Cryptol you will find that it is much easier to write correct cryptographic programs than with conventional languages. That\u2019s \u2018cause it\u2019s been tuned for such!\n\nCryptol is a domain-specific language. Not only does it have features to support its application domain, but also it elides a lot of junk that makes programming and analyzing the programs difficult.\n\nCryptol has been designed with automated reasoning about code as a priority, so that we can leverage it for verification. Some things are harder to do in Cryptol, but they pay off in code that can be proven correct!\n\nIn some ways this requires a new mind-set:\n\n- Write properties about your functions,\n- :check them, and\n- try to :prove (or :exhaust) them.\n\nEnjoy getting addicted to this level of assurance!\n\n## Preliminaries\n\nMany of the concepts in this lab were briefly introduced in the Overview lab. This lab goes over many of those same concepts, but in much more depth. Consider this lab a resource that you may want to revisit as you work through the course material, alongside the official book *Programming Cryptol* and the *Cryptol Reference Manual*.\n\nFor examples in this lab, as they are displayed here, the warning messages about specifying bit sizes of numbers have been turned off. This is not something you should do when you\u2019re new at Cryptol; it\u2019s only done here for teaching purposes.\n\n```cryptol\nlabs::Language::Basics> :set warnDefaulting = off\n```\n\nAlso, some examples have octets as outputs that are easier to see as characters. To see octets as characters, turn on ASCII mode:\n\n```cryptol\nlabs::Language::Basics> :set ascii = on\n```\n\nThat makes any sequence of octets be displayed as the corresponding ASCII string in double quotes (\") and an octet outside a sequence be displayed as the corresponding ASCII character in single quotes ('). (This is mostly useful as a pedagogical aid.)\n\n```cryptol\nlabs::Language::Basics> [0x63, 0x61, 0x74]\n\"cat\"\nlabs::Language::Basics> 0x78\n'x'\n```\n\nThe Cryptol interpreter parses `\"abc\"` and `[0x61, 0x62, 0x63]` into the exact same internal representation. `:set ascii = on` just causes the display of output to be ASCII strings or characters when appropriate.\n\n## Modules\n\nThis file is a Cryptol module. The first interpreted line of every Cryptol module must be\n\n```cryptol\nmodule Path::...Path::ModuleName where\n```\n\nThe `Path::...Path` component is the system path from the root of whatever set of modules you\u2019re creating or working from. The `ModuleName` component is the basename of this file. For instance, this module is `labs::Language::Basics` because its path from the root repository is `labs\/Language\/Basics.md`. Only one module can be declared in each file.\n\nA module declaration (`module ... where`) can be preceded by comments. This is a great place to document the module\u2019s purpose and how it relates to other content.\n\nUpdate! (Cryptol 3.2): A module can now have an associated docstring, a comment immediately preceding the module that can have an embedded code fence with verification commands.\n\nImporting modules is simple: just add a line starting with `import` followed by the name of the module. For example, here we import the Overview lab:\n\n```cryptol\nimport labs::Overview::Overview\n```\n\nTo avoid naming conflicts, or improve readability, you can qualify the module import using the `as` clause.\n\n```cryptol\nimport labs::Overview::Overview as OVLab\n```\n\nWhen the Cryptol interpreter loads this lab module, it gains access to all public definitions in the Overview lab module. Because the import was aliased as `OVLab`, all of the Overview definitions are accessed by prefixing `OVLab::`. For example,\n\n```cryptol\nlabs::Language::Basics> :browse\n...\n  From labs::Overview::Overview\n  -----------------------------\n\n    OVLab::decrypt : {a} (fin a) => [8] -> [a][8] -> [a][8]\n    OVLab::encrypt : {a} (fin a) => [8] -> [a][8] -> [a][8]\n    OVLab::sayHello : {a} (fin a) => [a][8] -> [7 + a][8]\n...\nlabs::Language::Basics> :set ascii=on\nlabs::Language::Basics> OVLab::sayHello \"Victoria\"\n\"Hello, Victoria\"\n```\n\nImports can be further refined with import lists, specifying which definitions to include or exclude:\n\n```cryptol\n\/\/ imports `product` and `distinct` from the NQueens demo\nimport labs::Demos::Cryptol::NQueens (product, distinct)\n\n\/\/ imports all _except_ the listed test definitions from the CRC spec\nimport labs::CRC::CRC hiding (\n  CRCSimpleTest, testM, CRCSimple_QTest, CRCSimple_XFERTest, \n  CRC32_BZIP2Test, CRC32_CTest, CRC32_DTest, CRC32_MPEG2Test, \n  CRC32_POSIXTest, CRC32_QTest, CRC32_JAMCRCTest, CRC32_XFERTest\n)\n\n\/\/ imports `littleendian`(`'`) functions, prefixed with `Salsa20::`\nimport labs::Salsa20::Salsa20 as Salsa20 (littleendian, littleendian')\n\n\/\/ imports all except `inc` functions from `ProjectEuler` into `PE::`\nimport labs::ProjectEuler::ProjectEuler as PE hiding (inc, inc1001)\n```\n\nTo keep a definition private, meaning it won\u2019t be imported by other modules, use the `private` clause.\n\n```cryptol\nprivate thisIsPrivate = 10\n```\n\nCryptol\u2019s module system also supports parameters, as presented in **Parameterized Modules**, a later lab.\n\nFile-only commands like `module`, `import`, `private`, `property`, `enum`, and `newtype` can only be used in files, not interactively.\n\n## Comments\n\n- `\/\/` comments until the end of the line\n- `\/* \u2026 *\/` block comments (can be nested)\n- Docstring comments: `\/** \u2026 *\/` preceding a definition\n\nExample:\n\n```cryptol\n\/**\n  * A totally made up identifier for pedagogical purposes. It is\n  * used elsewhere for demonstration of something or other.\n  *\/\nmask = 7 : [32]\n```\n\nWhen issuing `:help mask`, the above comments appear.\n\nUpdate! Cryptol 3.2 modules can have docstrings that include embedded code fences with verification commands automatically run by `:check-docstrings`.\n\n## Variable and Function Naming\n\nCryptol identifiers consist of alphanumeric characters plus `'` (apostrophe, read \u201cprime\u201d) and `_` (underscore). They must begin with an alphabetic character or underscore.\n\nExample:\n\n```cryptol\nmyValue  = 15 : [32]\nmyValue' = myValue && mask  \/\/ mask defined elsewhere\n```\n\nCamel case is often used when constraints aren\u2019t mandated. Cryptol supports Unicode, but this course does not use that feature.\n\n## Types of Variables\n\nCryptol\u2019s basic data type is an n-dimensional array (called a sequence) whose base type is bits.\n\n- 0-d: `False : Bit` and `True : Bit`\n- 1-d: sequences of bits, e.g., `0x2a : [8]`, `0b101010 : [6]`, etc.\n- 2-d: sequences of 1-d objects all of the same size, e.g., `[42, 0b0101, 0xa5a] : [4][12]`\n- 3-d: sequences of 2-d objects, e.g., `[[0, 1], [1, 2]] : [4][2][4]`\n\nNotes:\n\n- The lowest dimension\u2019s type is `Bit`. Writing `[8]Bit` is correct but `Bit` is usually left off.\n- No privileged bit widths in Cryptol; `[13]` is as valid as `[8]`, `[16]`, etc.\n- Literal prefixes: `0b...` binary, `0o...` octal, `0x...` hexadecimal.\n- Sequences can have zero length (identity for concatenation).\n- Possible values for `[n]` are from 0 to `2^n - 1`.\n- 1-d sequences of bits are treated as numbers by arithmetic\/comparison.\n- Cryptol distinguishes between dimensions; e.g., `True` and `[True]` are incompatible.\n- The number of bracket pairs in a type gives its dimension.\n- Holes in types via `_` are inferred.\n\nExamples of other data types:\n\n- Arbitrary-precision integers: `2^^1023 - 347835479 : Integer`\n- Integers modulo n: `[n]` types provide residues modulo `2^n`.\n- Heterogeneous tuples: `(False, 0b11) : (Bit, [2])`\n- Records with named fields: `{flag = True, x = 2} : {flag : Bit, x : [4]}`\n- newtypes, e.g.:\n\n```cryptol\nnewtype MySequence n a = { seq: [n]a }\n```\n\nExample usage:\n\n```cryptol\nsmall_pyth_triples = MySequence { seq = [[3,4,5], [5,12,13], [8,15,17 : Integer]] }\n```\n\n- enum types, e.g.:\n\n```cryptol\nenum Maybe a = Nothing | Just a\n\nhead' : {n, a} [n]a -> Maybe a\nhead' xs\n  | n == 0 => Nothing\n  | n  > 0 => Just (head xs)\n```\n\n## EXERCISE: Variable Types\n\nDetermine types of these variables:\n\n```cryptol\nvarType0 = False\nvarType1 = [False]\nvarType2 = [False, False, True]\nvarType3 = 0b001\nvarType4 = [0x1, 2, 3]\nvarType5 = [ [1, 2, 3 : [8]] , [4, 5, 6], [7, 8, 9] ]\nvarType6 = [ [1, 2, 3] : [3][8], [4, 5, 6], [7, 8, 9] ]\nvarType7 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] : [_][_][8]\nvarType8 = (0b1010, 0xff)\nvarType9 = [ (10 : [12], [1, 2 : [4], 3], ([0b101, 7], 0xab)),\n             (18 : [12], [0, 1 : [4], 2], ([0b100, 3], 0xcd)) ]\n```\n\n## Types of Functions\n\nFunctions are stateless definitions mapping input to output.\n\nExample:\n\n```cryptol\nadd x y = x + y\n```\n\n`add` is polymorphic, working with many types.\n\nTo type a function explicitly:\n\n```cryptol\nadd : [32] -> [32] -> [32]\nadd x y = x + y\n```\n\nType definitions have the name, optional type variables and constraints, input types separated by `->`, and output type.\n\nCurried style:\n\n```cryptol\nadd : [32] -> [32] -> [32]\nadd x y = x + y\n```\n\nUncurried style:\n\n```cryptol\naddUncurried : ([32], [32]) -> [32]\naddUncurried (x, y) = x + y\n```\n\nApplied as:\n\n```cryptol\nadd 20 28\naddUncurried (20, 28)\n```\n\nNative support for currying and uncurrying:\n\n```cryptol\ncurry addUncurried 20 28\nuncurry add (20, 28)\n```\n\nPartial application example:\n\n```cryptol\nincrement = add 1\n```\n\n## EXERCISE: Function Types\n\nGuess types for the following:\n\n```cryptol\nfunType0 a = a + 7 : [5]\n\nfunType1 a b = a + b + 0b0011100\n\nfunType2 a b = (a + 0x12, b + 0x1234)\n\nfunType3 (a, b) = (a + 0x12, b + 0x1234)\n\nfunType4 ((a, b), c) = c + 10 : [32]\n\nfunType5 [a, b, c : [10]] = [a, b, c]\n\nfunType6 (a : [3][10]) = [a@0, a@1, a@2]\n\nfunType7 x = (x, x, [ [[False, True], x], [x, x], [x, x] ])\n\nfunType8 = funType2 10\n\nfunType9 = False  \/\/ Value or function with no arguments?\n```\n\n## EXERCISE: Additional Function Types\n\n```cryptol\nfunType10 x = x + x : [10]\n\nfunType11 a b = [a : Bit, b, b]\n\nfunType12 [a, b] = [a : Bit, b, b]\n\nfunType13 (a, b) = [a : Bit, b, b]\n\nfunType14 a b ([c, d], e) = [ (a     , [b, b, b]),\n                              ([d, d], [c, c, c]),\n                              (a     , e) ]\n\nfunType15 a b = [ a, b, a, b, a, b,\n                  a, b, a, b, a, b,\n                  a, b, a, b, a, b,\n                  a, b, a, b, a, b,\n                  a, b, a, b, a, b,\n                  a, b, a, b, a, b,\n                  a, b, a, b, a, b ]\n\nfunType16 a b = [ [ a, b, a, b, a, b ],\n                  [ a, b, a, b, a, b ],\n                  [ a, b, a, b, a, b ],\n                  [ a, b, a, b, a, b ],\n                  [ a, b, a, b, a, b ],\n                  [ a, b, a, b, a, b ],\n                  [ a, b, a, b, a, b ] ]\n\nfunType17 a b = ( [ a, b, a, b, a, b ],\n                  [ a, b, a, b, a, b ],\n                  [ a, b, a, b, a, b ],\n                  [ a, b, a, b, a, b ],\n                  [ a, b, a, b, a, b ],\n                  [ a, b, a, b, a, b ],\n                  [ a, b, a, b, a, b ] )\n\nfunType18 a b = [ ( a, b, a, b, a, b ),\n                  ( a, b, a, b, a, b ),\n                  ( a, b, a, b, a, b ),\n                  ( a, b, a, b, a, b ),\n                  ( a, b, a, b, a, b ),\n                  ( a, b, a, b, a, b ),\n                  ( a, b, a, b, a, b ) ]\n\nfunType19 a b = ( ( a, b, a, b, a, b ),\n                  ( a, b, a, b, a, b ),\n                  ( a, b, a, b, a, b ),\n                  ( a, b, a, b, a, b ),\n                  ( a, b, a, b, a, b ),\n                  ( a, b, a, b, a, b ),\n                  ( a, b, a, b, a, b ) )\n```\n\n## Pattern Matching\n\nCryptol allows assignments with patterns:\n\n```cryptol\nlet (fst, snd) = (4, 5)\n```\n\n```cryptol\nlet r = (0xa, 0xb)\nlet (fst, snd) = r\n```\n\n```cryptol\nlet [ (a, b, _), (_, _, c), _ ] = [ (1, 2, 3), (4, 5, 6), (7, 8, 9) ] : [3]([4], [4], [4])\n```\n\nExample of sequence concatenation pattern matching:\n\n```cryptol\nfirstThreeBits : {n} [3 + n] -> [3]\nfirstThreeBits ([a, b, c] # xs) = [a, b, c]\n```\n\n## Polymorphic Functions\n\nFull type of a function with type variables and constraints:\n\n```cryptol\nfunctionName :\n    {typeVariable0, typeVariable1}\n    (typeConstraint0, typeConstraint1) =>\n    inputType0 -> inputType1 -> outputType\n```\n\nExample:\n\n```cryptol\nsayHello:\n    {n}\n    (fin n) =>\n    [n][8] -> [7+n][8]\nsayHello name = \"Hello, \" # name\n```\n\nWith an additional constraint:\n\n```cryptol\nsayHello:\n    {n}\n    (n <= 12) =>\n    [n][8] -> [7+n][8]\nsayHello name = \"Hello, \" # name\n```\n\nUse the interpreter to verify:\n\n```cryptol\n:s ascii=on\nsayHello \"Munkustrap\"\nsayHello \"Skimbleshanks\"  \/\/ rejected; length exceeds 12\n```\n\nConcatenation operator type:\n\n```cryptol\n(#) : {front, back, a} (fin front) =>\n        [front]a -> [back]a -> [front + back]a\n```\n\nExample of enforcing minimum size using type constraints:\n\n```cryptol\nbitTwelve :\n    {n}\n    (fin n, n >= 13) =>\n    [n] -> Bit\nbitTwelve x = x@12\n```\n\n## Passing Type Variables\n\nExample function to repeat a value `n` times:\n\n```cryptol\nrepeat :\n    {n, a}\n    () =>\n    a -> [n]a\nrepeat value = [ value | _ <- zero : [n] ]\n```\n\nExamples passing type and value variables to `repeat`:\n\n```cryptol\npolyType0 = repeat`{a=[64], n=2} 7\npolyType1 = repeat`{n=4, a=[64]} 7\npolyType2 = repeat`{a=Bit, n=20} True\npolyType3 = repeat`{n=20, a=Bit} True\npolyType4 = repeat`{n=20} True\npolyType6 = repeat`{n=4, a=[3][7]} [1, 2, 3]\npolyType7 = repeat`{n=4} ([1, 2, 3] : [3][7])\npolyType8 = repeat 7 : [5][16]\npolyType11 = repeat`{a=[16], n=5} 7\npolyType12 = repeat`{5, [16]} 7\npolyType13 = repeat`{5} (7 : [16])\n```\n\n## EXERCISE: zeroPrepend Function\n\nWrite a function to prepend `n` False bits to the beginning of an `m`-bit bitvector `input`.\n\n```cryptol\n\/\/zeroPrepend : {n, m} (fin n, fin m) => [m] -> [n + m]\nzeroPrepend input = undefined\n```\n\nTest cases (run in interpreter):\n\n```cryptol\n:s base=2\nzeroPrepend`{n=7} 0b111           \/\/ should be 0b0000000111\nzeroPrepend`{n=3, m=inf} zero    \/\/ infinite zeros prepended\nzeroPrepend`{m=6} 5 : [10]       \/\/ 0b0000000101\nzeroPrepend`{5, 6} 15            \/\/ 0b00000001111\n```\n\n## Demoting Types to Values\n\nType variables can be demoted to value variables using backtick:\n\nExample:\n\n```cryptol\nappendSize :\n    {size}\n    (fin size, 32 >= width size) =>\n    [size][32] -> [size + 1][32]\nappendSize input = input # [`size]\n```\n\n`[`size`]` converts the type variable `size` into a 1-element sequence suitable for concatenation.\n\n## Type Synonyms\n\nDefine synonyms with `type` keyword:\n\n```cryptol\ntype myType x = [x][x]\n```\n\nExamples:\n\n```cryptol\nzero : myType 2\nzero : myType 5\n```\n\n## Judicious Type System Usage\n\n- Don\u2019t let the type system do your work; specify types when needed.\n- Type signatures aid documentation and debugging.\n\n## Local Definitions\n\nUse `where` to create local definitions:\n\n```cryptol\naddMult :\n    {n}\n    (fin n) =>\n    [n] -> [n] -> [n] -> [n]\naddMult a b c = ab + bc\n  where\n    ab = a * b\n    bc = b * c\n```\n\n## Properties\n\nDefine properties for theorem proving using `property` keyword.\n\nExample:\n\n```cryptol\n\/**\n * Checks if any of the 4 bytes of a 32 bit word are zero.\n *\/\nanyZeroByteOpt : [32] -> Bit\nanyZeroByteOpt v =\n  ~((((v && 0x7F7F7F7F) + 0x7F7F7F7F) || v) || 0x7F7F7F7F) != 0\n\nanyZeroByteSpec : [32] -> Bit\nanyZeroByteSpec bytes =\n    b0 == 0 \\\/ b1 == 0 \\\/ b2 == 0 \\\/ b3 == 0\n  where\n    [b0, b1, b2, b3] = split bytes : [4][8]\n\nproperty anyZeroByteCorrect bytes =\n    anyZeroByteOpt bytes == anyZeroByteSpec bytes\n```\n\nExample properties about currying:\n\n```cryptol\nadd_curry_eq : [32] -> [32] -> Bool\nproperty add_curry_eq x y =\n  add x y == curry addUncurried x y\n\nadd_uncurry_eq : [32] -> [32] -> Bool\nproperty add_uncurry_eq x y =\n  addUncurried (x, y) == uncurry add (x, y)\n```\n\nUse `:prove` to verify properties:\n\n```cryptol\n:prove anyZeroByteCorrect\n:prove add_curry_eq\n:prove add_uncurry_eq\n```\n\n## Operators\n\nUse `:help` to see operator details.\n\nExamples:\n\n- Arithmetic: `+`, `-`, `*`, `\/`, `%`, `^^`\n- Bitwise: `~`, `&&`, `||`, `^`\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Signed versions: suffix `$`\n- Shift and rotate: `<<`, `>>`, `<<<`, `>>>`, signed versions `>>$`\n- Indexing: `@`, `!`, `@@`, `!!` (0-based indexing from start\/end)\n- Concatenation: `#`\n- Shortcut logical: `\/\\`, `\\\/`, `==>`\n\nExamples:\n\n```cryptol\n~0b000011001101\n0b111100110010\n\n0b111100110010 && 0b100001001101\n0b100000000000\n\n\"dog\" # \"cow\"\n\"dogcow\"\n\n\"cat\" @ 0\n'c'\n\n[~1,1] == [6 : [3], 3 * 3]\nTrue\n```\n\n## if ... then ... else ...\n\nExample:\n\n```cryptol\n2 + (if 10 < 7 then 12 else 4) + 2 : Integer\n8\n```\n\n## EXERCISE: Specify Speck2n Round Function\n\nHelper functions:\n\n```cryptol\nS amount value = value <<< amount\n\nS' amount value = value >>> amount\n```\n\nInverse round function:\n\n```cryptol\nR' :\n    {n}\n    (fin n) =>\n    [n] -> ([n], [n]) -> ([n], [n])\nR' k (x, y) =\n    (S a ((x ^ k) - S' b (x ^ y)), S' b (x ^ y))\n  where\n    n = `n : Integer\n    a = if n == 16 then 7 else 8 : [4]\n    b = if n == 16 then 2 else 3 : [2]\n```\n\nTask: define `R` according to the Speck specification (round function).\n\nProperty:\n\n```cryptol\nRInverseProperty :\n    {n}\n    (fin n) =>\n    [n] -> ([n], [n]) -> Bit\nproperty RInverseProperty k (x, y) =\n    R' k (R k (x, y)) == (x, y)\n```\n\nVerify:\n\n```cryptol\n:prove RInverseProperty`{32}\n:prove RInverseProperty`{64}\n```\n\n## Multi-way Conditional\n\nExample:\n\n```cryptol\nsignum : {a} (SignedCmp a, Zero a) => a -> [2]\nsignum x = if (x <$ zero) then -1\n            | (x >$ zero) then 1\n            | (x == zero) then 0\n                          else error \"Value is not comparable to zero\"\n```\n\n## Common Primitives\n\n- Collections of all False or all True bits: `0`, `zero`, `~0`, `~zero`\n- List manipulation: `take`, `drop`, `head` (`@0`), `tail`, `last` (`!0`), `reverse`\n- List shape: `split`, `groupBy`, `join`, `transpose`\n- Functional programming: `sum`, `map`, `iterate`, `scanl`, `foldl`\n\nExamples:\n\n```cryptol\ntake \"dogcow\" : [3][8]\ndrop [2, 3, 5, 7, 11] : [3]Integer\nhead [1, 2, 3] : Integer\ntail [0, 1, 1] : [2]Integer\nlast [2, 3, 5, 7, 11] : Integer\nreverse [0, 0, 1] : [3]Integer\n\nsplit`{8} 0xdeadbeef\ngroupBy`{4} 0xdeadbeef\njoin [0xca, 0xfe]\ntranspose [[1, 2], [3, 4]]\n\nsum [1, 2, 3, 4, 5]\nmap increment [1, 2, 3, 4, 5]\niterate increment 0\nscanl (+) 0 [1, 2, 3, 4, 5]\nfoldl (+) 0 [1, 2, 3, 4, 5]\n```\n\n## Small Functions\n\nGood Cryptol code is composed of small, easy-to-understand functions amenable to testing and proving properties.\n\n## Writing Loops\n\nLoops can be written functionally using sequence comprehensions:\n\nExample:\n\n```cryptol\n[ n^^3 | n <- [0..10] ]\n```\n\nCartesian and parallel branches:\n\n```cryptol\n[ (a, b) | a <- [0..3] , b <- [0..7] ]  \/\/ Cartesian\n[ (a, b) | a <- [0..3] | b <- [0..7] ]  \/\/ Parallel\n```\n\n## Example: Simple Block Encryption\n\n```cryptol\nkeyExpand : [32] -> [10][32]\nkeyExpand key = take roundKeys\n  where\n    roundKeys : [inf][32]\n    roundKeys = [key] # [ roundKey <<< 1 | roundKey <- roundKeys ]\n\nencrypt : [32] -> [32] -> [32]\nencrypt key plainText = cipherText\n  where\n    roundKeys = keyExpand key\n    roundResults = [plainText] # [ roundResult ^ roundKey\n                                 | roundResult <- roundResults\n                                 | roundKey <- roundKeys\n                                 ]\n    cipherText = last roundResults\n```\n\nExample usage:\n\n```cryptol\nencrypt 0x1337c0de 0xdabbad00\nencrypt 0 0xdabbad00\n```\n\n## Laziness\n\nCryptol uses lazy evaluation; expressions are not evaluated until needed.\n\nExample:\n\n```cryptol\nabs : [32] -> [32]\nabs n = if n >= 0 then n else -n\n\nlazyAbsMin : [32] -> [32] -> [32]\nlazyAbsMin x y = if x == 0 then 0 else min (abs x) (abs y)\n```\n\n## Debugging\n\nUse `trace` and `traceVal` for printing debugging values.\n\nExample:\n\n```cryptol\ndouble xs = [ traceVal \"xi * 2 =\" (xi * 2) | xi <- xs ]\n```\n\nRunning:\n\n```cryptol\ndouble [1, 2, 3, 4]\n```\n\n## Errors and Assertions\n\nUse `error` and `assert` for run-time checks.\n\nExample:\n\n```cryptol\nisDigits cs = and [ c >= '0' \/\\ c <= '9' | c <- cs ]\n\nconcatNumbers : {a, b} (fin a, fin b) => [a][8] -> [b][8] -> [a + b][8]\nconcatNumbers xs ys =\n    assert (isDigits xs \/\\ isDigits ys) \"The inputs contains invalid characters\"\n    xs # ys\n```\n\nExample usage:\n\n```cryptol\n:s ascii=on\nconcatNumbers \"123\" \"567\"\nconcatNumbers \"abc\" \"567\"  \/\/ Run-time error\n```\n\nSafe function usage with theorem proving:\n\n```cryptol\nnumToASCII : {digits} (fin digits) => Integer -> [digits][8]\nnumToASCII x = reverse (take`{digits} (tail ds.1))\n  where ds = [(x, 0)] # [ (di \/ 10, fromInteger (di % 10) + '0') | (di, _) <- ds ]\n\nconcatIntegers : {digits} (fin digits) => Integer -> Integer -> [digits * 2][8]\nconcatIntegers x y = concatNumbers x' y'\n  where\n    x' = numToASCII`{digits} x\n    y' = numToASCII`{digits} y\n\n:safe concatIntegers`{10}\n:safe signum`{[8]}\n```\n\n**Bottom line:** Functions with errors can be handled, but best to avoid them.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/weaversa.github.io\/cryptol-course\/labs\/CRC\/CRC.html","filetype":"txt","content":"## Cyclic Redundancy Checks\n\nFrom [1],\n\nA cyclic redundancy check (CRC) is an error-detecting code commonly used in digital networks and storage devices to detect accidental changes to raw data. CRCs are important to cryptography because they are often used, in part, to protect the integrity of key material (see Section 6.1 of NIST\u2019s Recommendation for Key Management).\n\nIn this lab we will create Cryptol specifications for a family of different CRCs.\n\n## Mathematics of CRCs\n\nA simple mathematical definition of CRCs can be found here: Mathematics of cyclic redundancy checks\n\nR(x) = M(x) * x\u207f mod G(x)\n\nHere M(x) is the original message polynomial and G(x) is the degree-n generator polynomial. The bits of M(x) * x\u207f are the original message with n zeroes added at the end. The CRC \u2018checksum\u2019 is formed by the coefficients of the remainder polynomial R(x) whose degree is strictly less than n.\n\nTo start, our definition of CRC in Cryptol will need a generator polynomial G of degree n. Cryptol has some support for polynomials; for instance, one can express a polynomial like so `<| x^^3 + x + 1 |>`, which is simply the four-bit string 0b1011. It\u2019s important to note that even though this is a degree three polynomial, it takes four bits to represent. Generally, Cryptol\u2019s representation of a degree n polynomial is a sequence of n+1 bits where each monomial is represented by a True bit in the sequence. For more on polynomials in Cryptol, see Section 5.2 of *Programming Cryptol*.\n\nWe\u2019ll also need a message M which is simply a sequence of m bits. Notice that the definition from [2] tells us that M is extended (concatenated) with n zeroes prior to performing the modulus operation. Cryptol supports multiplying (`pmult`), dividing (`pdiv`), and performing the modulus (`pmod`) of polynomials. This is more than we need to define a simple CRC function.\n\nEXERCISE: Here we provide a skeleton CRC for you to fill in according to the definition above. Use the `CRCSimpleTest` property to help you get it right.\n\n```cryptol\nCRCSimple :\n    {n, m}\n    (fin n, fin m) =>\n    [n+1] -> [m] -> [n]\nCRCSimple G M = R\n  where R  = undefined  \/\/ M' modulus G\n        M' = undefined  \/\/ Concatenate M with n zero bits\n```\n\nThis test-case is from [1].\n\n```cryptol\nproperty CRCSimpleTest = CRCSimple G 0b11010011101100 == 0b100\n  where G = <| x^^3 + x + 1 |>\n```\n\n## A Family of CRC32s\n\nBastian Molkenthin\u2019s CRC simulator [3] supports nine different 32-bit CRCs.\n\n| Name         | Polynomial      | Initial Fill | Post-XOR  | Reflect Input Bytes | Reverse Output |\n|--------------|-----------------|--------------|-----------|---------------------|---------------|\n| CRC32        | 0x104C11DB7     | 0xFFFFFFFF   | 0xFFFFFFFF| True                | True          |\n| CRC32_BZIP2  | 0x104C11DB7     | 0xFFFFFFFF   | 0xFFFFFFFF| False               | False         |\n| CRC32_C      | 0x11EDC6F41     | 0xFFFFFFFF   | 0xFFFFFFFF| True                | True          |\n| CRC32_D      | 0x1A833982B     | 0xFFFFFFFF   | 0xFFFFFFFF| True                | True          |\n| CRC32_MPEG2  | 0x104C11DB7     | 0xFFFFFFFF   | 0x00000000| False               | False         |\n| CRC32_POSIX  | 0x104C11DB7     | 0x00000000   | 0xFFFFFFFF| False               | False         |\n| CRC32_Q      | 0x1814141AB     | 0x00000000   | 0x00000000| False               | False         |\n| CRC32_JAMCRC | 0x104C11DB7     | 0xFFFFFFFF   | 0x00000000| True                | True          |\n| CRC32_XFER   | 0x1000000AF     | 0x00000000   | 0x00000000| False               | False         |\n\nHere we can see that the CRCs differ not only in polynomials (choice of G) but also in four other parameters that we\u2019ll go over soon. Though first, two of these, namely, CRC32_Q and CRC32_XFER, are simple enough to be compatible with `CRCSimple`.\n\nHere we define a test message using the canonical pangram.\n\n```cryptol\ntestM = \"The quick brown fox jumps over the lazy dog\"\n\nproperty CRCSimple_QTest = CRCSimple G (join testM) == 0xf4965ffc\n  where G = <| x^^32 + x^^31 + x^^24 + x^^22 + x^^16 + x^^14 + x^^8 + x^^7 + x^^5 + x^^3 + x + 1 |>\n\nproperty CRCSimple_XFERTest = CRCSimple G (join testM) == 0x140493e5\n  where G = <| x^^32 + x^^7 + x^^5 + x^^3 + x^^2 + x + 1 |>\n```\n\nEXERCISE: Make sure these two properties prove using the `CRCSimple` function you defined above.\n\n## Fully Parameterized CRC\n\nTo support the full suite of CRC32\u2019s from [3], we need to add four parameters.\n\n- **Initial Fill (fill)**  \n  Refers to the initial fill of a CRC when implemented by a linear feedback shift register. Since we\u2019re implementing CRC here with polynomial arithmetic, we can add this parameter by XORing the initial fill into the high-order bits of the zero-expanded message before performing the modulus operation.  \n- **Post-XOR (post)**  \n  A sequence of bits that are XOR\u2019d into the remainder polynomial to create the final output.  \n- **Reflect Input Bytes (rib)**  \n  Denotes whether or not the input (when viewed as a sequence of bytes) should have the bits inside each byte reversed.  \n- **Reverse Output (ro)**  \n  Denotes whether or not the output (when viewed as a bitvector) should be reversed.\n\nEXERCISE: Here we provide a skeleton for a fully parameterized CRC for you to fill in. It is essentially the `CRCSimple` function augmented with the four extra parameters given above. Use the `CRC32Test` property to help you get it right.\n\nNote, since there is now a parameter that possibly reflects the input bytes, to make things a little easier here, we\u2019ve reshaped the input M as a sequence of bytes.\n\n```cryptol\nCRC :\n    {n, m}\n    (fin n, fin m) =>\n    [n+1] -> [n] -> [n] -> Bit -> Bit -> [m][8] -> [n]\nCRC G fill post rib ro M =\n    undefined  \/\/ if R should be reversed, then reverse R, else return R\n  where\n    R      = undefined  \/\/ fill' XOR M'' modulus G XOR post\n    M'     = undefined  \/\/ reflect the input bytes, if necessary, and then join the bytes into a bitvector\n    M''    = undefined  \/\/ extend M' with n zero bits\n    fill'  = undefined  \/\/ extend fill with (m*8) zero bits so that fill' matches the type of M''\n```\n\nHere is a definition of CRC32, using the parameterized CRC function.\n\n```cryptol\nCRC32 = CRC G 0xffffffff 0xffffffff True True\n  where G = <| x^^32 + x^^26 + x^^23 + x^^22 + x^^16 + x^^12 + x^^11 + x^^10 + x^^8 + x^^7 + x^^5 + x^^4 + x^^2 + x + 1 |>\n\nproperty CRC32Test =\n    CRC32 testM == 0x414FA339\n```\n\nEXERCISE: Use the values in the table above to fill in values for each of the following eight 32-bit CRCs. Use the associated properties to help you get them right, or test them yourself with the CRC simulator [3].\n\n### BZIP2\n\n```cryptol\nCRC32_BZIP2 = CRC G undefined undefined undefined undefined\n  where G = <| x^^32 + x^^26 + x^^23 + x^^22 + x^^16 + x^^12 + x^^11 + x^^10 + x^^8 + x^^7 + x^^5 + x^^4 + x^^2 + x + 1 |>\n\nproperty CRC32_BZIP2Test =\n    CRC32_BZIP2 testM == 0x459DEE61\n```\n\n### C\n\n```cryptol\nCRC32_C = CRC G undefined undefined undefined undefined\n  where G = <| x^^32 + x^^28 + x^^27 + x^^26 + x^^25 + x^^23 + x^^22 + x^^20 + x^^19 + x^^18 + x^^14 + x^^13 + x^^11 + x^^10 + x^^9 + x^^8 + x^^6 + 1 |>\n\nproperty CRC32_CTest =\n    CRC32_C testM == 0x22620404\n```\n\n### D\n\n```cryptol\nCRC32_D = CRC G undefined undefined undefined undefined\n  where G = <| x^^32 + x^^31 + x^^29 + x^^27 + x^^21 + x^^20 + x^^17 + x^^16 + x^^15 + x^^12 + x^^11 + x^^5 + x^^3 + x + 1 |>\n\nproperty CRC32_DTest =\n    CRC32_D testM == 0x9D251C62\n```\n\n### MPEG2\n\n```cryptol\nCRC32_MPEG2 = CRC G undefined undefined undefined undefined\n  where G = <| x^^32 + x^^26 + x^^23 + x^^22 + x^^16 + x^^12 + x^^11 + x^^10 + x^^8 + x^^7 + x^^5 + x^^4 + x^^2 + x + 1 |>\n\nproperty CRC32_MPEG2Test =\n    CRC32_MPEG2 testM == 0xBA62119E\n```\n\n### POSIX\n\n```cryptol\nCRC32_POSIX = CRC G undefined undefined undefined undefined\n  where G = <| x^^32 + x^^26 + x^^23 + x^^22 + x^^16 + x^^12 + x^^11 + x^^10 + x^^8 + x^^7 + x^^5 + x^^4 + x^^2 + x + 1 |>\n\nproperty CRC32_POSIXTest =\n    CRC32_POSIX testM == 0x36B78081\n```\n\n### Q\n\n```cryptol\nCRC32_Q = CRC G undefined undefined undefined undefined\n  where G = <| x^^32 + x^^31 + x^^24 + x^^22 + x^^16 + x^^14 + x^^8 + x^^7 + x^^5 + x^^3 + x + 1 |>\n\nproperty CRC32_QTest =\n    CRC32_Q testM == 0xF4965FFC\n```\n\n### JAMCRC\n\n```cryptol\nCRC32_JAMCRC = CRC G undefined undefined undefined undefined\n  where G = <| x^^32 + x^^26 + x^^23 + x^^22 + x^^16 + x^^12 + x^^11 + x^^10 + x^^8 + x^^7 + x^^5 + x^^4 + x^^2 + x + 1 |>\n\nproperty CRC32_JAMCRCTest =\n    CRC32_JAMCRC testM == 0xBEB05CC6\n```\n\n### XFER\n\n```cryptol\nCRC32_XFER = CRC G undefined undefined undefined undefined\n  where G = <| x^^32 + x^^7 + x^^5 + x^^3 + x^^2 + x + 1 |>\n\nproperty CRC32_XFERTest =\n    CRC32_XFER testM == 0x140493E5\n```","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/weaversa.github.io\/cryptol-course\/labs\/Salsa20\/Salsa20.html","filetype":"txt","content":"## Salsa20\n\nSalsa20 is a cryptographic algorithm created by Daniel J. Bernstein. The specification is available here, but also provided in this repository here for ease of access. The specification document describes Salsa20 as well as how to use it as a stream cipher in counter mode.\n\nThis lab goes through the Salsa20 specification document section by section, showing how to write a fairly pedantic Cryptol specification of Salsa20. We recommend you either print the specification document, or have this lab and the specification document open side-by-side.\n\nNow we can begin to dig into the specification document!\n\n## 1 Introduction\n\nThe last paragraph of the introduction defines a byte to mean an element of {0,1,\u2026,255} and says that there are many common ways to represent a byte. This is an opportunity for us to specify a representation in our specification. Here, we define Bytes as a new type synonym for a sequence of n 8-bit words.\n\n```cryptol\ntype Bytes n = [n][8]\n```\n\n## 2 Words\n\nThis section defines word to be an element of {0,1,\u2026,2^32 - 1}. Similarly to Bytes above, we define Words as a new type synonym for a sequence of n 32-bit words.\n\n```cryptol\ntype Words n = [n][32]\n```\n\nThe specification then goes on to give an example of how words are expressed in hexadecimal throughout the rest of the document. Here, we show that Cryptol natively agrees with this expression by encoding the example as a property.\n\n```cryptol\nproperty hexadecimalProp =\n    (0xc0a8787e == 12 * (2^^28)\n                 +  0 * (2^^24)\n                 + 10 * (2^^20)\n                 +  8 * (2^^16)\n                 +  7 * (2^^12)\n                 +  8 * (2^^ 8)\n                 +  7 * (2^^ 4)\n                 + 14 * (2^^ 0)) \/\\\n    (0xc0a8787e == 3232266366)\n```\n\nLet's prove hexadecimalProp:\n\n```\nlabs::Salsa20::Salsa20> :prove hexadecimalProp\nQ.E.D.\n(Total Elapsed Time: 0.006s, using \"Z3\")\n```\n\nHere we see Q.E.D. which means the property is true. As you work through the rest of this document, please try and :prove the property statements littered throughout to help you check your work.\n\nThis section then defines the sum of two words and provides an example. Here, we show that Cryptol\u2019s `+` operator agrees with this definition of sum by encoding the example as a property.\n\n```cryptol\nproperty sumProp =\n    0xc0a8787e + 0x9fd1161d == 0x60798e9b\n```\n\nNext, exclusive-or and c-bit left rotation are defined and examples provided. One small syntactic change is needed, namely, the exclusive-or symbol in Cryptol is `^` rather than \u2295. So, in Cryptol, these examples become:\n\n```cryptol\nproperty exclusiveOrProp =\n    0xc0a8787e ^ 0x9fd1161d == 0x5f796e63\n\nproperty LeftRotationProp =\n    0xc0a8787e <<< 5 == 0x150f0fd8\n```\n\n## 3 The quarterround function\n\n### Inputs and outputs\n\nThis section begins by giving the type of the quarterround function as:\n\nIf y is a 4-word sequence then quarterround(y) is a 4-word sequence. In Cryptol, we would write this type as:\n\n```cryptol\nquarterround : Words 4 -> Words 4\n```\n\n### Definition\n\nThis section then goes on to define quarterround. Two syntactic changes are required, namely, sequences in Cryptol are book-ended by `[]` rather than `()` and commas are not needed after statements in a where clause.\n\n```cryptol\nquarterround [y0, y1, y2, y3] = [z0, z1, z2, z3] where\n    z1 = y1 ^ ((y0 + y3) <<< 7)\n    z2 = y2 ^ ((z1 + y0) <<< 9)\n    z3 = y3 ^ ((z2 + z1) <<< 13)\n    z0 = y0 ^ ((z3 + z2) <<< 18)\n```\n\n### Examples\n\nExample input-output pairs are provided. Cryptol can make use of these to provide evidence that quarterround was implemented correctly. Here we create a property that will verify whether quarterround works correctly on the provided example pairs.\n\n```cryptol\nproperty quarterroundExamplesProp =\n    (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000000]\n               == [0x00000000, 0x00000000, 0x00000000, 0x00000000]) \/\\\n    (quarterround [0x00000001, 0x00000000, 0x00000000, 0x00000000]\n               == [0x08008145, 0x00000080, 0x00010200, 0x20500000]) \/\\\n    (quarterround [0x00000000, 0x00000001, 0x00000000, 0x00000000]\n               == [0x88000100, 0x00000001, 0x00000200, 0x00402000]) \/\\\n    (quarterround [0x00000000, 0x00000000, 0x00000001, 0x00000000]\n               == [0x80040000, 0x00000000, 0x00000001, 0x00002000]) \/\\\n    (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000001]\n               == [0x00048044, 0x00000080, 0x00010000, 0x20100001]) \/\\\n    (quarterround [0xe7e8c006, 0xc4f9417d, 0x6479b4b2, 0x68c67137]\n               == [0xe876d72b, 0x9361dfd5, 0xf1460244, 0x948541a3]) \/\\\n    (quarterround [0xd3917c5b, 0x55f1c407, 0x52a58a7a, 0x8f887a3b]\n               == [0x3e2f308c, 0xd90a8f36, 0x6ab2a923, 0x2883524c])\n```\n\nThis is an excellent opportunity to check that the quarterround function we\u2019ve specified in Cryptol does indeed work correctly on these examples.\n\n```\nlabs::Salsa20::Salsa20> :prove quarterroundExamplesProp\nQ.E.D.\n(Total Elapsed Time: 0.005s, using \"Z3\")\n```\n\n### Comments\n\nThere is one last paragraph in this section that may not seem significant at first glance. This paragraph ends with:\n\n\u2026so the entire function is invertible.\n\nThis claim, if true, would make the quarterround function itself collision-free; an important property in cryptography. However, the author does little to convince us that this is true. Fortunately, we can prove this using Cryptol.\n\nYou may be wondering, what does it mean for a function to be invertible? Well, it means that a function (say, quarterround) has an inverse function (call it quarterround\u2019) such that for all possible values of y, quarterround\u2019 (quarterround y) == y. Unfortunately the author didn\u2019t provide us with such an inverse function. Now, we could attempt to create it, but there is a much simpler solution here!\n\nA function is invertible if:\n\n- each input maps to a unique output (collision free), and  \n- every element in the range of the function can be mapped to by some input (no output is missing).\n\nIn mathematics, this type of function would be called bijective. Bijective functions are both injective and surjective (one-to-one and onto). So, to prove that quarterround is invertible we can prove that it is bijective. This can be done by showing that quarterround is both injective and surjective. Now, since the domain and range of quarterround are the same (`Word 4 -> Word 4`), we know that, if the function is injective, it must also be surjective. Hence, we only need to prove that quarterround is injective.\n\nWikipedia defines an injective function as:\n\nFor the non-mathematician, this says that a function is injective if every pair of different inputs causes the function to produce different outputs. We can now encode this (almost verbatim) into a Cryptol property.\n\n```cryptol\nproperty quarterroundIsInjectiveProp x x' =\n    x != x' ==> quarterround x != quarterround x'\n```\n\nAnd then prove that the property is true.\n\n```\nlabs::Salsa20::Salsa20> :prove quarterroundIsInjectiveProp\nQ.E.D.\n(Total Elapsed Time: 0.430s, using \"Z3\")\n```\n\nIt\u2019s worth noting here that Cryptol and associated theorem provers are doing some very heavy lifting behind the scenes. Without an automated theorem prover, the best one could do is run some tests. Cryptol does support automated testing with its `:check` command.\n\n```\nlabs::Salsa20::Salsa20> :check quarterroundIsInjectiveProp\nUsing random testing.\nPassed 100 tests.\nExpected test coverage: 0.00% (100 of 2^^256 values)\n```\n\nThis command provides a quick check on properties and is useful if `:prove` is taking too long or fails for some reason. But the time it would take to ensure there are no \u201cneedles in the haystack\u201d is more than the number of seconds left before the Sun swallows the Earth. However, if you\u2019d prefer to try, Cryptol\u2019s `:exhaust` is the command to use.\n\n```\nlabs::Salsa20::Salsa20> 2^^256 : Integer\n115792089237316195423570985008687907853269984665640564039457584007913129639936\nlabs::Salsa20::Salsa20> :exhaust quarterroundIsInjectiveProp\nUsing exhaustive testing.\nTesting...     0%\n```\n\nWhile you wait, you should consider just how great automated theorem provers have become. Next, appreciate all the work the folks at Galois have put into Cryptol over the last 20 years\u2026you may even consider sending a thank you note to \u00c9variste (evariste@galois.com). After that, why not go on to the next section? And then the next, and the next\u2026oh just hit Ctrl-C already.\n\n## 4 The rowround function\n\nFrom here on out, this lab requires you to write the rest of Salsa20 by following the specification document. This may seem to you that we\u2019ve become lazy, but we see it as important that you have the opportunity to get your hands dirty. The lab will provide some commentary, type definitions, function stubs, and the example input-output pairs as property statements so you can check your work.\n\n### Inputs and outputs\n\n```cryptol\nrowround : Words 16 -> Words 16\n```\n\n### Definition\n\nEXERCISE: Here we provide a skeleton for rowround. Please replace the undefined symbols with the appropriate logic as given in the Salsa20 specification. You\u2019ll know you\u2019ve gotten it right when it looks like the specification and when `:prove rowroundExamplesProp` gives Q.E.D.\n\n```cryptol\nrowround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =\n    [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]\n  where\n    [ z0,  z1,  z2,  z3] = undefined\n    [ z5,  z6,  z7,  z4] = undefined\n    [z10, z11,  z8,  z9] = undefined\n    [z15, z12, z13, z14] = undefined\n```\n\n### Examples\n\n```cryptol\nproperty rowroundExamplesProp =\n    (rowround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n               0x00000001, 0x00000000, 0x00000000, 0x00000000,\n               0x00000001, 0x00000000, 0x00000000, 0x00000000,\n               0x00000001, 0x00000000, 0x00000000, 0x00000000]\n           == [0x08008145, 0x00000080, 0x00010200, 0x20500000,\n               0x20100001, 0x00048044, 0x00000080, 0x00010000,\n               0x00000001, 0x00002000, 0x80040000, 0x00000000,\n               0x00000001, 0x00000200, 0x00402000, 0x88000100]) \/\\\n    (rowround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n               0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n               0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n               0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a]\n           == [0xa890d39d, 0x65d71596, 0xe9487daa, 0xc8ca6a86,\n               0x949d2192, 0x764b7754, 0xe408d9b9, 0x7a41b4d1,\n               0x3402e183, 0x3c3af432, 0x50669f96, 0xd89ef0a8,\n               0x0040ede5, 0xb545fbce, 0xd257ed4f, 0x1818882d])\n```\n\n### Comments\n\nThe comments in this section hint at an optimized way to perform rowround. Here is one such optimized function:\n\n```cryptol\nrowroundOpt : Words 16 -> Words 16\nrowroundOpt ys =\n    join [ quarterround (yi <<< i) >>> i\n         | yi <- split ys\n         | (i : [2])  <- [0 .. 3] ]\n```\n\nEXERCISE: Here we want to prove that for all inputs, `rowroundOpt` is equal to `rowround`. Please replace the undefined symbol below with such a statement and then prove the property in the interpreter. It\u2019s not necessary to go through this exercise to create a complete Salsa20 specification, but it\u2019s a good opportunity here to learn more about Cryptol\u2019s properties.\n\n```cryptol\nproperty rowroundOptProp ys = undefined\n```\n\n## 4 The columnround function\n\n### Inputs and outputs\n\n```cryptol\ncolumnround : Words 16 -> Words 16\n```\n\n### Definition\n\nEXERCISE: Here we provide a skeleton for columnround. Please replace the undefined symbols with the appropriate logic as given in the Salsa20 specification. You\u2019ll know you\u2019ve gotten it right when it looks like the specification and when `:prove columnroundExamplesProp` gives Q.E.D.\n\n```cryptol\ncolumnround [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15] =\n    [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15]\n  where\n    [ y0,  y4,  y8, y12] = undefined\n    [ y5,  y9, y13,  y1] = undefined\n    [y10, y14,  y2,  y6] = undefined\n    [y15,  y3,  y7, y11] = undefined\n```\n\n### Examples\n\n```cryptol\nproperty columnroundExamplesProp =\n    (columnround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                  0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                  0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                  0x00000001, 0x00000000, 0x00000000, 0x00000000]\n              == [0x10090288, 0x00000000, 0x00000000, 0x00000000,\n                  0x00000101, 0x00000000, 0x00000000, 0x00000000,\n                  0x00020401, 0x00000000, 0x00000000, 0x00000000,\n                  0x40a04001, 0x00000000, 0x00000000, 0x00000000]) \/\\\n    (columnround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n                  0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n                  0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n                  0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a]\n              == [0x8c9d190a, 0xce8e4c90, 0x1ef8e9d3, 0x1326a71a,\n                  0x90a20123, 0xead3c4f3, 0x63a091a0, 0xf0708d69,\n                  0x789b010c, 0xd195a681, 0xeb7d5504, 0xa774135c,\n                  0x481c2027, 0x53a8e4b5, 0x4c1f89c5, 0x3f78c9c8])\n```\n\n### Comments\n\nThe comments in this section say that columnround is:\n\nOne can visualize the input (x0, x1, . . . , x15) as a square matrix\u2026The columnround function is, from this perspective, simply the transpose of the rowround function.\n\nEXERCISE: Here is another property we can prove using Cryptol. The author claims that rejiggering the input and outputs of rowround (in a special way) will cause rowround to produce results identical to columnround. To rejigger we:\n\n- transform the 16-element input sequence into a 4 by 4 element sequence,  \n- transpose this matrix, and  \n- transform the transposed 4 by 4 matrix back into a 16-element sequence.\n\nLuckily Cryptol provides `split`, `transpose`, and `join` to perform these three operations. Please replace the undefined symbol below with an appropriate rejigger function and use it to prove that columnround is the transpose of rowround.\n\n```cryptol\nproperty columnroundIsTransposeOfRowround ys =\n    columnround ys == rejigger (rowround (rejigger ys))\n  where\n    rejigger a = undefined\n```\n\n## 6 The doubleround function\n\n### Inputs and outputs\n\n```cryptol\ndoubleround : Words 16 -> Words 16\n```\n\n### Definition\n\nEXERCISE: Here we provide a skeleton for doubleround. Please replace the undefined symbol with the appropriate logic as given in the Salsa20 specification. You\u2019ll know you\u2019ve gotten it right when it looks like the specification and when `:prove doubleroundExamplesProp` gives Q.E.D.\n\n```cryptol\ndoubleround xs = undefined\n```\n\n### Examples\n\n```cryptol\nproperty doubleroundExamplesProp =\n    (doubleround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                  0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                  0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                  0x00000000, 0x00000000, 0x00000000, 0x00000000]\n              == [0x8186a22d, 0x0040a284, 0x82479210, 0x06929051,\n                  0x08000090, 0x02402200, 0x00004000, 0x00800000,\n                  0x00010200, 0x20400000, 0x08008104, 0x00000000,\n                  0x20500000, 0xa0000040, 0x0008180a, 0x612a8020]) \/\\\n    (doubleround [0xde501066, 0x6f9eb8f7, 0xe4fbbd9b, 0x454e3f57,\n                  0xb75540d3, 0x43e93a4c, 0x3a6f2aa0, 0x726d6b36,\n                  0x9243f484, 0x9145d1e8, 0x4fa9d247, 0xdc8dee11,\n                  0x054bf545, 0x254dd653, 0xd9421b6d, 0x67b276c1]\n              == [0xccaaf672, 0x23d960f7, 0x9153e63a, 0xcd9a60d0,\n                  0x50440492, 0xf07cad19, 0xae344aa0, 0xdf4cfdfc,\n                  0xca531c29, 0x8e7943db, 0xac1680cd, 0xd503ca00,\n                  0xa74b2ad6, 0xbc331c5c, 0x1dda24c7, 0xee928277])\n```\n\n### Comments\n\nThere don\u2019t seem to be any interesting properties to prove here, so we\u2019ll move on.\n\n## 7 The littleendian function\n\n### Inputs and outputs\n\n```cryptol\nlittleendian : Bytes 4 -> [32]\n```\n\n### Definition\n\nEXERCISE: Here we provide a skeleton for littleendian. Please replace the undefined symbol with the appropriate logic as given in the Salsa20 specification. You\u2019ll know you\u2019ve gotten it right when `:prove littleendianExamplesProp` gives Q.E.D.\n\nThis one is a little tricky because the elegant solution does not look like the solution in the paper document. This is because, for example, b0 (an 8-bit value) added to anything can never produce a 32-bit result \u2014 Cryptol enforces that it can only add, multiply, subtract, etc. n-bit things to other n-bit things. So, one solution would be to create new 32-bit variables that are b0 through b3 each padded with 24 zeroes, and then do the arithmetic in the specification. However, there is a much simpler solution. Good luck!\n\n```cryptol\nlittleendian [b0, b1, b2, b3] = undefined\n```\n\n### Examples\n\n```cryptol\nproperty littleendianExamplesProp =\n    (littleendian [  0,   0,   0,   0] == 0x00000000) \/\\\n    (littleendian [ 86,  75,  30,   9] == 0x091e4b56) \/\\\n    (littleendian [255, 255, 255, 250] == 0xfaffffff)\n```\n\n### Comments\n\nAs before, the author notes that this function is invertible and does not provide the inverse. However, this undefined littleendian inverse function is used in the next section! So, we will have to define it here. There\u2019s one hiccup though, the littleendian function works on 4-byte sequences, but littleendian inverse has to work on 4-byte and 8-byte sequences, so we\u2019ve defined the type of the function to work on n-byte sequences.\n\nEXERCISE: Here we provide a skeleton for littleendian', the inverse to littleendian. Please replace the undefined symbol with the appropriate logic such that `:prove littleendianInverseProp` gives Q.E.D.\n\n```cryptol\nlittleendian' : {n} (fin n) => [n*8] -> Bytes n\nlittleendian' w = undefined\n\nproperty littleendianInverseProp b = littleendian' (littleendian b) == b\n```\n\n## The Salsa20 hash function\n\nFrom The Salsa20 core (Bernstein):\n\nI originally introduced the Salsa20 core as the \u201cSalsa20 hash function,\u201d but this terminology turns out to confuse people who think that \u201chash function\u201d means \u201ccollision-resistant compression function.\u201d The Salsa20 core does not compress and is not collision-resistant.\n\nSo, given that the original author has reconsidered this nomenclature, even though the specification itself still refers to the Salsa20 core as a hash function and has not been amended, here we choose to go with the times and name this function Salsa20Core.\n\n### Inputs and outputs\n\n```cryptol\nSalsa20Core : Bytes 64 -> Bytes 64\n```\n\n### Definition\n\nThis function is more complicated than ones we\u2019ve seen so far, but operation can be simply described in four steps:\n\n1. map littleendian over chunks of the 64-byte sequence x, creating a 16-word sequence xs.  \n2. iterate doubleround 10 times, starting with the 16 words from step 1.  \n3. Add together the values produced in step 1 to step 2.  \n4. map littleendian' over 16-word sequence from step 3, creating a 64-byte sequence x'.\n\nEXERCISE: Here we provide a skeleton for Salsa20Core. Please replace the undefined symbol with the appropriate logic such that `:prove Salsa20CoreExamplesProp` gives Q.E.D.\n\n```cryptol\nSalsa20Core x = x'\n  where\n    \/\/ Step 1\n    xs    = undefined : [16][32]\n    \/\/ Step 2\n    zs    = undefined : [16][32]\n    \/\/ Step 3\n    xspzs = undefined : [16][32]\n    \/\/ Step 4\n    x'    = undefined\n```\n\n### Examples\n\n```cryptol\nproperty Salsa20CoreExamplesProp =\n    (Salsa20Core [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]\n              == [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]) \/\\\n    (Salsa20Core [211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37, 191, 187, 234, 136,\n                   49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,  86,  16, 179, 207,\n                   31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113, 238,  55, 204,  36,\n                   79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,  88, 118, 104,  54]\n              == [109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,  26, 110, 170, 154,\n                   29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,  69, 144,  51,  57,\n                  118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35,  27, 111, 114, 114,\n                  219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158, 179,  19,  48, 202]) \/\\\n    (Salsa20Core [ 88, 118, 104,  54,  79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,\n                  191, 187, 234, 136, 211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37,\n                   86,  16, 179, 207,  49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,\n                  238,  55, 204,  36,  31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113]\n              == [179,  19,  48, 202, 219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158,\n                   26, 110, 170, 154, 109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,\n                   69, 144,  51,  57,  29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,\n                   27, 111, 114, 114, 118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35])\n```\n\n### Comments\n\nNothing of consequence.\n\n## The Salsa20 expansion function\n\n### Inputs and outputs\n\nThis is our first polymorphic function (well, the first one of consequence). A polymorphic function is one that can take more than one type of input. In this case, we have to take two different types of k \u2014 one that is a 32-byte sequence and one that is a 16-byte sequence. Here we create a type variable `a` such that when `a` is 1, the function expects a 16-byte k and when it\u2019s 2, the function expects a 32-byte k. We also constrain k (using type constraints) to only be able to take on the value 1 or 2.\n\n```cryptol\nSalsa20Expansion :\n    {a}\n    (a >= 1, 2 >= a) =>\n    Bytes (16*a) -> Bytes 16 -> Bytes 64\n```\n\n### Definition\n\nThis definition is even trickier than the last because we have to account for the two different sizes of k. If a is 2 then we have to call `Salsa20Core(s0, k0, s1, n, s2, k1, s3)` where `k0` are the low 16 bytes of k and `k1` are the high 16 bytes of k. In the case where a is 1 then we have to call `Salsa20Core(t0, k0, t1, n, t2, k0, t3)`, and k1 is undefined. There are a few different ways to define k0 and k1. This is, admittedly, often the most frustrating part of specifying Salsa20Expansion. If you\u2019re up for figuring it out, please do, but you won\u2019t be faulted for skipping the headache and checking the answer key (3 different definitions are provided there).\n\nThe notation the author used here is also a little strange \u2014 you\u2019ll notice that Salsa20Core doesn\u2019t actually take 7 different values as input. The author means, for example, when a is 1 that t0, k, t1, n, t2, k, and t3 should be concatenated together to make a sequence of 64-bytes.\n\nAs well, you\u2019ll need to access the type variable a. Here we quote from Programming Cryptol, (A Crash Course in Cryptol, Type context vs. variable context):\n\nYou have seen, in the discussion of type variables above, that Cryptol has two kinds of variables \u2014 type variables and value variables. Type variables normally show up in type signatures, and value variables normally show up in function definitions. Sometimes you may want to use a type variable in a context where value variables would normally be used. To do this, use the backtick character `` ` ``.\n\nThe definition of the built-in length function is a good example of the use of backtick:\n\n```cryptol\nlength : {n, a, b} (fin n, Literal n b) => [n]a -> b\nlength _ = `n\n```\n\nYou\u2019ll find sigma and tau defined in a kind of fancy way in the Comments section below.\n\nEXERCISE: Here we provide a skeleton for Salsa20Expansion. Please fill in the definition of the function such that `:prove Salsa20ExpansionExamplesProp` gives Q.E.D. You\u2019ll likely want to add a where clause as well.\n\n```cryptol\nSalsa20Expansion k n = undefined\n```\n\n### Examples\n\n```cryptol\nproperty Salsa20ExpansionExamplesProp =\n    (Salsa20Expansion (k0#k1) n ==\n    [ 69,  37,  68,  39,  41,  15, 107, 193, 255, 139, 122,   6, 170, 233, 217,  98,\n      89, 144, 182, 106,  21,  51, 200,  65, 239,  49, 222,  34, 215, 114,  40, 126,\n     104, 197,   7, 225, 197, 153,  31,   2, 102,  78,  76, 176,  84, 245, 246, 184,\n     177, 160, 133, 130,   6,  72, 149, 119, 192, 195, 132, 236, 234, 103, 246,  74]) \/\\\n    (Salsa20Expansion k0 n ==\n    [ 39, 173,  46, 248,  30, 200,  82,  17,  48,  67, 254, 239,  37,  18,  13, 247,\n     241, 200,  61, 144,  10,  55,  50, 185,   6,  47, 246, 253, 143,  86, 187, 225,\n     134,  85, 110, 246, 161, 163,  43, 235, 231,  94, 171,  51, 145, 214, 112,  29,\n      14, 232,   5,  16, 151, 140, 183, 141, 171,   9, 122, 181, 104, 182, 177, 193])\n  where\n    k0 = [1 .. 16]\n    k1 = [201 .. 216]\n    n  = [101 .. 116]\n```\n\n### Comments\n\nThe Definition section of the Salsa20 specification gives integer values for sigma and tau. While it\u2019s possible to write them out that way, it looks much nicer to define them as below, corresponding to the ASCII strings given in the Comments section of the specification.\n\n```cryptol\n[s0, s1, s2, s3] = split \"expand 32-byte k\"\n[t0, t1, t2, t3] = split \"expand 16-byte k\"\n```\n\n## The Salsa20 encryption function\n\n### Inputs and outputs\n\nAgain we have a polymorphic function on k. Also notice the type constraint levied on l. This really shows Cryptol\u2019s strength as a specification language. Cryptol isn\u2019t powerful enough to actually run 2^^70 bytes through this function, but the constraint can still be expressed, if only for documentation purposes.\n\n```cryptol\nSalsa20Encrypt :\n    {a, l}\n    (a >= 1, 2 >= a, l <= 2^^70) =>\n    Bytes (16*a) -> Bytes 8 -> Bytes l -> Bytes l\n```\n\n### Definition\n\nThe only real trouble you may have with this function (and believe that expert cryptographers have messed it up) is that i needs to be expressed in little-endian, and Cryptol\u2019s bitvectors are natively in big-endian. So, feel free to use the overloaded littleendian' function from Section 7.\n\nSome hints:\n\n- Where the specification says \u201ctruncate\u201d think `take`.  \n- Don\u2019t be afraid to take from an implicitly constructed 2^^70 byte sequence.  \n- Salsa20Expansion returns a sequence of 64-bytes, so a `join` is needed if you want to create the sequence of 2^^70 bytes.  \n- `v` and `i` should be concatenated to be passed to Salsa20Expansion.\n\n```cryptol\nSalsa20Encrypt k v m = c\n  where\n    c = m ^ undefined\n```\n\n### Examples\n\nIt\u2019s a little strange to get to the main encryption function in a specification and find that the test vectors are missing. It\u2019s more often the other way around where test vectors are provided for the main function but not for anything else.\n\nTurns out there were official test vectors on ECRYPT, but that the link is now defunct. It doesn\u2019t seem to be that big of a loss because the test vectors really didn\u2019t test all the functionality of Salsa20Encrypt because they all took a message of entirely zeroes as input. This makes it difficult to know if you\u2019re processing an actual message correctly.\n\nSo, here we decided to take two of the test vectors from the defunct site and rework them with a random message, simply so that you can test your Salsa20Encrypt function against them.\n\n```cryptol\nproperty Salsa20EncryptExamplesProp =\n    (Salsa20Encrypt [0x00, 0x53, 0xa6, 0xf9, 0x4c, 0x9f, 0xf2, 0x45,\n                     0x98, 0xeb, 0x3e, 0x91, 0xe4, 0x37, 0x8a, 0xdd]\n                    [0x0d, 0x74, 0xdb, 0x42, 0xa9, 0x10, 0x77, 0xde]\n                    [0x46, 0x82, 0x39, 0x77, 0xf3, 0x81, 0xae, 0xd3,\n                     0x53, 0x45, 0x2c, 0x2f, 0xf2, 0x10, 0xfd, 0xfa,\n                     0x11, 0x44, 0x74, 0x3d, 0x23, 0xf1, 0xf0, 0xdb,\n                     0x6e, 0x99, 0x86, 0x73, 0xba, 0x23, 0xee, 0xfb,\n                     0xff, 0xde, 0xc0, 0x35, 0x03, 0x31, 0x47, 0x70,\n                     0x6d, 0x58, 0x38, 0x88, 0x2d, 0xa7, 0x66, 0xb8,\n                     0x2d, 0xb5, 0x88, 0xa0, 0x19, 0x76, 0x92, 0xcd,\n                     0x32, 0x24, 0x5b, 0xcc, 0x9d, 0xba, 0x2d, 0x2e]\n                 == [0x43, 0x63, 0xde, 0xc9, 0x45, 0x16, 0x77, 0x4a,\n                     0x36, 0x2e, 0xdf, 0x53, 0xe9, 0x87, 0x75, 0xfc,\n                     0x62, 0x19, 0x7f, 0xad, 0x19, 0x91, 0xf7, 0x66,\n                     0x5c, 0x00, 0xa1, 0x9c, 0x04, 0x38, 0xe0, 0xd1,\n                     0x7e, 0xe9, 0x01, 0x9b, 0x2a, 0x25, 0xd4, 0xda,\n                     0xee, 0xf0, 0x19, 0xfd, 0x76, 0x49, 0x6d, 0xbe,\n                     0xe0, 0xa1, 0x0d, 0xfa, 0x7e, 0x92, 0xf5, 0xce,\n                     0xd9, 0xdc, 0xa8, 0xdd, 0xd6, 0xe2, 0x61, 0x94]) \/\\\n    (Salsa20Encrypt [0x0a, 0x5d, 0xb0, 0x03, 0x56, 0xa9, 0xfc, 0x4f,\n                     0xa2, 0xf5, 0x48, 0x9b, 0xee, 0x41, 0x94, 0xe7,\n                     0x3a, 0x8d, 0xe0, 0x33, 0x86, 0xd9, 0x2c, 0x7f,\n                     0xd2, 0x25, 0x78, 0xcb, 0x1e, 0x71, 0xc4, 0x17]\n                    [0x1f, 0x86, 0xed, 0x54, 0xbb, 0x22, 0x89, 0xf0]\n                    [0x5f, 0xb7, 0x9d, 0xab, 0xec, 0x06, 0x21, 0xd8,\n                     0x76, 0x1e, 0x37, 0x00, 0x86, 0xfe, 0x0a, 0xea,\n                     0x0b, 0x4e, 0x92, 0x19, 0x27, 0x1f, 0x6a, 0x24,\n                     0xda, 0x29, 0xe6, 0x87, 0x9b, 0x8b, 0x8a, 0x72,\n                     0xb7, 0xa2, 0xae, 0x2b, 0x52, 0x9e, 0x82, 0x15,\n                     0x89, 0xd0, 0x0a, 0xf9, 0x3b, 0xcf, 0x9e, 0x4f,\n                     0x76, 0x6b, 0xff, 0x8b, 0x29, 0x57, 0xd5, 0x38,\n                     0x7d, 0x8c, 0x22, 0x88, 0x38, 0x18, 0x26, 0x4c]\n                 == [0x60, 0x5f, 0xc0, 0xf0, 0x5d, 0x90, 0x2b, 0x5a,\n                     0x3e, 0x15, 0x69, 0x6f, 0xc8, 0x68, 0x50, 0xae,\n                     0x6b, 0x99, 0x37, 0x5c, 0x26, 0x79, 0x25, 0x59,\n                     0xba, 0x9c, 0xad, 0x81, 0x8b, 0x81, 0xbd, 0x8d,\n                     0x6b, 0x54, 0x13, 0xce, 0x9c, 0xa1, 0xca, 0x93,\n                     0x33, 0xa7, 0xd7, 0xa2, 0x7f, 0x26, 0xc8, 0x0b,\n                     0x92, 0x61, 0x75, 0x4d, 0x71, 0x56, 0xc0, 0x65,\n                     0xc4, 0x83, 0x20, 0xda, 0x13, 0x7c, 0x66, 0x6f])  \n```","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/weaversa.github.io\/cryptol-course\/labs\/CryptoProofs\/CryptoProofs.html","filetype":"txt","content":"## Exploring Cryptography with Cryptol\u2019s Proof Tools\n\n### 1. DES\n\nTo start, we\u2019ll analyze the DES (Data Encryption Standard) algorithm. Let\u2019s take a moment to familiarize ourselves with how it works.\n\nFirst, we import it.\n\n```cryptol\nimport specs::Primitive::Symmetric::Cipher::Block::DES\n```\n\nWhen you loaded the labs::CryptoProofs::CryptoProofs module, these lines should have been printed:\n\nLoading module Cryptol  \nLoading module specs::Primitive::Symmetric::Cipher::Block::Cipher  \nLoading module specs::Primitive::Symmetric::Cipher::Block::DES  \nLoading module labs::CryptoProofs::CryptoProofs  \n\nIn reverse order: the last line says that this module has been loaded. Since it imported the DES module, Cryptol helpfully tells you that DES has been loaded. Since DES imported the Cipher module, Cryptol tells you that too.\n\nNext, we\u2019ll take a look at the type of the DES encryption function.\n\n```\nlabs::CryptoProofs::CryptoProofs> :t DES.encrypt\nDES.encrypt : [64] -> [64] -> [64]\n```\n\nDES takes two 64-bit values and returns a 64-bit value. (The key comes first and then the plaintext.) Let\u2019s encrypt something with DES.\n\n```\nlabs::CryptoProofs::CryptoProofs> DES.encrypt 0x752979387592cb70 0x1122334455667788\n0xb5219ee81aa7499d\n```\n\nNow decrypt:\n\n```\nlabs::CryptoProofs::CryptoProofs> DES.decrypt 0x752979387592cb70 0xb5219ee81aa7499d\n0x1122334455667788\n```\n\nNow that we have DES working, let\u2019s analyze it!\n\n### 2. Five Killer Apps\n\nFor the rest of the lab, we\u2019ll be looking at some of the types of questions you can ask (and often answer!) using Cryptol\u2019s powerful automated theorem proving capabilities. These are important questions that one might ask about a cryptographic algorithm along with a generic \u201cone-liner\u201d Cryptol invocation. (Don\u2019t worry if you don\u2019t understand these yet.)\n\n| Proof              | Invocation                          |\n|--------------------|-----------------------------------|\n| Function reversal  | :sat \\x -> f x == y                |\n| Proof of inversion | :prove \\x -> g (f x) == x          |\n| Proof of injectivity | :prove \\x y -> x != y ==> f x != f y |\n| Collision detection | :sat \\x y -> f x == f y \/\\ x != y  |\n| Equivalence checking | :prove \\x -> f x == g x            |\n\nEach subsection below will explore one of these questions in-depth.\n\n### 2.1 Function Reversal\n\nIt may be interesting to explore whether a particular cryptographic function can be reversed. Some examples of usage:\n\n- Attempt to reverse a hash function. This is called a preimage attack. (Of course, strong cryptographic hash functions are designed to resist this type of analysis.)\n- Carry out decryption when all you have is the encryption function.\n- In general, find an input given an output!\n\nWe\u2019ll start with an example where we reverse the following simple function:\n\n```cryptol\n\/** square - multiplies an Integer by itself *\/\n\nsquare : Integer -> Integer\nsquare x = x * x\n```\n\nNow we can reverse it from the REPL. Let\u2019s use the solver to find a square root using only a squaring function!\n\n```\nlabs::CryptoProofs::CryptoProofs> :sat \\x -> square x == 1764\nSatisfiable\n(\\x -> square x == 1764) 42 = True\n(Total Elapsed Time: 0.021s, using \"Z3\")\n```\n\nLet\u2019s take a closer look at this query, which makes use of a lambda (anonymous\/unnamed\/on-the-fly) function. Here\u2019s the breakdown:\n\n| Function Reversal     |                 |               |                    |\n|----------------------|-----------------|---------------|--------------------|\n| :sat                 | \\x              | ->            | square x == 1764   |\n| \u201cHey SAT solver!\u201d      | \u201cDoes there exist an x\u201d | \u201csuch that\u201d | \u201cx squared equals 1764?\u201d |\n\nFor more information on lambda functions in Cryptol, see Section 1.13.3 of Programming Cryptol.\n\n#### EXERCISE: 2.1.1 Reverse DES.encrypt\n\nGiven the following key and ciphertext, find the plaintext using only the solver and the DES.encrypt function. To do this, head over to the Cryptol interpreter, load up the module, and use the :sat command similar to the example above.\n\n```cryptol\nknown_key = 0x752979387592cb70\nknown_ct = 0xf2930290ea4db580\n```\n\nNote: For whatever reason, the default Z3 solver has trouble with this one. Try one of the other solvers, such as YICES:\n\n```\nlabs::CryptoProofs::CryptoProofs> :s prover=yices\n```\n\nOr use all the installed solvers in a first-to-the-post race. Caution! May exhaust system resources.\n\n```\nlabs::CryptoProofs::CryptoProofs> :s prover=any\n```\n\n#### EXERCISE: 2.1.2 Breaking DES\n\nGiven the following matched plaintext and ciphertext, ask the solver to find the key. Will this work? Why or why not? (Hint: see plaintext.) Note that you can stop the solver at any time by hitting ctrl-c.\n\n```cryptol\nmatched_pt = join \"tootough\"\nmatched_ct = 0x95d07f8a72707733\n```\n\nTo make this solvable, try it again with the first six bytes of key provided: 0x1234567890ab.\n\n### 2.2 Proof of Inversion\n\nFor symmetric ciphers, it is necessary that the decrypt function inverts the encrypt function. (That is, it restores the ciphertext to the original plaintext.) It is easy to express this property in Cryptol.\n\nConsider the following functions f and g:\n\n```cryptol\nf: Integer -> Integer\nf x = 3 * x + 2\n\ng: Integer -> Integer\ng x = (x - 2) \/ 3\n```\n\nWe want to prove that function g inverts function f; that is, applying g to the result of f x gets x back. Here\u2019s the invocation:\n\n```\nlabs::CryptoProofs::CryptoProofs> :prove \\x -> g (f x) == x\nQ.E.D.\n(Total Elapsed Time: 0.023s, using \"Z3\")\n```\n\nHere\u2019s the breakdown of this proof:\n\n| Proof of Inversion    |                 |               |                |\n|----------------------|-----------------|---------------|----------------|\n| :prove               | \\x              | ->            | g (f x) == x   |\n| \u201cProve to me\u201d         | \u201cthat for all x\u201d | \u201cit is true that\u201d | \u201cg inverts f\u201d  |\n\n#### EXERCISE: 2.2.1 The other direction\n\nOur example proof showed that g inverts f for all inputs. Does this work the other way around? Try it! If the proof fails, it will provide a counterexample. Use the counterexample to understand what went wrong.\n\n#### EXERCISE: 2.2.2 DES inversion\n\nUse Cryptol to prove that DES.encrypt and DES.decrypt are inverses for all possible inputs. Show both directions.\n\nHint: Lambda functions can take more than one input, just like normal functions! For example: \\x y z -> x + y + z\n\nHint: For fastest results, use the abc prover.\n\n### 2.3 Proof of Injectivity\n\nA function for which every input generates a distinct output is referred to in mathematics as injective (one-to-one). Cryptol can be used to prove that a function is injective.\n\n#### EXERCISE: 2.3.1 DES Injectivity\n\nShow that, for any given key, DES.encrypt is injective (collision-free) with respect to plaintext.\n\nTechnically, DES.encrypt (for any given key) is also surjective (onto) due to the fact that its domain and range are the same (The set of all possible 64-bit vectors.) A function that is both injective and surjective is called bijective.\n\nHint: Use the Boolector prover. (Even then, this proof may take a few minutes!)\n\nHint: Consider using the implication operator ==>\n\n### 2.4 Collision Detection\n\nIn cryptography, a collision occurs when two different inputs produce the same output. (That is, the function is not injective.) For some cryptographic functions, such as pseudo-random number generators (PRNGs), it may be desirable to demonstrate an absence of collisions. In other functions, such as cryptographic hash functions, collisions are inevitable, but should be difficult to discover. It is easy in Cryptol to ask the solver to search for collisions. (Though finding a solution may not be possible.)\n\n#### EXERCISE: 2.4.1 DES Key Collisions\n\nUse the solver to find two different keys and a single plaintext such that both keys encrypt that plaintext to the same ciphertext.\n\n### 2.5 Equivalence Checking\n\nIt\u2019s inevitable that there are collisions over the set of all key\/plaintext pairs in DES, but it may be surprising that they\u2019re easy to find with Cryptol\u2019s solver. We now know that the two keys you just found encrypt one particular plaintext to the same ciphertext; more concerning would be if they perform the same transformation on all plaintexts. Such keys are called equivalent keys.\n\nOne of the most powerful uses of Cryptol\u2019s theorem proving technology is the ability to show equivalence of two different functions for all possible inputs.\n\n#### EXERCISE: 2.5.1 DES Equivalent Keys\n\nProve that the two keys you just found are equivalent keys. That is, prove that these two keyed DES functions are equivalent for all plaintext inputs.\n\nHint: Use the abc prover.\n\n#### EXERCISE: 2.5.2 DES Parity Bits\n\nHaving equivalent keys is often considered a weakness in a cipher. However, in the case of DES, it turns out that this is a result of a design choice. The lowest bit of each byte of a DES key is actually a parity bit that is completely ignored by the cipher itself. For DES, the parity bit ensures that the total number of 1-bits in each byte is odd.\n\nWrite a function DESFixParity : [64] -> [64] that takes any 64-bit vector and returns the equivalent DES key with properly computed parity bits. (This is the first and only time in this lab that you\u2019ll need to edit this file directly.)\n\n```cryptol\nDESFixParity : [64] -> [64]\nDESFixParity key = undefined  \/\/ Replace \"undefined\" with your code\n```\n\n#### EXERCISE: 2.5.3 Proving DES Key Equivalence\n\nUse the function DESFixParity that you wrote above to show that DES completely ignores parity bits. That is, prove that the DES encryption that allows all 64-bit keys is equivalent to the DES encryption function that first corrects the parity bits on those keys.\n\nGiven that this proof passes, what is the actual maximum key strength of DES in terms of bits?","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/weaversa.github.io\/cryptol-course\/labs\/KeyWrapping\/KeyWrapping.html","filetype":"txt","content":"## Writing Key Wrapping Routines in Cryptol\n\nThis lab takes the student through developing wrapping algorithms described in NIST Special Publication 800-38F \u201cRecommendation for Block Cipher Modes of Operation: Methods for Key Wrapping\u201d. We recommend you have this lab and the specification document open side-by-side.\n\nHere is the abstract from this document:\n\nThis publication describes cryptographic methods that are approved for \u201ckey wrapping,\u201d i.e., the protection of the confidentiality and integrity of cryptographic keys. In addition to describing existing methods, this publication specifies two new, deterministic authenticated-encryption modes of operation of the Advanced Encryption Standard (AES) algorithm: the AES Key Wrap (KW) mode and the AES Key Wrap With Padding (KWP) mode. An analogous mode with the Triple Data Encryption Algorithm (TDEA) as the underlying block cipher, called TKW, is also specified, to support legacy applications.\n\nIn this lab we will focus on developing the three main algorithms \u2013 KW, TKW, and KWP \u2013 by building up the necessary subcomponents. In fact each of these is a family of algorithms: KW is composed of an authenticated encryption component KW-AE and an authenticated decryption component KW-AD; similarly for TKW and KWP.\n\n## Preliminaries\n\nThe NIST Special Publications 800 Series provides information of interest to the computer security community. The series comprises guidelines, recommendations, technical specifications, and annual reports of NIST\u2019s cybersecurity activities.\n\nReading through and implementing a formal specification in Cryptol for one of the cryptography standards in this series can be a challenge. The standards are written by a variety of authors and the algorithms are often described in one-off language-agnostic pseudo code which we have to parse. This translation process can lead to subtle implementation errors or potentially false assumptions about the algorithms which can be hard to spot.\n\nOur job is to extract the relevant details from the specification and build Cryptol specifications for the three main algorithms listed above.\n\n## Getting Started\n\nThe Key Wrapping algorithms described in this document are a form of Block Cipher Mode for an existing block cipher. Section 5.1 (p. 8) of the standard indicates:\n\nFor KW and KWP, the underlying block cipher shall be approved, and the block size shall be 128 bits. Currently, the AES block cipher, with key lengths of 128, 192, or 256 bits, is the only block cipher that fits this profile. For TKW, the underlying block cipher is specified to be TDEA, and the block size is therefore 64 bits; the KEK for TKW may have any length for which TDEA is approved; see [8].\n\nThat is, KW (and KWP) are defined to operate with AES for its three key sizes: 128, 192, and 256 bits.\n\nThe standard does not indicate a specific key size for TDEA, but TDEA\/Triple-DES is typically used with a 192-bit key and that is what we will develop later in this lab.\n\nAlso, we will not develop AES or TDEA in this lab. Instead we will use pre-written modules which provide these block cipher primitives. The algorithms are found under the specs\/ directory in specs\/Primitive\/Symmetric\/Cipher\/Block and we import them into our module with the following:\n\n```cryptol\nimport specs::Primitive::Symmetric::Cipher::Block::AES_parameterized as AES\nimport specs::Primitive::Symmetric::Cipher::Block::TripleDES as TDEA\n```\n\nCryptol modules must match the directory structure they reside in. Using descriptive names as we do here is a good way to organize related algorithms by type, function, or whatever works for your system.\n\nNow is a good time to scan through the specification document and get a sense of the overall organization:\n\n- Sections 1 - 3, Purpose, Authority, and Introduction \u2013 These sections provide background, usage, and cryptographic function of the algorithms described in this document. This information is good background if we were trying to decide how to use these algorithms; however we will not need to reference this information to build our specifications. Feel free to skim through this material or skip for now.\n\n- Section 4, Definitions and Notation \u2013 This section contains important definitions, acronyms, variables, and operations used in this standard. Let\u2019s scan through this to see if we find anything useful\u2026\n\n- Section 4.3 provides some constants ICV1, ICV2, and ICV3 which are defined to have special values.\n\n```\nICV1 = 0xA6A6A6A6A6A6A6A6\nICV2 = 0xA65959A6\nICV3 = 0xA6A6A6A6\n```\n\n- Section 4.4 introduces operators and notation for cryptographic functions and their building blocks. We have already imported the required block ciphers and we will be building some of these for ourselves. For the remainder, Cryptol provides analogous functionality to us in some fashion or another.\n\n## EXERCISE: Fill in definitions for the operators given in Section 4.4.\n\nUse the properties defined in Section 4.5 (also given below) to show that your answers are correct.\n\n```cryptol\n\/\/ 0^^s -- The bit string that consists of s consecutive '0' bits.\n\/\/ 0 : [s]\n\n\/**\n * The integer for which the bit string X is the binary\n * representation.\n *\/\nint X = undefined\n\n\/**\n * The bit length of bit string X.\n *\/\nlen X = undefined\n\n\/**\n * The bit string consisting of the s right-most bits\n * of the bit string X.\n *\/\nLSB : {s, a} (fin s, fin a, a >= s) => [a] -> [s]\nLSB X = undefined\n\n\/**\n * The bit string consisting of the s left-most bits of\n * the bit string X.\n *\/\nMSB : {s, a} (fin s, a >= s) => [a] -> [s]\nMSB X = undefined\n\n\/\/ [x]s -- The binary representation of the non-negative integer\n\/\/         x as a string of s bits, where x < 2^^s.\n\/\/ fromInteger transforms an Integer into a bitvector.\n\n\/\/ The bitwise exclusive-OR of bit strings X and Y whose bit\n\/\/ lengths are equal.\n\/\/ X ^ Y\n\n\/\/ The concatenation of bit strings X and Y\n\/\/ X # Y\n```\n\n## Section 4.5 contains properties of the operators given in Section 4.4.\n\n```cryptol\nproperty hexadecimalProp = 0xA659 == 0b1010011001011001\n\nproperty zeroBitsProp = (0 : [8]) == 0b00000000\n\nproperty concatenationProp = 0b001 # 0b10111 == 0b00110111\n\nproperty XORProp = 0b10011 ^ 0b10101 == 0b00110\n\nproperty lenProp = len 0b00010 == 5\n\nproperty LSBProp = LSB`{3} 0b111011010 == 0b010\n\nproperty MSBProp = MSB`{4} 0b111011010 == 0b1110\n\nproperty bitstringProp = fromInteger 39 == 0b00100111\n\nproperty intProp = int 0b00011010 == 26\n```\n\n## Formal Specification of KW\n\nKW is a family of algorithms comprised of KW-AE and KW-AD. We start with KW-AE.\n\n### Building a Formal Specification for KW-AE\n\nLet\u2019s take a look at writing a specification for the KW-AE which is presented in Section 6. We\u2019ll call our function KWAE in Cryptol because we cannot use the dash\/minus sign when naming functions.\n\nThe document indicates that KW-AE depends on a wrapping function W (Algorithm 1, page 11). This algorithm has certain prerequisites which we will have to model in our formal specification:\n\n- A Key Encryption Key (KEK) K and  \n- A designated cipher function CIPHk, which operates on 128-bit blocks\n\nThe document defines a semiblock to be a block with half the width of the underlying block cipher, CIPHk. Since KW-AE uses AES as its CIPHk, semiblocks will be 64-bit blocks. Also notice that the specification for W defines the Input to be a string S of n semiblocks and the Output will be a transformed string C of n semiblocks. W was previously defined in Section 4.4 to take a bitstring, not a sequence of semiblocks, so we will write W to consume bitstrings, but we will have to split W into semiblocks internally. We now have enough to build a simple type signature for W which will contain the following components:\n\n- n \u2013 A type parameter which controls the number of semiblocks in our inputs and outputs  \n- ([128] -> [128]) \u2013 The type of our keyed block cipher CIPHk  \n- [n * 64] \u2013 The type of our string of input semiblocks  \n- [n * 64] \u2013 The type of our transformed output  \n\nPutting these together we have our preliminary type signature:\n\n```cryptol\nW_prelim :\n  {n}\n  (fin n) =>\n  ([128] -> [128]) -> [n * 64] -> [n * 64]\n```\n\nWe haven\u2019t quite captured enough about the type of W \u2013 for the algorithm to operate correctly, and according to the standard, we will have to add two more constraints on n, namely, that n >= 3 and fin n.\n\n```cryptol\nW :\n  {n}\n  (fin n, 3 <= n) =>\n  ([128] -> [128]) -> [n * 64] -> [n * 64]\n```\n\nTaking a close look at Algorithm 1 we can see that W\u2019s step 2 transforms its inputs over a series of s rounds. It will make our job easier to model this step of the function first. Also, it may help to understand this step by studying Figure 2 on page 12.\n\nWStep2 will inherit the same type parameters, inputs, and outputs as W. We add a new input t of type Integer which serves as the round counter found in step 2 of Algorithm 1. We also use pattern matching to pull out specific entries in the sequence of semiblocks, i.e., ([A, R2] # Rs) gives names to the first two semiblocks of the input.\n\n## EXERCISE: Study Algorithm 1 and Figure 2 and implement WStep2.\n\n```cryptol\nWStep2:\n    {n}\n    (fin n, n >= 3) =>\n    ([128] -> [128]) -> [n][64] -> Integer -> [n][64]\nWStep2 CIPHk ([A, R2] # Rs) t = [A'] # Rs # [Rn]\n  where\n    A'  = undefined\n    Rn  = undefined\n```\nNote: Pattern matching (a kind of shorthand) is used for one of the parameters to WStep2. According to the type signature, the second parameter is of type [n][64] \u2013 a sequence of semiblocks. In the definition of WStep2 we see that this parameter is identified as ([A, R2] # Rs). Cryptol assigns the first semiblock to A, the second semiblock to R2, and all the remaining semiblocks to Rs. Since we have the type parameter condition n >= 3 we know that there are at least three such blocks to assign, and at least one will be assigned to Rs.\n\nObservation: It\u2019s possible that requiring n >= 3 is a mistake. We say this because (and you can test this) Cryptol also accepts the definitions of W and WStep2 with type constraint n >= 2 instead of n >= 3. In the case where n == 2, Rs is simply the empty sequence. Unfortunately, this and the use of 1-based indexing (starting t at 1) causes reverberations throughout the rest of the specification, culminating in a more-complex-than-necessary KWP function.\n\nGiven WStep2, it is a simple matter to complete the definition for W that we started above. But first we take a quick aside to recall the foldl operator which will come in very handy.\n\n## A Quick Aside on foldl\n\nfoldl is a Cryptol Primitive and higher order function which is useful for (among other things) extracting the final state from some iterative process.\n\nThe signature for foldl is as follows:\n\n```cryptol\nfoldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\n```\n\nWe see that foldl takes as inputs the following data:\n\n- A function of type (a -> b -> a) which transforms a \u201cstate\u201d of type a into a new one by processing an element of type b  \n- An element of type a (an initial state value)  \n- A sequence of elements of type b  \n\nOne application for foldl is to access the final element of some iterative process. For instance, we could find a list of partial sums from the sequence [1..10] as follows:\n\n```cryptol\nsums where sums = [0] # [ x + partial | x <- [1..10] | partial <- sums ]\n```\nproduces:  \n[0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55]\n\nHowever, if we are only interested in the final element of this sequence, then we can use foldl as follows:\n\n```cryptol\nfoldl (+) 0 [1..10]\n```\nwhich produces:  \n55\n\n\u2026we now return to our regularly scheduled program.\n\nWe will use foldl along with our step function WStep2 to write a definition for W.\n\n## EXERCISE: Complete the definition of W below by filling in the function skeleton provided.\n\n```cryptol\nW :\n    {n}\n    (fin n, 3 <= n) =>\n    ([128] -> [128]) -> [n * 64] -> [n * 64]\nW CIPHk S = join C\n  where\n    type s = 6 * (n-1)\n    S'     = split`{n} S\n    C      = foldl (WStep2 CIPHk) undefined [1..s]\n```\n\nWith W in hand there it isn\u2019t much more work to complete the KW-AE algorithm.\n\n## EXERCISE: Study Algorithm 3 and complete the specification for KW-AE by filling in the snippet below with the correct definition for S and C. Remember that ICV1 was defined earlier in this module. Also, notice that the bounds from Table 1 (Section 5.3.1, page 10) are included as type constraints.\n\n```cryptol\nKWAE :\n    {n}\n    (fin n, 2 <= n, n < 2^^54) =>\n    ([128] -> [128]) -> [n * 64] -> [(n+1) * 64]\nKWAE CIPHk P = C\n  where\n    S = undefined\n    C = undefined\n```\n\nAt this point you can check your work against six test vectors given in a property defined later on in this document. Here is the command and sample output for KWAETests.\n\n```cryptol\nlabs::KeyWrapping::KeyWrapping> :check KWAETests\nUsing exhaustive testing.\nPassed 1 tests.\nQ.E.D.\n```\n\n## Building a Formal Specification for KW-AD\n\nIt should be fairly straightforward at this point to implement the authenticated decryption function KW-AD which is the other algorithm in the KW family. There is one significant difference, though: since the algorithm authenticates the decryption we will need to add an authentication check and slightly alter the type for KW-AD.\n\n## EXERCISE: Review Algorithm 2 and Figure 3 of the document and complete the definitions for the inverse routines to W and WStep2 which we shall call W' and WStep2' respectively. The type declarations for these functions are provided.\n\nHint: Notice that, except for the names, the type declarations are identical. The function definitions are also very similar. Pay special attention to the order of the index variable for the main loop, the sequence of operations, and how the sequence of Rs transforms:\n\n```cryptol\nWStep2' :\n    {n}\n    (fin n, n >= 3) =>\n    ([128] -> [128]) -> [n][64] -> Integer -> [n][64]\nWStep2' CIPHk' ([A] # Rs # [Rn]) t = [A', R2] # Rs\n  where\n    A'  = undefined\n    R2  = undefined\n\nW' :\n    {n}\n    (fin n, 3 <= n) =>\n    ([128] -> [128]) -> [n * 64] -> [n * 64]\nW' CIPHk' C = join S\n  where\n    type s = 6 * (n-1)\n    C'     = split`{n} C\n    S      = foldl (WStep2' CIPHk') undefined [s, s-1 .. 1]\n```\n\nOnce you have these completed you should be able to check your work by having Cryptol :prove the properties WStep2'Prop and W'Prop. Your output should look something like the following:\n\n```cryptol\nlabs::KeyWrapping::KeyWrapping> :prove WStep2'Prop\nQ.E.D.\n(Total Elapsed Time: 0.063s, using \"Z3\")\nlabs::KeyWrapping::KeyWrapping> :prove W'Prop\nQ.E.D.\n(Total Elapsed Time: 0.630s, using \"Z3\")\n```\n\nThese two properties state that for a fixed, dummy CIPHk and S of length 3 semiblocks, WStep2 and WStep2' are inverses and W and W' are inverses. Here are the definitions of these properties:\n\n```cryptol\nproperty WStep2'Prop ARs t =\n    WStep2'`{3} (\\a -> a-1) (WStep2 (\\a -> a+1) ARs t) t == ARs\n\nproperty W'Prop S =\n    W'`{3} (\\a -> a-1) (W (\\a -> a+1) S) == S\n```\n\nThe final step is to use these components to write the authenticated decryption algorithm KW-AD. Unlike W' and WStep2' this function will have a different type than its related routine in the KW-AE family because it needs to capture whether or not the ciphertext authenticates as well as computes the corresponding plaintext.\n\n## EXERCISE: Study Algorithm 4 from the standard and complete the definition of KWAD below by filling in the function skeleton provided. This function needs both an appropriate definition for S, a computation of the authentication bit to assign to FAIL, and finally the appropriate plaintext.\n\nNotice that FAIL indicates a failure to authenticate so should be False for authenticated decryptions and True for failures to authenticate.\n\n```cryptol\nKWAD :\n    {n}\n    (fin n, 2 <= n, n < 2^^54) =>\n    ([128] -> [128]) -> [(n+1) * 64] -> (Bit, [n * 64])\nKWAD CIPHk' C = (FAIL, P)\n  where\n    S    = undefined\n    FAIL = undefined\n    P    = undefined\n```\n\nWhen you have successfully defined this function, you can test your work by :proveing that KWAE and KWAD are inverses (well, at least for a dummy CIPHk and P of length 3 semiblocks) using the KWAEInvProp. You can also :check your work against six test vectors by using the property KWADTests (this is defined later on in this document).\n\n```cryptol\nproperty KWAEInvProp S =\n    KWAD`{3} (\\a -> a-1) (KWAE (\\a -> a+1) S) == (False, S)\n```\n\n## Formal Specifications of TKW-AE and TKW-AD\n\nWe\u2019re briefly skipping over the definitions of KWP-AE and KWP-AD in Section 6.3 because the definitions of TWK-AE and TWK-AD in Section 7 are very similar to KW-AE and KW-AD. We\u2019ll come back to KWP a little later.\n\n## EXERCISE: Try your hand at writing the specification for TKW-AE and TKW-AD from Section 7. These functions are very similar to KW-AE and KW-AD but they use the 64-bit block cipher TDEA (also known as Triple-DES). We recommend following the same steps from above and defining the helper functions TWStep2, TWStep2', TW, and TW' before you attempt TKW-AE and TKW-AD. Test vectors are available in the kwtestvectors directory.\n\nThere are some minor modifications to be made, but things should go easily using KW-AE and KW-AD as a reference. This is a good opportunity to go back through and take a close look at the type parameters and conditions and be sure you understand what they mean and how to use them. One important thing to note is that had we defined our functions above using a semigroup type parameter (rather than hard-code 128 and 64), our work defining the TKW family of functions would already be done! Consider working through the Simon and Speck lab next. There you\u2019ll learn how to write parameterized modules \u2013 imagine writing a Cryptol module that takes in the semiblock size as a parameter and defines W and W', and then importing that module with semiblock = 64 into an AES key wrap module, and with semiblock = 32 into a TDES key wrap module. This concept of parameterized, hierarchical modules can really help you make clear, duplication free, reusable Cryptol specifications. For those with poor imaginations, we\u2019ve provided such a thing here.\n\nBack to TDES: One important difference in the TKW family is you will use the Triple-DES algorithm that\u2019s implemented in the TDEA module we imported earlier. You can check the type of TDEA in the interpreter via :t TDEA::blockEncrypt and :t TDEA::blockDecrypt. This has a slightly different interface than the block cipher we used from the AES module earlier. You can view how we use it here by looking at TestTKWAE and TestTKWAD. It is worth taking a quick look through the TripleDES.cry to learn a little bit about a particularly famous NIST test vector.\n\nYou can test your work with the TKWAETests and TKWADTests properties. Good luck!\n\n```cryptol\nTWStep2:\n    {n}\n    (fin n, n >= 3) =>\n    ([64] -> [64]) -> [n][32] -> Integer -> [n][32]\nTWStep2 CIPHk ([A, R2] # Rs) t = undefined\n\nTW :\n    {n}\n    (fin n, 3 <= n) =>\n    ([64] -> [64]) -> [n * 32] -> [n * 32]\nTW CIPHk S = undefined\n\nTKWAE :\n    {n}\n    (fin n, 2 <= n, n < 2^^28) =>\n    ([64] -> [64]) -> [n * 32] -> [(n+1) * 32]\nTKWAE CIPHk P = undefined\n\nTWStep2' :\n    {n}\n    (fin n, n >= 3) =>\n    ([64] -> [64]) -> [n][32] -> Integer -> [n][32]\nTWStep2' CIPHk' ([A] # Rs # [Rn]) t = undefined\n\nTW' :\n    {n}\n    (fin n, 3 <= n) =>\n    ([64] -> [64]) -> [n * 32] -> [n * 32]\nTW' CIPHk' C = undefined\n\nTKWAD :\n    {n}\n    (fin n, 2 <= n, n < 2^^28) =>\n    ([64] -> [64]) -> [(n+1) * 32] -> (Bit, [n * 32])\nTKWAD CIPHk' C = undefined\n```\n\n## A Formal Specification of KWP-AE\n\nKWP-AE is the authenticated-encryption function and makes use of our previously defined W. There is a new concept to introduce with this specification.\n\n### Oddly Typed if-then-else Statements\n\nSometimes, though not often, cryptographic algorithms will contain if statements where the then and else branches return different types. You were exposed to this a bit already in the Salsa20 lab. First off, this is always frustrating to deal with in Cryptol, and we want you to know that we feel your pain and we\u2019re sorry. Cryptol can handle these types of situations, but coming up with a solution requires experience with the type system that is likely only learned through trial and error.\n\nTo dig into this a bit, let\u2019s consider the type of a generic if-then-else statement\n\n```cryptol\nlabs::KeyWrapping::KeyWrapping> :t \\(c, t, e) -> if c then t else e\n(\\(c, t, e) -> if c then t else e) : {a} (Bit, a, a) -> a\n```\n\nHere we see that the condition c has to be of type Bit. This makes perfect sense given that c is a condition. Next, notice that the types of t and e, the values returned by the then and else cases, both have to have the same type. Here we see that Cryptol doesn\u2019t support if-then-else statements that return different types. So, when we see a specification that purports to do such a thing, we can either give up, or try and unify the two cases.\n\nHere is a silly example that closely models the behavior we\u2019ll see in KWP-AE and KWP-AD:\n\n```cryptol\ng : [32] -> [32]\ng x = x + 1\n\nh : [64] -> [64]\nh x = x - 1\n\nf : {a} (fin a, 32 <= a, a <= 64) => [a] -> [48]\nf x = if `a <= 0x30 then\n          g x\n        else\n          h x\n```\n\nHere we have a function f that takes an a-bit bitvector as input where a is some length between 32 and 64 bits. f always returns 48 bits. Here\u2019s the strange part \u2014 if a <= 0x30 (0x30 is 48), f returns g x, where g takes and returns only 32-bit values. If a > 0x30, f returns h x where h takes and returns only 64-bit values. If we try to load this function into Cryptol we see:\n\n```\n[error] at labs\/KeyWrapping\/KeyWrapping.md:863:1--866:14:\n  Failed to validate user-specified signature.\n    in the definition of 'f', at labs\/KeyWrapping\/KeyWrapping.md:863:1--863:2,\n    we need to show that\n      for any type a\n      assuming\n        \u2022 fin a\n        \u2022 32 <= a\n        \u2022 a <= 64\n      the following constraints hold:\n        \u2022 a == 64\n            arising from\n            matching types\n            at labs\/KeyWrapping\/KeyWrapping.md:866:13--866:14\n        \u2022 a == 32\n            arising from\n            matching types\n            at labs\/KeyWrapping\/KeyWrapping.md:864:13--864:14\n[error] at labs\/KeyWrapping\/KeyWrapping.md:864:11--864:12:\n  Type mismatch:\n    Expected type: 48\n    Inferred type: 32\n[error] at labs\/KeyWrapping\/KeyWrapping.md:866:11--866:12:\n  Type mismatch:\n    Expected type: 48\n    Inferred type: 64\n```\n\nThis message tells us that a, the length of our input, has to simultaneously be both 64 and 32 and (looking at the line numbers) that these constraints come from the types of g and h.\n\nIn support of fixing the function, notice that since g always takes and returns 32-bit values, we have to shrink x from a bits to 32 bits, and widen the result up to 48 bits. And, since h always takes and returns 64-bit values, we have to widen x from a bits to 64 bits, and shrink the result back down to 48 bits. To help us do this resizing work, we\u2019ll introduce shrink and widen functions.\n\n```cryptol\nwiden : {a, b} (fin a, fin b) => [b] -> [a + b]\nwiden a = 0 # a\n\nshrink : {a, b} (fin a, fin b) => [a + b] -> [b]\nshrink a = drop a\n```\n\nwiden takes any sized input and prepends 0 or more False bits. shrink takes any sized input and removes 0 or more bits from the front. Using these two functions, we can fix our f from above:\n\n```cryptol\nf : {a} (32 <= a, a <= 64) => [a] -> [48]\nf x = if `a <= 0x30 then\n        widen (g (shrink x))\n      else\n        shrink (h (widen x))\n```\n\nAnd here we test that f correctly calls g and h (which increment and decrement by 1, respectively):\n\n```cryptol\nlabs::KeyWrapping::KeyWrapping> f (10 : [37])\n0x00000000000b\nlabs::KeyWrapping::KeyWrapping> f (10 : [53])\n0x000000000009\n```\n\n## KWP-AE Top Level Function\n\nWith that consideration firmly under our belt, we can now tackle KWP-AE.\n\n## EXERCISE: Study Algorithm 5 from the standard and complete the definition of KWPAE below by filling in the function skeleton provided with appropriate logic. Use the shrink and widen functions to assist in resizing S and the outputs of W and CIPHk on the then and else branches of line 5.\n\nHint: You\u2019ll notice that we needed to pull in the type variable n and the type constraints from W, as well as to relate n and k (the types of S and C). You\u2019ll need to pass n into W, ensuring that we avoid the n == 2 case. This can be done by calling W like so W`{max 3 n}. Also, remember that ICV2 was defined above, so we do not need to redefine it inside KWPAE.\n\n```cryptol\nKWPAE :\n    {k, n}              \/\/ k is [len(P)\/8], Algorithm 5\n    ( 1 <= k, k < 2^^32 \/\/ Bounds on the number of octets of P, from Table 1\n    , 2 <= n, n == 1 + k \/^ 8) => \/\/ Here we relate n and k\n    ([128] -> [128]) -> [k * 8] -> [n * 64]\nKWPAE CIPHk P = C\n  where\n    type padlen = 0\n    PAD = undefined : [8 * padlen]\n    S = undefined : [n * 64]\n    C = if len P <= 64 then\n          undefined\n        else\n          undefined\n```\n\nFeel free to use the provided KWPAETests property to check your work.\n\nHere we point out our observation from earlier \u2013 if the type constraint on n in W had been n >= 2 and had t started at 0 rather than 1, then W CIPHk S == CIPHK S and we wouldn\u2019t have needed to test on the length of P. The definition of C would then have been C = W'{n} CIPHk S. So, hopefully you see how an arbitrary (mistaken?) constraint (compounded by 1-based indexing) percolated through this specification and caused trouble.\n\n## A Formal Specification of KWP-AD\n\nKWP-AD is the authenticated-decryption function and makes use of our previously defined W'.\n\n## EXERCISE: Study Algorithm 6 from the standard and complete the definition of KWPAD below by filling in the function skeleton provided with appropriate logic. You\u2019ll notice we\u2019ve used types and pattern matching to separate out the 4 components of S, rather than ask you to muck about defining Plen, padlen, LSB..., etc. In truth, it\u2019s not possible to follow the spec verbatim here because Plen is derived from a value variable (S) but later used to derive a type variable (padlen on line 6 which is then used as the size of 0 on line 8), and promotion of value variables to a type variables is explicitly forbidden in Cryptol.\n\n```cryptol\nKWPAD :\n    {k, n}              \/\/ k is [len(P)\/8], Algorithm 5\n    ( 1 <= k, k < 2^^32 \/\/ Bounds on the number of octets of P, from Table 1\n    , 2 <= n, n == 1 + k \/^ 8) => \/\/ Here we relate n and k\n    ([128] -> [128]) -> [n * 64] -> (Bit, [k * 8])\nKWPAD CIPHk' C = (FAIL, P)\n  where\n    S = if `n == 2 then\n          undefined\n        else\n          undefined\n    Plen  : [32]\n    PAD   : [k*8 %^ 64]\n    ICV2' # Plen # P # PAD = S\n    FAIL = ICV2' != ICV2                             \\\/\n           Plen  != (fromInteger (len P \/ 8) : [32]) \\\/\n           PAD   != 0\n```\n\nFeel free to use the provided KWPADTests property to check your work.\n\n## Test Vectors\n\nTest vectors were not included in NIST-SP-800-38F; however, the KW-AE, KW-AD family of key-wrapping algorithm enjoy common usage and are described and referenced in other standards material. The test vectors in this section were drawn from RFC 3394.\n\nRecall that you can check individual properties with the :check command in the interpreter. Here are some test vectors from RFC 3394 that are useful for testing KW-AE and KW-AD.\n\n```cryptol\nTestKWAE :\n   {a, n}\n   (a >= 2, 4 >= a, n >= 2, 2^^54-1 >= n) =>\n   [a*64] -> [n*64] -> [(n+1)*64]\nTestKWAE k pt = ct\n  where\n    ct = KWAE (\\p -> AES::encrypt k p) pt\n\nproperty KWAETests =\n    (TestKWAE (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F ])\n              (join [ 0x0011223344556677, 0x8899AABBCCDDEEFF ]) ==\n     join [ 0x1fa68b0a8112b447, 0xaef34bd8fb5a7b82, 0x9d3e862371d2cfe5 ]) \/\\\n    (TestKWAE (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F, 0x1011121314151617 ])\n              (join [ 0x0011223344556677, 0x8899AABBCCDDEEFF ]) ==\n     join [ 0x96778b25ae6ca435, 0xf92b5b97c050aed2, 0x468ab8a17ad84e5d ]) \/\\\n    (TestKWAE (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F,\n                       0x1011121314151617, 0x18191A1B1C1D1E1F ])\n              (join [ 0x0011223344556677, 0x8899AABBCCDDEEFF ]) ==\n     join [ 0x64e8c3f9ce0f5ba2, 0x63e9777905818a2a, 0x93c8191e7d6e8ae7 ])\n```\n\n```cryptol\nTestKWAD :\n   {a, n}\n   (a >= 2, 4 >= a, n >= 2, 2^^54-1 >= n) =>\n   [a*64] -> [(n+1)*64] -> (Bit, [n*64])\nTestKWAD k ct = (FAIL, pt)\n  where\n    (FAIL, pt) = KWAD (\\c -> AES::decrypt k c) ct\n\nproperty KWADTests =\n    (TestKWAD (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F ])\n              (join [ 0x1fa68b0a8112b447, 0xaef34bd8fb5a7b82, 0x9d3e862371d2cfe5 ]) ==\n     (False, join [ 0x0011223344556677, 0x8899AABBCCDDEEFF ])) \/\\\n    (TestKWAD (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F, 0x1011121314151617 ])\n              (join [ 0x96778b25ae6ca435, 0xf92b5b97c050aed2, 0x468ab8a17ad84e5d ]) ==\n     (False, join [ 0x0011223344556677, 0x8899AABBCCDDEEFF ])) \/\\\n    (TestKWAD (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F,\n                      0x1011121314151617, 0x18191A1B1C1D1E1F ])\n              (join [ 0x64e8c3f9ce0f5ba2, 0x63e9777905818a2a, 0x93c8191e7d6e8ae7 ]) ==\n     (False, join [ 0x0011223344556677, 0x8899AABBCCDDEEFF ])) \/\\\n    (TestKWAD (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F,\n                      0x1011121314151617, 0x18191A1B1C1D1E10 ])\n              (join [ 0x28c9f404c4b810f4, 0xcbccb35cfb87f826,\n                      0x3f5786e2d80ed326, 0xcbc7f0e71a99f43b,\n                      0xfb988b9b7a02dd21 ]) ==\n     (True, join [ 0x20ca3cba6f93747e, 0x456c666158ed83da,\n                   0x3a6d614e94ba1ac5, 0xfe957c5963100091]))\n```\n\n```cryptol\nTestTKWAE :\n   {n}\n   (n >= 2, 2^^28-1 >= n) =>\n   [192] -> [n*32] -> [(n+1)*32]\nTestTKWAE (k0#k1#k2) pt = ct\n  where\n    ct = TKWAE (\\p -> TDEA::blockEncrypt (k0, k1, k2, p)) pt\n\nproperty TKWAETests =\n    (TestTKWAE 0x12b84c663120c196f8fc17428bc86a110d92cc7c4d3cb695\n               0xef7da3da918d0679\n            == 0x7a72bbca3aa323aa1ac231ba)\n```\n\n```cryptol\nTestTKWAD :\n   {n}\n   (n >= 2, 2^^28-1 >= n) =>\n   [192] -> [(n+1)*32] -> (Bit, [n*32])\nTestTKWAD (k0#k1#k2) pt = (FAIL, ct)\n  where\n    (FAIL, ct) = TKWAD (\\p -> TDEA::blockDecrypt (k0, k1, k2, p)) pt\n\nproperty TKWADTests =\n    (TestTKWAD 0xe273cd9d7210a973b4113c5772474938d353b54e265dd944\n               0x10a38310b604b48f94357d67\n            == (False, 0x2ffd56320f1dff99)) \/\\\n    ((TestTKWAD 0x8476d056582e322d93ab9919086798ba48d03eddf77803e5\n               0x2c9bf0131cf486402422b8ef).0\n            == True)\n```\n\n```cryptol\nTestKWPAE :\n   {a, k, n}\n   ( a >= 2, 4 >= a\n   , 1 <= k, k < 2^^32\n   , 2 <= n, n == 1 + k \/^ 8\n   ) =>\n   [a*64] -> [k][8] -> [n * 64]\nTestKWPAE k pt = ct\n  where\n    ct = KWPAE`{k, n} (\\p -> AES::encrypt k p) (join pt)\n\nproperty KWPAETests =\n    (TestKWPAE 0x6decf10a1caf8e3b80c7a4be8c9c84e8\n               [0x49]\n            == 0x01a7d657fc4a5b216f261cca4d052c2b)\n```\n\n```cryptol\nTestKWPAD :\n   {a, k, n}\n   ( a >= 2, 4 >= a\n   , 1 <= k, k < 2^^32\n   , 2 <= n, n == 1 + k \/^ 8\n   ) =>\n   [a*64] -> [n * 64] -> (Bit, [k][8])\nTestKWPAD k ct = (FAIL, split pt)\n  where\n    (FAIL, pt) = KWPAD`{k, n} (\\c -> AES::decrypt k c) ct\n\nproperty KWPADTests =\n    (TestKWPAD 0x49319c331231cd6bf74c2f70b07fcc5c\n               0x9c211f32f8b341f32b052fed5f31a387\n            == (False, [0xe4])) \/\\\n    ((TestKWPAD`{k=1} 0x30be7ff51227f0eef786cb7be2482510\n                      0x7f61a0a8b2fe7803f2947d233ec3a255).0\n            == True) \/\\\n    (TestKWPAD 0x58e7c85b60c7675002bd66e290d20cc694279f0bfc766840\n               0xf2edd87dabb4a6ae568662f20fcc4770\n            == (False, [0x76])) \/\\\n    ((TestKWPAD`{k=1} 0x94c8dae772a43b5e00468e0947699b239dfe30ab5f90e2f6\n                      0x239c6bceee3583fe7825011e02f01cc0).0\n            == True)\n```","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/www.galois.com\/articles\/cryptographic-assurance-with-cryptol","filetype":"txt","content":"## Cryptographic Assurance with Cryptol\n\nJoey Dodds  \nJune 25, 2021\n\nField arithmetic code is important and has edge cases lurking everywhere. Cryptol is a tool that can guarantee you've got the edge cases right!\n\nIn this post, we continue reproducing an NCC Group post about programming in z3. In our last post, we checked the implementation of part of the QUIC protocol. Now we'll explore an optimized implementation of field arithmetic.\n\nI'd love it if you installed Cryptol and worked along, but I've reproduced everything here, so I'll forgive you if you don't.\n\nI'm also going to take you through a mistake I actually made in the specification and explain how I debugged it. I promise I really made this mistake, and I didn't just put it in there to make you feel good.\n\nI can't believe you've done this.\n\nFor field arithmetic to work, we need to do math on big numbers. Loads of work have gone into making math on numbers up to 64 bits go fast. Beyond that, you won\u2019t get much help from the hardware most of us have in our computers. That means that when we need to do fast math operations on bigger numbers, we're forced to introduce risk into our code. Cryptol can help mitigate that risk.\n\nSo if I want to do math on 256-bit numbers, I've got a couple of choices:\n\n- Build up some lists of bits (usually booleans) in my language, along with operations on them (bitvector approach)  \n- Map those operations onto the numbers that the computer represents\n\nThe first is far easier to get right. You get to treat your numbers uniformly, so you have far fewer edge cases to deal with. Unfortunately, it tends to be too slow and memory intensive. In many cases, you'll end up using 8 or 16 times as much memory to represent your bit vectors as you would using the computer representations. The cost for computations could be even worse.\n\nThat means that for most high-performance uses, we'll need to map operations onto machine numbers. Bignum libraries such as GMP can do this reasonably well, but they're generalized, and performance can often still be improved for specific applications.\n\n## Setting up the types\n\nThe NCC post shows some Go code and we're going to work from the same code. Our goal is to implement this Galois field addition algorithm in Cryptol and show that it's equivalent to a simpler, slower operation over large bitvectors.\n\n```go\n\/\/ Internal function for field addition.\n\/\/ Parameters:\n\/\/   d    destination\n\/\/   a    first operand\n\/\/   b    second operand\n\/\/   mq   modulus definition parameter\nfunc gf_add(d, a, b *[4]uint64, mq uint64) {\n  \/\/ First pass: sum over 256 bits + carry\n  var cc uint64 = 0\n  for i := 0; i < 4; i++ {\n    d[i], cc = bits.Add64(a[i], b[i], cc)\n  }\n\n  \/\/ Second pass: if there is a carry, subtract 2*p = 2^256 - 2*mq;\n  \/\/ i.e. we add 2*mq.\n  d[0], cc = bits.Add64(d[0], (mq << 1) & -cc, 0)\n  for i := 1; i < 4; i++ {\n    d[i], cc = bits.Add64(d[i], 0, cc)\n  }\n\n  \/\/ If there is an extra carry, then this means that the initial\n  \/\/ sum was at least 2^257 - 2*mq, in which case the current low\n  \/\/ limb is necessarily lower than 2*mq, and adding 2*mq again\n  \/\/ won't trigger an extra carry.\n  d[0] += (mq << 1) & -cc\n}\n\nfunc gf_sub(d, a, b *[4]uint64, mq uint64) {\n  \/\/ First pass: difference over 256 bits + borrow\n  var cc uint64 = 0\n  for i := 0; i < 4; i++ {\n    d[i], cc = bits.Sub64(a[i], b[i], cc)\n  }\n\n  \/\/ Second pass: if there is a borrow, add 2*p = 2^256 - 2*mq;\n  \/\/ i.e. we subtract 2*mq.\n  d[0], cc = bits.Sub64(d[0], (mq << 1) & -cc, 0)\n  for i := 1; i < 4; i++ {\n    d[i], cc = bits.Sub64(d[i], 0, cc)\n  }\n\n  \/\/ If there is an extra borrow, then this means that the\n  \/\/ subtraction of 2*mq above triggered a borrow, and the first\n  \/\/ limb is at least 2^64 - 2*mq; we can subtract 2*mq again without\n  \/\/ triggering another borrow.\n  d[0] -= (mq << 1) & -cc\n}\n```\n\nIt\u2019s good to set up the types, and try to understand how they correlate to numbers first. Doing this right up front can save a lot of trouble in the future.\n\nThe inputs are big numbers of size 4*64. We'll give this a type alias so we can reuse it easily.\n\n```cryptol\ntype BN = [4][64]\n```\n\nThat's a transparent alias in Cryptol; BN can be used interchangeably with `[4][64]`.\n\nWe'll state a couple of properties about what that type \u201cmeans\u201d. In general, it's meant to be a way to split up a longer number into 64-bit chunks. Let's record that, along with a property:\n\n```cryptol\nbn_to_sequence : BN -> [4*64]\nbn_to_sequence bn = join bn\n\nsequence_to_bn : [4*64] -> BN\nsequence_to_bn seq = split seq\n\nproperty bn_roundtrip bn = bn == sequence_to_bn (bn_to_sequence bn)\n```\n\nThe property is a \"roundtrip\" property, stating that if we encode a long sequence as a BN and then convert back, we end up back where we started.\n\n```\nMain> :prove bn_roundtrip\nQ.E.D.\n(Total Elapsed Time: 0.006s, using \"Z3\")\n```\n\nWoah, that went fast. I bet Cryptol knows some properties about join, split, and reverse that it can simplify away.\n\nIt's good to have these \"denotations\" for the BN type. They will serve as specs as we start to implement operations.\n\n## Implementing addition with carry\n\nLooks like we're going to need an implementation of `bits_add` before we go further.\n\n```cryptol\nbits_add : {n} (fin n) => [n] -> [n] -> Bit -> (Bit, [n])\nbits_add x y cin = (z@0, drop z)\n  where\n    z : [n+1]\n    z = zext x + zext y + zext [cin]\n```\n\nWe can do it as a 65-bit addition in Cryptol, where the 65th bit gets the final carry from adding two 64-bit numbers. If this were the actual function we were specifying, we might want to make it look more like the original. We'll do that for the other function.\n\nThere's some new Cryptol stuff here too. We see the `zext` function, which makes use of Cryptol types to automatically add zeros to the most significant digits in order to make the value the length that Cryptol expects it to be, without changing the value itself.\n\nIn this case, since we've said `z` has length `n+1` we know that the arguments to the addition must also have length `n+1`. We also see the `drop` function, which drops values from the front, in order to get the right length. In this case, we do that because the carry is in the 0th index, but we don\u2019t want to include it in the sum portion of the return.\n\n## Specifying 256-bit addition\n\nWith that implemented, we can start to look at the body of the `gf_add` function. We\u2019ll try to treat each loop separately, since they might also be useful on their own.\n\nThe first part of the `gf_add` function is doing a straight addition of the two numbers. We'll implement that with the following Cryptol:\n\n```cryptol\nbn_add : BN -> BN -> ([5]Bit, BN)\nbn_add a b = (drop cc, d.1)\n  where\n    cc : [5]Bit\n    cc  = [0] # d.0\n\n    d : [4] (Bit, [64])\n    d@i = bits_add (a@i) (b@i) (cc@i)\n```\n\nWe\u2019ve got lots of Cryptol here. Let's break it down and explain some things.\n\n- `drop cc` drops the first value in the sequence. That's the initial 0 carry; there's no reason to return it. For the computation, we really only need the last carry, but we keep them all so that later we can see how many carries are exercised.  \n- `d.1` takes the second item of tuple (or pair) containing the value and the carry. That matches up with our `bits_add` implementation which returns a pair of the carry and the result.\n\nWe start our list of all of the carries off with zero, and then build the rest from the 0th indices of `d`. Cryptol is wildly polymorphic so we can do:\n\n```cryptol\nMain> [(0,1),(2,3)].0\n[0, 2]\n```\n\nFinally, we construct a sequence `d` which refers back to the list of carry results.\n\nThis is a lot to take in, so let's write a property to be sure we got it right.\n\n```cryptol\nproperty bn_add_correct x y = sequence_to_bn (bn_to_sequence x + bn_to_sequence y) == (bn_add x y).1\n```\n\nWe'll prove it in the REPL.\n\n```\nMain> :prove bn_add_correct\nCounterexample\nbn_add_correct\n ...\n False\n(Total Elapsed Time: 0.072s, using \"Z3\")\n```\n\nOr try to at least. We got something wrong. The counterexample provides an input that violates the property, but it looks like it'd be hard to figure out what went wrong. Sometimes a good thing to do is use simpler test cases to learn more. Let's add 1 + 1.\n\n```\nMain> bn_add_correct (sequence_to_bn (zext 1)) (sequence_to_bn (zext 1))\nTrue\n```\n\nOur property is True for those values, so things are partially right at least. Let's try something that triggers a carry, since that's an obvious place we might make a mistake.\n\n```\nMain> bn_add_correct (sequence_to_bn (zext (1 # (0 : [63])))) (sequence_to_bn (zext (1 # (0 : [63]))))\nFalse\n```\n\nNarrowing it down... let's look at the two sides of our property individually and see if we can spot the problem.\n\n```\nMain> sequence_to_bn ((zext (1 # (0 : [63]))) + (zext (1 # (0 : [63]))))\n[0b000...0000, 0b000...0000, 0b000...0001, 0b000...0000]\n```\n\nOk, that worked pretty well. We can see that the bit carried from the 4th item to the third. Let's try our function.\n\n```\nMain> bn_add (sequence_to_bn (zext (1 # (0 : [63]))))  (sequence_to_bn (zext (1 # (0 : [63]))))\n(0x8,\n [0b000...0000,\n  0b000...0000,\n  0b000...0000,\n  0b000...0000])\n```\n\nOh! The carry went the other way, falling off the end of the operation and returning as a set bit for the final carry (0x08 in binary is 0b1000).\n\nNow we just need to spend some time thinking about if our spec or implementation is wrong.\n\nIt seems likely that it was our specification. We (look I included you when \"we\" made a mistake) made an assumption about the representation of BN before we knew what was intended by the implementation. The implementation carries from the 0th index increasing through the sequence. The carry in our Cryptol addition went the other way though. Byte-ordering is a notoriously tricky bit of operations like this, and here it is, striking again!\n\nLet's adjust our representation functions.\n\n```cryptol\nbn_to_sequence : BN -> [4*64]\nbn_to_sequence bn = join (reverse bn)\n\nsequence_to_bn : [4*64] -> BN\nsequence_to_bn seq = reverse (split seq)\n```\n\nWe used `reverse` because the function seems to be looping from zero, carrying up with the index. That means that the 0th number will be the least significant. Cryptol does have a built-in bit-order for constants and operators. We can check this in the REPL:\n\n```\nMain> (1 : [8]) @ 0\nFalse\nMain> (1 : [8]) @ 7\nTrue\n```\n\nThe least significant digit is at index 7, so we'll get the order wrong if we don't reverse our BN first.\n\nLet's try our proof again and see if that fixed it.\n\n```\nMain> :prove bn_add_correct\nQ.E.D.\n```\n\nAll good! On with the post!\n\n## Specifying the gf_add function (finally)\n\nThere are two more passes. If there was a carry resulting from the first addition, we add `2*mq` and propagate that. If there's still a carry, we repeat the addition, but this time (the comments say) we don't need to repeat the carry. Since we\u2019re not actually doing anything that our add function can\u2019t do we can define `gf_add`. We're going to make `mq` the first argument though, so we can more easily set it to a fixed value when we're using it. We're also returning all of the carries.\n\n```cryptol\ngf_add : [64] -> BN -> BN -> (BN, [8]Bit)\n\ngf_add mq a b = (ds3, ccs1 # ccs2) where\n\n  (ccs1, ds1) = bn_add a b\n\n  (ccs2, ds2) = bn_add ds1 (update zero 0 (((mq : [64]) << 1) && -(zext [(ccs1!0)])))\n\n  ds3 = update ds2 0 (ds2@0 + (((mq : [64]) << 1) && -(zext [(ccs2!0)])))\n```\n\nThis looks similar to the Go implementation. We have to use subscripts as the variables update them because Cryptol is functional and doesn't allow you to shadow names. It also looks a bit shorter than the code in Go. One reason is that we pulled the two loops out into the `bn_add` function. The other is that we removed the special case in the Go code, instead using the `update` function in Cryptol to allow us to reuse the code from the first loop.\n\nOne thing I thought a little mystifying in the implementation was the pattern:\n\n```cryptol\n(((mq : [64]) << 1) && -(zext [(ccs2!0)]))\n```\n\nIt's being a little tricky with the shift and the mask. I think this is to avoid introducing side-channels, but we can prove it is equivalent to something that has side channels and is easier to read. We can write a little property:\n\n```cryptol\nproperty mq_mask_correct cc mq = ((mq : [64]) << 1) && -(zext [cc]) == if cc then 2 * mq else 0\n```\n\nAnd prove it.\n\n```\nMain> :prove mq_mask_correct\nQ.E.D.\n(Total Elapsed Time: 0.007s, using \"Z3\")\n```\n\nIt's nice to do this kind of thing as you go, because if you make a mistake it's helpful to know that some of your implementation is definitely right.\n\n## Correctness property\n\nNow that we've got the implementation done we can write a correctness property for it. First let's write a version of our function that operates on and returns bitvectors:\n\n```cryptol\ngf_add_bv x y = bn_to_sequence ((gf_add mqc (sequence_to_bn x) (sequence_to_bn y))).0\n```\n\nThen we can line it up with an operation over long sequences.\n\n```cryptol\nproperty gf_add_correct x y = (((zext x) : [257]) + (zext y)) % pc == (zext (gf_add_bv x y)) % pc\n```\n\nWe have to do the modulus on both sides because the `gf_add` function doesn't fully reduce. This is a pretty common trick to avoid doing expensive operations until they're actually necessary.\n\nWe can prove it pretty quickly, surprisingly.\n\n```\nMain> :prove gf_add_correct\nQ.E.D.\n(Total Elapsed Time: 13.243s, using \"Z3\")\n```\n\nThe NCC post said it takes a few hours. The difference could either be that Cryptol is leveraging built-in simplifications, resulting in a better goal for Z3, or that Z3 itself has improved for this problem since the NCC post was written.\n\nNice! All done! Looks like the algorithm is in good shape. Regardless, we've proved an algorithm, not an implementation. What if someone made a mistake writing this down in C, Rust, or their language of choice?\n\n## Tying it to implementation\n\nThere are two ways we could tie a spec like this to an implementation:\n\n- Proofs, using a tool like SAW  \n- Test cases\n\nBoth! (Recommended)  \nThat was 3, I guess. The recommended order (from me) is tests first, then proofs.\n\nBig words from someone who spends their days writing proofs! Why would I make this recommendation?\n\nTests give immediate feedback, and every developer already understands how to work with them. This is in contrast to proofs, which will often require learning an additional tool or two, along with a paradigm for reasoning. Tests are generally far quicker to develop than proofs, and easier to update. They also test cover \"full stack\" and can catch bugs in compilers or even hardware, if bugs exist.\n\nProofs, on the other hand, will give a higher assurance of correctness, but in general will take longer and be harder to interact with. In this case, writing a proof of a C program wouldn't be much harder than the work we just did.\n\nWith the implementation we just made, we can automatically generate some tests to cover the behavior of various carry combinations. First we'll define a property that's true if it matches the supplied carry.\n\n```cryptol\ncarry_eq p c x y r = p c \/\\ ((gf_add mqc x y).1 == c) \/\\ ((gf_add mqc x y).0 == r)\n```\n\nWe did something a little funny here. We take a predicate on the carries, so we can say something like, \"I want a carry pattern where the 0th bit is 1.\"\n\nWe also add an argument `r` for convenience.\n\nThen we can ask the solver to give us a satisfying input:\n\n```\nMain> :sat (carry_eq (\\c -> c @ 0 == True))\nSatisfiable\n(carry_eq (\\c -> c @ 0 == True))\n 0x80\n [0xffffffffffffffff, 0x0000000000000000, 0x0000000000000000,\n  0x0000000000000000]\n [0xffff7fffffffffff, 0x0000000000000000, 0x0000000000000000,\n  0x0000000000000000]\n [0xffff7ffffffffffe, 0x0000000000000001, 0x0000000000000000,\n  0x0000000000000000] = True\n```\n\nThat tells us the arguments supplied to `carry_eq`, as well as the result!\n\nIt's worth noting again how much less verbose our approach was than doing things directly in z3 syntax. Our whole effort took around 50 lines of code (closer to 60 if you count the commands at the REPL). The z3 implementation took hundreds of lines.\n\nIn general, this is why I prefer interacting with Cryptol to interacting with the solver directly when I can manage it. Thanks for reading!","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/www.galois.com\/articles\/cryptol-saw-and-the-galois-origin-story","filetype":"txt","content":"## Cryptol, SAW, and the Galois Origin Story\n\nAndrew Shaughnessy  \nNovember 6, 2023  \n\nAmong the many tales of innovation and impact to come from Galois over the years, the origin story of Cryptol and SAW is perhaps the most closely tied with that of the company itself. Today, these open-source verification tools have been used in national security, fintech, and cloud computing applications to keep citizens, systems, and data safe; secure financial transactions; and protect the privacy of millions of people across the globe. The high assurance approach they represent forms the backbone\u2014both technologically and philosophically\u2014of Galois\u2019s larger effort to create trustworthiness in the most critical systems on the planet, and to maximize impact through sharing these powerful tools with the open source community. But in the early days, no one could have even dreamed of all that was to come.\n\nBack in the late 1990s, Galois founder John Launchbury was still a computer science professor at the Oregon Graduate Institute (OGI). By that point in his career, Launchbury was consulting for the National Security Agency (NSA), including working with OGI colleagues to model a programmable cryptography chip.\n\n\u201cIt could handle multiple cryptographic algorithms with a guaranteed cleaning out of all the registers, and had a mathematically-assured kernel in the chip itself,\u201d Launchbury said. \u201cIt was pretty cool, but they didn\u2019t have the technology to be able to model the correctness of their algorithms. At OGI, we showed that it was possible.\u201d\n\nThe results soon circulated through government R&D circles. Impressed, and seeing the potential for a tool with a broader impact, a government contact approached Launchbury about creating a domain-specific language (DSL) for specifying cryptographic algorithms.\n\n\u201cMy first reaction was, \u2018That would be cool, but I\u2019m hesitant to do it,\u2019\u201d Launchbury said. \u201cAt the university, we had tried building things in the past, but there\u2019s a conflict between focusing on actually building a good product and focusing on publishable research. When you try to do both, you end up with neither great research nor a good product.\u201d\n\nBut the idea of developing a crypto-focused DSL was too intriguing, and Launchbury couldn\u2019t let it go. If it wouldn\u2019t work to do it at the university, perhaps there was another way.\n\nIn the past, Launchbury and his colleagues had discussed the possibility of starting companies to commercialize and productize the technologies and innovations from their academic research. This seemed the perfect opportunity. And so, in 1999, Launchbury founded Galois. Developing the crypto-focused DSL for the U.S. Government was their very first contract. They called it: \u201cCryptol.\u201d\n\n## Setting the Standard for Advanced Encryption\n\nGalois\u2019s brand new tool was almost immediately put to work helping the government decide on a new gold standard for cryptographic encryption.\n\nSince the early 1970s, the Data Encryption Standard (DES) had been the NSA\u2019s officially approved symmetric key algorithm for cryptography applications. But by the late \u201890s, DES\u2019s 56 bits of security was viewed as too vulnerable for increasingly complex and software-heavy systems. In 1997, the National Institute of Standards and Technology (NIST) spread the word in the cryptography community that they were in the market for a replacement. In the years that followed, more than a dozen designs were submitted for consideration as the new Advanced Encryption Standard (AES), each a block cipher algorithm in 128, 192, or 256-bit key sizes.\n\nJust as Galois was being formed, the competition had been whittled down to 10 finalists, and the government wanted to be able to better analyze and understand the algorithms in order to make a more informed decision. Cryptol became a key part of NIST and the U.S. government's decision-making process.\n\n\u201cThat was some of our earliest work,\u201d said Launchbury. \u201cNowadays these algorithms are so well known, but back then they were very new. We used Cryptol to express these algorithms at a very high level that allowed people to understand their structure and explore their behavior.\u201d\n\nBecause Cryptol empowers users to create a precise mathematical model of a cryptographic algorithm, it served as an invaluable tool by which the government\u2019s mathematically-minded cryptographers could make sense of the AES candidates\u2014mapping specifications and comparing them to implementations to demonstrate correctness and root out potential problems. With Cryptol as a part of their toolset, NIST and the NSA were able to choose a winning symmetric encryption algorithm, the Rijndael algorithm. Today, Rijndael, now branded as AES, continues to be widely recognized and accepted as the global standard for symmetric encryption in a broad spectrum of applications and environments.\n\n## Open Sourcing Cryptol and Uncovering New Capabilities\n\nFrom the beginning, it was well understood that the R&D community, the industry, and the public at large can benefit when tools like Cryptol are open sourced. In addition, it was known that open sourced tools could themselves benefit from and be independently verified by a broad, diverse user community. With this in mind, the U.S. Government and Galois agreed to open source Cryptol for broad application and public benefit, releasing the first fully public version (Cryptol 2) in 2014. With Cryptol\u2019s source code available for anyone to explore and use, adoption and collaboration began to increase.\n\nBit by bit, Cryptol was proving its mettle and making its mark, and Launchbury and his fellow researchers were uncovering more and more applications\u2014including the ability to generate or analyze hardware circuits.\n\n\u201cIt turns out that you can generate logic from a Cryptol specification,\u201d Launchbury explained. \u201cAnd if I\u2019ve got a descriptor of a hardware circuit, I can also turn that into logic. And so now I\u2019ve got two logic circuits that I can compare against one another and ask: \u2018Are they equal to one another?\u2019\u201d\n\nThus a new \u201cbackend\u201d to Cryptol was born\u2014one that could generate and understand hardware designs written in a language called VHDL.\n\nThough the tool was only initially used by a handful of individuals within the government, the speed at which Cryptol could be used to generate test vectors (inputs used to test system correctness), study algorithmic behavior, and root out problems hidden deep within complex code slowly began to catch people\u2019s attention, and the grassroots user base began to grow.\n\n\u201cI started to hear that hundreds of people in the government were using Cryptol for all sorts of wonderful things,\u201d Launchbury said.\n\nMeanwhile, Galois continued to grow, not only researching and developing more tools and technologies, but expanding Cryptol\u2019s reach. Soon, other organizations and government agencies expressed interest\u2014wanting to use the tool to better analyze, understand, and improve their own cryptographic algorithms as well as those made or used by vendors. Cryptol\u2019s use extended to commercial companies who used Cryptol internally or worked with Galois to apply Cryptol to their next generation cryptographic products.\n\n\u201cLet\u2019s say a vendor is supplying you with equipment, and they say, \u2018This equipment correctly implements such and such an algorithm,\u2019\u201d Launchbury said. \u201cYou can use Cryptol to gain confidence in the equipment being supplied\u2014figuring out early on whether there\u2019s a flaw deep in the code. It would give you that kind of answer instantaneously so that you can correct any flaws before a system is fielded.\u201d\n\n## Verifying Elliptic Curve Algorithms and the Creation of SAW\n\nOver the decades, Cryptol was steadily becoming a key tool for the U.S. government assessing code in their critical systems. All that time, cyber-physical systems (systems that integrate hardware, software, networking, and physical processes) and the algorithms used to secure them from growing threats were becoming more and more complex\u2014making it more and more difficult for conventional testing methods to keep up. Cryptol evolved right alongside, keeping pace every step of the way.\n\nWhen a new class of cryptographic algorithms called \u201celliptic curve algorithms\u201d arrived on the scene, they presented a puzzle far more challenging than that posed by AES. Galois set out to specify several versions of these enormously complex algorithms, including the de facto standard open source Java implementation that was a part of the \u201cBouncy Castle\u201d cryptography library. Using Cryptol, Galois was able to show that there was an exploitable error deep in the arithmetic of Bouncy Castle\u2019s implementation.\n\n\u201cIt's one of those cases where you really needed to do real verification work,\u201d Launchbury said. \u201cThese algorithms were so complex that we couldn\u2019t simply create a whole logic description and show equivalence. We had to start modeling their structures, showing subpart equivalents, and subparts equivalents of those subparts, and so on.\u201d\n\nIn order to analyze an implementation using Cryptol, Galois needed some means by which to bridge the gap between a mathematical specification in Cryptol and a software implementation written in a variety of programming languages, not just in a hardware design language like VHDL. In response, Galois created the Software Analysis Workbench (SAW), which allows more control over SAT and SMT solvers to enable them to formally verify properties of code written in C, Java, and Cryptol\u2014automating as much of the verification process as possible and enabling the process to scale to complex systems. Before long, SAW caught the interest of Amazon Web Services (AWS).\n\n## The Amazon Catalyst\n\nAWS\u2019s global cloud infrastructure serves small businesses, large companies, individuals, and government agencies in more than 245 countries and territories across the globe. They\u2019re responsible for hosting some of the most valuable data in the world\u2014a high stakes task that demands guaranteed security and privacy, all without compromising high performance.\n\nBeginning in 2015, Galois worked alongside AWS Cryptography, applying an approach called \u201cprovable security\u201d to mathematically guarantee that particular security flaws cannot happen in some of the key cryptographic systems that protect their cloud. By integrating Cryptol and SAW into their CI\/CD pipeline, Galois was able to provide continuous, automatic verification of AWS\u2019s cryptographic library every time they updated their code. The result was provable security protecting critical data for millions of active customers. The AWS use case and global deployment demonstrated the power of automated reasoning tools and their ability to scale into real world, global deployments.\n\n\u201cThat was the first time that anyone had demonstrated continually maintained code infrastructure over many iterations of CI\/CD,\u201d Launchbury said. \u201c98% of the time the whole process was automatic. That was a huge improvement, and it caught the attention of operational groups in the government. Federal agencies basically said: \u2018Well, if Amazon is using this, why aren\u2019t we?\u2019\u201d\n\n## Looking to the Future\n\nIn the years since, Cryptol and SAW\u2019s applications and impact have only continued to grow. Galois continued to contribute feature enhancements and extensions to the open source tools, including the ability to generate high-performance, high-assurance implementations from Cryptol specifications or SAW intermediate representations. Reports came in from government and commercial clients that Cryptol and SAW were uncovering problems \u201cthat no other tools have found.\u201d Later, when NIST launched the Post Quantum Algorithm competition, Galois modeled and verified several algorithms for customers.\n\nToday, Cryptol and SAW are being actively used across government and industry to secure some of the most valuable data in the world and for a number of tangible national security applications. That impact is quite significant, but Launchbury still considers it just the tip of the iceberg in terms of the potential that tools like SAW and Cryptol present\u2014particularly in our current context of growing system complexity and interconnectivity.\n\n\u201cWe live in an increasingly connected world where lots and lots of devices are connected that weren\u2019t before. Right now, your car is likely connected to the internet, but soon your car will be connected to the cars next to it and to the road itself. That\u2019s a quantum leap of connectivity. And as you add capability and connectivity, you get a perfect storm for challenges\u2014exactly the sort of challenges that these approaches are built to handle.\u201d\n\nVerifying the security of systems with that level of complexity through conventional techniques is increasingly difficult or even impossible. Formal verification, through tools like Cryptol and SAW, makes future-proofed scalable security a reality.\n\n## TECHNICAL EPILOGUE: Under the Hood: Applying SAW to different programming languages\n\nAs mentioned above, in order to analyze implementations using Cryptol, Galois needed some means by which to bridge the gap between a mathematical specification in Cryptol and a software implementation written in a variety of programming languages. Most deployed cryptography is written in software in programming languages like C and Java, or in assembly language. In order to reason about those implementations, Galois created the Software Analysis Workbench (SAW) which could automatically lift models out of implementations, and then compare those lifted models to each other, or with Cryptol models.\n\nRather than writing a \u201clifter\u201d for every new programming language, this \u201clifting\u201d focuses on widely used intermediate representations (IR) that are used for many programming languages. Initially SAW supported the LLVM compiler infrastructure\u2019s IR, and later was extended to support understanding the Java Virtual Machine bytecode format.\n\nBy supporting these two IRs, suddenly one could use SAW to attempt to reason about not just C or Java code, but any compiler that uses LLVM or the JVM as a backend, such as Rust, C++, Kotlin, Scala, and more. What\u2019s more, after implementing two compiler backends, adding support for others became more straightforward.\n\nOver the years, support was added also for programming language IRs like MATLAB and Ghidra P-code, and hardware design languages like Verilog and Bluespec SystemVerilog. These advancements meant it was possible to begin to reason about optimized, complex implementations of new kinds of cryptographic primitives, such as elliptic curves.\n\n## Cryptol and SAW for Implementation and Assurance Case Generation\n\nIn parallel with the advancements in specification and program reasoning discussed above, new features in Cryptol and SAW were also added in order to generate implementations from Cryptol specifications or SAW IR representations, as well as to generate test benches from specifications.\n\nBackends now exist to generate high-performance, formally verifiable C, LLVM bitcode, JVM, and Verilog implementations. These implementations have been used in two ways: (1) as \u201cgolden models\u201d for further manual or automated refinement, such as performance or resource use optimizations, or (2) directly as deployable implementations.\n\nSeveral case studies have demonstrated that the implementations automatically generated by these tools are extremely competitive with all public hand-written-by-experts (with great effort and cost) implementations, especially when compared using throughput, latency, and energy benchmarks.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/www.galois.com\/articles\/cryptol-saw-minilock","filetype":"txt","content":"## Applying Cryptol and SAW to Minilock Primitives\n\nTom DuBuisson  \nJune 12, 2015  \n\nTo commemorate the public release of the Software Analysis Workbench (SAW), it seemed fitting to blog about some recent work specifying algorithms in Cryptol and proving properties, leveraging SAW along the way.\n\nCryptol, Galois\u2019s domain specific language for describing cryptographic algorithms, has frequently been demonstrated over individual algorithms and toy problems. Our blog is covered with Cryptol posts such as ZUC, Skein, Simon, SPECK, Sudoku, and N-Queens. Complementing these small, single-algorithm efforts we wrote a Cryptol specification for the popular file encryption tool Minilock.\n\nMinilock allows users to encrypt files such that only a select few people are capable of decryption using their respective private keys. To accomplish this, user passwords and SCrypt are used to generate Curve25519 asymmetric keys. These asymmetric keys and ECDH allow each party to derive symmetric keys which are used to decrypt the Salsa20+Poly1305 encrypted file. A key-wrapping scheme is used to avoid duplicating ciphertext for each recipient.\n\nOur executable Minilock specification, called Crylock, allows us to produce encrypted files compatible with Minilock, analyze the algorithms, and formally verify functional equivalence of implementations. In building this specification we developed Cryptol implementations of Blake2s, Curve25519, HMAC, SHA256, PBKDF2, SCrypt, Salsa20, base64 and 58 encodings, and NaCl\u2019s CryptoBox primitive.\n\nArmed with this body of specifications and evidence of functional correctness due to interoperability testing, we can now use our SMT solvers of choice as a hammer and treat any publication or bit of code as a nail to be struck. It\u2019s hammer time.\n\n## Salsa20 and TweetNacl\n\nOne issue in implementing cryptographic algorithms is knowing it is done right, without corner cases. Was shift accidentally used instead of rotate? Have all operations accounted for overflow correctly? SAW can prove equivalence of implementations in a straightforward manner. For example, using a couple dozen lines of SAW script and our Salsa20 Cryptol implementation we can quickly verify the core of Salsa20 from TweetNaCl:\n\n```cryptol\nimport \"Salsa20.cry\";\n\nlet sym = \"crypto_core_salsa20_tweet\";\n\nlet main : TopLevel () = do {\n    print \"Proving equivalence between spec and tweet nacl.\";\n\n    out <- fresh_symbolic \"out\" {| [64][8] |};\n    n   <- fresh_symbolic \"n\" {| [16][8] |};\n    k   <- fresh_symbolic \"k\" {| [32][8] |};\n    let allocs  = [ (\"out\", 64), (\"in\", 16)\n                  , (\"k\", 32), (\"c\", 16) ];\n    let inits   = [ (\"*out\", out, 64)\n                  , (\"*in\", n, 16)\n                  , (\"*k\", k, 32)\n                  , (\"*c\", {{ \"expand 32-byte k\" }}, 16) ];\n    let results = [ (\"*out\", 64) ];\n\n    print \"\\tLoading tweetnacl llvm byte code.\";\n    tnacl <- llvm_load_module \"tweetnacl.bc\";\n\n    print \"\\tExtracting the Salsa20 encryption function.\";\n    nacl_salsa20 <- time (llvm_symexec tnacl sym\n                                        allocs inits results);\n\n    print \"\\tBit blasting the NaCl and Cryptol terms.\";\n    nacl_as  <- abstract_symbolic nacl_salsa20;\n    let cry_f  = {{ \\key nonce -> Salsa20_expansion `{a=2} (key,nonce) }};\n    let nacl_f = {{ \\key nonce -> nacl_as nonce key }};\n    naclAIG <- time (bitblast nacl_f);\n    cryAIG  <- time (bitblast cry_f);\n\n    print \"\\tUsing CEC to prove equivalence.\";\n    res <- time (cec naclAIG cryAIG);\n    print res;\n};\n```\n\nThe ABC-backed \u2018cec\u2019 solver is too good. We don\u2019t have time to get coffee.\n\nOutput example:\n\n```\nProving Salsa20_encrypt equivalent between Cryptol spec and tweet nacl.\n        Loading tweetnacl llvm byte code.\n        Extracting the Salsa20 encryption function.\n        Time:     3.143s\n        Bit blasting the NaCl and Cryptol terms.\n        Time:     1.183s\n        Time:     0.204s\n        Using CEC to prove equivalence.\n        Time:     0.069s\nValid\n```\n\nThe exact same steps can successfully show equivalence with Salsa20 encryption. A caveat is the SAW engine works over monomorphic types, so while one might desire to show the Salsa20 encryptions from Cryptol and NaCl are identical for all possible input sizes, SAWScript requires a static size prior to validation.\n\n## Cryptographic Properties\n\nThe 2008 paper \"On the Salsa20 Core Function\" highlighted seven theorems relating to a part of Salsa20. These are exactly the type of properties Cryptol and the underlying solvers are intended to quickly verify, allowing the user to more efficiently explore the algorithm.\n\nThe first few properties are about invariant inputs for transformations, for example:\n\n```cryptol\nproperty theorem1 a =\n    quarterround [a, -a, a, -a] == [a, -a, a, -a]\n\nproperty theorem2 a b c d = rowround val == val\n  where val = [a, -a, a, -a,\n               b, -b, b, -b,\n               c, -c, c, -c,\n               d, -d, d, -d]\n\nproperty theorem3 a b c d = columnround val == val\n  where val = [a, -b, c, -d,\n              -a, b, -c, d,\n               a, -b, c, -d,\n              -a, b, -c, d]\n\nproperty theorem4 a = doubleround val == val\n  where val = [a, -a, a, -a,\n              -a, a, -a, a,\n               a, -a, a, -a,\n              -a, a, -a, a]\n```\n\nThat is, for the Salsa sub-functions of doubleround, columnround, rowround, and quarterround there exist inputs such that f x = x. These theorems all can be handled by Cryptol directly:\n\n```\nSalsa20> :set prover=any\nSalsa20> :prove theorem1\nQ.E.D.\nSalsa20> :prove theorem2\nQ.E.D.\nSalsa20> :prove theorem3\nQ.E.D.\nSalsa20> :prove theorem4\nQ.E.D.\n```\n\nThe seventh, and last, theorem of the paper does not terminate in a timely manner. This is unfortunate but not unexpected \u2013 it is a slightly more complex theorem that leverages the prior six. In order to make such compositional proofs painless, SAW returns proof objects which can be used to enhance future proof tactics in a simple manner. This is a middle ground between the full power of manual theorem prover and the \"all-or-nothing\" system exposed by Cryptol. The SAWScript is:\n\n```cryptol\nimport \"..\/src\/prim\/Salsa20.cry\";\n\nlet main : TopLevel () = do {\n    print \"Proving Salsa20 hash theorems.\";\n    let simpset x = addsimps x empty_ss;\n\n    t1_po <- time (prove_print abc {{ \\a ->\n              quarterround [a, -a, a, -a] == [a, -a, a, -a] }});\n    t2_po <- time (prove_print abc {{ \\a b c d ->\n              (rowround val == val\n                  where val = [a, -a, a, -a,\n                               b, -b, b, -b,\n                               c, -c, c, -c,\n                               d, -d, d, -d])}});\n    t3_po <- time (prove_print abc {{ \\a b c d ->\n              (columnround val == val\n                  where val = [a, -b, c, -d,\n                              -a, b, -c, d,\n                               a, -b, c, -d,\n                              -a, b, -c, d]) }});\n    t4_po <- time (prove_print abc {{ \\a ->\n              (doubleround val == val\n                  where val = [a, -a, a, -a,\n                              -a, a, -a, a,\n                               a, -a, a, -a,\n                              -a, a, -a, a]) }});\n    let ss = simpset [ t1_po, t2_po, t3_po, t4_po ];\n\n    print \"Proving Theorem 7\";\n    time (prove_print do { simplify ss; abc ; } {{ \\a ->\n                ((Salsa20Words a == Salsa20Words (a ^ diff))\n                  where diff = [ 0x80000000 | _ <- [0..15]]) }});\n    print \"Done\";\n};\n```\n\nSAW yields the result quickly:\n\n```\nProving Salsa20 hash theorems.\nValid\nTime:     0.145s\nValid\nTime:     0.232s\nValid\nTime:     0.218s\nValid\nTime:     0.245s\nProving Theorem 7\nValid\nTime:     0.411s\nDone\n```\n\nThis task took SAW under two seconds while proving theorem 7 without the simplification rules, as in Cryptol, takes over a week of computation time.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/www.galois.com\/articles\/proving-program-equivalence-with-saw","filetype":"txt","content":"## Part three: Proving Program Equivalence with SAW\n\nGalois  \nSeptember 15, 2016  \n\nThis is the third in a series of three blog posts detailing the use of SAW and Cryptol to prove the correctness of the HMAC implementation in Amazon\u2019s s2n TLS library. Part one: Verifying s2n HMAC with SAW. Part two: Specifying HMAC in Cryptol.\n\nIn the second post, we left off with the Cryptol specification for HMAC. That\u2019s all well and good, but to bring back an example from last post, knowing that a tiger is a large orange and black cat doesn\u2019t do you very much good if you can\u2019t see. In this post, we will discuss how we recognize that a program is actually described by a Cryptol specification. We will perform this recognition using the Software Analysis Workbench (SAW).\n\nSAW uses a language called SAW Script to help guide automated proofs between two programs. It helps you do things like set up mappings between corresponding elements of the two programs. For example if we had the following two tiger-recognition programs:\n\n```c\nglobal boolean hasStripes;\n\nisTiger(Animal animalType, Color animalColor) {\n  return (hasStripes\n          && animalType == Cat\n          && animalColor == Orange);\n}\n\nnotTiger(String type, String the_color, boolean striped) {\n  if (type == \"cat\"\n      && the_color == \"orange\"\n      && striped)\n    return \"It\u2019s a tiger. Do not hunt\";\n  else\n    return \"Not a tiger, you\u2019re on your own\";\n}\n```\n\nWe would use SAW Script to tell SAW that we wish to show that the results of isTiger and notTiger are the same assuming that hasStripes is the same as striped. We will also need to specify some correspondence between the other inputs, and specify that a result of true from isTiger corresponds to a result of \u201cIt\u2019s a tiger. Do not hunt\u201d from notTiger.\n\nThis means that the SAW Script is actually part of the specification. Without understanding the SAW Script you can\u2019t be sure that SAW is actually verifying the correct thing.\n\n## Equivalence between high and low level Cryptol\n\nLast post we asserted that it is easier to do proofs between two Cryptol specifications than it is to do a proof between a Cryptol specification and C code. To warm up, we\u2019ll start with the easy one.\n\nTo prove equivalence between the high and low level Cryptol specs we run:\n\n```bash\n$ saw hmac_imp_correct.saw\n```\n\nOn a file containing:\n\n```cryptol\nimport \"spec\/HMAC.cry\";\n\nlet check n = do {\n   print (str_concat \"Checking 'hmac_c_state_correct' for byte count \" (show n));\n   time (prove_print abc {{ hmac_c_state_correct : HMAC_c_state -> [n][8] -> [n][8] -> Bit }});\n};\n\nfor [0, 1, 2, 63, 64, 65, 127, 128, 129, 1000] check;\n```\n\nWhere `HMAC.cry` contains a property definition:\n\n```cryptol\nhmac_c_state_correct : { key_size, msg_size }\n            ( 32 >= width msg_size, 64 >= width (8 * key_size) )\n           => HMAC_c_state -> [key_size][8] -> [msg_size][8] -> Bit\nproperty hmac_c_state_correct st0 key msg =\n  hmacSHA256 key msg == hmac_c_state st0 key msg\n```\n\nThis states that the results of running the high and low level specifications on the same inputs are equivalent.\n\nThen we wait a while and each time SAW prints out \u201cverified\u201d telling us that the property has been proved at the sizes specified. SAW can not yet do polymorphic proofs. That means that before proving a property we must instantiate all of the type variables to specific values, and then the proof is done at those values.\n\n## Proving C correct with respect to Cryptol\n\nNow for the hard part. We want to prove the C implementation correct with respect to our low-level Cryptol specification.\n\nFirst we load in our two files:\n\n```saw\nimport \"HMAC.cry\";\nm <- llvm_load_module \"..\/bitcode\/all_llvm.bc\";\n```\n\n## Let\u2019s talk about LLVM\n\nNotice that we are loading in LLVM bitcode, not the C code. There is an important implication here. Information is lost in the compilation from C to LLVM. Some of this information is more important than other.\n\nThe important kind of information that is lost is about undefined behavior in C. The definition of undefined behavior is good for compiler writers because it gives them license to simply not worry about what their compiler does in certain cases. For example, a valid C compiler could take the expression:\n\n```c\nx = 1 \/ 0;\n```\n\nAnd compile it into LLVM that does nothing to the value of x and as a side effect calls you a rude name in stdout. Because SAW is only aware of the LLVM, it won\u2019t be aware that we are trying to prove something about a program that we can\u2019t even reason about (because of undefined behavior). Instead, SAW will just see a program.\n\nThis strongly suggests that the user not go to a zoo lest their odor frightens the animals. In the general case, this implies that to gain the highest assurance from a SAW proof, a compilation must be done through LLVM by the same compiler that compiled the bitcode used for the proof. Even better, the bitcode used for the proof could be used directly to create the executable.\n\nThis is the case unless you can separately verify that there is no undefined behavior in the C program. Amazon has done this, and they discuss it here. In this case, it is reasonable to expect that your compiler of choice will produce programs that do the same thing as a different compiler that uses LLVM.\n\nThere is less challenging loss of information in the form of source information that is translated into a more readily machine-readable form. The example of this that we run into in our verification is that record names are transformed into record indices between C and LLVM. That means that our SAW Script doesn\u2019t get to mention record names, and instead references record indices.\n\nFortunately, in this case we can mostly use a function to encapsulate our use of these indices. We created a function to initialize a Cryptol record with the values in the LLVM struct:\n\n```saw\nlet setup_initial_hash_state prefix = do {\n  \/\/ Make struct path using 'prefix'.\n  let p before after = str_concat before (str_concat prefix after);\n\n  alg0 <- llvm_var (p \"\" \"0\") (llvm_int 32);\n\n  hash_ctx0_h  <- llvm_var (p \"((\" \"1).0).0\") (llvm_array 8 (llvm_int 64));\n  hash_ctx0_Nl <- llvm_var (p \"((\" \"1).0).1\") (llvm_int 64);\n  \u2026\n\n  let st0 = {{\n    h  = hash_ctx0_h,\n    Nl = hash_ctx0_Nl,\n    \u2026\n  } : SHA512_c_state};\n\n  return (alg0, st0);\n}\n```\n\nWe define a similar function `check_final_hash_state` that allows us to compare an LLVM hash state to a Cryptol record. We also create the analogous functions for the HMAC state.\n\nThis limitation can be fixed by including debug information in the bitcode along with some engineering work on SAW, but for now it slightly affects the readability of our proof scripts. It can also lead to challenges in counter-examples, when the index paths are printed instead of the name paths. It is easy enough to reverse engineer them, but it is an additional step in the debugging process.\n\n## Specifying HMAC update\n\nNow that we understand the implications of proving things about LLVM (and why the important one doesn\u2019t really matter for this case), and we\u2019ve encapsulated the ugliness that currently comes with verifying LLVM, we can get back to business. We will start by creating a specification for the `HMAC_update` function, starting with the definition:\n\n```saw\nlet hmac_update_spec\n     msg_size\n     (cfg : { name            : String,\n              hmac_alg        : Term,\n              digest_size     : Int,\n              block_size      : Int,\n              hash_block_size : Int\n            }) = do {\n```\n\nThe arguments to this specification are the size of a message and a record that defines all of the variables that vary depending on the hash function. This allows us to easily use this specification to verify HMAC with any of the s2n hash functions.\n\nFirst we need to allocate the symbolic variable that corresponds to the LLVM function parameter `in`. We do this with the SAW function `llvm_pointer`. Next we use the `setup_initial_hmac_state` which allocates an entire symbolic HMAC state and returns a record containing all of the fields of that state. We then load the initial value of `in` into variable `in0` and do the same with `size` and `size0` to complete our initialization of the state.\n\n```saw\n  llvm_ptr \"in\" (llvm_array msg_size (llvm_int 8));\n  st0 <- setup_initial_hmac_state;\n  in0 <- llvm_var \"*in\" (llvm_array msg_size (llvm_int 8));\n  size0 <- llvm_var \"size\" (llvm_int 32);\n```\n\nNow we perform a number of assertions using the `llvm_assert_eq` function which takes a LLVM variable name as its first argument and a Cryptol expression as the second. You can think of this function as defining an equality as a precondition. That means that the verification of this function will get to assume that these equalities hold, and in order to use this function you must be able to prove these equalities.\n\nIn this case, we are asserting that the HMAC state matches the HMAC configuration that was supplied to the specification.\n\n```saw\n  llvm_assert_eq \"state->0\" cfg.hmac_alg;\n\n  let hash_block_size = cfg.hash_block_size;\n  llvm_assert_eq \"state->1\" {{ `hash_block_size : [16] }};\n\n  let block_size = cfg.block_size;\n  llvm_assert_eq \"state->3\" {{ `block_size : [16] }};\n\n  let digest_size = cfg.digest_size;\n  llvm_assert_eq \"state->4\" {{ `digest_size : [8] }};\n\n  llvm_assert_eq \"size\" {{ `msg_size : [32] }};\n```\n\nNow we call our Cryptol implementation of HMAC update and store the result in variable `st1`.\n\n```saw\n  let st1 = {{ hmac_update_c_state st0 in0 }};\n```\n\nFinally we check the results of the function. We have two results that we need to check. First we use `check_final_hmac_state st1` which is a function we defined to check if the struct at LLVM variable `state` is equal to its argument. In this case the argument is `st1` that we created by calling the Cryptol function. We also need to be sure that the C function returned without errors, and we do that using `llvm_return`.\n\n```saw\n  check_final_hmac_state st1;\n  llvm_return {{ 0 : [32] }};\n```\n\nWe now set options that determine how the specification will be verified. These are not run at the time of this definition, but rather when we try to prove that a C function meets this spec, SAW will use the tactic contained in the specification to perform the verification.\n\nFirst we set an option that is for performance only (not correctness related). `llvm_sat_branches true` says that at every branch (including loops) the solver should check if both branches are feasible before entering them. In cases where all branches are always feasible, it is better to leave this option false because it will result in unnecessary calls to the solver. In cases where a branch might be eliminated, leaving this option true can save SAW from examining branches that are irrelevant.\n\nFinally, we describe what prover we will use. In this case we will use Z3, but when we come across the Cryptol functions `hash_init_c_state`, etc., we will not unfold their definitions. Instead we will treat them as opaque uninterpreted functions. All we know about them is that when called on the same arguments, they will give the same result.\n\n```saw\n  llvm_sat_branches true;\n  llvm_verify_tactic do {\n      unint_z3 [\n        \"hash_init_c_state\",\n        \"hash_update_c_state\",\n        \"hash_digest_c_state\"\n      ];\n  };\n```\n\nThe Cryptol with uninterpreted functions matches with the C code, because we also write SAW specifications stating that the hash functions are equivalent to the Cryptol functions. These specifications look much like the one that you just saw, but for the tactic we give:\n\n```saw\nllvm_no_simulate;\n```\n\nThis tactic means that when we try to verify a C function with respect to the spec, SAW won\u2019t try to do any work, it will just trust that the specification is correct. We are alright with doing this for two reasons:\n\n- We can always check them against the specification later, and  \n- Nothing we could verify about a hash would be of much interest to HMAC anyways.\n\n## Running the verification\n\nOnce we have specified all of the functions we wish to verify, we can tell SAW what we would actually like to verify. In order to verify the HMAC update specification we just defined we add the following statement:\n\n```saw\nhmac_update_ov <-\n   llvm_verify m \"s2n_hmac_update\" hash_ovs (hmac_update_spec msg_size cfg);\n```\n\nThe `llvm_verify` function takes a llvm module `m` which we loaded at the very beginning, a LLVM function to verify `\"s2n_hmac_update\"`, a list of overrides, or specifications that we will use in place of their respective llvm functions when we come across a call to that function. In the statement above, we have already rolled all of the hash specifications together into a list called `hash_ovs`. We also give the specification that we are verifying with respect to. The `llvm_verify` function returns an override that can be used in future verifications.\n\nThe output of `hmac.saw` when run for a single hash, message size, and key size is something like:\n\n```\nVerifying HMAC: alg = SHA512, key size = 128, msg size = 10 ...\nWARNING: skipping simulation of @s2n_hash_init\n\u2026\nSuccessfully verified @s2n_hmac_update (overriding [Symbol \"s2n_hash_init\",Symbol \"s2n_hash_update\",Symbol \"s2n_hash_update\",Symbol \"s2n_hash_update\",Symbol \"s2n_hash_update\",Symbol \"s2n_hash_digest\"])\nSuccessfully verified @s2n_hmac_digest (overriding [Symbol \"s2n_hash_init\",Symbol \"s2n_hash_update\",Symbol \"s2n_hash_update\",Symbol \"s2n_hash_update\",Symbol \"s2n_hash_update\",Symbol \"s2n_hash_digest\"])\nDone!\n```\n\nThe warnings are for functions that we skipped the proof of using `llvm_no_simulate`. In this case we aren\u2019t worried about them. Then SAW tells us what functions we verified and we are done!\n\n## Integrating SAW tests with s2n\n\nWith the verification complete, we have learned that s2n is equivalent to the high level specification. Almost as important, however, is to integrate the SAW verification with the s2n code so that verification can continuously be run as the code evolves. It should be fully automatic to run enough SAW verifications to make a very convincing argument that the `s2n_hmac` functions are implemented correctly, and it should require no additional user effort beyond starting the tests.\n\nWe have created two kinds of tests that will be run by calling `make saw` from the s2n root directory. The first kind of test is standard verification. We prove that the s2n implementation is equal to the Cryptol implementation for various hashes, message sizes, and key sizes. The second kind of tests are negative tests. These are tests to ensure that SAW is working properly to catch bugs by intentionally introducing bugs and making sure that SAW does not successfully verify the functions.\n\nWe achieved the negative tests by copying all of the s2n code, patching the copy with bugs, and then compiling the patched code to LLVM for verification with the exact same SAW file that was used for the standard verification tests.\n\nOne of the negative test cases involves the code we discussed in the previous post:\n\n```c\nstate->currently_in_hash_block += (4294949760 + size) % state->hash_block_size;\n```\n\nWhich we change to:\n\n```c\nstate->currently_in_hash_block += (4294949761 + size) % state->hash_block_size;\n```\n\nThis is a particularly compelling negative test case because the large constant was computed by the developers of s2n and is not contained in any standard. When SAW tries to verify it, it returns a counterexample. What that counterexample is isn\u2019t particularly meaningful, since this bug should trigger an error on a wide variety of test cases.\n\nTo show SAW\u2019s ability to find bugs that occur more rarely, we introduce a bug that occurs in one out of every 256 cases. More specifically, it checks the 10th byte of a message for a certain value, and changes it if it has that value. This sort of case would be almost impossible to catch by testing alone but SAW finds it in around 20 seconds, returning a counterexample that shows that the input message should have its 10th bit set to the correct value in order to find the bug.\n\nWe also modified the Amazon Travis CI script, so now when you see the green \u201cbuild:passing\u201d button on the Amazon Github page, you know that our SAW tests have been successfully run on that version.\n\n## Answers to the Homework\n\nNow let\u2019s discuss exactly what our verification means, and what you still need to trust to be absolutely certain that the s2n code is correct.\n\nIn the last post, we discussed asking the question \u201cwhy should I believe a SAW verification of s2n HMAC is correct?\u201d and asked you to make a list of the answers to that question. Here are our answers to that question. On the left we have the answers for believing a SAW proof is correct and on the right is believing that s2n\u2019s implementation of HMAC is correct using the current tests as evidence:\n\n| SAW Proof Trust Basis                          | s2n HMAC Test Trust Basis                   |\n|-----------------------------------------------|---------------------------------------------|\n| LLVM behaves the way SAW believes LLVM behaves | C compiler behaves as the reader\/developers believe it does |\n| Running SAW at specific sizes is sufficient to show full program equivalence | Specific s2n tests are sufficient to show full correctness of the program |\n| Cryptol implementation of HMAC is correct     | C program is correct                         |\n| SMT solver makes correct decisions about equations | Reader\u2019s handwritten math is correct        |\n\nNow we will discuss why each of the SAW points on the left is a significant improvement over the comparable test point on the right.\n\n- **Compiler behavior:** SAW has been tested on a wide range of C programs already. If the assertions SAW makes about program behavior turn out to be incorrect, SAW will be fixed and be more correct about LLVM behavior going forward. Any individual\u2019s understanding of the C language, however, is unlikely to be very complete or correct. The C language is massive, and has no shortage of tricky corner cases. Making sure to test every corner case every time is much better done by verification software than humans.\n\n- **Coverage:** SAW does not prove full program equivalence yet, it proves it at specific input sizes. However, as we discussed in the first post, SAW running at even a single input size covers far more cases than we could ever hope to cover with test cases.\n\n- **Specification\/Implementation correctness:** Cryptol is a language that has been designed specifically to be readable by cryptography experts. The specifications look as close as possible to the math that appears in standards and should be visually comparable to those specifications. Furthermore, a single specification could be used to prove multiple implementations correct. This would further increase trust that the specification is correct. C implementations on the other hand are very specific to the library they are part of. Each has its own optimizations, safety features, and memory layout. All of these things can have an effect on program correctness, and distract from the real meaning of the program from a correctness point of view.\n\n- **Solving equations:** SMT solvers are very widely used for solving equations, making bugs unlikely. Many solvers are capable of generating evidence of correctness that can independently be checked by hand or by other programs. Comparably, math done by hand is less likely to be correct, and should be less convincing when presented as an argument for program correctness.\n\nThere are still things that need to be trusted in order to be completely sure that s2n HMAC is correct, but by running the SAW proofs, we have taken a gigantic step from \u201cnot particularly sure\u201d to \u201cpretty darn sure\u201d about the correctness of s2n HMAC. Furthermore, each individual thing that needs to be trusted about SAW can be made easier to trust through further development of SAW. For example, we would love to allow SAW to do inductive reasoning so that it doesn\u2019t need to be limited to a finite number of input sizes. This would give us the ability to cover the input\/output space of a program completely, which would be an incredible capability.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/www.galois.com\/articles\/solving-n-queens-in-cryptol","filetype":"txt","content":"## Solving n-Queens in Cryptol\n\nApril 12, 2010  \nThe eight queens puzzle asks how to place eight queens on a chess board such that none of them attacks any other. The problem easily generalizes to n queens, using an n\u00d7n board. In this post, we\u2019ll see how to solve the n-Queens puzzle in Cryptol, without lifting a finger!\n\n## Representing the board\n\nIt is easy to see that any solution to the n-Queens puzzle will have precisely one queen on each row and column of the board. Therefore, we can represent the solution as a sequence of n row numbers, corresponding to subsequent columns. For instance, the board pictured below (taken from the Wikipedia page), can be represented by the sequence\n\n```\n3 7 0 2 5 1 6 4\n```\n\nrecording the row of the queen appearing in each consecutive column, starting from the top-left position. (And yes, we always count from 0!)\n\n## Recognizing a valid solution\n\nLet us start by asking a simpler question. How can we recognize that a given sequence of n row indices constitutes a valid solution? We have to verify that the following hold:\n\n- The numbers must be between 0 and n-1. (Sanity checking.)\n- The numbers should not be duplicated. (Ensures that there is exactly one queen per row.)\n- For any pair of numbers in the sequence, their row-value difference should be different than their column-value difference. (Ensures that there are no diagonal conflicts.)\n\nThe first two conditions are fairly trivial. The last one simply says that if two queens are positioned such that their vertical and horizontal displacements are the same, then they are on the same diagonal: a situation we must avoid for all pairs of queens.\n\n## Writing a Cryptol predicate\n\nHaving described how we will recognize an alleged solution, let us now consider how we can code this in Cryptol. First, we will need a helper function that applies a given predicate to all the elements of a sequence and returns True if all elements satisfy the predicate. Naturally, we call this function `all`:\n\n```cryptol\nall : {n a} (fin n) => (a -> Bit, [n]a) -> Bit;\nall (f, xs) = [| f x || x <- xs |] == ~zero;\n```\n\nThe type of this function is worth spending a few moments looking at, as it demonstrates some crucial aspects of Cryptol\u2019s type system that sets it apart from other languages. In particular, it says that the function `all` takes a sequence of n elements, each of some arbitrary size a. However, it also restricts n to be finite; i.e., the type system will complain if you pass `all` an infinite sequence. Then, we apply the predicate `f` to each element in the sequence, and check that the result consists of all True bits. (The polymorphic Cryptol value `zero` represents a value with an arbitrary shape with all bits set to False. The complement operator (~) flips all those bits to True.)\n\nThe second utility function we will need is a predicate that checks whether the elements of a given sequence are all distinct:\n\n```cryptol\ndistinct : {a b} (fin a, fin b) => [a]b -> Bit;\ndistinct xs = diff == ~zero\n  where {\n    n = width xs;\n    diff = [| check (x, i) || x <- xs || i <- [0 .. (n-1)] |];\n    check (x, start) = walk (start + 1)\n      where walk cur = if cur == n then True else if xs @ cur == x then False else walk (cur + 1);\n  };\n```\n\nThe function `distinct` is fairly simple: for each element in the sequence, it walks through the rest to make sure that none of the remaining elements are the same as that particular element. Note how Cryptol\u2019s `width` function allows us to determine the size of the input sequence, and recurse properly.\n\nHaving done the heavy lifting above, we can now write the predicate that recognizes a valid n-Queens solution in Cryptol:\n\n```cryptol\ntype Solution(n) = [n][1 + width n] -> Bit;\nnQueens : {n} (fin n) => Solution(n);\nnQueens qs = all(inRange, qs) & distinct qs & all(checkDiag, ijs)\n  where {\n    n = width qs;\n    inRange x = x < n;\n    ijs = [| (i, j) || i <- [0 .. n - 1], j <- [0 .. n - 1] |];\n    checkDiag (i, j) = (i >= j) | (diffR != diffC)\n      where {\n        qi = qs @ i;\n        qj = qs @ j;\n        diffR = if qi >= qj then qi - qj else qj - qi;\n        diffC = j - i;\n      };\n  };\n```\n\nThe `nQueens` function simply executes our checks as we described above. It first makes sure that all the elements are `inRange`. (Note that we do not have to check for negative numbers since all Cryptol numbers are non-negative.) Then, we check that all the elements are distinct. Following this, we generate the pairs of indices `ijs`, and call `checkDiag` on all these pairs to make sure that the row and column differences do not match.\n\nWe can test this function in Cryptol by providing sample input:\n\n```\nNQueens> nQueens [3 7 0 2 5 1 6 4]\nTrue\nNQueens> nQueens [3 7 0 2 5 6 1 4]\nFalse\n```\n\nIn the second example, I swapped the elements 1 and 6; effectively putting the 6th queen on row 6 and the 7th on row 1. This creates a diagonal conflict as the reader can easily verify.\n\n## Solving n-Queens\n\nIt appears that all we have done so far is to write a Cryptol program to recognize whether a given solution to the n-Queens problem is valid. But how do we actually solve the puzzle?\n\nRemember that I promised to solve n-Queens without lifting a finger, and this is where Cryptol\u2019s formal methods based tools come into the picture. Given any predicate (like `nQueens` above), Cryptol can find inputs that will satisfy it automatically, at the push of a button! (We have briefly described how this works in our previous post on Sudoku, so I shall not go into any details. Suffice it to say that one can exploit modern SAT\/SMT solvers to generate automatic solvers for validity problems, and Cryptol provides just the right framework for doing so.)\n\nWithout further ado, here is how we solve n-Queens in Cryptol, without writing any additional code on top of what we have already seen:\n\n```\nNQueens> :set sbv\nNQueens> :set base=10\nNQueens> :sat nQueens : Solution(8)\n```\n\nThe first command puts Cryptol in the `sbv` mode, which allows for the use of SAT\/SMT solvers. The second command tells Cryptol to print results in base 10. Finally, the `:sat` command finds satisfying assignments for predicates. The type-signature on the `:sat` command indicates that we are interested in solutions for 8-queens, for which we are given a solution almost instantaneously!\n\nIf you look at the wiki page for n-queens, you will see that they claim there is always a solution when n = 1 and n \u2265 4. We can indeed verify that there are no solutions when n is 2 or 3, using Cryptol:\n\n```\nNQueens> :sat nQueens : Solution(2)\nNo variable assignment satisfies this function\nNQueens> :sat nQueens : Solution(3)\nNo variable assignment satisfies this function\n```\n\nWhile these two properties are easy to see, it\u2019s quite valuable to get independent verification!\n\n## In practice\u2026\n\nWe would be remiss if we didn\u2019t mention some of the actual uses of the satisfiability checker in the Cryptol tool chain. The most important application is in verifying functional equivalence of two functions. If `f` and `g` are two functions, then they are functionally equivalent exactly when the predicate `(x -> f x != g x)` is not satisfiable. (Conversely, if this predicate is satisfiable then the satisfying value is where `f` and `g` disagree, indicating a potential bug.)\n\nMore importantly, `f` and `g` need not be both written in Cryptol. The toolchain allows performing equivalence checking between functions written in VHDL, C, and Java (with varying degrees of \u201cseamless\u201d integration!). Furthermore, this is also how we make sure our compiler produces correct code: The function `g` can be generated code, for instance in one of Cryptol\u2019s intermediate languages as we compile Cryptol to FPGA descriptions. In summary, we can check the equivalence of 3rd party code (generated or hand-written) against \u201cgold\u201d Cryptol specifications, increasing assurance in the correctness of crypto-implementations.","variant":null,"set":"supervised"}
{"filename":"https:\/\/www.galois.com\/articles\/block-ciphers-homomorphically","filetype":"txt","content":"## Block Ciphers, Homomorphically\n\nBrent Carmer and David Archer  \nDecember 3, 2014\n\nOur team at Galois, Inc. is interested in making secure computation practical. Much of our secure computation work has focused on linear secret sharing (LSS, a form of multi-party computation) and the platform we\u2019ve built on that technology. However, we\u2019ve also done a fair bit of comparison between LSS, garbled circuit approaches, and homomorphic encryption (HE). We recently noticed that Shai Halevi and Victor Shoup\u2019s open source homomorphic encryption library HElib was just waiting for someone to implement some interesting block ciphers. In this post, we talk about our experience implementing and evaluating performance of the SIMON block cipher in HElib. Our implementation processes 1800 64b blocks in parallel, achieving a rate of 3.1 seconds per block.\n\nIn homomorphic encryption (HE), a user encrypts data and sends it to a single untrusted server. That server, which does not hold the encryption key, computes on the encrypted data and returns an encrypted answer to the user. Each step in HE computation accumulates noise that eventually makes the plaintext unrecoverable unless extra time-consuming steps (informally called bootstrapping) are taken. When these steps are not taken, HE cryptosystems are typically called somewhat homomorphic (SHE for short). When bootstrapping is used, more complex computations can be performed. Such cryptosystems are typically called fully homomorphic (FHE for short).\n\nUnfortunately, making HE practical is challenging. HE is very much (many orders of magnitude) slower than computing the same result \u201cin the clear\u201d. Typical HE ciphertexts are also far (thousands to millions of times) bigger than the plaintexts they represent. Even with such challenges, the promise of HE is compelling, particularly where mobile devices may have insufficient computational power, cloud-based servers may be readily used to outsource such computation, and users are not prepared to trust those servers with their (plaintext) data.\n\nAs of this posting, HElib as available on GitHub falls into the SHE category. Shai and Victor have indicated that they plan to make bootstrapping (and thus FHE) available in a few weeks. To gain experience using HElib, we implemented a member of the SIMON block cipher family. SIMON is a new family of lightweight block ciphers released by the NSA in 2013. We implemented SIMON with 64 bit block size and 128 bit key size. The SIMON specification calls for 44 processing \u201crounds\u201d in SIMON 64\/128, which we were able to implement using the current (somewhat homomorphic) version of HElib.\n\nKey portions of our SIMON implementation are shown below encoded in Cryptol, a domain-specific language for expressing cryptographic algorithms developed by Galois and widely used in some government agencies. Cryptol is designed to describe cryptographic algorithms at a level of abstraction very close to mathematical specification, to minimize the likelihood of error when translating from specification to code. The Cryptol tool suite supports automated verification for some target languages that implementation matches a Cryptol description. The Cryptol suite can also automatically generate certain implementations from Cryptol descriptions. Using Cryptol\u2019s support for SAT solvers, we have proven some properties of our SIMON implementation: absence of weak keys, injectivity of key expansion, and identity of decryption composed with encryption.\n\n```cryptol\n-- encRound is the core of our SIMON implementation \n-- It takes a key and a 64b plaintext block, \n-- divided into two 32b chunks.\n-- As with all Feistel ciphers, at each round we \n-- swap the chunks and only manipulate one of them.\n\n-- type signature for encRound:\nencRound : [32] -> ([32], [32]) -> ([32], [32])\n\n-- implementation of encRound:\nencRound k (x, y) = (y ^ f x ^ k, x)\n\n-- f is a helper function that performs \n-- rotations and xors over a chunk of input.\nf : [32] -> [32]\nf x = ((x <<< 1) && (x <<< 8)) ^ (x <<< 2)\n\n-- encrypt performs one encRound on the input \n-- for each of the keys\nencrypt : [4][32] -> ([32], [32]) -> ([32], [32])\nencrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [ encRound k b | b <- bs | k <- ks ]\n    ks = expandKey k0\n```\n\nNote: find the whole Cryptol specification for SIMON in simon.cry\n\nThis description specifies what we set out to implement, using HElib as a platform. Ciphertexts in HElib are composed of vectors of elements of certain rings. For our implementation, we use Ring(2). Thus each element in the ciphertext vector represents a single bit. HElib also supports the notion of \"packing\" multiple plaintexts into a single ciphertext, and computing on these in parallel, in a SIMD-like paradigm. The number of plaintexts packable into a ciphertext, which we call nSlots, is impacted by a number of parameters, including the maximum supported computation depth of the circuit, which we call L. As we vary L to allow for more computation and parallelism, we also affect the cost of the computation in the form of the size of cryptographic keys used at each level in the Boolean circuit.\n\n## Our first attempt\n\n### Representing SIMON ciphertext blocks\n\nBlocks for the SIMON block cipher are 64b in size, but must be manipulated as two 32b halves (typical of Feistel ciphers). Because of this natural structure, we first implemented ciphertexts as two vectors of 32b each. In our implementation, the nSlots parameter is much larger than 32, so we padded the ciphertexts with zeroes, not taking advantage of packing. We represent these vectors as follows:\n\n```cpp\n\/\/ a plaintext block is simply two 32b unsigned integers\nstruct pt_block {\n    uint32_t x;\n    uint32_t y;\n};\n\n\/\/ we encrypt each half by itself\nCtxt heEncrypt(const FHEPubKey& k, uint32_t x) {\n    vector vec = uint32ToBits(x); \n    pad(0, vec, global_nslots);\n    Ctxt c(k);\n    global_ea->encrypt(c, k, vec);\n    return c;\n}\n\n\/\/ then, a secret block is simply two ciphertexts\nstruct heBlock {\n    Ctxt x;\n    Ctxt y;\n};\n```\n\n### Processing SIMON blocks\n\nThe SIMON algorithm requires use of addition in GF(2) (that is, XOR), multiplication in GF(2) (AND), negation, and both left and right rotations. HElib provides the required addition and multiplication primitives. However, we must compose our own negation function by bitwise XOR with a vector of all ones:\n\n```cpp\n\/\/ x is the ciphertext, global_maxint is the all 1's vector\nvoid negate32(Ctxt &x) { \n    x += *global_maxint;\n}\n```\n\nBecause HElib provides shift operations but not rotation, we create the required rotation functions. Because this is a bit tricky, we use Cryptol to specify our rotation approach and prove its correctness.\n\nBelow is our resulting HElib code for rotation.\n\n```cpp\nvoid rotateLeft32(Ctxt &x, int n) {\n    Ctxt other = x;\n    global_ea->shift(x, n);\n    global_ea->shift(other, -(32-n));\n    \/\/ x |= other. Must do De Morgan's law manually\n    negate32(x);\n    \/\/ since we do not have bitwise OR in HElib\n    negate32(other);\n    x.multiplyBy(other);\n    negate32(x);\n}\n```\n\n### Implementing encRound\n\nAt this point, we have all the basic functions we need to build SIMON. Next, we implement the key function on which SIMON depends: encRound. Implementing encRound is straightforward and follows directly from the Cryptol:\n\n```cpp\nvoid encRound(Ctxt key, heBlock &inp) {\n    Ctxt tmp = inp.x;\n    Ctxt x0  = inp.x;\n    Ctxt x1  = inp.x;\n    Ctxt x2  = inp.x;\n    Ctxt y   = inp.y;\n    rotateLeft32(x0, 1);\n    rotateLeft32(x1, 8);\n    rotateLeft32(x2, 2);\n    x0.multiplyBy(x1);\n    y    += x0;\n    y    += x2;\n    y    += key;\n    inp.x = y;\n    inp.y = tmp;\n}\n```\n\n### Evaluating the first attempt\n\nWe evaluated this approach by testing performance and ability to complete SIMON without exceeding the allowable circuit depth. In one experiment, the computation took unreasonable time: 14 hours for a single block at a circuit depth (L=80) that allowed the computation to finish all rounds correctly. In another experiment, the computation was much faster, but cannot complete all rounds within the homomorphic noise threshold, completing only 10 rounds of the required 44 in 500 seconds with L=16. We concluded that this first approach was unworkable in practice.\n\n## Our second attempt\n\nFor our next try, we adopted the concept used by Smart et al. to achieve concurrency in leveled homomorphic AES implementations. This idea, called \"bit-slicing\", interleaves individual bits of multiple plaintexts.\n\nFirst, we select the same bit from each plaintext, and form a vector of those bits. For example, a vector is formed by selecting the first bit of each plaintext in a group of plaintexts. Next, each vector is homomorphically encrypted. Then we form a vector of the resulting ciphertexts. This vector thus contains the ciphertexts for all included plaintexts.\n\nWhile this original motivation for this approach was to achieve concurrency with appropriate computing resources, we use it for a different purpose. The highest cost computational primitive in our SIMON implementation is rotation. Rotation is expensive because (as shown in simon-blocks.cpp) it requires bitwise OR, which in turn requires multiplication.\n\nEach of the 44 rounds in SIMON requires three such rotations in addition to the other multiplications and additions used. Because addition is inexpensive and there is only a single other multiplication per round, rotation dominates computational cost. The bit-slicing approach allows us to rotate \"for free\" by simply permuting indices in the vector of ciphertexts. Thus the multiplication involved in rotation is eliminated, reducing the number of multiplications per round of SIMON from 4 to 1. See the resulting implementation at simon-simd.cpp.\n\n## Results\n\nWith this new approach and a selection of L=23, we were successful at completing all rounds of SIMON without the need for recryption. Our implementation achieves 126 seconds per round. Thus all 44 rounds are completed in 1 hour and 52 minutes. This compares favorably to our naive implementation that required 14 hours. In addition, L=23 (along with our choices for other parameters) allows us nSlots of up to 1800. Taking advantage of this parallelism, we process 1800 64b blocks concurrently for performance averaging 70ms per round, or 3.1 seconds per block.\n\nBlock ciphers are a popular class of benchmark applications for secure computation. A linear secret sharing implementation of AES-128 on the Galois ShareMonad platform was for some time the fastest known secure computation implementation of AES, achieving 3ms per block [LAD12]. Our implementation of SIMON on HElib adds to this body of work the first known implementation of a modern block cipher using this library. Our code base is available at GitHub. In the near future, we plan to explore the upcoming recryption capability in HElib to implement and study AES in this framework.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/www.galois.com\/articles\/a-cryptol-implementation-of-skein","filetype":"txt","content":"## A Cryptol Implementation of Skein\n\nGalois  \nJanuary 24, 2009\n\nFollowing on from the MD6-in-Cryptol posting, let's consider another very interesting candidate from the (deep) pool of SHA-3 submissions; Skein (http:\/\/www.skein-hash.info\/).\n\n(http:\/\/www.schneier.com\/skein.html) by the merry band of Ferguson, Lucks, Schneier, et al. The expression of their reference implementation comes out, we think, fairly cleanly in Cryptol. The digest output size is a variable parameter to the algorithm, but we'll focus on the 512-bit version here \u2014 the submission's primary candidate for SHA-3. In order to avoid duplicating the introductory material on Cryptol, we suggest the reader go through the MD6 writeup to get a grounding in Cryptol, its idioms, and syntax.\n\n## The structure of Skein\n\nSkein refers to a family of hashing functions, differing in the size of their internal state. We'll look at the 512-bit version here. Skein is built up out of three main components:\n\n- A tweakable block cipher, Threefish.\n- The Unique Block Iteration (UBI) chaining mode, defining the mode-of-operation by the repeated application of the block cipher function.\n- Optional arguments to the hashing function. Extra functionality and input to the hashing function can be accommodated via Skein's optional argument system. There is also input, like key material and randomized-hashing via nonces, etc. (see spec for details). We won't consider any such additional inputs in our implementation of the basic hashing functionality.\n\nWe'll take the same tack as with the MD6 presentation \u2014 starting at the top by showing the mode-of-operation function, working our way down to the tweakable block cipher that the Skein team developed as part of Skein.\n\n## The Skein hashing function\n\nThe pure\/simple Skein hashing function (512 bit) transforms an arbitrary length byte sequence into a 512-bit output:\n\n```cryptol\nhash512 : {a}\n\/\/ type constraints\n( fin a \/\/ finite input\n, 32 >= width (8*((8*a+7)\/8))\n, 32 >= width (8*a)\n, 64*(((8*a+7)\/8+63)\/64) >= (8*a+7)\/8\n, 8*((8*a+7)\/8) >= 8*a\n) => [a][8]   \/\/ input message\n  -> [64][8]; \/\/ 512-bit result\n```\n\nThe Cryptol type signature captures that (and more!), with the `[64][8]` result packaging up the result into a 64-element wide sequence of 8-bit bytes. The type constraints look involved, but capture the pre-condition that the input message size has already been padded out to the desired width. (Writing Cryptol functions that automatically perform padding based on input sizes is possible, but would be a distraction here.) The definition of `hash512` closely mirrors the specification (Section 3.5.4):\n\n```cryptol\nhash512 m = output512 g1\n  where {\n    k = (zero : [64][8]);\n    c = mkConfig(512); \/\/ config string, see Section 3.5.2 of spec.\n    g0 = ubi512 (encrypt512, k, join c, t_cfg);\n    g1 = ubi512 (encrypt512, g0, join m, t_msg);\n  };\n```\n\ni.e., it is the double application of the chaining mode UBI, followed in the end by the computation of the result by the `output512` function. As the internal size has been fixed here to 512, the innermost UBI computation is actually all over constant inputs and could be folded\/optimized away. This optimization can be done manually or by the Cryptol tools, but we won't bother with the optimization here.\n\nThe output function is simply another application of the UBI:\n\n```cryptol\noutput512 : [64][8] -> [64][8];\n\noutput512 g = ubi512 (encrypt512, g, (zero : [64]), t_out);\n```\n\ni.e., a straight UBI computation of the internal state argument `g` to the null message and a special output type value.\n\nRegarding `t_out`, the various `t_X` values in the above represent the type values that Skein defines:\n\n```cryptol\nt_out : [128];\nt_out = ((0x3f : [6]) # zero) << 120;\n\nt_cfg : [128];\nt_cfg = ((0x04 : [6]) # zero) << 120;\n\nt_msg : [128];\nt_msg = ((0x30 : [6]) # zero) << 120;\n```\n\ni.e., padded out to 128-bit widths so as to fit with subsequent use as basis for Skein's tweak values.\n\nThat's the toplevel driver for the Skein hashing function. Let's consider next the chaining mode that it builds upon.\n\n## UBI: the Unique Block Iteration chaining mode\n\nThe chaining mode employed by Skein is parameterized over the following values:\n\n- G - (chained) internal state \/ starting value.\n- M - the message string.\n- T - a 128-bit starting value for the tweak (the type value from the above).\n\nAs a Cryptol type signature, its external interface would be:\n\n```cryptol\nubi512 : {a}\n( fin a\n, 32 >= width (8*((a+7)\/8))\n, 32 >= width a\n, 64*(((a+7)\/8+63)\/64) >= (a+7)\/8\n, 8*((a+7)\/8) >= a\n) => ( (([64][8],[16][8],[64][8]) -> [8][64]) \/\/ block cipher function\n     , [64][8]       \/\/ initial (chained) value \/ state.\n     , [a]           \/\/ input message\n     , [128]         \/\/ tweak base value\n     ) -> ([64][8]); \/\/ 512 bit result\n```\n\nThe type constraints all involve the type variable `a`, which is the size of the input message. Together they express the padding assumptions made or introduced over that bit string.\n\nThe function takes four arguments, the first being a function value \u2014 the block cipher function to apply for each of the blocks that the input message is divided up into. We'll have more to say about its type and properties in the next section when we show how the Threefish cipher is expressed in Cryptol. The other three are the `G`, `M`, and `T` parameters to the UBI, which we can now define as follows:\n\n```cryptol\nubi512 (encryptor, g, m, t) = last hs\n  where {\n    hs = [g] # [| m ^ split(join(encryptor(h, groupBy(8, mkTweak(t, width(m1), nb, width ms, i, b)), m)))\n               || h\n  };\n```\n\nLike before, let's start with the result value and work ourselves inwards from there \u2014 the result being the last element of the `hs` sequence. `hs` represents the result of processing each block (512 bits) of the input message. The definition of `hs` expresses how to compute block N's digested output:\n\n```cryptol\nhs = [g] # [| m ^ split(join(encryptor(h, groupBy(8, mkTweak(t, width(m1), nb, width ms, i, b)), m)))\n           || h\n```\n\nThe iterative nature of the chaining mode is captured as a recursive sequence comprehension in Cryptol, with each of the arms of the comprehension providing input to the UBI's result computation (e.g., `m <- ms` selects each block in turn). That result computation is a bit of a mouthful, but easy enough to pick apart a bit:\n\n```cryptol\nm ^ split(join(encryptor(h, groupBy(8, mkTweak(t, width(m1), nb, width ms, i, b)), m)))\n```\n\ni.e., XORing the message block with the application of the block cipher encryptor:\n\n```\nencryptor(H, Tweak, MsgBlock)\n```\n\nwhere `Tweak` is a 128-bit value made up out of a range of parameters, globally-constant, per-UBI-specific and per-round, all contributing to diffusing the output. The `h` is the output from the previous invocation of the block cipher, i.e., to compute element we need to have access to the previous UBI result only.\n\nWe hope it is relatively straightforward to map the definition of `hs` back to the recurrence relation that defines the UBI in Section 3.4 of the Skein specification. With tweaks and message blocks in place, it is time to consider the block cipher that Skein uses.\n\n## Threefish, a tweakable block cipher\n\nThis block cipher is parameterized over the following values:\n\n- K - block cipher key (512 bits \/ 64 bytes)\n- T - tweak (128 bits \/ 16 bytes)\n- P - plaintext (equal to key)\n\nDeriving the Cryptol type signature from that is straightforward:\n\n```cryptol\nencrypt512 : ([64][8], [16][8], [64][8]) -> [8][64];\n```\n\nwith the result being 8 64-bit words. This simple type hides many a clever detail though:\n\n```cryptol\nencrypt512 (key, tweak, pt) = vn + kn\n  where {\n    vn : [nw][64];\n    vn = last vss;\n    kn : [nw][64];\n    kn = last kss;\n    \/\/ ...more below...\n  };\n```\n\nThe result is the element-wise addition of two 64-bit word sequences of width 8 (cf. the definition of the ciphertext C in Section 3.3 of the specification). `kn` is the last value from the key schedule of the cipher, and `vn` is the last value from the round computation. The key schedule is a Cryptol sequence of values, splitting up the input key and tweak into round\/4 sub-keys:\n\n```cryptol\nkss : [19][nw][64];\nkss = [| keySchedule_8(tw_words, key_words, d) || d\n```\n\nWe won't show the implementation of the `keySchedule_8()` function here, but the reader is encouraged to download the sources and look it over in Skein\/Threefish.cry.\n\nThe subkeys are combined together with the per-round values:\n\n```cryptol\nvss : [73][nw][64];\nvss = [pt_words] # [| fs @@ pi_8 || fs\n```\n\nAgain, we won't go into further details on the internals of the cipher, but it is worth highlighting the use of mutually recursive sequence values \u2014 `vss` is computed in terms of `fss`, which is defined in terms of `ess`, which ties the knot back to `vss` in its definition. The recursive nature works out by being initialized with `pt_words` as the result of round 0.\n\n## The MIX function\n\nThreefish uses the MIX function to perform its permutation and mixing; encoded in Cryptol as follows:\n\n```cryptol\nmix8 : ([8], [8][64]) -> [8][64];\nmix8 (d, xss) = join [| mix_8(d, j, xs) || j |]\n\nmix_8 (d, j, [x0, x1]) = [y0, y1]\n  where {\n    y0 : [64];\n    y0 = x0 + x1;\n    y1 = (x1 <<< (rs_8 @ j @ ((d % 0x8) # zero))) ^ y0;\n  };\n```\n\nIncluded here for completeness, the round-dependent permutation of its 512-bit input maps relatively cleanly onto the specification of MIX in Section 3.3.1. The built-in `groupBy` operator performs a useful function here in dividing up its per-round input:\n\n```cryptol\ngroupBy : {a b c} (b, [a * b]c) -> [a][b]c\n```\n\ni.e., if the second argument is a multiple of the first (`b`), we can divide it up into `a` values of width `b`. We use it here to split up the 512-bit input into 4 pairs of 128-bit values.\n\n## Concluding remarks\n\nSkein has an appealingly clean structure and composition, something we hope to have maintained in its Cryptol rendition. The use of recursive sequence definitions to express the chaining and iterative nature of the algorithm is one place which helped in maintaining the clear mapping back to the specification. Having a clean reference implementation like this has considerable value, but using it with Cryptol and its toolchain, you may take advantage of its definition in a number of ways. Please see the concluding remarks for the MD6 posting for an outline of what they are.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/pure.royalholloway.ac.uk\/ws\/portalfiles\/portal\/52628521\/Accepted_Manuscript.pdf","filetype":"txt","content":"## Verifying Classic McEliece: examining the role of formal methods in post-quantum cryptography standardisation\n\nMartin Brain, Carlos Cid, Rachel Player, and Wrenna Robson  \n1 Royal Holloway University of London, Egham, UK  \n2 Simula UiB, Bergen, Norway  \n3 City, University of London, Northampton Square, London, UK  \n4 Okinawa Institute of Science and Technology Graduate University, Okinawa, Japan\n\n### Abstract\n\nDevelopers of computer-aided cryptographic tools are optimistic that formal methods will become a vital part of developing new cryptographic systems. We study the use of such tools to specify and verify the implementation of Classic McEliece, one of the code-based cryptography candidates in the fourth round of the NIST Post-Quantum standardisation Process. From our case study we draw conclusions about the practical applicability of these methods to the development of novel cryptography.\n\n## 1 Introduction\n\nComputer-aided cryptography [10] is the field of study which \u201cdevelops and applies formal, machine-checkable approaches to the design, analysis, and implementation of cryptography\u201d. This can be categorised into three strands:  \n\u2013 Establishing security guarantees at the design level, using symbolic and computational approaches.  \n\u2013 Verifying that implementations (new or pre-existing) are both efficient and functionally correct, by showing they conform to the design about which security guarantees have been established.  \n\u2013 Establishing security guarantees at the implementation level, such as constant-time execution and secret-data-independent memory accesses, both of which indicate resistance to timing attacks.\n\nPanelists in a recent roundtable [29] on computer-aided cryptography expressed broad optimism on the future of the field, citing the success of tools and projects like HACL* [32], Fiat Cryptography [24], and Cryptoline [26]. One participant expressed the view that, within a few years, \u201cthe state of the art in program proofs will have advanced enough that verifying primitives will be considered mundane and a strong requirement for any new proposed algorithm\u201d.\n\nDespite this optimism, most submissions to the NIST Post-Quantum Cryptography standardisation Process [5] made no documented use of computer-aided cryptography in their development. Indeed, only two submissions \u2014 NTRU Prime [15] and Classic McEliece [8] \u2014 made mention of any potential use of formal methods in improving their designs. The NTRU Prime supporting documentation stated [15] that the design choices of the scheme enabled easier formal verification of its security properties, and that the authors had begun work on verifying the optimised NTRU Prime implementation against the reference implementation [14]. The Classic McEliece specification suggested a need for formally verified proofs of quantum security, and also mentioned the potential of formal verification of defences against timing attacks. Moreover, there has not been much use of computer-aided formal techniques in the evaluation of any of the schemes proposed for standardisation thus far.\n\nRecently, NIST concluded the third round of their standardisation process. After round three, none of the remaining code-based candidates were selected for standardisation, but all of them were moved forward to the fourth round [1]. The isogeny-based scheme SIKE was also advanced to the fourth round, but has subsequently seen a successful attack on its underlying hard problem [21]. If any fourth-round candidates for KEM are selected for standardisation, they are thus likely to be code-based, which motivates further scrutiny of these candidates.\n\nThe security of the remaining code-based candidates is reasonably well-understood, especially Classic McEliece, which has been long studied. Therefore, other criteria will play an important role in evaluating and distinguishing these schemes. We argue that applying the tools of computer-aided cryptography to study these schemes is vital at this stage. Firstly, the amenability of each scheme to being scrutinised and verified using these tools could be a criterion for their evaluation. Secondly, demonstrating that the design or an implementation of a scheme has been verified gives further confidence in this scheme.\n\nIn this work, we focus on applying computer-aided cryptography techniques for developing efficient verified implementations to the Classic McEliece scheme. Our main focus is an application of the SAW\/Cryptol toolchain [25,20] to the Classic McEliece reference implementation. We also report on our recent efforts using the interactive theorem prover Lean in the verification of the mathematics underlying aspects of the Classic McEliece design.\n\n### 1.1 Related work\n\nVerification of code-based cryptography To the best of our knowledge, there are only two other works [4,3] whose goal, as in this work, is to create a formal specification of Classic McEliece. The first is a partial specification [4] written in Cryptol, which, as far as we are aware, has not been used for the verification of an implementation. The specification is comparable in size to the one we produced in this work, but is incomplete in different ways. Moreover, it does not seem to correspond to a named version of the Classic McEliece implementation, and targets a different parameter set than the one we aimed at. Thus, we did not derive our own specification from it.\n\nThe second is a specification [3] written in Lean 4, that was made public only after this work was concluded. As with our work, the goal of that work was to investigate the use of Lean 4 for cryptographic specification. The specification [3] compiled to an implementation of the Round 3 version of Classic McEliece which passes the Known Answer Tests, and some of its functions have proven properties.\n\nConsidering the formalisation of code-based cryptography more broadly, the HOL Light theorem prover was used in [13] to formally verify an algorithm to calculate the \u201ccontrol-bits\u201d of a permutation. The implementation of this algorithm is a key component of Classic McEliece. We also note that there are formalisations in Coq of linear error-correcting codes [7], but they are not orientated towards cryptography.\n\nApplications of the SAW\/Cryptol toolchain While our application of the SAW\/Cryptol toolchain to Classic McEliece is novel, we draw inspiration from prior work applying this toolchain to other cryptographic schemes. The primary work we build on is from Galois and Amazon [19]. The paper takes two highly-optimised, trusted implementations of two current primitives, AES-256-GCM and SHA-384, and describes the process of proof engineering and tool development that led to high-level functional correctness proofs for these primitives. It demonstrates some of the current capabilities and limits of the toolchain; as we will discuss, our own work demonstrates different limits.\n\nDeveloping verified implementations While our work focuses on verifying an existing implementation, another approach [9,18] is to generate verified code directly from the specification. For example, a framework for building verified cryptographic implementations is provided in [9]; delivering assembly code that is provably functionally correct, protected against side-channels, and as efficient as hand-written assembly. The framework is illustrated in [9] by an application to the ChaCha20-Poly1305 cipher suite.\n\n### 1.2 Our contributions towards Classic McEliece implementation verification\n\nIn our work, our primary goal is to explore to what extent the Classic McEliece reference implementation submitted to the NIST standardisation process can be formally specified and verified using the SAW\/Cryptol toolchain. Our secondary goal is to see if it is possible to find improvements on the implementation that make it easier to specify and verify, while not impacting performance or its security properties.\n\nTo this end, we offer in this paper:  \n\u2013 Formal specifications and verification proofs for large parts of the Classic McEliece reference implementation as of the Round 3 submission, available at [31].  \n\u2013 A revised implementation for one of the core encryption routines in Classic McEliece which both runs faster and admits a verification proof.  \n\u2013 A set of recommendations for designers and those setting standardisation criteria for engaging with computer-aided cryptography.\n\nAs an additional contribution, we also report on recent efforts to apply the interactive theorem prover Lean [27,30] to produce verified proofs of certain mathematical constructions used in the design of Classic McEliece.\n\nOur attack model assumes that an attacker has full access to the implementation source code and is acting as a man-in-the-middle between a client and server attempting to perform key agreement using this KEM. Bugs in the implementation are relevant only when they cause the implementation to deviate from the theoretical design sufficiently that the IND-CCA2 security guaranteed by the design is violated. Deviations between the specification and implementation that do not cause a weakening of security in practice are less relevant. Our verification target, therefore, was the equivalence of parts of the Classic McEliece implementation with equivalent parts of the design.\n\n## 2 Our toolchain and its target\n\nThe SAW\/Cryptol toolchain consists of Cryptol [25], a domain-specific language for specifying cryptographic algorithms, and the Software Analysis Workbench (SAW) [20], a tool for verifying compiled bytecode against specifications defined using Cryptol. They have both been developed and are maintained by Galois Inc. Cryptol is a size-polymorphic and strongly typed functional programming language, and a Cryptol specification of an algorithm can resemble its mathematical specification more closely than an implementation in a general purpose language. The SAW\/Cryptol toolchain is suitable for verifying pre-existing code against a specification. Thus, it could be applied to code that is highly trusted and so cannot be changed. The SAW\/Cryptol toolchain could also form part of a continuous integration framework, where changes to the underlying program are run against tests that include SAW proof scripts.\n\nThe Classic McEliece key-establishment scheme is derived from the code-based public-key cryptosystem introduced in 1978 by McEliece [28]. The public key in the McEliece cryptosystem specifies a random binary Goppa code \u2014 a linear binary code with certain useful mathematical properties. The private key contains information necessary to perform efficient decoding from an input that is within a bounded error of a codeword. It is the claim of the designers that Classic McEliece is not \u201cnew\u201d in any sense: it aims to be a conservative implementation of an established scheme. Where there are relatively novel elements, such as the storage of permutations in the form of control bits, they are not core to the PKE encryption and decryption operations.\n\nOur target system for verification was the reference implementation for the version of Classic McEliece submitted in Round 3 of the NIST process [8], using the mceliece348864 parameter set (the smallest parameter set). This reference implementation was created by the Classic McEliece team to be the definitive reference for their scheme\u2019s operation. It formed a key part of their submission to the NIST process, and has been available for manual public review since its initial release. Its operation and the rationale for its design have been fairly well-documented in the literature by its creators [16,22], as have the operation of the optimised implementations released alongside it. Our decision to target the reference implementation was partly based on its status as a \u201cgolden reference\u201d for the scheme, and partly because as a reference implementation we hoped to avoid verifying too much low-level optimisation, which can be extremely challenging [19].\n\nWe aimed to create a specification for this system in Cryptol, using SAW to create proofs of equivalency between the abstract Cryptol specification and the compiled bytecode of key functions used in the implementation. It should be noted that SAW and Cryptol were not originally designed for specifying and verifying asymmetric cryptography, but rather block ciphers, hash functions, and other forms of symmetric cryptography. As such, Cryptol is not a very expressive language for describing complex algebraic constructions, and specifying a scheme in this way can lead to unusably slow performance. On the other hand, expressing asymmetric ciphers in terms of bitwise operations as might suit Cryptol better could obscure the rich mathematical structures that often underlie them. This issue is not specific to Cryptol and reflects a general pattern in the computer-aided cryptography literature: it is a lot easier to find verifications of symmetric cryptographic schemes and implementations. We therefore expected that the task of applying the SAW\/Cryptol toolchain to Classic McEliece to be very challenging, and this is why our primary goal was to test the capability limits of SAW\/Cryptol in this task.\n\nWe emphasise that our SAW\/Cryptol work sits in the \u2018second strand\u2019 of research in computer-aided cryptography (see Section 1). It does not cover aspects in the \u2018first strand\u2019 (such as formal verification of the Classic McEliece security proofs) or the \u2018third strand\u2019 (such as verifying that the implementations possess the claimed resistance to constant-time attacks).\n\n## 3 Verifying Classic McEliece with SAW\/Cryptol\n\nWe begin with an overview of what was successfully verified and what was not. Discounting those functions that are part of the RNG or that call the external hash function used in Classic McEliece, there are 41 different functions that make up the mceliece348864 reference implementation. Of these, 18 were completely specified and verified; a further five were partially verified. All verifications were performed within WSL2 on a Windows 10 PC with 16GB of RAM and an Intel i5-8400 2.8 GHz processor. The limit on performance was generally memory: it is conceivable that, in a few cases, with a higher-specification machine it would have been possible for some additional proofs to complete, but this would require further testing to verify. This work represents around 5.5 months of person-time.\n\nIn general, the lower-level \u201cutility\u201d functions were easily verifiable. The most substantial successes on cryptographically-relevant functions were in verifying the implementation of the finite field operations, both against a mathematically-defined specification and a literal translation of the C source, which we could prove were equivalent under relevant preconditions. The PKE encryption and decryption functions were where we found partial success, with full verification of the key calculation loops. We found little success with the KEM wrapper, which needed functions that Cryptol could not implement efficiently, and so it was impractical to test them.\n\nOf the five functions that we partially verified, these can be split into three categories. Firstly, there were two functions for which it was possible to verify the core loop used in the function but not the function\u2019s effect across all loops. Secondly, there were two functions for which we found errors in the original code. These were the two sorting functions, which contain small but vital bugs in their comparators. Our discovery of these issues \u2014 which do not impact Classic McEliece directly but are nevertheless real bugs in these functions \u2014 demonstrates that verification can find problems that current methods of scrutiny might miss. Finally, there was one function that we found we could rewrite into a form that appears both slightly higher in performance and possible to verify. This function is especially interesting as it demonstrates that it is possible to write implementations that are \u201cmore verifiable\u201d, and this does not have to come at the cost of performance (in this case, quite the opposite) or, indeed, security.\n\nThe above information is summarised in Figure 1, which shows the call graph of functions in the implementation, with functions and their groupings colour-coded to signify the level of verification achieved. Green notes that the contents of that box have been fully specified and verified, orange that the contents have been partially verified, red that the contents have been verified and a bug found, purple that a refactored version of the contents has been verified, and blue that the contents have not been specified or verified. A standalone version of this diagram is available at https:\/\/github.com\/linesthatinterlace\/verifying-cmce\/blob\/main\/docs\/graph.pdf\n\nIt should also be noted that all functions for which it was possible to symbolically execute them using SAW \u2014 which include all verified functions but also some that could not be fully verified \u2014 are thus guaranteed to be memory-safe and free of undefined behaviour, simply by virtue of having been executed through SAW\u2019s internal model.\n\n### 3.1 Verification details\n\nIn the following, we highlight certain representative examples to demonstrate the different classes of function we considered. These are chosen in order to illustrate the strengths and weaknesses of the tools we used. Details of the specifications and proof scripts are omitted here but are available in a public repository [6].\n\n**Transposition** The function `transpose_64x64` transposes a 64\u00d764 matrix over the binary field F\u2082, represented as a sequence of 64 64-bit unsigned integers taken as little-endian bitstrings. In the reference implementation, this is 33 lines of code, with the method of its operation being non-obvious, using masks to avoid any branching. We produced a two-line specification for this. This specification exactly captures the mathematical definition of `transpose_64x64`, adjusting for Cryptol\u2019s big-endian representation of 64-bit integers. There were multiple functions with simple definitions that had complex implementations (often to avoid branching for constant-time reasons), and these often admitted simple specifications against which they could be easily verified. The SAW\/Cryptol toolchain excels at handling situations like these.\n\n**Field operations** There is a set of low-level functions for performing operations over a finite field of prime order and one of its extensions. At the lowest level, these use simple bit operations, but for an operation like field division, a combination of field inversion and field multiplication is needed. SAW\/Cryptol has the facility for compositional proofs, which means it can use equivalence proofs for functions that have already been proved or assumed in order to simplify a new proof that uses those functions. This lends itself well to proving facts about field arithmetic, where this is a common pattern.\n\nFor many of these field functions, we created two specifications: a low-level specification corresponding to the original implementation, and a higher-level one closer to the arithmetic implementation. The higher-level one is only equivalent to the low-level one under the condition that the inputs are valid members of the field. That this invariant is preserved \u2014 that is, that valid field members remain valid field members under all field operations \u2014 is a fact that it is possible and desirable to prove, but which was slightly out of scope of our own work (though we were able to do so in some cases). We were able to prove this equivalence under the assumption of this invariant using both SAW\u2019s symbolic execution and the native SMT support within Cryptol.\n\n**Loop functions** There were some functions that took the form of loops operating on a large array. For these, it was possible to prove that the body of the loop (or a large section of it) was equivalent to the specification, but it was not possible to then use that equivalence to prove equivalence across all loop iterations.\n\nWe theorised that it might be possible to re-write one of these functions in some cases, re-factoring it to avoid one or more of the issues that cause SAW to stumble. In particular, a large amount of state needed to be carried across the loops \u2014 the entire current state of the array. We theorised that if the data flow could be isolated and split into smaller operations \u2014 removing the need to carry a large state \u2014 it would result in a more verifiable implementation. This turned out to be correct in at least one case.\n\nThe core component of encryption under Classic McEliece is the multiplication, in the ring of matrices over F\u2082, of a vector e of length n by an (n\u2212k)\u00d7n matrix H, producing the result s := He of length (n\u2212k); this vector s is the syndrome of e. The values n and k are parameters of the scheme. For a given parameter set, n is the code length and k the code dimension of the underlying permuted Goppa code, the linear code on which Classic McEliece is based. H has the form (I_{n\u2212k} | T), where I_{n\u2212k} is the identity matrix of dimension (n\u2212k), and T, the public key, is a (n\u2212k) \u00d7 k matrix.\n\nFor all parameter sets, n and k divide by 8, and thus so does (n\u2212k). The data for e, T, and s are stored in the implementation as byte arrays, treating bytes as little-endian as with `transpose_64x64`. These byte arrays have length n\/8, (n\u2212k)\u00d7k\/8, and (n\u2212k)\/8 respectively.\n\nThe implementation version of the function `syndrome` takes the byte array storing T and e and the pointer of the byte array that will store s, reconstructs H, and loops over its (n\u2212k) rows. Each iteration of the loop sets a bit in s, performing the appropriate row multiplication of H for the current index with e. This is done using bit-manipulation to avoid branching.\n\n```c\n\/\/ Listing 1: Original syndrome implementation.\nvoid syndrome(unsigned char *s, const unsigned char *pk, unsigned char *e) {\n    unsigned char b, row[SYS_N\/8];\n    const unsigned char *pk_ptr = pk;\n    int i, j;\n\n    for (i = 0; i < SYND_BYTES; i++)\n        s[i] = 0;\n\n    for (i = 0; i < PK_NROWS; i++) {\n        for (j = 0; j < SYS_N\/8; j++)\n            row[j] = 0;\n        for (j = 0; j < PK_ROW_BYTES; j++)\n            row[SYS_N\/8 - PK_ROW_BYTES + j] = pk_ptr[j];\n        row[i\/8] |= 1 << (i % 8);\n        b = 0;\n        for (j = 0; j < SYS_N\/8; j++)\n            b ^= row[j] & e[j];\n        b ^= b >> 4;\n        b ^= b >> 2;\n        b ^= b >> 1;\n        b &= 1;\n        s[i\/8] |= (b << (i % 8));\n        pk_ptr += PK_ROW_BYTES;\n    }\n}\n```\n\nThe issue for verification is that this means each loop stores the entire state of s. We found that while we could verify that one loop correctly modified s per the specification, the symbolic execution of all of `syndrome` could not complete when we applied the compositional override. As each loop sets the appropriate bit of s by performing an accumulative OR on the appropriate byte with a suitably shifted weight-1 byte, every iteration was storing more and more accumulative information about the byte array s that SAW had to keep track of in the execution. We suspect that the loop became too large for SAW to support.\n\nHowever, we were able to rewrite `syndrome` to avoid this issue. The key insight was the following one: each eight rows, a byte in s is completely determined, and thereafter plays no role in what follows. This is easy to see as a human reader, but is not information that SAW can derive. This is possibly because the index of the byte set each loop is calculated each time as i\/8, where in our loop function we simply model the row index i as a 16-bit integer. It is possible that SAW, internally, cannot conclude that this implies that as i is incremented by one each time, after eight values of i a byte in s is fixed. Our idea was to implement not only a row-multiplication function, but also a function to take a block of eight rows and perform the corresponding multiplications across all of them, producing the resultant byte.\n\nIn addition, we noted that because e is multiplied by the identity matrix, it can be split into (e_id, e_pk) := e, where e_id and e_pk are stored as byte arrays of length (n\u2212k)\/8 and k\/8 respectively. This means that s = e_id + T e_pk, and so we can focus on performing T e_pk, with no need to reconstruct H. We can calculate T e_pk a byte at a time, exclusive-or this byte to the corresponding byte of e_id, and this gives the corresponding byte of s.\n\nThis means that we are performing (n\u2212k)\/8 loops rather than (n\u2212k), but at each loop we perform eight row multiplications instead of one, albeit also on a smaller matrix. The crucial part is that then each loop sets a byte of s without reference to the current state of s. This is unlike the original implementation, which modifies s each loop by performing an OR operation on one of its bytes.\n\nNot only does this implementation of `syndrome` actually allow efficient symbolic execution and a verification proof, but our re-implementation appears to result in a modest performance improvement over the original. In testing on random data, we found it ran in an average of 1.4ms as opposed to an average of 1.5ms for the original implementation. We should note that this implementation is also used in the scheme\u2019s optimised implementation, though not the additionally optimised implementation that uses assembly-level code. In addition, we believe we have maintained the side-channel resistance properties of the original \u2013 in testing, there did not appear to be an appreciable difference in performance with different random inputs, and there is no branching or memory accesses indexed with secret data.\n\nIn summary, we were able to produce an implementation of `syndrome` that was faster, as secure, and, crucially, more verifiable than the original. This is evidence for the following claim: it is meaningful to consider one implementation being more verifiable than another, and there are properties a function can have that make it inherently easier to find a more verifiable implementation. If it was not the case that the data flow for `syndrome` could be separated as we did here, then the above approach would not have worked. Thus, at the design stage, such \u201cseparability\u201d could be considered as a desirable attribute that can make an implementation more verifiable (for some chosen definition of verifiability).\n\n```c\n\/\/ Listing 2: Revised syndrome implementation.\n\nunsigned char bytes_bit_dot_prod(const unsigned char *u, const unsigned char *v, size_t n) {\n    unsigned char b = 0;\n    for (size_t i = 0; i < n; i++)\n        b ^= u[i] & v[i];\n    return b;\n}\n\nunsigned char bytes_bit_mul_block(const unsigned char *u, const unsigned char *v, size_t n) {\n    unsigned char b = 0;\n    const unsigned char *u_ptr = u;\n    for (int i = 0; i < 8; i++) {\n        b += (bytes_bit_dot_prod(u_ptr, v, n) << i);\n        u_ptr += n;\n    }\n    return b;\n}\n\nvoid syndrome_bytewise(unsigned char *s, const unsigned char *pk, unsigned char *e) {\n    const unsigned char *pk_ptr = pk;\n    const unsigned char *e_id = e;\n    const unsigned char *e_pk = e + SYND_BYTES;\n    for (int i = 0; i < SYND_BYTES; i++) {\n        s[i] = e_id[i] ^ bytes_bit_mul_block(pk_ptr, e_pk, PK_ROW_BYTES);\n        pk_ptr += 8 * PK_ROW_BYTES;\n    }\n}\n```\n\n**Sorting comparator bugs** We discovered bugs in the sorting functions used by the Classic McEliece implementation, which do not directly affect the implementation but could certainly present an issue in code reuse. The bugs we found were in macros used by the sorting functions as element comparators. These macros take two variables, and place the minimum value in the first variable and the maximum one in the second without performing a branch. The first acts on two unsigned 64-bit integers, and the second acts on two signed 32-bit integers. In the former case, it simply does not produce the right output for certain inputs. In the latter, signed integer overflow can occur for certain inputs, which leads to implementation-defined and possibly undefined behaviour.\n\n```\nuint64_MINMAX(a, b) = min(a, b), max(a, b) \u21d0\u21d2\nmax(a, b) \u2212 min(a, b) < 2^63 \u2228 (b < a) \u2227 (a \u2212 b) = 2^63\n```\n\n*Fig. 2: Conditions for `uint64_MINMAX` to behave correctly.*\n\nThe problem in both cases is the most significant bit; the sign bit in the signed case. Using a Cryptol implementation of the unsigned case, and careful, iterative use of its SMT-solving capabilities, we were able to isolate a condition (Fig. 2) for the first macro to work correctly. That is, the first macro only works when the inputs have the same most significant bit.\n\nWe did not detect the bug with the second macro in Cryptol directly, but instead when verifying the sorting algorithm in SAW. This is because Cryptol\u2019s behaviour for integer overflow is always that it wraps, which is also the assumption of the macro. However, SAW\u2019s symbolic execution models the C specification itself, in which it is implementation-defined whether signed integers are treated as modular or if they overflow, and an overflow is undefined behaviour. Therefore, SAW detects the possibility of undefined behaviour and terminates the symbolic execution. The condition for avoiding any possibility of overflow is exactly that b\u2212a can be stored in a 32-bit integer, which admits a similar condition to that for the 64-bit case.\n\nBy looking at where these functions are used and what is stored in them, it appears that the troublesome bit will only ever be set to 0 in practice, and thus these bugs appear to be of limited, if any, impact to Classic McEliece. However, another implementor might re-use these sorting functions in another context. Indeed, these functions are derived from a separate library, the djbsort library [11], and thus the bugs could have a wider impact. These functions could be fixed by applying input validation to check for the problematic cases.\n\nThis sort of subtle issue is one that is very hard to see with casual human review, but was easy to spot once the formal tool drew our attention to it. Thus this example further motivates the use of formal verification tools in the development of cryptographic schemes.\n\n## 4 Verifying aspects of Classic McEliece with Lean\n\nIn this section, we report on our efforts to apply the interactive theorem prover Lean 3 and its mathlib library [27] to produce verified proofs relating to Classic McEliece. Lean aims to be both a functional programming language, in which it is easy to write correct and maintainable code; and also an interactive theorem prover, similar to Coq [17]. Like Coq and its MathComp library, Lean has its own mathematical components library, mathlib. The mathlib library has enjoyed extensive interest from the pure mathematics community and has been growing and updating at a rapid pace in the last few years. The style in Lean and mathlib is generalised and abstract; in contrast to Coq formalisations, which tend towards a concrete approach [7].\n\n**Verification of control bit constructions** In [13], Bernstein uses the HOL Light tool to give proofs and formal verifications of those proofs, for the control bit constructions used in Classic McEliece. As a proof of concept, we decided to attempt to re-implement the same proofs in Lean. The proofs we were able to obtain verified more theorems than the verifications in [13]; in addition, unlike HOL Light, it is relatively easy in Lean to talk about permutations of {0, 1, ..., n} rather than permutations of {0, 1, ...} that fix {n, n+1, ...}, or indeed permutations defined on any well-ordered type. As such, unlike the verifications in HOL Light, the theorems we verified were closer to the original mathematical statements, with no translations required.\n\nHowever, these proofs are not compatible with the most recent version of Lean and mathlib, because the library itself has advanced since then. While they are available [2], they would require further work to update to the latest version of the library. This illustrates an issue with formal methods in general and ones based on unstable libraries in particular: they create an extra technical debt as they require maintenance. Nevertheless, the relative ease at which our work proceeded made us optimistic to try more experiments in proving aspects of Classic McEliece\u2019s design using Lean in future.\n\n**Verification of coding theory** We also investigated the use of Lean to verify the correctness of the decoding methods used in Classic McEliece. We targeted a recent monograph of Bernstein [12] setting out the necessary theorems of coding theory used in the proof of correctness. In theory, Lean\u2019s mathlib contains all the mathematics necessary to prove these theorems. In practice, there were a number of hurdles to overcome, for example in edge cases that need to be formally specified even though they may appear not to matter on paper, and this work is still in progress.\n\nTowards this goal, we have provided to mathlib a refactor of theorems about Lagrange interpolation, and an implementation of the Hamming distance and theorems around it. These theorems are a building block towards verifying Goppa codes and Classic McEliece. Given the recent publishing of a Lean 4 specification of Classic McEliece [3], the possibility (even if a difficult one) of joining this work with proofs about the abstract design of the scheme is an interesting and potentially exciting one. This would be \u2018first strand\u2018 verification \u2014 in that it is verifying the mathematical correctness of the design itself \u2014 combined with \u2018second strand\u2018 verification \u2014 as it would be verifying an implementation against the constraints of a design.\n\n## 5 Conclusions and perspectives\n\n### 5.1 Recommendations\n\nOur work adds to the increasing body of work showing that formal approaches can and should be incorporated into cryptographic design evaluation. In particular, we demonstrate that it is meaningful to talk of the verifiability of a particular implementation, and, by extension, of a particular design. Such verifiability can be treated as evidence in favour of a proposed design or implementation. Advocates for the use of computer-aided cryptography should aim to play a role in the setting of common standards around verifiability.\n\nDesigners and implementers of cryptographic schemes can follow two main approaches to incorporate computer-aided cryptography techniques. The first approach is using tools that aim to verify existing code. In this case, we recommend engaging with the limits of the chosen tool before beginning implementation. For instance, with SAW\/Cryptol, we found that large loops that carried large amounts of state between each loop iteration were not feasibly verifiable. Other tools will have different limitations. Such tools can be incorporated into the software development cycle, as prior work has demonstrated [19,23]. It is easier to adjust the design of an implementation at an earlier stage in its development, and our experience in this study demonstrates that seemingly-small alterations in a design can make a real difference to verifiability.\n\nThe second approach is for implementors to choose a synthesis-first approach [9,18]. Novel cryptography has the advantage that it is necessarily based on \u201cfresh\u201d code, and has the flexibility to support verified code synthesis. Moreover, such implementations can be as efficient as hand-written code, if not more so.\n\n### 5.2 Future work using similar approaches\n\n**Verification of Classic McEliece** The functions that we could verify or partially verify with SAW\/Cryptol constitute the core of the decryption and encryption operations of Classic McEliece. It would be interesting to extend this to the higher-level encapsulation or decapsulation functions. For example, their memory safety could be determined by checking that SAW could symbolically execute them. In addition, some components of the implementation were technically challenging to specify in Cryptol. For instance, whilst we were able to produce a specification for the function that calculates permutation control bits, we were not successful at using it in verification. Prior work has explored formally proving the design of the formulae used for the control bit calculation [13]. Future work should seek to explore this further, perhaps porting these proofs to a language like Project Everest\u2019s F* [18] which has the facility for code synthesis.\n\n**Verification using Lean** Lean is a relatively new theorem prover, and as such has seen relatively little attention from the cryptographic community. Lean\u2019s strong support for Unicode and the tendency of mathlib towards abstraction and generality means that statements and even proofs in mathlib can look closer to their \u201cpen and paper\u201d equivalents in, say, Coq. This is of interest for forms of cryptography in which the underlying constructions are often abstract and mathematical, even though the instantiations are necessarily concrete. The rapid development of Lean and mathlib means there is an opportunity for cryptographers to \u201cget in at the ground floor\u201d and shape the implementation choices behind key concepts. We see this as an important direction for future work.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/assets.amazon.science\/4e\/23\/177acd514c799204ae22f98e193d\/verified-cryptographic-code-for-everybody.pdf","filetype":"txt","content":"## Verified Cryptographic Code for Everybody\n\nBrett Boston, Samuel Breese, Joey Dodds, Mike Dodds, Brian Huffman,  \nAdam Petcher, and Andrei Stefanescu\n\n1 Galois, Inc.  \n2 Amazon Web Services\n\n---\n\n## Abstract\n\nWe have completed machine-assisted proofs of two highly-optimized cryptographic primitives, AES-256-GCM and SHA-384. We have verified that the implementations of these primitives, written in a mix of C and x86 assembly, are memory safe and functionally correct, meaning input-output equivalent to their algorithmic specifications. Our proofs were completed using SAW, a bounded cryptographic verification tool extended to handle embedded x86. The code verified comes from AWS LibCrypto, which is identical to BoringSSL and very similar to OpenSSL. We believe we are the first to formally verify these implementations, which protect the security of nearly everybody on the internet.\n\nKeywords: Cryptography \u00b7 Automated reasoning \u00b7 Verification\n\n---\n\n## 1 Introduction\n\nWidely-used cryptographic libraries such as OpenSSL, BoringSSL, and AWS LibCrypto are enticing targets for formal verification. These libraries are used by billions worldwide. Each primitive typically consists of a modest amount of code but has significant security and performance impact. Cryptographic primitives have clearly defined specifications and few dependencies, simplifying verification challenges. However, widely-used cryptographic libraries resist verification due to heavy optimization, mixed-language (C and assembly) implementations, and abstraction-breaking optimizations.\n\nPurpose-built libraries like EverCrypt can match OpenSSL\u2019s performance but are not widely adopted yet. Our aim is to verify legacy cryptographic code that runs in production for hundreds of millions of users.\n\n---\n\n## Approach and Results\n\nWe formally verified memory safety and functional correctness of AES-256-GCM and SHA-384 as they appear in AWS LibCrypto (AWS-LC). AWS-LC is a general-purpose library maintained by Amazon Web Services. The AES-256-GCM and SHA-384 implementations are identical to those in Google\u2019s BoringSSL. Our proofs show input-output equivalence to formal Cryptol specifications and guarantee absence of undefined behavior such as memory safety errors. We do not verify side-channel properties or cryptographic security proofs.\n\nThe proofs use the Software Analysis Workbench (SAW), a bounded verifier requiring fixed input sizes to guarantee termination and bounded execution length. The proofs consist of two stages: (1) symbolic execution of the imperative input code into a functional term using models of LLVM and x86 instructions; (2) comparison of the symbolic term to a Cryptol specification using SMT solving and rewriting logic to handle challenging optimizations.\n\nVerification is modular via overrides, allowing function calls to be replaced with verified Cryptol specifications, improving scalability.\n\nProof scripts and specifications are available online.\n\n---\n\n## 1.1 Related Work\n\nPrior work verifying cryptographic primitives includes AWS's verification of the simpler HMAC and DRBG in the s2n TLS library, EverCrypt\u2019s co-designed verified cryptographic library, CASM\u2019s symbolic execution-based verification of OpenSSL assembly (excluding highly optimized parts), Fiat Crypto and Jasmin foundational synthesis of verified cryptographic code, and the Verified Software Toolchain for C.\n\nSAW\u2019s approach focuses on symbolic execution with bounded verification, modular reasoning, and term rewriting tactics to enable proofs for highly optimized legacy code.\n\n---\n\n## 2 Project Design Constraints\n\nDesign constraints included:\n\n- Proofs run on executed C and assembly code to minimize trusted base.\n- Automated proofs with low time budget suitable for CI integration.\n- No modification of original source code.\n- Verification toolchain operates independently from software build system.\n\nThese constraints motivated using the SAW tool.\n\n---\n\n## 3 AES-256-GCM and SHA-384 Proof Structure\n\nSAW symbolically executes C and x86 code into functional terms describing outputs as functions of inputs. Symbolic execution guarantees memory safety. Terms are compared to Cryptol function specifications via SMT solving. Complex proofs require rewriting tactics to bridge specification and optimized implementation gaps.\n\nProofs verify compatibility with OpenSSL\u2019s EVP interface. SAW-script defines pre\/post memory conditions, symbolic execution, and assertions about output memory. Cryptol specifications define functional behavior, e.g., the CTR mode encryption function `ctr32_encrypt`:\n\n```cryptol\nctr32_encrypt : {n} (fin n) => AES_GCM_Ctx -> [n][8] -> [n][8]\nctr32_encrypt ctx in = out\n  where\n    out = [ byte ^ (EKij ctx ((take`{32} (drop`{28} i)) + 1) (drop`{60} i)) |\n             byte <- in | i <- [ctx.len ...] ]\n```\n\nRewrites such as `Sigma0_thm` transform implementation expressions to match Cryptol definitions, crucial for bridging optimized assembly code to high-level specification.\n\n---\n\n## 4 SAW\u2019s Verification Pipeline\n\nVerification stages:\n\n1. Extract x86 binary and construct CFG via Macaw.\n2. Identify functions in x86 and LLVM code per SAW-script interface.\n3. Symbolically execute leaf functions into SAW-core terms, substituting verified overrides.\n4. Symbolically execute Cryptol specifications into SAW-core terms.\n5. Apply rewriting rules to terms.\n6. Prove equivalence between rewritten terms via SMT solver What4.\n\n---\n\n## 5 New Capability: x86 Semantics\n\nSymbolic execution of x86 includes modeling instruction semantics and memory. Macaw decompiles binaries into CFGs. The memory model differentiates between allocated memory regions, with pointer arithmetic constrained within regions.\n\nThe strict memory model may disallow some valid assembly, but matches conventions used by cryptographic code adhering to ABI and C memory models, enabling practical verification.\n\n---\n\n## 6 New Capability: Verified Rewrites\n\nTerm rewriting tactics verified by SMT solvers bridge differences between specification and implementation. For example, the `Sigma0_thm` rewrite verifies equivalence:\n\n```cryptol\nSigma0_thm <- prove_folding_theorem\n{{ \\x -> (x ^ ((x ^ (x <<< 59)) <<< 58)) <<< 36 == S0 x }};\n```\n\nRewrites serve as a lightweight tactic language enabling proofs that would be infeasible for SMT solvers alone.\n\n---\n\n## 6.1 Role of Rewrites in AES-256-GCM and SHA-384 Proofs\n\nRewrites recover lost abstractions and prune proof search space. Careful design is required to balance abstraction with solver tractability. They operate after SAW\u2019s optimizations, which may break up terms and complicate rewriting. An example rewrite:\n\n```cryptol\nrotate59_slice_add_thm <- prove_folding_theorem\n{{ \\x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18\n   x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34\n   x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 ->\n   (slice_59_5_0 (x0 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11\n    + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20\n    + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29\n    + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38\n    + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47\n    + x48 + x49 + x50))\n   # (slice_0_59_5 (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 + x8\n    + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17\n    + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26\n    + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35\n    + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44\n    + x45 + x46 + x47 + x48 + x49 + x50))\n   == (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11\n     + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22\n     + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33\n     + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44\n     + x45 + x46 + x47 + x48 + x49 + x50) <<< 59 }};\n```\n\n---\n\n## 7 Results and Lessons Learned\n\nProofs target the January 2021 AWS-LC version, verifying AVX implementations (SHA-384) and AESNI\/CLMUL\/AVX implementation (AES-256-GCM).\n\n- Top-level interface specifications: 168 lines.\n- Functional specifications: 435 lines, mostly reused and concise.\n- Proof scripts: 1286 lines, including intermediate specs, rewrites, and tactics.\n\nProofs run in CI with quickcheck (~25 minutes) and full proofs (~30 minutes on private hardware).\n\nTrusted Code Base (TCB) includes: top-level specs, assumptions on malloc\/free, SAW and Cryptol toolchain (including SMT solvers), compiler correctness, and hardware execution correctness.\n\nProof engineering took approximately nine person-months, emphasizing the value of expertise, proof automation, and separating memory safety from functional correctness proofs.\n\nAutomation handles trivial reasoning; engineers focus on difficult verifications and managing rewrites.\n\n---\n\n## 7.1 Trade-Offs When Building on Existing Verification Tools\n\nMature tools like SAW embody design decisions and optimizations that may constrain direct control but provide extensive capabilities and community support.\n\nWorking with established tools reduces effort by leveraging existing components like Macaw decompiler, LLVM semantics, and What4 solver interface.\n\nCollaboration across verification teams is vital for tackling complex projects.\n\n---\n\n## 7.2 Verified Code Generation versus Verifying Existing Code\n\nApproaches like EverCrypt, Jasmin, and Fiat Crypto synthesize verified implementations but require writing or generating new code.\n\nVerifying existing optimized code avoids risks from modifying mature, widely audited code and fits into existing build pipelines without new compilers or toolchains.\n\nMaintains certifications and reduces risk associated with code change.\n\n---\n\n## 8 Conclusion and Future Work\n\nWe demonstrate it is feasible to verify highly optimized cryptographic code used by billions, matching implementations to formal specifications.\n\nFuture work includes verifying OpenSSL versions, proving correctness at arbitrary sizes rather than fixed inputs, reducing reliance on term rewriting tactics, and verifying side-channel resistance.\n\nFormal verified cryptography is close to mainstream deployment without performance compromise.\n\n---\n\n## References\n\nReferences omitted for brevity.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/www.galois.com\/articles\/verifying-s2n-hmac-with-saw?utm_source=chatgpt.com","filetype":"txt","content":"## Get started\n\n## Part one: Verifying s2n HMAC with SAW\n\nGalois  \nSeptember 4, 2016\n\nIn June 2015, Amazon introduced its s2n library, an open-source TLS library that prioritizes simplicity. A stated benefit of this simplicity is ease of auditing and testing. Galois recently collaborated with Amazon to show that this benefit extends to verifiability by proving the correctness of s2n\u2019s implementation of the keyed-Hash Message Authentication Code (HMAC) algorithm. To construct this proof, we used Galois\u2019s Software Analysis Workbench (SAW). This is the first in a series of three blog posts explaining the project, what we proved, and how we used SAW to prove it.\n\nAmazon\u2019s s2n is now at the forefront of verification in cryptography libraries. We would like to thank the team at Amazon for taking such a forward-thinking approach towards the correctness of their library, and giving us the opportunity to collaborate on such a great piece of software.\n\n## Why Verify?\n\nCryptography libraries like s2n are responsible for much of the security and privacy you experience on the internet from day to day. They protect your credit card numbers, keep people from snooping on your video chats, and even keep your employer from finding out that you spend all day looking at cat pictures. Because of its importance, weak, incorrect, or misused cryptography is the root cause of a large number of security vulnerabilities on the web today. Because cryptography libraries take so much responsibility for our daily security, it is essential that they are correctly implemented.\n\nVerification is the ultimate in showing program correctness. Verification allows you to use mathematical reasoning to make strong statements about all possible program behaviors. This is in direct contrast to testing, which can only make statements about the program behaviors covered by the test suite. Anyone who has programmed knows the pain of believing that they wrote a program perfectly, and even tested sufficiently, only to later find the strange edge case that causes everything to go wrong.\n\nFor example, we can use SAW to prove that \u201cfor any message of length 64 bytes, and any key of length 64 bytes, the s2n_hmac function behaves correctly.\u201d To make a statement of equivalent strength using testing you would need to have a test suite with ~1.7\u00d710^308 tests. To allow you to easily conceptualize this number, if each test case were an inch long, you could use your chain of test cases to reach across the measurable universe ~4.8\u00d710^279 times. To allow you to conceptualize that number, if each trip across the universe were an inch long, you could use your chain of trips to reach across the universe\u2026 ok, we\u2019d have to do this at least 9 times before we got to a number any of us would have a chance of fitting in our heads. In conclusion, if someone tells you they can verify such a property completely with test cases, you should jump on their spaceship and enjoy the ride.\n\nOn the other hand, if the software contains an error that would trigger precisely one of those test cases, SAW will find that error within a minute, though we still won\u2019t have a spaceship, intergalactic or otherwise.\n\n## Specifying HMAC\n\nIn order to prove a program correct, you need to state what it means to be correct. If you\u2019ve learned what HMAC is, you\u2019ve likely seen something like this:\n\nHMAC(K, m) = H((K' \u2295 opad) || H((K' \u2295 ipad) || m))  \nopad = 0x5c5c5c\u20265c5c  \nipad = 0x363636\u20263636  \n\nIf you haven\u2019t learned what HMAC is, you have now seen it too. In this formula, K is the secret key, m is the message to be authenticated, and K\u2019 is a key of a specific size that is derived from K. ipad and opad are constants used for padding. It is hard to deny the appeal behind such a specification. It is concise and unambiguous, and gives a complete description of how to implement HMAC if you want a correct implementation that nobody would like to use because it is inefficient (s2n\u2019s implementation is correct and efficient; we\u2019ll say more on that later).\n\nThis mathematical definition appears in documents such as an IETF RFC or a FIPS standard. Such documents are some of the most widely examined specifications of what it means to be HMAC, and therefore the most likely to present a correct specification of a message authentication code. So to prove an implementation of HMAC correct, we should prove that it is equivalent to the mathematical specification.\n\nTo facilitate such proofs, Galois has developed Cryptol, a domain specific language for specifying cryptographic primitives and proving properties of those primitives. Cryptol allows cryptographers to create executable programs that look like the mathematical notation commonly used in RFCs and FIPS standards. The Cryptol specification for HMAC (with comments denoting the related math) is:\n\n```cryptol\n\/\/ H((K\u2019 xor opad) || H((K\u2019 xor ipad) || message))\nhmac hash hash2 hash3 key message = hash2 (okey # internal)\n where\n  ks : [blockLength][8]\n  ks = kinit hash3 key \/\/ K\u2019\n  okey = [k ^ 0x5C | k <- ks] \/\/ K\u2019 xor opad\n  ikey = [k ^ 0x36 | k <- ks] \/\/ K\u2019 xor ipad\n  \/\/ H((K\u2019 xor ipad) || message)\n  internal = split (hash (ikey # message))\n```\n\nThe comments show how similar the structure of these two definitions really are. One noticeable quirk is that the Cryptol specification uses three different hash functions (`hash`, `hash2`, and `hash3`). This is due to a technicality in the type checker: Cryptol types for byte arrays include the length of those arrays and Cryptol does not allow for a function supplied as an argument to be used at multiple lengths (type theory folks will recognize this as Cryptol supporting rank-1 polymorphism). When using the Cryptol `hmac` function, we just pass the same hash function in three times, so the instantiation of `hmac` using the SHA256 hash function is given by:\n\n```cryptol\nhmacSHA256 = hmac `{blockLength=64} SHA256 SHA256 SHA256\n```\n\nThe argument in curly braces is a type that can\u2019t be inferred automatically. Without that argument, the definition of `hmacSHA256` would give an error, because Cryptol would be unable to determine `blockLength`.\n\n## Proving the C code correct\n\nCryptol allows us to describe, test, and manipulate the specification. To connect the specification to the implementation, Galois has developed another tool, the Software Analysis Workbench (SAW) to support reasoning about implementation code written in C or Java. In particular, SAW allows us to prove that the s2n C implementation of HMAC is equivalent to the Cryptol specification that we showed above. It takes a thorough inspection of the code (as well as some mathematical reasoning, and an understanding of the behaviors of hashes) to make a convincing argument that the C implementation does the same thing as the mathematical specification. There are 166 lines of C code (comments and whitespace excluded). Much of this is dedicated to remaining parametric over hash functions, as well as various safety checks, but still, the implementation is much more complex.\n\nThis complexity results from implementing an efficient imperative interface broken into initialization, message update, and digest construction functions, which allows messages to be authenticated iteratively. This is perfect for network encryption protocols like TLS, because it allows messages to be authenticated a packet at a time, and decreases space requirements \u2014 the entire message does not have to be stored in memory in order to authenticate it.\n\nSo there is some distance between the appearance of the source code and the mathematical object representing what its behavior should be. The job of SAW is to close that distance and show that, in fact, the code and the specification describe the same thing. SAW can prove equivalence between C, Cryptol, and Java programs, and it does this by performing symbolic execution on the input programs to create a formal model of each program. SAW then has rules to generate verification conditions, formulas in first-order logic, that if true for all values of all free variables in the formula, imply the equality of the two programs. Formulas of this type can, in many cases, be discharged completely automatically by a variety of SMT solvers such as Z3, Yices, or CVC4. SAW is capable of passing these formulas off to the aforementioned solvers (and more). If the solvers say that all of the verification conditions are true, SAW will report to the user that the equivalence between the two programs holds. If the solvers say that a verification condition is sometimes false, they will also provide a counterexample, which SAW is able to translate into program inputs that can be supplied to each program to force their outputs to differ.\n\nIn summary, once the structure of the equality proof is given, SAW is able to automatically fill in the gaps, resulting in a proof of equivalence that can be re-run each time we change the code to continually check the correctness of the implementation. For example, we can create a test case that adds the following pseudocode to the HMAC update function:\n\n```\nif (msg == \u201cMess up the hash, please\u201d)\n  then (msg == \u201cEEEEVVVILLLLLL\u201d)\n```\n\nAssuming that we didn\u2019t accidentally program the same \u201cbug\u201d into our Cryptol spec, SAW will quickly return a message letting us know that if we run the update function with the admittedly polite message \u201cMess up the hash, please,\u201d we will see different outputs from the C code and the Cryptol code.\n\n## Putting it all together\n\nWe completed the verification and integrated the resulting proof checking procedure into s2n\u2019s existing build system. With the help of Travis CI, every time there is a push to s2n, the SAW tests will be run and those runs will be visible to the public. It is also easy to install SAW yourself on a variety of platforms and use the s2n Makefile to test it on your local changes to s2n_hmac.c. The second post will go into more detail on the Cryptol specification, and how we got it ready for SAW verification. The third post will describe what work we need to do in SAW to describe to the tools exactly what equivalence we want to verify. The fourth post will be by request only, and we\u2019ll type out the rest of the trips across the universe that you need to conceptualize an excessively large number of test cases. Just kidding, we won\u2019t do that.","variant":null,"set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/MD5.md","filetype":"txt","content":"# The MD5 Message-Digest Algorithm\n\n## Introduction\n\nAll text in this document is directly from the [MD5 Specification](https:\/\/www.ietf.org\/rfc\/rfc1321.txt).\n\n```cryptol\nmodule Primitive::Keyless::Hash::MD5 where\n```\n\n## 2 Terminology and Notation\n\nIn this document, a \"word\" is a 32-bit quantity and a \"byte\" is an 8-bit quantity. A sequence of\nbits can be interpreted in a natural manner as a sequence of bytes, where each consecutive group of\neight bits is interpreted as a byte with the high-order (most significant) bit of each byte listed\nfirst. Similarly, a sequence of bytes can be interpreted as a sequence of 32-bit words, where each\nconsecutive group of four bytes is interpreted as a word with the low-order (least significant)\nbyte given first.\n\n```cryptol\nconvert_length : [64] -> [64]\nconvert_length msg = join (reverse (groupBy`{8} msg))\n\nconvert : {n} (fin n) => [n*32] -> [n*32]\nconvert msg = join (join (map reverse msg''))\n    where\n        msg'  = groupBy`{8} msg\n        msg'' = groupBy`{4} msg'\n\nproperty test_convert_length_1 = convert_length msg == 0x0800000000000000\n    where\n        msg = 8 : [64]\n\nproperty test_convert_initial = initialize == output\n    where\n        output = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]\n\nproperty test_convert_msg = convert msg == output\n    where\n        msg    = 0xd98c1dd404b2008f980980e97e42f8ec\n        output = 0xd41d8cd98f00b204e9800998ecf8427e\n```\n\nLet x_i denote \"x sub i\". If the subscript is an expression, we surround it in braces, as in\nx_{i+1}. Similarly, we use ^ for superscripts (exponentiation), so that x^i denotes x to the\ni-th power.\n\nLet the symbol \"+\" denote addition of words (i.e., modulo-2^32 addition). Let `X <<< s` denote the\n32-bit value obtained by circularly shifting (rotating) X left by s bit positions. Let `not(X)`\ndenote the bit-wise complement of X, and let `X v Y` denote the bit-wise OR of X and Y. Let\n`X xor Y` denote the bit-wise XOR of X and Y, and let `XY` denote the bit-wise AND of X and Y.\n\n## 3 MD5 Algorithm Description\n\nWe begin by supposing that we have a b-bit message as input, and that we wish to find its message\ndigest. Here `b` is an arbitrary nonnegative integer; `b` may be zero, it need not be a multiple of\neight, and it may be arbitrarily large. We imagine the bits of the message written down as follows:\n\n```example\nm_0 m_1 ... m_{b-1}\n```\n\nThe following five steps are performed to compute the message digest of the message.\n\n### 3.1 Step 1. Append Padding Bits\n\nThe message is \"padded\" (extended) so that its length (in bits) is congruent to 448 modulo 512.\nThat is, the message is extended so that it is just 64 bits shy of being a multiple of 512 bits\nlong. Padding is always performed, even if the length of the message is already congruent to 448\nmodulo 512.\n\nPadding is performed as follows: a single \"1\" bit is appended to the message, and then \"0\" bits are\nappended so that the length in bits of the padded message becomes congruent to 448 modulo 512. In\nall, at least one bit and at most 512 bits are appended.\n\n```cryptol\npad : {b, p} (fin p, p >= 0, 64 >= width b) => [b] -> [b + p + 1]\npad msg = msg # [1] # zero\n```\n\n### 3.2 Step 2. Append Length\n\nA 64-bit representation of b (the length of the message before padding bits were added) is appended\nto the result of the previous step. In the unlikely event that b is greater than 2^64, then only the\nlow-order 64 bits of b are used. (These bits are appended as two 32-bit words and appended low-order\nword first in accordance with the previous conventions.)\n\n```cryptol\nappendLength : {b, p} (fin p, p >= 0, 64 >= width b)\n            => [b + p + 1] -> [b + p + 65]\nappendLength msg = msg # b'\n    where\n        b' = convert_length (`b : [64])\n\nprepMsg : {b} (64 >= width b)\n       => [b] -> [((b + 65)\/^ 512)][16][32]\nprepMsg msg = groupBy`{16} (groupBy`{32} msgL)\n    where\n        type p = (b + 65) %^ 512  \/\/ how much padding is needed in addition to the [1]\n        msgP   = pad`{b, p} msg\n        msgL   = appendLength`{b, p} msgP\n```\n\nAt this point the resulting message (after padding with bits and with b) has a length that is an\nexact multiple of 512 bits. Equivalently, this message has a length that is an exact multiple of\n16 (32-bit) words. Let `M[0...N-1]` denote the words of the resulting message, where N is a multiple\nof 16.\n\n### 3.3 Step 3. Initialize MD Buffer\n\nA four-word buffer (A,B,C,D) is used to compute the message digest. Here each of A, B, C, D is a\n32-bit register. There registers are initialized to the following values in hexadecimal, low-order\nbytes first:\n\n```cryptol\ntype Buffer = [4][32]\n\ninitialize : Buffer\ninitialize = [A', B', C', D']\n    where\n        A = [0x01, 0x23, 0x45, 0x67]\n        B = [0x89, 0xab, 0xcd, 0xef]\n        C = [0xfe, 0xdc, 0xba, 0x98]\n        D = [0x76, 0x54, 0x32, 0x10]\n        A' = convert (join A)\n        B' = convert (join B)\n        C' = convert (join C)\n        D' = convert (join D)\n```\n\n### 3.4 Step 4. Process Message in 16-Word Blocks\n\nWe first define four auxiliary functions that each take as input three 32-bit words and produce as\noutput one 32-bit word.\n\n```cryptol\nF : [32] -> [32] -> [32] -> [32]\nF X Y Z = (X && Y) || (~X && Z)  \/\/ XY v not(X) Z\n\nG : [32] -> [32] -> [32] -> [32]\nG X Y Z = (X && Z) || (Y && ~Z)  \/\/ XZ v Y not(Z)\n\nH : [32] -> [32] -> [32] -> [32]\nH X Y Z = X ^ Y ^ Z \/\/ X xor Y xor Z\n\nI : [32] -> [32] -> [32] -> [32]\nI X Y Z = Y ^ (X || ~Z) \/\/ Y xor (X v not(Z))\n```\n\nIn each bit position F acts as a conditional: if X then Y else Z. The function F could have been\ndefined using + instead of v since XY and not(X)Z will never have 1's in the same bit position. It\nis interesting to not that if the bits of X, Y and Z are independent and unbiased, then each bit of\nF(X, Y, Z) will be independent and unbiased.\n\n```cryptol\nF_add : [32] -> [32] -> [32] -> [32]\nF_add X Y Z = (X && Y) + (~X && Z)  \/\/ XY + not(X) Z\n\nproperty f_equiv x y z = F x y z == F_add x y z\n```\n\nThe functions G, H and I are similar to the function F, in that they act in \"bitwise parallel\" to\nproduce their output from the bits of X, Y, and Z, in such a manner that if the corresponding bits\nof X, Y, and Z are independent and unbiased, then each bit of G(X,Y,Z), H(X,Y,Z), and I(X,Y,Z) will\nbe independent and unbiased. Note that the function H is the bit-wise \"xor\" or \"parity\" function of\nits inputs.\n\nThis step uses a 64-element table T[1...64] constructed from the sine function. Let T[i] denote the\ni-th element of the table, which is equal to the integer part of `4294967296 times abs(sin(i))`,\nwhere `i` is in radians. The elements of the table are given in the appendix.\n\n```cryptol\nT : [64][32]\nT =\n    [0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE, 0xF57C0FAF,\n     0x4787C62A, 0xA8304613, 0xFD469501, 0x698098D8, 0x8B44F7AF,\n     0xFFFF5BB1, 0x895CD7BE, 0x6B901122, 0xFD987193, 0xA679438E,\n     0x49B40821, 0xF61E2562, 0xC040B340, 0x265E5A51, 0xE9B6C7AA,\n     0xD62F105D, 0x02441453, 0xD8A1E681, 0xE7D3FBC8, 0x21E1CDE6,\n     0xC33707D6, 0xF4D50D87, 0x455A14ED, 0xA9E3E905, 0xFCEFA3F8,\n     0x676F02D9, 0x8D2A4C8A, 0xFFFA3942, 0x8771F681, 0x6D9D6122,\n     0xFDE5380C, 0xA4BEEA44, 0x4BDECFA9, 0xF6BB4B60, 0xBEBFBC70,\n     0x289B7EC6, 0xEAA127FA, 0xD4EF3085, 0x04881D05, 0xD9D4D039,\n     0xE6DB99E5, 0x1FA27CF8, 0xC4AC5665, 0xF4292244, 0x432AFF97,\n     0xAB9423A7, 0xFC93A039, 0x655B59C3, 0x8F0CCC92, 0xFFEFF47D,\n     0x85845DD1, 0x6FA87E4F, 0xFE2CE6E0, 0xA3014314, 0x4E0811A1,\n     0xF7537E82, 0xBD3AF235, 0x2AD7D2BB, 0xEB86D391]\n```\n\nDo the following:\n\n```cryptol\nround1_op : Buffer -> [32] -> [5] -> [32] -> Buffer\nround1_op [a, b, c, d] Xk s Ti = [a', b, c, d]\n    where\n        a' = b + ((a + (F b c d) + Xk + Ti) <<< s)\n\nround1_alt : Buffer -> [16][32] -> Buffer\nround1_alt [a0, b0, c0, d0] X = [a16, b16, c16, d16]\n    where\n        [ a1, b1, c1, d1] = round1_op [ a0,  b0,  c0,  d0]  (X@0)  7  (T@0)\n        [ d2, a2, b2, c2] = round1_op [ d1,  a1,  b1,  c1]  (X@1) 12  (T@1)\n        [ c3, d3, a3, b3] = round1_op [ c2,  d2,  a2,  b2]  (X@2) 17  (T@2)\n        [ b4, c4, d4, a4] = round1_op [ b3,  c3,  d3,  a3]  (X@3) 22  (T@3)\n        [ a5, b5, c5, d5] = round1_op [ a4,  b4,  c4,  d4]  (X@4)  7  (T@4)\n        [ d6, a6, b6, c6] = round1_op [ d5,  a5,  b5,  c5]  (X@5) 12  (T@5)\n        [ c7, d7, a7, b7] = round1_op [ c6,  d6,  a6,  b6]  (X@6) 17  (T@6)\n        [ b8, c8, d8, a8] = round1_op [ b7,  c7,  d7,  a7]  (X@7) 22  (T@7)\n        [ a9, b9, c9, d9] = round1_op [ a8,  b8,  c8,  d8]  (X@8)  7  (T@8)\n        [d10,a10,b10,c10] = round1_op [ d9,  a9,  b9,  c9]  (X@9) 12  (T@9)\n        [c11,d11,a11,b11] = round1_op [c10, d10, a10, b10] (X@10) 17 (T@10)\n        [b12,c12,d12,a12] = round1_op [b11, c11, d11, a11] (X@11) 22 (T@11)\n        [a13,b13,c13,d13] = round1_op [a12, b12, c12, d12] (X@12)  7 (T@12)\n        [d14,a14,b14,c14] = round1_op [d13, a13, b13, c13] (X@13) 12 (T@13)\n        [c15,d15,a15,b15] = round1_op [c14, d14, a14, b14] (X@14) 17 (T@14)\n        [b16,c16,d16,a16] = round1_op [b15, c15, d15, a15] (X@15) 22 (T@15)\n\nround1 : Buffer -> [16][32] -> Buffer\nround1 abcd X = last abcds\n    where\n        ss = [7, 12, 17, 22]\n        abcds = [ abcd ]\n              # [ (round1_op abcd' (X@i) (ss@(i % 4)) (T@i)) >>> 1\n                | abcd' <- abcds | i <- [0..15]\n                ]\n\nproperty round1_equiv x = round1 abcd x == round1_alt abcd x\n    where\n        abcd = initialize\n\nround2_op : Buffer -> [32] -> [8] -> [32] -> Buffer\nround2_op [a, b, c, d] Xk s Ti = [a', b, c, d]\n    where\n        a' = b + ((a + (G b c d) + Xk + Ti) <<< s)\n\nround2 : Buffer -> [16][32] -> Buffer\nround2 abcd X = last abcds\n    where\n        ss = [5, 9, 14, 20]\n        abcds = [ abcd ]\n              # [ (round2_op abcd' (X@((i*5+1)%16)) (ss@(i % 4)) (T@(16+i)) >>> 1)\n                | abcd' <- abcds | i <- [0..15]\n                ]\n\nround3_op : Buffer -> [32] -> [8] -> [32] -> Buffer\nround3_op [a, b, c, d] Xk s Ti = [a', b, c, d]\n    where\n        a' = b + ((a + (H b c d) + Xk + Ti) <<< s)\n\nround3 : Buffer -> [16][32] -> Buffer\nround3 abcd X = last abcds\n    where\n        ss = [4, 11, 16, 23]\n        abcds = [ abcd ]\n              # [ (round3_op abcd' (X@((i*3+5)%16)) (ss@(i % 4)) (T@(32+i)) >>> 1)\n                | abcd' <- abcds | i <- [0..15]\n                ]\n\nround4_op : Buffer -> [32] -> [8] -> [32] -> Buffer\nround4_op [a, b, c, d] Xk s Ti = [a', b, c, d]\n    where\n        a' = b + ((a + (I b c d) + Xk + Ti) <<< s)\n\nround4 : Buffer -> [16][32] -> Buffer\nround4 abcd X = last abcds\n    where\n        ss = [6, 10, 15, 21]\n        abcds = [ abcd ]\n              # [ (round4_op abcd' (X@((i*7)%16)) (ss@(i % 4)) (T@(48+i)) >>> 1)\n                | abcd' <- abcds | i <- [0..15]\n                ]\n\nrounds : Buffer -> [16][32] -> Buffer\nrounds abcd0 X = abcd0 + abcd4\n    where\n        abcd1 = round1 abcd0 X\n        abcd2 = round2 abcd1 X\n        abcd3 = round3 abcd2 X\n        abcd4 = round4 abcd3 X\n\nprocessMsg : {n} (fin n, n > 0) => [n][16][32] -> Buffer\nprocessMsg M = last abcd'\n    where\n        abcd0 = initialize\n        abcd' = [ abcd0 ]\n              # [ rounds abcd (groupBy`{32} (convert (join X)))\n                | abcd <- abcd' | X <- M ]\n```\n\n### 3.5 Step 5. Output\n\nThe message digest produced as output is A, B, C, D. That is, we begin with the low-order byte of A,\nand end with the high-order byte of D.\n\n```cryptol\nmd5 : {a} (64 >= width (a)) => [a] -> [128]\nmd5 msg = convert (join abcd)\n    where\n        msg' = prepMsg msg\n        abcd = processMsg msg'\n```\n\nThis completes the description of MD5. A reference implementation in C is given in the appendix.\n\n## Appendix\n\n### A.5 Test suite\n\n```cryptol\ntest1 = md5 (join \"\") == 0xd41d8cd98f00b204e9800998ecf8427e\ntest2 = md5 (join \"a\") == 0x0cc175b9c0f1b6a831c399e269772661\ntest3 = md5 (join \"abc\") == 0x900150983cd24fb0d6963f7d28e17f72\ntest4 = md5 (join \"message digest\") == 0xf96b697d7cb7938d525a2f31aaf161d0\ntest5 = md5 (join \"abcdefghijklmnopqrstuvwxyz\") == 0xc3fcd3d76192e4007dfb496cca67e13b\ntest6 = md5 (join \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\") == 0xd174ab98d277d9f5a5611c2c9f419d9f\ntest7 = md5 (join \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\") == 0x57edf4a22be3c955ac49da2e2107b67a\n\nproperty tests_pass = test1 \/\\ test2 \/\\ test3 \/\\ test4\n                   \/\\ test5 \/\\ test6 \/\\ test7\n```\n\n## Backwards Compatibility\n\nThe functions defined below maintain backwards compatibility with previous versions of the `MD5`\ncryptol module.\n\n```cryptol\n\/\/ Test driver. Given a sequence of bytes, calculate the MD5 sum.\ntest s = md5 (join s)\n\n\/\/ Reference implementation of MD5 on exactly 16 bytes\nmd5_ref : [16][8] -> [16][8]\nmd5_ref msg = map reverse (groupBy`{8} (md5 (join (map reverse msg))))\n\nmd5_ref' : [128] -> [128]\nmd5_ref' msg = join (md5_ref msg')\n    where\n        msg' = groupBy`{8} msg","variant":null,"set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/TripleDES.md","filetype":"txt","content":"# FIPS 46-3: TRIPLE DATA ENCRYPTION STANDARD\n\n## Introduction\n\nAll text in this document is directly from the\n[Data Encryption Standard](https:\/\/csrc.nist.gov\/files\/pubs\/fips\/46-3\/final\/docs\/fips46-3.pdf).\n\n```cryptol\nmodule Primitive::Symmetric::Cipher::Block::TripleDES where\n\nimport Primitive::Symmetric::Cipher::Block::DES (DES)\n\nE = DES.encrypt\nD = DES.decrypt\n```\n\n## TRIPLE DATA ENCRYPTION ALGORITHM\n\nLet *E<sub>K<\/sub>(I)* and *D<sub>K<\/sub>(I)* represents the DES encryption and decryption of *I*\nusing DES key *K* respectively. Each TDEA encryption\/decryption operation (as specified in ANSI\nX9.52) is a compound operation of DES encryption and decryption operations. The following operations\nare used:\n\n1. TDEA encryption operation: the transformation of a 64-bit block *I* into a 64-bit block *O* that\nis defined as follows:\n\n```cryptol\nencrypt : [3][64] -> [64] -> [64]\nencrypt [K1, K2, K3] I = O\n    where\n        O = E K3 (D K2 (E K1 I))\n\n\/\/ Maintain backwards compatibility\nblockEncrypt : ([64], [64], [64], [64]) -> [64]\nblockEncrypt (k1, k2, k3, data) = encrypt [k1, k2, k3] data\n```\n\n2. TDEA decryption operation: the transformation of a 64-bit block *I* into a 64-bit block *O* that\nis defined as follows:\n\n```cryptol\ndecrypt : [3][64] -> [64] -> [64]\ndecrypt [K1, K2, K3] I = O\n    where\n        O = D K1 (E K2 (D K3 I))\n```\n\nThe standard specifies the following keying options for bundle *(K<sub>1<\/sub>, K<sub>2<\/sub>,\nK<sub>3<\/sub>)*\n\n1. Keying Option 1: *K<sub>1<\/sub>*, *K<sub>2<\/sub>*, and *K<sub>3<\/sub>* are independent keys;\n\n2. Keying Option 2: *K<sub>1<\/sub>* and *K<sub>2<\/sub>* are independent keys and\n*K<sub>3<\/sub> = K<sub>1<\/sub>*;\n\n3. Keying Option 3: *K<sub>1<\/sub> = K<sub>2<\/sub> = K<sub>3<\/sub>*.\n\nA TDEA mode of operation is backward compatible with its single DES counterpart if, with compatible\nkeying options for TDEA operations,\n\n1. an encrypted plaintext computed using a single DES mode of operation can be decrypted correctly\nbe a corresponding TDEA mode of operation; and\n\n2. an encrypted plaintext computed using a TDEA mode of operation can be decrypted correctly by a\ncorresponding single DES mode of operation.\n\nWhen using Keying Option 3 (*K<sub>1<\/sub> = K<sub>2<\/sub> = K<sub>3<\/sub>*), TECB, TCBC, TCFB and\nTOFB modes are backward compatible with single DES modes of operation ECB, CBC, CFB, OFB\nrespectively.\n\nThe diagram in Appendix 2 illustrates TDEA encryption and TDEA decryption.\n\n## APPENDIX 2: TRIPLE DES BLOCK DIAGRAM (ECB Mode)\n\n**TDEA Encryption Operation:**\n\n*I -> DES E<sub>K1<\/sub> -> DES D<sub>K2<\/sub> -> DES E<sub>K2<\/sub> -> O*\n\n**TDEA Decryption Operation:**\n\n*I -> DES D<sub>K3<\/sub> -> DES E<sub>K2<\/sub> -> DES D<sub>K1<\/sub> -> O*\n\n## Test Vectors\n\n### 2-Key Tests\n\nThe following test vectors are pulled from\n[Project NESSIE](https:\/\/www.cosic.esat.kuleuven.be\/nessie\/testvectors\/bc\/des\/Triple-Des-2-Key-128-64.unverified.test-vectors).\n\n```cryptol\nproperty test_twokey = encrypt k0' pt0 == ct0\n                    \/\\ encrypt k1' pt1 == ct1\n                    \/\\ encrypt k2' pt2 == ct2\n    where\n        k0  = 0x80000000000000000000000000000000\n        k0' = [take`{64} k0, drop`{64} k0, take`{64} k0]\n        pt0 = 0x0000000000000000\n        ct0 = 0xFAFD5084374FCE34\n        k1  = 0x40000000000000000000000000000000\n        k1' = [take`{64} k1, drop`{64} k1, take`{64} k1]\n        pt1 = 0x0000000000000000\n        ct1 = 0x60CC37B7B537A1DC\n        k2  = 0x20000000000000000000000000000000\n        k2' = [take`{64} k2, drop`{64} k2, take`{64} k2]\n        pt2 = 0x0000000000000000\n        ct2 = 0xBE3E7304FE92C2BC","variant":null,"set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/DES.md","filetype":"txt","content":"# FIPS 46-3: DATA ENCRYPTION STANDARD\n\n## Introduction\n\nAll text in this document is directly from the\n[Data Encryption Standard](https:\/\/csrc.nist.gov\/files\/pubs\/fips\/46-3\/final\/docs\/fips46-3.pdf).\n\n```cryptol\nmodule Primitive::Symmetric::Cipher::Block::DES where\n\nimport Primitive::Symmetric::Cipher::Block::Cipher\n```\n\n## Introduction\n\nThe algorithm is designed to encipher and decipher blocks of data consisting of 64 bits under\ncontrol of a 64-bit key. Deciphering must be accomplished by using the same key as for enciphering,\nbut with the schedule of addressing the keys bits altered so that the deciphering process is the\nreverse of the enciphering process. A block to be enciphered is subjected to an initial permutation\n*IP*, then to a complex key-dependent computation and finally to a permutation which is the inverse\nof the initial permutation *IP^-1*. The key-dependent computation can be simply defined in terms of\na function *f*, called the cipher function, and a function *KS*, called the key schedule. A\ndescription of the computation is given first, along with details as to how the algorithm is used\nfor encipherment. Next, the use of the algorithm for decipherment is described. Finally, a\ndefinition of the cipher function *f* is given in terms of primitive functions which are called the\nselection functions *S<sub>i<\/sub>* and the permutation function *P*. *S<sub>i<\/sub>*, *P*, and *KS*\nof the algorithm are contained in Appendix 1.\n\n```cryptol\nDES : Cipher 64 64\nDES = { encrypt key pt = encipher key pt\n      , decrypt key ct = decipher key ct\n      }\n\nprivate\n    encipher : [64] -> [64] -> [64]\n    encipher K input = IP' (join preoutput)\n        where\n            LR0 = split (IP input) : [2][32]  \/\/ initial permutation\n            Ks  = KS K\n            LRs = [ LR0 ] # [ round LRn Kn | LRn <- LRs | Kn <- Ks ]\n            preoutput = reverse (last LRs)\n```\n\nThe following notation is convenient: Given two blocks *L* and *R* of bits, *LR* denotes the block\nconsisting of the bits of *L* followed by the bits of *R*. Since concatenation is associative,\n*B<sub>1<\/sub>B<sub>2<\/sub>...B<sub>8<\/sub>* for example, denotes the block consisting of the bits\nof *B<sub>1<\/sub>* followed by the bits of *B<sub>2<\/sub>*...followed by the bits of\n*B<sub>8<\/sub>*.\n\n## Enciphering\n\nA sketch of the enciphering computation is given in Figure 1.\n\nThe 64 bits of the input block to be enciphered are first subjected to the following permutation,\ncalled the initial permutation `IP`:\n\n```cryptol\nprivate\n    IPTable : [64][8]\n    IPTable = [ 58, 50, 42, 34, 26, 18, 10, 2\n              , 60, 52, 44, 36, 28, 20, 12, 4\n              , 62, 54, 46, 38, 30, 22, 14, 6\n              , 64, 56, 48, 40, 32, 24, 16, 8\n              , 57, 49, 41, 33, 25, 17,  9, 1\n              , 59, 51, 43, 35, 27, 19, 11, 3\n              , 61, 53, 45, 37, 29, 21, 13, 5\n              , 63, 55, 47, 39, 31, 23, 15, 7\n              ]\n\n    IP : [64] -> [64]\n    IP input = [ input@(i-1) | i <- IPTable ]\n```\n\nThat is the permuted input has bit 58 of the input as its first bit, bit 50 as its second bit, and\nso on with bit 7 as its last bit. The permuted input block is then the input to a complex\nkey-dependent computation described below. The output of that computation, called the preoutput, is\nthen subjected to the following permutation which is the inverse of the initial permutation:\n\n```cryptol\nprivate\n    IPTable' : [64][8]\n    IPTable' = [ 40, 8, 48, 16, 56, 24, 64, 32\n               , 39, 7, 47, 15, 55, 23, 63, 31\n               , 38, 6, 46, 14, 54, 22, 62, 30\n               , 37, 5, 45, 13, 53, 21, 61, 29\n               , 36, 4, 44, 12, 52, 20, 60, 28\n               , 35, 3, 43, 11, 51, 19, 59, 27\n               , 34, 2, 42, 10, 50, 18, 58, 26\n               , 33, 1, 41,  9, 49, 17, 57, 25\n               ]\n\n    IP' : [64] -> [64]\n    IP' preoutput = [ preoutput@(i-1) | i <- IPTable' ]\n```\n\nThat is, the output of the algorithm has bit 40 of the preoutput block as its first bit, bit 8 as\nits second bit, and so on, until bit 25 of the preoutput block is the last bit of the output.\n\nThe computation which used the permuted input block as its input to produce the preoutput block\nconsists, but for a final interchange of blocks, of 16 iterations of a calculation that is described\nbelow in terms of the cipher function `f` which operates on two blocks, one of 32 bits and one of 48\nbits, and produces a block of 32 bits.\n\n*Note: defined below in [The Cipher Function f](#the-cipher-function-f)*.\n\n```cryptol\nprivate\n    f : [32] -> [48] -> [32]\n```\n\nLet the 64 bits of the input block to an iteration consist of a 32 bit block `L` followed by a 32\nbit block `R`. Using the notation defined in the introduction, the input block is then `LR`.\n\nLet `K` be a block of 48 bits chosen from the 64-bit key. Then the output `L'R'` of an iteration\nwith input `LR` is defined by:\n\n(1)\n```cryptol\nprivate\n    initial : [64] -> [48] -> [64]\n    initial LR K = L' # R'\n        where\n            [L, R] = split LR : [2][32]\n            L' = R\n            R' = L ^ (f R K)\n```\n\nwhere `^` denotes bit-by-bit addition modulo 2.\n\nAs remarked before, the input of the first iteration of the calculation is the permuted input block.\nIf `L'R'` is the output of the 16th iteration then `R'L'` is the preoutput block. At each iteration\na different block `K` of key bits is chosen from the 64-bit key designated by `KEY`.\n\nWith more notation we can describe the iterations of the computation in more detail. Let `KS` be a\nfunction which takes an integer `n` in the range from 1 to 16 and a 64-bit block `KEY` as input and\nyields as output a 48-bit block *K<sub>n<\/sub>* which is permuted selection of bits from `KEY`. That\nis\n\n(2)\n\n*Note: Defined below in\n[Appendix 1](#appendix-1-primitive-functions-for-the-data-encryption-algorithm).*\n\n```cryptol\nprivate\n    KS : [64] -> [16][48]\n```\n\nwith *K<sub>n<\/sub>* determined by the bits in 48 distinct bit positions of `KEY`. `KS` is called\nthe key schedule because the block `K` used in the *n*'th iteration of (1) is the block\n*K<sub>n<\/sub>* determined by (2).\n\nAs before, let the permuted input block be `LR`. Finally, let *L<sub>0<\/sub>* and *R<sub>0<\/sub>* be\nrespectively `L` and `R` and let *L<sub>n<\/sub>* and *R<sub>n<\/sub>* be respectively `L'` and `R'`\nof (1) when `L` and `R` are respectively *L<sub>n-1<\/sub>* and *R<sub>n-1<\/sub>* and `K` is\n*K<sub>n<\/sub>*; that is, when *n* is in the range from 1 to 16,\n\n(3)\n```cryptol\nprivate\n    round : [2][32] -> [48] -> [2][32]\n    round [L, R] K = [L', R']\n        where\n            L' = R\n            R' = L ^ (f R K)\n```\n\nThe preoutput block is then *R<sub>16<\/sub>L<sub>16<\/sub>*.\n\nThe key schedule `KS` of the algorithm is described in detail in the Appendix. The key schedule\nproduces the 16 *K<sub>n<\/sub>* which are required by the algorithm.\n\n## Deciphering\n\nThe permutation `IP'` applied to the preoutput block is the inverse of the initial permutation `IP`\napplied to the input. Further, from (1) it follows that:\n\n(4)\n```cryptol\nprivate\n    initial' : [64] -> [48] -> [64]\n    initial' L'R' K = L # R\n        where\n            [L', R'] = split L'R' : [2][32]\n            R = L'\n            L = R' ^ (f L' K)\n```\n\nConsequently, to *decipher* it is only necessary to apply the *very same algorithm to an enciphered\nmessage block*, taking care that at each iteration of the computation *the same block of key bits K\nis used* during decipherment as was used during the encipherment of the block. Using the notation of\nthe previous section, this can be expressed by the equations:\n\n(5)\n```cryptol\nprivate\n    round' : [2][32] -> [48] -> [2][32]\n    round' [L, R] K = [L', R']\n        where\n            R' = L\n            L' = R ^ (f L K)\n```\n\nwhere now *R<sub>16<\/sub>L<sub>16<\/sub>* is the permuted input block for the deciphering calculation\nand *L<sub>0<\/sub>R<sub>0<\/sub>* is the preoutput block. That is, for the decipherment calculation\nwith *R<sub>16<\/sub>L<sub>16<\/sub>* as the permuted input, *K<sub>16<\/sub>* is used in the first\niteration, *K<sub>15<\/sub>* in the second, and so on, with *K<sub>1<\/sub>* used in the 16th\niteration.\n\n```cryptol\nprivate\n    decipher : [64] -> [64] -> [64]\n    decipher K output = IP' (join LR0)\n        where\n            LR16 = reverse (split (IP output) : [2][32])\n            Ks' = reverse (KS K)\n            LRs' = [ LR16 ] # [ round' LRn' Kn | LRn' <- LRs' | Kn <- Ks' ]\n            LR0 = last LRs'\n\n    property DecipherInvertsEncipher input key = decipher key (encipher key input) == input\n    property DESCorrect key msg = DES.decrypt key (DES.encrypt key msg) == msg\n```\n\n## The Cipher Function *f*\n\nA sketch of the calculation of `f(R, K)` is given in **Figure 2**.\n\nLet `E` denote a function which takes a block of 32 bits as input and yields a block of 48 bits as\noutput. Let `E` be such that the 48 bits of its output, written as 8 blocks of 6 bits each, are\nobtained by selecting the bits in its inputs in order according to the following table:\n\n```cryptol\nprivate\n    \/\/ E BIT-SELECTION TABLE\n    Ebits : [48][8]\n    Ebits = [ 32,  1,  2,  3,  4,  5\n            ,  4,  5,  6,  7,  8,  9\n            ,  8,  9, 10, 11, 12, 13\n            , 12, 13, 14, 15, 16, 17\n            , 16, 17, 18, 19, 20, 21\n            , 20, 21, 22, 23, 24, 25\n            , 24, 25, 26, 27, 28, 29\n            , 28, 29, 30, 31, 32,  1\n            ]\n\n    E : [32] -> [48]\n    E R = R'\n        where\n            R' = [ R@(ebit - 1) | ebit <- Ebits]\n```\n\nThus the first three bits of `E(R)` are the bits in positions 32, 1, and 2 of `R` while the last 2\nbits of `E(R)` are the bits in positions 32 and 1.\n\nEach of the unique selection functions *S<sub>1<\/sub>,S<sub>2<\/sub>,...,S<sub>8<\/sub>* takes a 6-bit\nblock as input and yields a 4-bit block as output and is illustrated by using a table containing the\nrecommended *S<sub>1<\/sub>*:\n\n**S<sub>1<\/sub>**\n\n| Row No | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |\n| ------ | - | - | - | - | - | - | - | - | - | - | -- | -- | -- | -- | -- | -- |\n| 0 | 14 |  4 | 13 |  1 |  2 | 15 | 11 |  8 |  3 | 10 |  6 |  12 |  5 |  9 |  0 |  7 |\n| 1 |  0 | 15 |  7 |  4 | 14 |  2 | 13 |  1 | 10 |  6 | 12 |  11 |  9 |  5 |  3 |  8 |\n| 2 |  4 |  1 | 14 |  8 | 13 |  6 |  2 | 11 | 15 | 12 |  9 |   7 |  3 | 10 |  5 |  0 |\n| 3 | 15 | 12 |  8 |  2 |  4 |  9 |  1 |  7 |  5 | 11 |  3 |  14 | 10 |  0 |  6 | 13 |\n\nIf *S<sub>1<\/sub>* is the function defined in this table and *B* is a block of 6 bits, then\n*S<sub>1<\/sub>(B)* is determined as follows: The first and last bits of *B* represent in base 2 a\nnumber in the range 0 to 3. Let that number be `i`. The middle 4 bits of *B* represent in base 2 a\nnumber in the range 0 to 15. Let that number be `j`. Look up in the table the number in the `i`'th\nrow and `j`'th column. It is a number in the range 0 to 15 and is uniquely represented by a 4 bit\nblock. That block is the output *S<sub>1<\/sub>(B)* of *S<sub>1<\/sub>* for the input *B*. For\nexample, for input `011011` the row is `01`, that is row 1, and the column is determined by `1101`,\nthat is column 12. In row 1 column 13 appears 5 so that the output is `0101`. Selection functions\n*S<sub>1<\/sub>,S<sub>2<\/sub>,...,S<sub>8<\/sub>* of the algorithm appear in Appendix 1.\n\n```cryptol\nprivate\n    S : [6] -> [8] -> [4]\n    S B idx = (Si@i@j)\n        where\n            ss = [s1, s2, s3, s4, s5, s6, s7, s8]\n            Si = (ss@(idx - 1))\n            i = [(B@0), (B@5)]\n            j = B@@[1..4]\n\n    property example_s1 = S input 1 == output\n        where\n            input  = 0b011011\n            output = 0b0101\n```\n\nThe permutation function *P* yields a 32-bit output from a 32-bit input by permuting the bits of the\ninput block. Such a function is defined by the following table:\n\n```cryptol\nprivate\n    Ptable : [32][8]\n    Ptable = [ 16,  7, 20, 21\n             , 29, 12, 28, 17\n             ,  1, 15, 23, 26\n             ,  5, 18, 31, 10\n             ,  2,  8, 24, 14\n             , 32, 27,  3,  9\n             , 19, 13, 30,  6\n             , 22, 11,  4, 25\n             ]\n```\n\nThe output *P(L)* for the function *P* defined by this table is obtained from the input *L* by\ntaking the 16th bit of *L* as the first bit of *P(L)*, the 7th bit as the second bit of *P(L)*, and\nso on until the 25th bit of *L* is taken as the 32nd bit of *P(L)*. The permutation function *P* of\nthe algorithm is repeated in Appendix 1.\n\n```cryptol\nprivate\n    P : [32] -> [32]\n    P L = [ L@(p-1) | p <- Ptable ]\n```\n\nNow let *S<sub>1<\/sub>,...,S<sub>8<\/sub>* be eight distinct selection functions, let *P* be the\npermutation function and let *E* be the function defined above.\n\nTo define *f(R, K)* we first define *B<sub>1<\/sub>,...,B<sub>8<\/sub>* to be blocks of 6 bits each\nfor which\n\n(6)\n```example\nB = K ^ (E R)\n```\n\nThe block *f(R, K)* is then defined to be\n\n(7)\n```cryptol\nprivate\n    f R K = P Ss\n        where\n            Bs = split`{8} (K ^ (E R))\n            Ss = join [ S B i | B <- Bs | i <- [1..8] ]\n```\n\nThus *K ^ E(R)* is first divided into the 8 blocks as indicated in (6). Then each *B<sub>i<\/sub>* is\ntaken as an input to *S<sub>i<\/sub>* and the 8 blocks\n*S<sub>1<\/sub>(B<sub>1<\/sub>),S<sub>2<\/sub>(B<sub>2<\/sub>),...,S<sub>8<\/sub>(B<sub>8<\/sub>)* of 4\nbits each are consolidated into a single block of 32 bits which forms the input to *P*. The output\n(7) is then the output of the function *f* for the inputs *R* and *K*.\n\n## APPENDIX 1: PRIMITIVE FUNCTIONS FOR THE DATA ENCRYPTION ALGORITHM\n\nThe choice of the primitive functions *KS*, *S<sub>1<\/sub>,...,S<sub>8<\/sub>* and *P* is critical to\nthe strength of an encipherment resulting from the algorithm. Specified below is the recommended set\nof functions describing *S<sub>1<\/sub>,...,S<sub>8<\/sub>* and *P* in the same way they are described\nin the algorithm. for the interpretation of the tables describing these functions, see the\ndiscussion in the body of the algorithm.\n\nThe primitive functions *S<sub>1<\/sub>,...,S<sub>8<\/sub>* are:\n\n```cryptol\nprivate\n    s1 : [4][16][4]\n    s1 = [ [14,  4, 13, 1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9, 0,  7]\n         , [ 0, 15,  7, 4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5, 3,  8]\n         , [ 4,  1, 14, 8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10, 5,  0]\n         , [15, 12,  8, 2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0, 6, 13]\n         ]\n\n    s2 : [4][16][4]\n    s2 = [ [15,  1,  8, 14,  6, 11,  3,  4,  9, 7,  2, 13, 12, 0,  5, 10]\n         , [ 3, 13,  4,  7, 15,  2,  8, 14, 12, 0,  1, 10,  6, 9, 11,  5]\n         , [ 0, 14,  7, 11, 10,  4, 13,  1,  5, 8, 12,  6,  9, 3,  2, 15]\n         , [13,  8, 10,  1,  3, 15,  4,  2, 11, 6,  7, 12,  0, 5, 14,  9]\n         ]\n\n    s3 : [4][16][4]\n    s3 = [ [10,  0,  9, 14, 6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8]\n         , [13,  7,  0,  9, 3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1]\n         , [13,  6,  4,  9, 8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7]\n         , [ 1, 10, 13,  0, 6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12]\n         ]\n\n    s4 : [4][16][4]\n    s4 = [ [ 7, 13, 14, 3,  0,  6,  9, 10,  1, 2, 8,  5, 11, 12,  4, 15]\n         , [13,  8, 11, 5,  6, 15,  0,  3,  4, 7, 2, 12,  1, 10, 14,  9]\n         , [10,  6,  9, 0, 12, 11,  7, 13, 15, 1, 3, 14,  5,  2,  8,  4]\n         , [ 3, 15,  0, 6, 10,  1, 13,  8,  9, 4, 5, 11, 12,  7,  2, 14]\n         ]\n\n    s5 : [4][16][4]\n    s5 = [ [ 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13, 0, 14,  9]\n         , [14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3, 9,  8,  6]\n         , [ 4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6, 3,  0, 14]\n         , [11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10, 4,  5,  3]\n         ]\n\n    s6 : [4][16][4]\n    s6 = [ [12,  1, 10, 15, 9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11]\n         , [10, 15,  4,  2, 7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8]\n         , [ 9, 14, 15,  5, 2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6]\n         , [ 4,  3,  2, 12, 9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13]\n         ]\n\n    s7 : [4][16][4]\n    s7 = [ [ 4, 11,  2, 14, 15, 0,  8, 13,  3, 12, 9,  7,  5, 10, 6,  1]\n         , [13,  0, 11,  7,  4, 9,  1, 10, 14,  3, 5, 12,  2, 15, 8,  6]\n         , [ 1,  4, 11, 13, 12, 3,  7, 14, 10, 15, 6,  8,  0,  5, 9,  2]\n         , [ 6, 11, 13,  8,  1, 4, 10,  7,  9,  5, 0, 15, 14,  2, 3, 12]\n         ]\n\n    s8 : [4][16][4]\n    s8 = [ [13,  2,  8, 4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7]\n         , [ 1, 15, 13, 8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2]\n         , [ 7, 11,  4, 1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8]\n         , [ 2,  1, 14, 7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11]\n         ]\n```\n\nThe primitive function *P* is:\n\n*Note: Previously defined above in [The Cipher Function f](#the-cipher-function-f)*.\n\n```example\n[ 16,  7, 20, 21\n, 29, 12, 28, 17\n,  1, 15, 23, 26\n,  5, 18, 31, 10\n,  2,  8, 24, 14\n, 32, 27,  3,  9\n, 19, 13, 30,  6\n, 22, 11,  4, 25 ]\n```\n\nRecall that *K<sub>n<\/sub>* for `1<=n<=16`, is the blokc of 48 bits in (2) of the algorithm. Hence,\nto describe *KS*, it is sufficient to describe the calculation of *K<sub>n<\/sub>* from `KEY` for\n`n=1, 2,..., 16`. That calculation is illustrated in **Figure 3**. To complete the definition of\n*KS* it is therefore sufficient to describe the two permuted choices, as well as the schedule of\nleft shifts. One bit in each 8-bit byte of the `KEY` may be utilized for error detection in key\ngeneration, distribution and storage. Bits 8, 16, ..., 64 are for use in assuring that each byte is\nof odd parity.\n\nPermuted choice 1 is determined by the following table:\n\n```cryptol\nprivate\n    PC1Table : [2][28][8]\n    PC1Table = [C, D]\n        where\n            C = [ 57, 49, 41, 33, 25, 17,  9\n                ,  1, 58, 50, 42, 34, 26, 18\n                , 10,  2, 59, 51, 43, 35, 27\n                , 19, 11,  3, 60, 52, 44, 36\n                ]\n            D = [ 63, 55, 47, 39, 31, 23, 15\n                ,  7, 62, 54, 46, 38, 30, 22\n                , 14,  6, 61, 53, 45, 37, 29\n                , 21, 13,  5, 28, 20, 12,  4\n                ]\n```\n\nThe table has been divided into two parts, with the first part determining how the bits of *C* are\nchosen, and the second part determining how the bits of *D* are chosen. The bits of `KEY` are\nnumbered 1 through 64. The bits of *C* are respectively bits 57, 49, 41,...,44 and 36 of `KEY`, with\nthe bits of of *D* being bits 63, 55, 47,..., 12 and 4 of `KEY`.\n\n```cryptol\nprivate\n    PC1 : [64] -> [2][28]\n    PC1 K = [join C0, join D0]\n        where\n            [C, D] = PC1Table\n            C0 = [ [(K@((C@i)-1))] | i <- [0..27]]\n            D0 = [ [(K@((D@i)-1))] | i <- [0..27]]\n```\n\nWith *C* and *D* defined, we now define how the blocks *C<sub>n<\/sub>* and *D<sub>n<\/sub>* are\nobtained from the blocks *C<sub>n-1<\/sub>* and *D<sub>n-1<\/sub>*, respectively, for\n`n = 1,2,...,16`. That is accomplished by adhering to the following schedule of left shifts of the\nindividual blocks:\n\n```cryptol\nprivate\n    KS K = [ PC2 (join cd) | cd <- drop CnDns ]\n        where\n            C0D0  = PC1 K\n            CnDns = [C0D0] # [ [Cn <<< (shifts@i), Dn <<< (shifts@i) ]\n                             | [Cn, Dn] <- CnDns\n                             | i <- [0..15]]\n```\n\n| Iteration Number | Number of Left Shifts |\n| :--------------: | :-------------------: |\n|  1 | 1 |\n|  2 | 1 |\n|  3 | 2 |\n|  4 | 2 |\n|  5 | 2 |\n|  6 | 2 |\n|  7 | 2 |\n|  8 | 2 |\n|  9 | 1 |\n| 10 | 2 |\n| 11 | 2 |\n| 12 | 2 |\n| 13 | 2 |\n| 14 | 2 |\n| 15 | 2 |\n| 16 | 1 |\n\n```cryptol\nprivate\n    shifts : [16][8]\n    shifts = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]\n```\n\nFor example, *C<sub>3<\/sub>* and *D<sub>3<\/sub>* are obtained from *C<sub>2<\/sub>* and\n*D<sub>2<\/sub>*, respectively, by two left shifts, and *C<sub>16<\/sub>* and *D<sub>16<\/sub>* are\nobtained from *C<sub>15<\/sub>* and *D<sub>15<\/sub>*, respectively, by one left shift. In all cases,\nby a single left shift is meant a rotation of the bits one place to the left, so that after one left\nshift the bits in the 28 positions are the bits that were previously in positions 2, 3,..., 28, 1.\n\nPermuted choice 2 is determined by the following table:\n\n```cryptol\nprivate\n    PC2Table : [48][8]\n    PC2Table = [ 14, 17, 11, 24,  1,  5\n               ,  3, 28, 15,  6, 21, 10\n               , 23, 19, 12,  4, 26,  8\n               , 16,  7, 27, 20, 13,  2\n               , 41, 52, 31, 37, 47, 55\n               , 30, 40, 51, 45, 33, 48\n               , 44, 49, 39, 56, 34, 53\n               , 46, 42, 50, 36, 29, 32\n               ]\n```\n\nTherefore, the first bit of *K<sub>n<\/sub>* is the 14th bit of *C<sub>n<\/sub>D<sub>n<\/sub>* the\nsecond bit the 17th, and so on with the 47th bit the 29th, and the 48th bit the 32nd.\n\n```cryptol\nprivate\n    PC2 : [56] -> [48]\n    PC2 CnDn = join Kn\n        where\n            Kn = [ [CnDn@(i-1)] | i <- PC2Table ]\n```\n\n## Test Vectors\n\nThe following test vectors are pulled from the appendix of\n[NIST 800-17](https:\/\/nvlpubs.nist.gov\/nistpubs\/Legacy\/SP\/nistspecialpublication800-17.pdf).\n\n### Appendix B: Tables of Values for the Known Answer Tests\n\nTable 1. Resulting Ciphertext from the Variable Plaintext Known Answer Test for DES\n\n(*NOTE: KEY = 01 01 01 01 01 01 01 01 (odd parity set)*)\n\n```cryptol\nprivate\n    property test_tbl1 = DES.encrypt key pt0 == ct0\n                      \/\\ DES.encrypt key pt1 == ct1\n                      \/\\ DES.encrypt key pt2 == ct2\n        where\n            key = 0x0101010101010101\n            pt0 = 0x8000000000000000\n            ct0 = 0x95f8a5e5dd31d900\n            pt1 = 0x4000000000000000\n            ct1 = 0xdd7f121ca5015619\n            pt2 = 0x2000000000000000\n            ct2 = 0x2e8653104f3834ea\n```\n\nTable 2. Resulting Ciphertext from the Variable Key Known Answer Test for DES\n\n(*NOTE: Plaintext\/text = 00 00 00 00 00 00 00 00 and, where applicable,\nIV = 00 00 00 00 00 00 00 00*)\n\n```cryptol\nprivate\n    property test_tbl2 = DES.encrypt k0 pt == ct0\n                      \/\\ DES.encrypt k1 pt == ct1\n                      \/\\ DES.encrypt k2 pt == ct2\n        where\n            pt  = 0x0000000000000000\n            k0  = 0x8001010101010101\n            ct0 = 0x95a8d72813daa94d\n            k1  = 0x4001010101010101\n            ct1 = 0x0eec1487dd8c26d5\n            k2  = 0x2001010101010101\n            ct2 = 0x7ad16ffb79c45926\n```\n\nTable 3. Values To Be Used for the Permutation Operation Known Answer Test\n\n(*NOTE: Plaintext\/text = 00 00 00 00 00 00 00 00 for each round and, where applicable,\nIV = 00 00 00 00 00 00 00 00*)\n\n```cryptol\nprivate\n    property test_tbl3 = DES.encrypt k0 pt == ct0\n                      \/\\ DES.encrypt k1 pt == ct1\n                      \/\\ DES.encrypt k2 pt == ct2\n        where\n            pt  = 0x0000000000000000\n            k0  = 0x1046913489980131\n            ct0 = 0x88d55e54f54c97b4\n            k1  = 0x1007103489988020\n            ct1 = 0x0c0cc00c83ea48fd\n            k2  = 0x10071034c8980120\n            ct2 = 0x83bc8ef3a6570183\n```\n\nTable 4. Values To Be Used for the Substitution Table Known Answer Test\n\n```cryptol\nprivate\n    property test_tbl4 = DES.encrypt k0 pt0 == ct0\n                      \/\\ DES.encrypt k1 pt1 == ct1\n                      \/\\ DES.encrypt k2 pt2 == ct2\n                      \/\\ DES.encrypt k3 pt3 == ct3\n        where\n            k0  = 0x7ca110454a1a6e57\n            pt0 = 0x01a1d6d039776742\n            ct0 = 0x690f5b0d9a26939b\n            k1  = 0x0131d9619dc1376e\n            pt1 = 0x5cd54ca83def57da\n            ct1 = 0x7a389d10354bd271\n            k2  = 0x07a1133e4a0b2686\n            pt2 = 0x0248d43806f67172\n            ct2 = 0x868ebb51cab4599a\n            k3  = 0x3849674c2602319e\n            pt3 = 0x51454b582ddf440a\n            ct3 = 0x7178876e01f19b2a","variant":null,"set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/LED.md","filetype":"txt","content":"# The LED Block Cipher\n\n## Introduction\n\nAll text in this document is directly from the\n[LED Specification](https:\/\/eprint.iacr.org\/2012\/600.pdf).\n\n```cryptol\nmodule Primitive::Symmetric::Cipher::Block::LED where\n\nimport Common::GF24 (gf24VectorMult)\n```\n\n## 2 Design approach and specifications\n\nLike so much in today's symmetric cryptography, an AES-like design appears to be the ideal starting\npoint for a clean and secure design. The design of LED will inevitably have many parallels with this\nestablished approach, and features such as `Sboxes`, `ShiftRows`, and (a variant of) `MixColumns`\nwill all take their familiar roles.\n\nFor the key schedule we chose to do-away with the \"schedule\"; instead the user-provided key is used\nrepeatedly *as is*. As well as giving obvious advantages in hardware implementation, it allows for\nsimple proofs to be made for the security of the scheme even in the most challenging attack model of\nrelated keys. At first sight the re-use of the encryption key without variation appears dangerous,\ncertainly to those familiar with slide attacks and some of their advanced variants. But such a\nsimple key schedule is not without precedent though the treatment here is more complete than\npreviously.\n\nThe `LED` cipher is described in Section 2.1. It is a 64-bit block cipher with two primary instances\ntaking 64- and 128-bit keys. The cipher state is conceptually arranged in a (4 x 4) grid where each\nnibble represents an element from GF(2^4) with the underlying polynomial for field multiplication\ngiven by `X^4 + X + 1`.\n\n```cryptol\ntype BlockSize = 64\ntype Nibble = [4]\ntype State = [4][4]Nibble\ntype SubKey = [16][4]\n```\n\n`Sboxes`. LED cipher re-uses the PRESENT Sbox which has been adopted in many lightweight\ncryptographic algorithms. The actions of this box in hexadecimal notation is given by the following\ntable.\n\n| | | | | | | | | | | | | | | | | |\n| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| x    | 0x0 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 | 0x8 | 0x9 | 0xA | 0xB | 0xC | 0xD | 0xE | 0xF |\n| S[x] | 0xC | 0x5 | 0x6 | 0xB | 0x9 | 0x0 | 0xA | 0xD | 0x3 | 0xE | 0xF | 0x8 | 0x4 | 0x7 | 0x1 | 0x2 |\n\n```cryptol\nSbox : [16][4]\nSbox = [ 0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2 ]\n\n\/\/ Inverse of Sbox; Required for decryption.\nSbox' : [16][4]\nSbox' = [ 0x5, 0xE, 0xF, 0x8, 0xC, 0x1, 0x2, 0xD, 0xB, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xA]\n```\n\n`MixColumnSerial`. We re-use the tactic adopted in [23] to define an MDS matrix for linear diffusion\nthat is suitable for compact serial implementation. The `MixColumnSerial` layer can be viewed as\nfour applications of a hardware-friendly matrix *A* with the net result being equivalent to using\nthe MDS matrix *M* where\n\n```example\n        [ 0 1 0 0 ] ^ 4  [ 4 1 2 2 ]\n(A)^4 = [ 0 0 1 0 ]    = [ 8 6 5 6 ] = M\n        [ 0 0 0 1 ]      [ B E A 9 ]\n        [ 4 1 2 2 ]      [ 2 2 F B ]\n```\n\n```cryptol\nM : [4][4][4]\nM = [ [0x4, 0x1, 0x2, 0x2]\n    , [0x8, 0x6, 0x5, 0x6]\n    , [0xB, 0xE, 0xA, 0x9]\n    , [0x2, 0x2, 0xF, 0xB]]\n\n\/\/ Required for decryption\nM' : [4][4][4]\nM' = [ [0xC, 0xC, 0xD, 0x4]\n     , [0x3, 0x8, 0x4, 0x5]\n     , [0x7, 0x6, 0x2, 0xE]\n     , [0xD, 0x9, 0x9, 0xD]]\n```\n\nThe basic component of LED will be a sequence of four identical rounds used without the addition of\nany key material. This basic unit, that we later call \"step\", makes it easy to establish security\nbounds for the construction.\n\n### 2.1 Specification of LED\n\nFor a 64-bit plaintext *m* the 16 four-bit nibbles `m0||m1||...||m14||m15` are arranged\n(conceptually) in a square array:\n\n```example\n[  m0,  m1,  m2,  m3\n,  m4,  m5,  m6,  m7\n,  m8,  m9, m10, m11\n, m12, m13, m14, m15 ]\n```\n\nThis is the initial value of the cipher STATE and note that the state is loaded row-wise rather than\nin the column-wise fashion we have come to expect from the AES; this is a more hardware-friendly\nchoice, as pointed out in [38].\n\n```cryptol\ninitialState : [64] -> [4][4][4]\ninitialState m = groupBy`{4} m'\n    where\n        m' = groupBy`{4} m\n```\n\nThe key is viewed nibble-wise and we denote *k0, k1, ..., kl* the *l* nibbles of the key. Then the\n*i*-th subkey *SK^i*, also arranged (conceptually) in a square way:\n\n```example\n[  sk0,  sk1,  sk2,  sk3\n,  sk4,  sk5,  sk6,  sk7\n,  sk8,  sk9, sk10, sk11\n, sk12, sk13, sk14, sk15 ]\n```\n\nis simply obtained by setting *sk^i_j = k_(j + i*16 mod l). Note that for a 64-bit key *K*, all\nsubkeys are equal to *K*, while for a 128-bit key *K*, the subkeys are alternatively equal to the\nleft part *K1* and the right part *K2* of *K*.\n\n```cryptol\nsubKeys : {s, l} (l >= 16, 32 >= l, s >= 8, 12 >= s)\n       => [4*l] -> [s+1]SubKey\nsubKeys K = sks\n    where\n        ks = groupBy`{4} K\n        sks = [ [ks@((j + i*16) % `l) | j <- [0..15]] | i <- [0..s] ]\n\n\/\/ all subkeys for the 64-bit key case\ntest_subKey64 : [64] -> Bit\nproperty test_subKey64 key = and [ sk == key' | sk <- sks ]\n    where\n        sks  = subKeys`{8} key\n        key' = groupBy`{4} key\n\n\/\/ the two first subkeys for the 80-bit key case\ntest_subKey80 : [80] -> Bit\nproperty test_subKey80 key = sk@0 == key'@@[0..15]\n                          \/\\ sk@1 == (key'@@[16..19] # key'@@[0..11])\n    where\n        sk = subKeys`{12} key\n        key' = groupBy`{4} key\n\n\/\/ all alternating subkeys for the 128-bit key case\ntest_subKey128 : [128] -> Bit\nproperty test_subKey128 key = and [ sk == k | sk <- sks | k <- ks' ]\n    where\n        type s = 12\n        sks = subKeys`{s} key\n        ks  = split (groupBy`{4} key) : [2]SubKey\n        ks' = join (repeat ks)\n```\n\nThe operation `addRoundKey(STATE, SK^i)` combines nibbles of subkey *SK^i* with the state,\nrespecting array positioning, using bitwise exclusive-or. Encryption is described using\n`addRoundKey(STATE, SK^i)` and a second operation, `step(STATE)`. This is illustrated in Figure 1.\nThe number of steps *s* during encryption depends on the key size. For 64-bit key, *s = 8*. For\nbigger key sizes up to 128 bits, *s = 12*.\n\n```cryptol\nround : {n} (n >= 64, 128 >= n)\n     => State -> SubKey -> [8] -> State\nround state SKi i = state''\n    where\n        state' = addRoundKey state SKi\n        state'' = step`{n} state' i\n\n\/\/ Required for decryption\nround' : {n} (n >= 64, 128 >= n)\n      => State -> SubKey -> [8] -> State\nround' state SKi i = state''\n    where\n        state'  = step'`{n} state i\n        state'' = addRoundKey state' SKi\n\nproperty roundInverts st sk i = i < 12 ==> round'`{64}  (round`{64}  st sk i) sk i == st\n                                        \/\\ round'`{128} (round`{128} st sk i) sk i == st\n\naddRoundKey : State -> SubKey-> State\naddRoundKey state SKi = state ^ SKi'\n    where\n        SKi' = groupBy`{4} SKi\n\nencrypt : {s, l} (l >= 16, 32 >= l, s >= 8, 12 >= s)\n       => [4*l] -> [64] -> [64]\nencrypt key pt = join (join stateS)\n    where\n        state0 = initialState pt\n        ks = subKeys`{s} key\n        states = [state0] # [ round`{4*l} state (ks@i) i\n                            | state <- states\n                            | i <- [0..s-1]\n                            ]\n        stateS = addRoundKey (states ! 0) (ks@(`s))\n\n\/\/ Required for decryption\ndecrypt : {s, l} (l >= 16, 32 >= l, s >= 8, 12 >= s)\n       => [4*l] -> [64] -> [64]\ndecrypt key ct = join (join (states ! 0))\n    where\n        state' = initialState ct\n        ks = subKeys`{s} key\n        stateF = addRoundKey state' (ks@(`s))\n        states = [stateF] # [round'`{4*l} state (ks@i) i\n                            | state <- states\n                            | i <- (reverse [0..s-1])\n                            ]\n\nencryptDecryptInverts64 : [64] -> [64] -> Bit\nproperty encryptDecryptInverts64 key pt = decrypt`{8} key (encrypt`{8} key pt) == pt\n\n\/\/ Encrypt 64 bit key\nledEncrypt64 : ([64], [64]) -> [64]\nledEncrypt64 (key, pt) = encrypt`{8} key pt\n\n\/\/ Encrypt 128 bit key\nledEncrypt128 : ([128], [64]) -> [64]\nledEncrypt128 (key, pt) = encrypt`{12} key pt\n\n```\n\nThe operation `step(STATE)` consists of four rounds of encryption of the cipher state. Each of these\nfour rounds uses, in sequence, the operations `AddConstants`, `SubCells`, `ShiftRows`, and\n`MixColumnsSerial` as illustrated in Figure 2.\n\n```cryptol\nstep : {n} (n >= 64, 128 >= n)\n    => State -> [8] -> State\nstep state i = state3\n    where\n        state0 = step1`{n} state (4*i)\n        state1 = step1`{n} state0 (4*i+1)\n        state2 = step1`{n} state1 (4*i+2)\n        state3 = step1`{n} state2 (4*i+3)\n\n\/\/ Required for decryption\nstep' : {n} (n >= 64, 128 >= n)\n     => State -> [8] -> State\nstep' state i = state0\n    where\n        state3 = step1'`{n} state  (4*i+3)\n        state2 = step1'`{n} state3 (4*i+2)\n        state1 = step1'`{n} state2 (4*i+1)\n        state0 = step1'`{n} state1 (4*i)\n\nproperty stepInverts state i = i < 12 ==> step'`{64}  (step`{64}  state i) i == state\n                                       \/\\ step'`{128} (step`{128} state i) i == state\n\nstep1 : {n} (n >= 64, 128 >= n)\n    => State -> [8] -> State\nstep1 state i = state4\n    where\n        state1 = AddConstants state `n (rcs@i)\n        state2 = SubCells state1\n        state3 = ShiftRow state2\n        state4 = MixColumnsSerial state3\n\n\/\/ Required for decryption\nstep1' : {n} (n >= 64, 128 >= n)\n     => State -> [8] -> State\nstep1' state i = state0\n    where\n        state3 = MixColumnsSerial' state\n        state2 = ShiftRow' state3\n        state1 = SubCells' state2\n        state0 = AddConstants state1 `n (rcs@i)\n\nproperty step1Inverts state i = i < 48 ==> step1'`{64}  (step1`{64}  state i) i == state\n                                        \/\\ step1'`{128} (step1`{128} state i) i == state\n```\n\n`AddConstants`. A round constant is defined as follows. At each round, six bits (rc5, rc4, rc3, rc3,\nrc1, rc0) are shifted one position to the left with the new value to rc0 being computed as\n`rc5 \u2295 rc4 \u2295 1`. The six bits are initialized to zero, and updated *before* use in a given round.\nWe also denote (ks7, ks6, ...ks0) the 8 bits representing the key size in bits, with ks7 being the\nMSB. The constant, when used in a given round, is arranged into an array as follows:\n\n```example\n[ 0\u2295(ks7||ks6||ks5||ks4) (rc5||rc4||rc3) 0 0\n, 1\u2295(ks7||ks6||ks5||ks4) (rc2||rc1||rc0) 0 0\n, 2\u2295(ks3||ks2||ks1||ks0) (rc5||rc4||rc3) 0 0\n, 3\u2295(ks3||ks2||ks1||ks0) (rc2||rc1||rc0) 0 0\n]\n```\n\nThe round constants are combined with the state, respecting array positioning, using bitwise\nexclusive-or. The values of the (rc5, rc4, rc3, rc2, rc1, rc0) constants for each round are given in\nthe Appendix.\n\n```cryptol\nAddConstants : State -> [8] -> [6] -> State\nAddConstants state ks rc = state ^ cs\n    where\n        [ks7, ks6, ks5, ks4, ks3, ks2, ks1, ks0] = split ks\n        [rc5, rc4, rc3, rc2, rc1, rc0] = split rc\n        cs = [ [ 0 ^ (ks7 # ks6 # ks5 # ks4), (0 # rc5 # rc4 # rc3), 0, 0]\n             , [ 1 ^ (ks7 # ks6 # ks5 # ks4), (0 # rc2 # rc1 # rc0), 0, 0]\n             , [ 2 ^ (ks3 # ks2 # ks1 # ks0), (0 # rc5 # rc4 # rc3), 0, 0]\n             , [ 3 ^ (ks3 # ks2 # ks1 # ks0), (0 # rc2 # rc1 # rc0), 0, 0]\n             ]\n\n\/\/ Inverse required for decryption and backwards compatibility\nproperty AddConstantsInverts state ks rc = AddConstants (AddConstants state ks rc) ks rc == state\n```\n\n`SubCells`. Each nibble in the array STATE is replaced by the nibble generated after using the\nPRESENT Sbox.\n\n```cryptol\nSubCells : State -> State\nSubCells state = state'\n    where\n        state' = [ [ Sbox@b | b <- row ] | row <- state ]\n\n\/\/ Required for LED decryption\nSubCells' : State -> State\nSubCells' state = state'\n    where\n        state' = [ [ Sbox'@b | b <- row ] | row <- state ]\n\nproperty SubCellsInverts state = SubCells' (SubCells state) == state\n```\n\n`ShiftRow`. Row *i* of the array STATE is rotated *i* cell positions to the left, for *i* = 0,1,2,3\n\n```cryptol\nShiftRow : State -> State\nShiftRow state = state'\n    where\n        state' = [ row <<< i | i <- [0,1,2,3] | row <- state ]\n\n\/\/ Required for LED decryption\nShiftRow' : State -> State\nShiftRow' state = state'\n    where\n        state' = [ row >>> i | i <- [0,1,2,3] | row <- state ]\n\nproperty ShiftRowInverts state = ShiftRow' (ShiftRow state) == state\n```\n\n`MixColumnsSerial`. Each column of the array STATE is viewed as a column vector and replaced by the\ncolumn vector that results after post-multiplying the vector by the matrix *M* (see earlier\ndescription in this section).\n\n```cryptol\nMixColumnsSerial : State -> State\nMixColumnsSerial state = transpose [ gf24VectorMult row M\n                                   | row <- state'\n                                   ]\n    where\n        state' = transpose state\n\n\/\/ Required for decryption\nMixColumnsSerial' : State -> State\nMixColumnsSerial' state = transpose [ gf24VectorMult row M'\n                                    | row <- state'\n                                    ]\n    where\n        state' = transpose state\n\nproperty MixColumnsSerialInverts state = MixColumnsSerial' (MixColumnsSerial state) == state\n```\n\nThe final value of the STATE provides the ciphertext with nibbles of the \"array\" being unpacked in\nthe obvious way. Test vectors for LED are provided in the Appendix.\n\n## Appendix\n\n`Round constants`. The generating methods of the round constants have been described in Section 2.1.\nBelow are the list of (rc5, rc4, rc3, rc2, rc1, rc0) encoded to byte values for each round, with rc0\nbeing the least significant bit.\n\n| Rounds | Constants |\n| --- | --- |\n|  1-24 | 01,03,07,0F,1F,3E,3D,3B,37,2F,1E,3C,39,33,27,0E,1D,3A,35,2B,16,2C,18,30 |\n| 25-48 | 21,02,05,0B,17,2E,1C,38,31,23,06,0D,1B,36,2D,1A,34,29,12,24,08,11,22,04 |\n\n```cryptol\nrcs : [48][6]\nrcs = map drop [ 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3E\n               , 0x3D, 0x3B, 0x37, 0x2F, 0x1E, 0x3C\n               , 0x39, 0x33, 0x27, 0x0E, 0x1D, 0x3A\n               , 0x35, 0x2B, 0x16, 0x2C, 0x18, 0x30\n               , 0x21, 0x02, 0x05, 0x0B, 0x17, 0x2E\n               , 0x1C, 0x38, 0x31, 0x23, 0x06, 0x0D\n               , 0x1B, 0x36, 0x2D, 0x1A, 0x34, 0x29\n               , 0x12, 0x24, 0x08, 0x11, 0x22, 0x04\n               ] : [48][6]\n```\n\n`Test vectors`. Test vectors for LED with 64-bit and 128-bit key arrays are given below. More test\nvectors are provided at https:\/\/sites.google.com\/site\/ledblockcipher\/.\n\n```cryptol\nproperty led64_1 = ledEncrypt64 (key, pt) == ct\n    where\n        pt  = 0x0000000000000000\n        key = 0x0000000000000000\n        ct  = 0x39C2401003A0C798\n\nproperty led64_2 = ledEncrypt64 (key, pt) == ct\n    where\n        pt  = 0x0123456789ABCDEF\n        key = 0x0123456789ABCDEF\n        ct  = 0xA003551E3893FC58\n\nproperty led128_1 = ledEncrypt128 (key, pt) == ct\n    where\n        pt  = 0x0000000000000000\n        key = 0x00000000000000000000000000000000\n        ct  = 0x3DECB2A0850CDBA1\n\nproperty led128_2 = ledEncrypt128 (key, pt) == ct\n    where\n        pt  = 0x0123456789ABCDEF\n        key = 0x0123456789ABCDEF0123456789ABCDEF\n        ct  = 0xD6B824587F014FC2\n```\n\n## Backwards Compatibility\n\nThe following functionality has been included to maintain backwards compatibility.\n\n```cryptol\n\/\/ Helper to run the experiments\n\nledEncrypt64' : ([64], [64]) -> [64]\nledEncrypt64' (key, ct) = decrypt`{8} key ct\n\nledEncrypt128' : ([128], [64]) -> [64]\nledEncrypt128' (key, ct) = decrypt`{12} key ct\n\nproperty encryptDecrypt64 key pt = ledEncrypt64' (key, ct) == pt\n    where\n        ct = ledEncrypt64 (key, pt)\n\nproperty encryptDecrypt128 key pt = ledEncrypt128' (key, ct) == pt\n    where\n        ct = ledEncrypt128 (key, pt)","variant":null,"set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/PRINCE.md","filetype":"txt","content":"# PRINCE - A Low-latency Block Cipher for Pervasive Computing Applications\n\n## Introduction\n\nAll text in this document is directly from the\n[PRINCE Specification](https:\/\/eprint.iacr.org\/2012\/529.pdf).\n\n```cryptol\nmodule Primitive::Symmetric::Cipher::Block::PRINCE where\n```\n\n## 2 Cipher Description\n\nPRINCE is a 64-bit block cipher with a 128-bit key.\n\n```cryptol\ntype PrinceBlock = [64]\ntype PrinceKey   = [128]\ntype PrinceKeyPt = [64]\n```\n\nThe key is split into two parts of 64 bits each,\n\n```example\nk = k0||k1\n```\n\nand extended to 192 bits by the mapping\n\n```cryptol\nkeyExtend : PrinceKey -> [3]PrinceKeyPt\nkeyExtend k = [k0, k0', k1]\n    where\n        k0' = (k0 >>> 1) ^ (k0 >> 63)\n        [k0, k1] = groupBy`{64} k\n```\n\nPRINCE is based on the so-called *FX* construction [7,30]: the first two subkeys k0 and k0' are used\nas whitening keys, while the key k1 is the 64-bit key for a 12-round block cipher we refer to as\nPRINCE_core. We provide test vectors in Appendix A.\n\n```cryptol\nPRINCE : PrinceKey -> PrinceBlock -> PrinceBlock\nPRINCE k m = m' ^ k0'\n    where\n        [k0, k0', k1] = keyExtend k\n        m' = PRINCE_core k1 (m ^ k0)\n```\n\n### Specification of PRINCE_core\n\nThe whole encryption process of PRINCE_core is depicted below.\n\n```cryptol\nPRINCE_core : PrinceKeyPt -> PrinceBlock -> PrinceBlock\nPRINCE_core k1 pt = c6 ^ k1\n    where\n        c1 = pt ^ k1\n        c2 = (RC@0) ^ c1\n        cs = [c2] # [ round c k1 i | c <- cs | i <- [1..5] ]\n        c3 = S (last cs)\n        c4 = M' c3\n        c5 = SInv c4\n        cs' = [c5] # [ round' c k1 i | c <- cs' | i <- [6..10] ]\n        c6 = (RC@11) ^ (last cs')\n\nPRINCE_core' : PrinceKeyPt -> PrinceBlock -> PrinceBlock\nPRINCE_core' k1 ct = c1 ^ k1\n    where\n        c6 = ct ^ k1\n        c5 = (RC@11) ^ c6\n        cs' = [c5] # [ round c k1 i | c <- cs' | i <- reverse [6..10] ]\n        c4 = S (last cs')\n        c3 = M' c4\n        c2 = SInv c3\n        cs = [c2] # [ round' c k1 i | c <- cs | i <- reverse [1..5] ]\n        c1 = (RC@0) ^ (last cs)\n\nproperty PRINCE_coreInverts k1 pt = PRINCE_core' k1 (PRINCE_core k1 pt) == pt\n\nround : PrinceBlock -> PrinceKeyPt -> [8] -> PrinceBlock\nround state k1 i = kiAdd stateR k1\n    where\n        stateS = S state\n        stateM = M stateS\n        stateR = (RC@i) ^ stateM\n\nround' : PrinceBlock -> PrinceKeyPt -> [8] -> PrinceBlock\nround' state k1 i = SInv stateM'\n    where\n        stateK  = kiAdd state k1\n        stateR  = (RC@i) ^ stateK\n        stateM' = MInv stateR\n\nproperty roundInverts state k1 = state == state''\n    where\n        state' = round state k1 1\n        state'' = round' state' k1 1\n```\n\nEach round of PRINCE_core consists of a key addition, an Sbox-layer, a linear layer, and the addition\nof a round constant.\n\n**k_i-add**. Here the 64-bit state is xor-ed with the 64-bit subkey.\n\n```cryptol\nkiAdd : PrinceBlock -> PrinceKeyPt -> PrinceBlock\nkiAdd state k1 = state ^ k1\n```\n\n**S-Layer**. The cipher uses one 4-bit Sbox. The action of the Sbox in hexadecimal notation is given\nby the following table.\n\n|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |\n| - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |\n| x | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |\n| x | B | F | 3 | 2 | A | C | 9 | 1 | 6 | 7 | 8 | 0 | E | 5 | D | 4 |\n\n```cryptol\nsbox : [16][4]\nsbox = [ 0xb, 0xf, 0x3, 0x2\n       , 0xa, 0xc, 0x9, 0x1\n       , 0x6, 0x7, 0x8, 0x0\n       , 0xe, 0x5, 0xd, 0x4 ]\n\nsbox' : [16][4]\nsbox' = [ 0xb, 0x7, 0x3, 0x2\n        , 0xf, 0xd, 0x8, 0x9\n        , 0xa, 0x6, 0x4, 0x0\n        , 0x5, 0xe, 0xc, 0x1 ]\n\nS : PrinceBlock -> PrinceBlock\nS m = join s\n    where\n        m' = groupBy`{4} m\n        s = [ sbox@x | x <- m' ]\n\nSInv : PrinceBlock -> PrinceBlock\nSInv m = join s\n    where\n        m' = groupBy`{4} m\n        s = [ sbox'@x | x <- m' ]\n\nproperty SInverts m = SInv (S m) == m\n```\n\n**The Matrices: M\/M'-layer**. In the M and M' layer the 64-bit state is multiplied with a 64x64\nmatrix *M* (resp. *M'*) defined in Section 3.3.\n\n```cryptol\nMultiply : PrinceBlock -> [4][4][4][4][4] -> PrinceBlock\nMultiply input Ms = join (join out)\n    where\n        input' = split (split input) : [4][4][4]\n        out = [ [ MultiplyBlock in ms' | ms' <- ms ] | in <- input' | ms <- Ms ]\n\nMultiplyBlock : [4][4] -> [4][4][4] -> [4]\nMultiplyBlock in ms = join out\n    where\n        in' = transpose in\n        out = [ SingleMultiply xx mm | xx <- in' | mm <- ms ]\n\nSingleMultiply : [4] -> [4][4] -> [1]\nSingleMultiply xx mm = foldl (^) zero xm'\n    where\n        xm = [ (groupBy`{1} xx * groupBy`{1} mm0) | mm0 <- mm ]\n        xm' = foldl (+) zero xm\n```\n\n**RC_i-add**. In the RC_*i* add step a 64-bit round constant is xor-ed with the state. We define the\nconstants used below (in hex notation)\n\n```cryptol\nRC : [12][64]\nRC = [ 0x0000000000000000\n     , 0x13198a2e03707344\n     , 0xa4093822299f31d0\n     , 0x082efa98ec4e6c89\n     , 0x452821e638d01377\n     , 0xbe5466cf34e90c6c\n     , 0x7ef84f78fd955cb1\n     , 0x85840851f1ac43aa\n     , 0xc882d32f25323c54\n     , 0x64a51195e0e3610d\n     , 0xd3b5a399ca0c2399\n     , 0xc0ac29b7c97c50dd\n     ]\n```\n\nNote that, for all 0 <= i <= 11, `RC_i \u2295 RC_(11-i)` is the constant `\u03b1 = c0ac29b7c97c50dd`,\n`RC_0 = 0` and that RC_i, ..., RC_5 and `\u03b1` are derived from the fraction part of `\u03c0 = 3.141...`.\n\n```cryptol\nproperty note1 = and [ (RC@i) ^ (RC@(11 - i)) == 0xc0ac29b7c97c50dd\n                     | i <- [0..11] ]\n```\n\nFrom the fact that the round constants satisfy `RC_i \u2295 RC_(11-i) = \u03b1` and that M' is an involution,\nwe deduce that the core cipher is such that the inverse of PRINCE_core parameterized with `k` is\nequal to PRINCE_core parameterize with (`k \u2295 \u03b1`). We call this property of PRINCE_core the\n`\u03b1-reflection property`. It follows that, for any expanded key `(k0||k0'||k1)`,\n\n```cryptol\nproperty aReflection k m = PRINCE_core' k m == PRINCE_core (k ^ a) m\n    where\n        a = 0xc0ac29b7c97c50dd\n\nencrypt : PrinceKey -> PrinceBlock -> PrinceBlock\nencrypt k pt =  ct ^ k0'\n    where\n        [k0, k0', k1] = keyExtend k\n        ct = PRINCE_core k1 (pt ^ k0)\n\ndecrypt : PrinceKey -> PrinceBlock -> PrinceBlock\ndecrypt k ct = pt ^ k0'\n    where\n        [k0', k0, k1] = keyExtend k\n        a  = 0xc0ac29b7c97c50dd\n        pt = PRINCE_core (k1 ^ a) (ct ^ k0)\n\nproperty EncryptDecrypt k pt = decrypt k (encrypt k pt) == pt\n```\n\nwhere `\u03b1` is the 64-bit constant `\u03b1=c0ac29b7c97c50dd`. Thus, for decryption one only has to do a\nvery cheap change to the master key and afterwards reused the exact same circuit.\n\n## 3 Design Decisions\n\n### 3.3 The Linear Layer\n\nIn the *M* and *M'*-layer the 64-bit state is multiplied with a 64 x 64 matrix *M* (resp. *M'*)\ndefined below. We have different requirements for the two different linear layers. The *M'*-layer is\nonly used in the middle round, thus *M'* has to be an involution to ensure the `\u03b1`-reflection\nproperty. This requirement does not apply for the *M*-layer used in the round functions. Here we\nwant to ensure full diffusion after two rounds. To achieve this we combine the *M'*-mapping with an\napplication of matrix *S R* which behaves like the AES shift rows and permutes the 16 nibbles in\nthe following way\n\n```example\n|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15| --> |0|5|10|15|4|9|14|3|8|13|2|7|12|1|6|11|\n```\n\n```cryptol\nSR : [16][4]\nSR = [ 0x0, 0x5, 0xa, 0xf\n     , 0x4, 0x9, 0xe, 0x3\n     , 0x8, 0xd, 0x2, 0x7\n     , 0xc, 0x1, 0x6, 0xb\n     ]\n\nSR' : [16][4]\nSR' = [ 0x0, 0xd, 0xa, 0x7\n      , 0x4, 0x1, 0xe, 0xb\n      , 0x8, 0x5, 0x2, 0xf\n      , 0xc, 0x9, 0x6, 0x3\n      ]\n```\n\nThus `M = SR \u25e6 M'`.\n\n```cryptol\nM : PrinceBlock -> PrinceBlock\nM input = join shifted\n    where\n        output  = Multiply input M'Matrix\n        output' = groupBy`{4} output\n        shifted = [ output'@sr | sr <- SR ]\n\nMInv : PrinceBlock -> PrinceBlock\nMInv input = output\n    where\n        input' = groupBy`{4} input\n        shifted = [ input'@sr | sr <- SR' ]\n        output  = Multiply (join shifted) M'Matrix\n```\n\nAdditionally the implementation costs should be minimized, meaning that the number of ones in the\nmatrices *M'* and *M* should be minimal, while at the same time it should be guaranteed that at\nleast 16 Sboxes are active in 4 consecutive rounds (cf. Appendix C.1 for details). Thus, trivially\neach output bit of an Sbox has to influence 3 Sboxes in the next round and therefore the minimum\nnumber of ones per row and column is 3. Thus we can use the following four 4 x 4 matrices as\nbuilding blocks for the *M'*-layer.\n\n```cryptol\nm0 : [4][4]\nm0 = [ 0b0000\n     , 0b0100\n     , 0b0010\n     , 0b0001\n     ]\n\nm1 : [4][4]\nm1 = [ 0b1000\n     , 0b0000\n     , 0b0010\n     , 0b0001\n     ]\n\nm2 : [4][4]\nm2 = [ 0b1000\n     , 0b0100\n     , 0b0000\n     , 0b0001\n     ]\n\nm3 : [4][4]\nm3 = [ 0b1000\n     , 0b0100\n     , 0b0010\n     , 0b0000\n     ]\n```\n\nIn the next step we generate a 4 x 4 block matrix M^ where each row and column in a permutation of\nthe four 4 x 4 matrices M0, ..., M3. The row permutations are chosen such that we obtain a symmetric\nblock matrix. The choice of the building blocks and the symmetric structure ensures that the\nresulting 16 x 16 matrix is an involution. We define\n\n```cryptol\nM0 : [4][4][4][4]\nM0 = [ [ m0, m1, m2, m3 ]\n     , [ m1, m2, m3, m0 ]\n     , [ m2, m3, m0, m1 ]\n     , [ m3, m0, m1, m2 ]\n     ]\n\nM0' : [4][4][4][4]\nM0' = reverse (M0 <<< 1)\n\nM1 : [4][4][4][4]\nM1 = [ [ m1, m2, m3, m0 ]\n     , [ m2, m3, m0, m1 ]\n     , [ m3, m0, m1, m2 ]\n     , [ m0, m1, m2, m3 ]\n     ]\n\nM1' : [4][4][4][4]\nM1' = reverse (M1 >>> 1)\n```\n\nIn order to obtain a permutation for the full 64-bit state, we construct a 64 x 64 block diagonal\nmatrix *M'* with (M0, M1, M1, M0) as diagonal blocks. The matrix *M'* is an involution with 2^32\nfixed points, which is average for a randomly chosen involution. The linear layer *M* is not an\ninvolution anymore due to the composition of *M'* and shift rows, which is not an involution.\n\n```cryptol\nM'Matrix : [4][4][4][4][4]\nM'Matrix = [ M0', M1', M1', M0' ]\n\nM' : PrinceBlock -> PrinceBlock\nM' input = Multiply input M'Matrix\n\nproperty M'Involutes input = M' (M' input) == input\n```\n\n### 3.4 The Key Expansion\n\nThe 128-bit key `(k0||k1)` is extended to a 192-bit key\n\n## Appendix\n\n### A Test Vectors\n\n| plaintext | k0 | k1 | ciphertext |\n| --------- | -- | -- | ---------- |\n| 0x0000000000000000 | 0x0000000000000000 | 0x0000000000000000 | 0x818665aa0d02dfda |\n| 0xffffffffffffffff | 0x0000000000000000 | 0x0000000000000000 | 0x604ae6ca03c20ada |\n| 0x0000000000000000 | 0xffffffffffffffff | 0x0000000000000000 | 0x9fb51935fc3df524 |\n| 0x0000000000000000 | 0x0000000000000000 | 0xffffffffffffffff | 0x78a54cbe737bb7ef |\n| 0x0123456789abcdef | 0x0000000000000000 | 0xfedcba9876543210 | 0xae25ad3ca8fa9ccf |\n\n```cryptol\nproperty testsPass = test1 \/\\ test2 \/\\ test3 \/\\ test4 \/\\ test5\n\ntest1 = PRINCE (k0 # k1) pt == ct\n    where\n        pt = 0x0000000000000000\n        k0 = 0x0000000000000000\n        k1 = 0x0000000000000000\n        ct = 0x818665aa0d02dfda\n\ntest2 = PRINCE (k0 # k1) pt == ct\n    where\n        pt = 0xffffffffffffffff\n        k0 = 0x0000000000000000\n        k1 = 0x0000000000000000\n        ct = 0x604ae6ca03c20ada\n\ntest3 = PRINCE (k0 # k1) pt == ct\n    where\n        pt = 0x0000000000000000\n        k0 = 0xffffffffffffffff\n        k1 = 0x0000000000000000\n        ct = 0x9fb51935fc3df524\n\ntest4 = PRINCE (k0 # k1) pt == ct\n    where\n        pt = 0x0000000000000000\n        k0 = 0x0000000000000000\n        k1 = 0xffffffffffffffff\n        ct = 0x78a54cbe737bb7ef\n\ntest5 = PRINCE (k0 # k1) pt == ct\n    where\n        pt = 0x0123456789abcdef\n        k0 = 0x0000000000000000\n        k1 = 0xfedcba9876543210\n        ct = 0xae25ad3ca8fa9ccf\n```\n\n### B All Sboxes for the PRINCE-Family Up To Equivalence\n\nIn Table 3 we list all Sboxes for the PRINCE-Family, up to affine equivalence. Note that `S0` is\nequivalent to the inverse function `F16` and the Sbox of PRINCE defined in Section 2 is equivalent\nto S7.\n\n| | |\n| -- | -- |\n| S0 | 0x0, 0x1, 0x2, 0xD, 0x4, 0x7, 0xF, 0x6, 0x8, 0xC, 0x5, 0x3, 0xA, 0xE, 0xB, 0x9 |\n| S1 | 0x0, 0x1, 0x2, 0xD, 0x4, 0x7, 0xF, 0x6, 0x8, 0xC, 0x9, 0xB, 0xA, 0xE, 0x5, 0x3 |\n| S2 | 0x0, 0x1, 0x2, 0xD, 0x4, 0x7, 0xF, 0x6, 0x8, 0xC, 0xB, 0x9, 0xA, 0xE, 0x3, 0x5 |\n| S3 | 0x0, 0x1, 0x2, 0xD, 0x4, 0x7, 0xF, 0x6, 0x8, 0xC, 0xB, 0x9, 0xA, 0xE, 0x5, 0x3 |\n| S4 | 0x0, 0x1, 0x2, 0xD, 0x4, 0x7, 0xF, 0x6, 0x8, 0xC, 0xE, 0xB, 0xA, 0x9, 0x3, 0x5 |\n| S5 | 0x0, 0x1, 0x2, 0xD, 0x4, 0x7, 0xF, 0x6, 0x8, 0xE, 0xB, 0xA, 0x5, 0x9, 0xC, 0x3 |\n| S6 | 0x0, 0x1, 0x2, 0xD, 0x4, 0x7, 0xF, 0x6, 0x8, 0xE, 0xB, 0xA, 0x9, 0x3, 0xC, 0x5 |\n| S7 | 0x0, 0x1, 0x2, 0xD, 0x4, 0x7, 0xF, 0x6, 0x8, 0xE, 0xC, 0x9, 0x5, 0xB, 0xA, 0x3 |\n\n## Backwards Compatibility\n\nThe following cryptol methods are defined to maintain backwards compatibility with previous\nimplementations of the PRINCE algorithms.\n\n```cryptol\ntype princeBlockSize = 64\ntype princeKeySize = 128\n\nprinceEncrypt : ([princeKeySize], [princeBlockSize]) -> [princeBlockSize]\nprinceEncrypt (key, pt) = encrypt key pt\n\nprinceDecrypt : ([princeKeySize], [princeBlockSize]) -> [princeBlockSize]\nprinceDecrypt (key, ct) = decrypt key ct\n\nprinceEncrypt64 : ([princeBlockSize], [princeBlockSize]) -> [princeBlockSize]\nprinceEncrypt64 (key, pt) = encrypt (key # zero) pt\n\nprinceDecrypt64 : ([princeBlockSize], [princeBlockSize]) -> [princeBlockSize]\nprinceDecrypt64 (key, ct) = decrypt (key # zero) ct\n\nproperty princeCorrectPrime key m = princeDecrypt64 (key, princeEncrypt64 (key, m)) == m\n\nprinceEncrypt128 : ([princeKeySize], [princeKeySize]) -> [princeKeySize]\nprinceEncrypt128 (key, pt) = (encrypt key (take`{64} pt)) # zero","variant":null,"set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/ChaChaPolyCryptolIETF.md","filetype":"txt","content":"## Abstract\n\nThis document defines the ChaCha20 stream cipher, as well as the use\nof the Poly1305 authenticator, both as stand-alone algorithms, and as\na \"combined mode\", or Authenticated Encryption with Additional Data\n(AEAD) algorithm.\n\nThis document does not introduce any new crypto, but is meant to\nserve as a stable reference and an implementation guide.\n\nThis version of the document is a translation of the IETF draft document\ndraft-irtf-cfrg-chacha20-poly1305 into \"literate Cryptol\".\nThis document can be loaded and executed by a Cryptol interpreter.\nThere is an open source implementation of Cryptol available at http:\/\/cryptol.net\n\n# Introduction\n\nThe Advanced Encryption Standard (AES - [FIPS-197]) has become the\ngold standard in encryption.  Its efficient design, wide\nimplementation, and hardware support allow for high performance in\nmany areas.  On most modern platforms, AES is anywhere from 4x to 10x\nas fast as the previous most-used cipher, 3-key Data Encryption\nStandard (3DES - [FIPS-46]), which makes it not only the best choice,\nbut the only practical choice.\n\nThe problem is that if future advances in cryptanalysis reveal a\nweakness in AES, users will be in an unenviable position.  With the\nonly other widely supported cipher being the much slower 3DES, it is\nnot feasible to re-configure implementations to use 3DES.\n[standby-cipher] describes this issue and the need for a standby\ncipher in greater detail.\n\nThis document defines such a standby cipher.  We use ChaCha20\n([chacha]) with or without the Poly1305 ([poly1305]) authenticator.\nThese algorithms are not just fast.  They are fast even in software-\nonly C-language implementations, allowing for much quicker deployment\nwhen compared with algorithms such as AES that are significantly\naccelerated by hardware implementations.\n\nThis document does not introduce these new algorithms.  They have\nbeen defined in scientific papers by D. J. Bernstein, which are\nreferenced by this document.  The purpose of this document is to\nserve as a stable reference for IETF documents making use of these\nalgorithms.\n\nThese algorithms have undergone rigorous analysis.  Several papers\ndiscuss the security of Salsa and ChaCha ([LatinDances],\n[Zhenqing2012]).\n\n## Conventions Used in This Document\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\ndocument are to be interpreted as described in [RFC2119].\n\nThe description of the ChaCha algorithm will at various time refer to\nthe ChaCha state as a \"vector\" or as a \"matrix\".  This follows the\nuse of these terms in DJB's paper.  The matrix notation is more\nvisually convenient, and gives a better notion as to why some rounds\nare called \"column rounds\" while others are called \"diagonal rounds\".\nHere's a diagram of how matrices relate to vectors (using the C\nlanguage convention of zero being the index origin).\n\n```example\n    0 , 1 ,  2 ,  3,\n    4 , 5 ,  6 ,  7,\n    8 , 9 ,  10,  11,\n    12, 13,  14,  15\n```\n\nThe elements in this vector or matrix are 32-bit unsigned integers.\n\n```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::ChaChaPolyCryptolIETF where\n\nimport Common::OptionUtils\n\ntype ChaChaState = [16][32]\n```\n\nThe algorithm name is \"ChaCha\".  \"ChaCha20\" is a specific instance where\n20 \"rounds\" (or 80 quarter rounds - see \"The ChaCha Quarter Round\", below)\nare used.  Other variations are defined, with 8 or 12 rounds, but in this\ndocument we only describe the 20-round ChaCha, so the names \"ChaCha\"\nand \"ChaCha20\" will be used interchangeably.\n\n# The Algorithms\n\nThe subsections below describe the algorithms used and the AEAD\nconstruction.\n\n## The ChaCha Quarter Round\n\nThe basic operation of the ChaCha algorithm is the quarter round.  It\noperates on four 32-bit unsigned integers, denoted a, b, c, and d.\nThe operation is as follows:\n\n```cryptol\nChaChaQuarterround : [4][32] -> [4][32]\nChaChaQuarterround [a, b, c, d] = [a'', b'', c'', d''] where\n    a' = a + b\n    d' = (d ^ a') <<< 16\n    c' = c + d'\n    b' = (b ^ c') <<< 12\n    a'' = a' + b'\n    d'' = (d' ^ a'') <<< 8\n    c'' = c' + d''\n    b'' = (b' ^ c'') <<< 7\n```\n\nWhere \"+\" denotes integer addition without carry, \"^\" denotes a\nbitwise XOR, and \"<<< n\" denotes an n-bit left rotation (towards the\nhigh bits).\n\nFor example, let's see the add, XOR and roll operations from the\nfirst two lines with sample numbers:\n\n *  b = 0x01020304\n *  a = 0x11111111\n *  d = 0x01234567\n *  a = a + b = 0x11111111 + 0x01020304 = 0x12131415\n *  d = d ^ a = 0x01234567 ^ 0x12131415 = 0x13305172\n *  d = d<<<16 = 0x51721330\n\n### Test Vector for the ChaCha Quarter Round\n\nFor a test vector, we will use the same numbers as in the example,\nadding something random for c.\n\nAfter running a Quarter Round on these 4 numbers, we get these:\n\n```cryptol\nproperty ChaChaQuarterround_passes_test =\n    ChaChaQuarterround [ 0x11111111 \/\/ a\n                       , 0x01020304 \/\/ b\n                       , 0x9b8d6f43 \/\/ c\n                       , 0x01234567 \/\/ d\n                       ]\n    ==\n                       [ 0xea2a92f4\n                       , 0xcb1cf8ce\n                       , 0x4581472e\n                       , 0x5881c4bb\n                       ]\n```\n\n## A Quarter Round on the ChaCha State\n\nThe ChaCha state does not have 4 integer numbers, but 16.  So the\nquarter round operation works on only 4 of them - hence the name.\nEach quarter round operates on 4 pre-determined numbers in the ChaCha\nstate.  We will denote by QUATERROUND(x,y,z,w) a quarter-round\noperation on the numbers at indexes x, y, z, and w of the ChaCha\nstate when viewed as a vector.  For example, if we apply\nQUARTERROUND(1,5,9,13) to a state, this means running the quarter\nround operation on the elements marked with an asterisk, while\nleaving the others alone:\n\n```example\n0   *a   2   3\n4   *b   6   7\n8   *c  10  11\n12  *d  14  15\n```\n\nNote that this run of quarter round is part of what is called a\n\"column round\".\n\n### Test Vector for the Quarter Round on the ChaCha state\n\nFor a test vector, we will use a ChaCha state that was generated\nrandomly:\n\nSample ChaCha State\n\n```example\n   879531e0  c5ecf37d  516461b1  c9a62f8a\n   44c20ef3  3390af7f  d9fc690b  2a5f714c\n   53372767  b00a5631  974c541a  359e9963\n   5c971061  3d631689  2098d9d6  91dbd320\n```\nWe will apply the QUARTERROUND(2,7,8,13) operation to this state.\nFor obvious reasons, this one is part of what is called a \"diagonal\nround\":\n\nAfter applying QUARTERROUND(2,7,8,13)\n\n```example\n   879531e0  c5ecf37d  bdb886dc  c9a62f8a\n   44c20ef3  3390af7f  d9fc690b  cfacafd2\n   e46bea80  b00a5631  974c541a  359e9963\n   5c971061  ccc07c79  2098d9d6  91dbd320\n```\n\nNote that only the numbers in positions 2, 7, 8, and 13 changed.\n\nIn the Cryptol implementation of ChaCha20, the ChaChaQuarterround is called on four elements at a time,\nand there is no destructive state modification, so it would be artificial to reproduce the\nabove example of the partially-destructively modified matrix. Instead, we show the output of\ncalling ChaChaQuarterround on the diagonal elements identified above:\n\n```cryptol\nproperty ChaChaQuarterround_passes_column_test =\n    ChaChaQuarterround [ 0x516461b1 \/\/ a\n                       , 0x2a5f714c \/\/ b\n                       , 0x53372767 \/\/ c\n                       , 0x3d631689 \/\/ d\n                       ]\n    ==\n                       [ 0xbdb886dc\n                       , 0xcfacafd2\n                       , 0xe46bea80\n                       , 0xccc07c79\n                       ]\n```\n\n## The ChaCha20 block Function\n\nThe ChaCha block function transforms a ChaCha state by running\nmultiple quarter rounds.\n\nThe inputs to ChaCha20 are:\n\n * A 256-bit key, treated as a concatenation of 8 32-bit little-endian integers.\n * A 96-bit nonce, treated as a concatenation of 3 32-bit little-endian integers.\n * A 32-bit block count parameter, treated as a 32-bit little-endian integer.\n\nThe output is 64 random-looking bytes.\n\n```cryptol\nChaCha20Block : ChaChaKey -> [96] -> [32] -> ChaChaState\n```\n\nThe ChaCha algorithm described here uses a 256-bit key.  The original\nalgorithm also specified 128-bit keys and 8- and 12-round variants,\nbut these are out of scope for this document.  In this section we\ndescribe the ChaCha block function.\n\n```cryptol\ntype ChaChaKey = [256]\n```\n\nNote also that the original ChaCha had a 64-bit nonce and 64-bit\nblock count.  We have modified this here to be more consistent with\nrecommendations in section 3.2 of [RFC5116].  This limits the use of\na single (key,nonce) combination to 2^32 blocks, or 256 GB, but that\nis enough for most uses.  In cases where a single key is used by\nmultiple senders, it is important to make sure that they don't use\nthe same nonces.  This can be assured by partitioning the nonce space\nso that the first 32 bits are unique per sender, while the other 64\nbits come from a counter.\n\nThe ChaCha20 state is initialized as follows:\n\n * The first 4 words (0-3) are constants: 0x61707865, 0x3320646e,\n   0x79622d32, 0x6b206574.\n\n```cryptol\nFirstRow = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]\nproperty FirstRow_correct = groupBy`{8}(join [ littleendian (split w)\n                                             | w <- FirstRow ])\n                            == \"expand 32-byte k\"\n```\n\n * The next 8 words (4-11) are taken from the 256-bit key by\n   reading the bytes in little-endian order, in 4-byte chunks.\n\n```cryptol\nKeyToRows : ChaChaKey -> [8][32]\nKeyToRows key = [littleendian (split words) | words <- (split key)]\n```\n\n * Word 12 is a block counter.  Since each block is 64-byte,\n   a 32-bit word is enough for 256 Gigabytes of data.\n * Words 13-15 are a nonce, which should not be repeated for the same\n   key.  The 13th word is the first 32 bits of the input nonce taken\n   as a little-endian integer, while the 15th word is the last 32\n   bits.\n\n```verbatim\nInitial state structure:\n\ncccccccc  cccccccc  cccccccc  cccccccc\nkkkkkkkk  kkkkkkkk  kkkkkkkk  kkkkkkkk\nkkkkkkkk  kkkkkkkk  kkkkkkkk  kkkkkkkk\nbbbbbbbb  nnnnnnnn  nnnnnnnn  nnnnnnnn\n\nc=constant k=key b=blockcount n=nonce\n```\n\n```cryptol\nNonceToRow : [96] -> [32] -> [4][32]\nNonceToRow n i = [i] # [ littleendian (split words) | words <- groupBy`{32} n ]\n```\n\n```cryptol\nBuildState : ChaChaKey -> [96] -> [32] -> [16][32]\nBuildState key nonce i = split (join (FirstRow # KeyToRows key # NonceToRow nonce i))\n```\n\nChaCha20 runs 20 rounds, alternating between \"column\" and \"diagonal\"\nrounds.  Each round is 4 quarter-rounds, and they are run as follows.\nRounds 1-4 are part of the \"column\" round, while 5-8 are part of the\n\"diagonal\" round:\n\n```cryptol\ncolumns = [ 0, 4, 8,  12,   \/\/ round 1 - column round\n            1, 5, 9,  13,   \/\/ round 2\n            2, 6, 10, 14,   \/\/ round 3\n            3, 7, 11, 15 ]  \/\/ round 4\ndiags  = [ 0, 5, 10, 15,    \/\/ round 5 - diagonal round\n           1, 6, 11, 12,    \/\/ round 6\n           2, 7, 8,  13,    \/\/ round 7\n           3, 4, 9,  14 ]   \/\/ round 8\n```\n\nThe Cryptol pattern of using the `@@` operator on permutations of the indices of\nthe matrix creates a new matrix that consists of rows that correspond to the\nquarter-round calls. To restore the element-indices to their original ordering,\nafter each application we perform the inverse permutation. Since the column\nround is just a square matrix transposition, it inverts itself, but the\ndiagonal round needs to have an inverse permutation calculated, which we do\nhere:\n\n```cryptol\ninversePermutation (perms:[a+1]_) = [ indexOf i perms | i <- [ 0 .. a ] ]\ninvDiags = inversePermutation diags\ninvCols  = inversePermutation columns \/\/ which happens to be the same as columns\n\nChaChaTwoRounds (xs:ChaChaState) = xs'' where\n    xs'  =  join [ChaChaQuarterround x | x <- groupBy`{4}(xs@@columns) ] @@ invCols\n    xs'' = (join [ChaChaQuarterround x | x <- groupBy`{4}(xs'@@diags ) ]) @@ invDiags\n\nChaCha : ChaChaState -> [8] -> ChaChaState\nChaCha s n = chain@n where\n    chain = [s] # [ ChaChaTwoRounds ci | ci <- chain | i <- [0 .. 9] ]\n```\n\nAt the end of 20 rounds, the original input words are added to the\noutput words, and the result is serialized by sequencing the words\none-by-one in little-endian order.\n\n```cryptol\n\/\/ ChaCha20Block : ChaChaKey -> [96] -> [32] -> ChaChaState (repeated from above)\nChaCha20Block key nonce i = (ChaCha initialState 10) + initialState where\n    initialState = BuildState key nonce i\n```\n\n### Test Vector for the ChaCha20 Block Function\n\nFor a test vector, we will use the following inputs to the ChaCha20\nblock function:\n\n```cryptol\nTestKey : ChaChaKey\nTestKey = join (parseHexString\n    ( \"00:01:02:03:04:05:06:07:08:09:0a:0b:0c:0d:0e:0f:10:11:12:13:\" #\n      \"14:15:16:17:18:19:1a:1b:1c:1d:1e:1f.\") )\n```\n\nThe key is a sequence of octets with no particular structure before we copy it\ninto the ChaCha state.\n\n```cryptol\nTestNonce : [96]\nTestNonce = join (parseHexString \"00:00:00:09:00:00:00:4a:00:00:00:00.\")\n```\n\nAfter setting up the ChaCha state, it looks like this:\n\nChaCha State with the key set up.\n\n```cryptol\nTestState = BuildState TestKey TestNonce 1\n\nproperty BuildState_correct = TestState == [\n    0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,\n    0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,\n    0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c,\n    0x00000001, 0x09000000, 0x4a000000, 0x00000000 ]\n```\n\nAfter running 20 rounds (10 column rounds interleaved with 10\ndiagonal rounds), the ChaCha state looks like this:\n\nChaCha State after 20 rounds\n\n```cryptol\nChaCha20_state1 = [\n    0x837778ab, 0xe238d763,  0xa67ae21e,  0x5950bb2f,\n    0xc4f2d0c7, 0xfc62bb2f,  0x8fa018fc,  0x3f5ec7b7,\n    0x335271c2, 0xf29489f3,  0xeabda8fc,  0x82e46ebd,\n    0xd19c12b4, 0xb04e16de,  0x9e83d0cb,  0x4e3c50a2\n    ]\n\nproperty ChaChaStateAfter20_correct = ChaCha TestState 10 == ChaCha20_state1\n```\n\nFinally we add the original state to the result (simple vector or\nmatrix addition), giving this:\n\nChaCha State at the end of the ChaCha20 operation\n\n```cryptol\nChaCha20_block_1 = [\n    0xe4e7f110, 0x15593bd1, 0x1fdd0f50, 0xc47120a3,\n    0xc7f4d1c7, 0x0368c033, 0x9aaa2204, 0x4e6cd4c3,\n    0x466482d2, 0x09aa9f07, 0x05d7c214, 0xa2028bd9,\n    0xd19c12b5, 0xb94e16de, 0xe883d0cb, 0x4e3c50a2\n    ]\n\nproperty ChaCha20_test1 = ChaCha20Block TestKey TestNonce 1 == ChaCha20_block_1\n```\n\n## The ChaCha20 encryption algorithm\n\nChaCha20 is a stream cipher designed by D. J. Bernstein.  It is a\nrefinement of the Salsa20 algorithm, and uses a 256-bit key.\n\nChaCha20 successively calls the ChaCha20 block function, with the\nsame key and nonce, and with successively increasing block counter\nparameters.  ChaCha20 then serializes the resulting state by writing\nthe numbers in little-endian order, creating a key-stream block.\nConcatenating the key-stream blocks from the successive blocks forms\na key stream, which is then XOR-ed with the plaintext.\nAlternatively, each key-stream block can be XOR-ed with a plaintext\nblock before proceeding to create the next block, saving some memory.\n\nThere is no requirement for the plaintext to be an integral multiple\nof 512-bits.  If there is extra keystream from the last block, it is\ndiscarded.  Specific protocols MAY require that the plaintext and\nciphertext have certain length.  Such protocols need to specify how\nthe plaintext is padded, and how much padding it receives.\n\nThe inputs to ChaCha20 are:\n\n *   A 256-bit key\n *   A 32-bit initial counter.  This can be set to any number, but will\n     usually be zero or one.  It makes sense to use 1 if we use the\n     zero block for something else, such as generating a one-time\n     authenticator key as part of an AEAD algorithm.\n *   A 96-bit nonce.  In some protocols, this is known as the\n     Initialization Vector.\n *   an arbitrary-length plaintext\n\nThe output is an encrypted message of the same length.\n\n```cryptol\n\/\/ TODO: reorder args below, and get rid of this wrapper\nChaCha20Encrypt : {a} (fin a) => ChaChaKey -> [32] -> [96] -> [a][8] -> [a][8]\nChaCha20Encrypt k i n msg = ChaCha20EncryptBytes msg k n i\n\nChaCha20EncryptBytes msg k n i= [ m ^ kb | m <- msg | kb <- keystream ] where\n    keystream = groupBy`{8}(join (join (ChaCha20ExpandKey k n i)))\n\nChaCha20ExpandKey : ChaChaKey -> [96] -> [32] -> [inf]ChaChaState\nChaCha20ExpandKey k n i = [ ToLittleEndian (ChaCha20Block k n j)\n                          | j <- ([i ...]:[_][32])\n                          ]\n\n```\n\nDecryption is done in the same way.  The ChaCha20 block function is\nused to expand the key into a key stream, which is XOR-ed with the\nciphertext giving back the plaintext.\n\n```cryptol\nChaCha20DecryptBytes = ChaCha20EncryptBytes\n```\n\n### Example and Test Vector for the ChaCha20 Cipher\n\nFor a test vector, we will use the following inputs to the ChaCha20\nblock function:\n\n```cryptol\nSunscreen_Key = join (parseHexString\n    ( \"00:01:02:03:04:05:06:07:08:09:0a:0b:0c:0d:0e:0f:10:11:12:13:\"\n    # \"14:15:16:17:18:19:1a:1b:1c:1d:1e:1f.\"\n    ) )\n\nSunscreen_Nonce = join (parseHexString \"00:00:00:00:00:00:00:4a:00:00:00:00.\")\nSunscreen_Initial_Counter = 1\n```\n\nWe use the following for the plaintext.  It was chosen to be long\nenough to require more than one block, but not so long that it would\nmake this example cumbersome (so, less than 3 blocks):\n\nPlaintext Sunscreen:\n\n```cryptol\nPlaintext_Sunscreen = \"Ladies and Gentlemen of the class of '99: \" #\n                      \"If I could offer you only one tip for the \" #\n                      \"future, sunscreen would be it.\"\n```\n\nThe following figure shows 4 ChaCha state matrices:\n\n 1.  First block as it is set up.\n 1.  Second block as it is set up.  Note that these blocks are only\n        two bits apart - only the counter in position 12 is different.\n 1.  Third block is the first block after the ChaCha20 block\n        operation.\n 1.  Final block is the second block after the ChaCha20 block\n        operation was applied.\n\nAfter that, we show the keystream.\n\nFirst block setup:\n\n```cryptol\nSunscreen_State1 = [\n    0x61707865,  0x3320646e,  0x79622d32,  0x6b206574,\n    0x03020100,  0x07060504,  0x0b0a0908,  0x0f0e0d0c,\n    0x13121110,  0x17161514,  0x1b1a1918,  0x1f1e1d1c,\n    0x00000001,  0x00000000,  0x4a000000,  0x00000000\n    ]\n\nproperty SunscreenBuildState_correct =\n    BuildState Sunscreen_Key Sunscreen_Nonce 1 == Sunscreen_State1\n```\n\nSecond block setup:\n\n```cryptol\nSunscreen_State2 = [\n    0x61707865,  0x3320646e,  0x79622d32,  0x6b206574,\n    0x03020100,  0x07060504,  0x0b0a0908,  0x0f0e0d0c,\n    0x13121110,  0x17161514,  0x1b1a1918,  0x1f1e1d1c,\n    0x00000002,  0x00000000,  0x4a000000,  0x00000000\n    ]\n\nproperty SunscreenBuildState2_correct =\n    BuildState Sunscreen_Key Sunscreen_Nonce 2 == Sunscreen_State2\n```\n\nFirst block after block operation:\n\n```cryptol\nSunscreenAfterBlock1 = [\n    0xf3514f22, 0xe1d91b40, 0x6f27de2f, 0xed1d63b8,\n    0x821f138c, 0xe2062c3d, 0xecca4f7e, 0x78cff39e,\n    0xa30a3b8a, 0x920a6072, 0xcd7479b5, 0x34932bed,\n    0x40ba4c79, 0xcd343ec6, 0x4c2c21ea, 0xb7417df0\n    ]\n\nproperty SunscreenBlock1_correct =\n    ChaCha20Block Sunscreen_Key Sunscreen_Nonce 1 == SunscreenAfterBlock1\n```\n\nSecond block after block operation:\n\n```cryptol\nSunscreenAfterBlock2 = [\n    0x9f74a669, 0x410f633f, 0x28feca22, 0x7ec44dec,\n    0x6d34d426, 0x738cb970, 0x3ac5e9f3, 0x45590cc4,\n    0xda6e8b39, 0x892c831a, 0xcdea67c1, 0x2b7e1d90,\n    0x037463f3, 0xa11a2073, 0xe8bcfb88, 0xedc49139\n    ]\n\nproperty SunscreenBlock2_correct =\n    ChaCha20Block Sunscreen_Key Sunscreen_Nonce 2 == SunscreenAfterBlock2\n```\n\nKeystream:\n\n```cryptol\nSunscreenKeystream = (parseHexString\n    ( \"22:4f:51:f3:40:1b:d9:e1:2f:de:27:6f:b8:63:1d:ed:8c:13:1f:82:3d:2c:06:\"\n    # \"e2:7e:4f:ca:ec:9e:f3:cf:78:8a:3b:0a:a3:72:60:0a:92:b5:79:74:cd:ed:2b:\"\n    # \"93:34:79:4c:ba:40:c6:3e:34:cd:ea:21:2c:4c:f0:7d:41:b7:69:a6:74:9f:3f:\"\n    # \"63:0f:41:22:ca:fe:28:ec:4d:c4:7e:26:d4:34:6d:70:b9:8c:73:f3:e9:c5:3a:\"\n    # \"c4:0c:59:45:39:8b:6e:da:1a:83:2c:89:c1:67:ea:cd:90:1d:7e:2b:f3:63.\"\n    ) )\n\nSunscreenKeystream_correct (skref:[skwidth][8]) =\n    take`{skwidth}\n        (groupBy`{8} (join (join(ChaCha20ExpandKey\n                                    Sunscreen_Key Sunscreen_Nonce 1)))) == skref\n```\n\nFinally, we XOR the Keystream with the plaintext, yielding the Ciphertext:\n\n```cryptol\nCiphertext_Sunscreen =\n    [0x6e, 0x2e, 0x35, 0x9a, 0x25, 0x68, 0xf9, 0x80, 0x41, 0xba, 0x07,\n     0x28, 0xdd, 0x0d, 0x69, 0x81, 0xe9, 0x7e, 0x7a, 0xec, 0x1d, 0x43,\n     0x60, 0xc2, 0x0a, 0x27, 0xaf, 0xcc, 0xfd, 0x9f, 0xae, 0x0b, 0xf9,\n     0x1b, 0x65, 0xc5, 0x52, 0x47, 0x33, 0xab, 0x8f, 0x59, 0x3d, 0xab,\n     0xcd, 0x62, 0xb3, 0x57, 0x16, 0x39, 0xd6, 0x24, 0xe6, 0x51, 0x52,\n     0xab, 0x8f, 0x53, 0x0c, 0x35, 0x9f, 0x08, 0x61, 0xd8, 0x07, 0xca,\n     0x0d, 0xbf, 0x50, 0x0d, 0x6a, 0x61, 0x56, 0xa3, 0x8e, 0x08, 0x8a,\n     0x22, 0xb6, 0x5e, 0x52, 0xbc, 0x51, 0x4d, 0x16, 0xcc, 0xf8, 0x06,\n     0x81, 0x8c, 0xe9, 0x1a, 0xb7, 0x79, 0x37, 0x36, 0x5a, 0xf9, 0x0b,\n     0xbf, 0x74, 0xa3, 0x5b, 0xe6, 0xb4, 0x0b, 0x8e, 0xed, 0xf2, 0x78,\n     0x5e, 0x42, 0x87, 0x4d]\n\nproperty ChaCha_encrypt_sunscreen_correct =\n    ChaCha20EncryptBytes Plaintext_Sunscreen Sunscreen_Key Sunscreen_Nonce 1\n    == Ciphertext_Sunscreen\n\nproperty Sunscreen_decrypt_correct =\n    ChaCha20DecryptBytes Ciphertext_Sunscreen Sunscreen_Key Sunscreen_Nonce 1\n    == Plaintext_Sunscreen\n```\n\n# The Poly1305 algorithm\n\nPoly1305 is a one-time authenticator designed by D. J. Bernstein.\nPoly1305 takes a 32-byte one-time key and a message and produces a\n16-byte tag.\n\nThe original article ([poly1305]) is entitled \"The Poly1305-AES\nmessage-authentication code\", and the MAC function there requires a\n128-bit AES key, a 128-bit \"additional key\", and a 128-bit (non-\nsecret) nonce.  AES is used there for encrypting the nonce, so as to\nget a unique (and secret) 128-bit string, but as the paper states,\n\"There is nothing special about AES here.  One can replace AES with\nan arbitrary keyed function from an arbitrary set of nonces to 16-\nbyte strings.\"\n\nRegardless of how the key is generated, the key is partitioned into\ntwo parts, called \"r\" and \"s\".  The pair ``(r,s)`` should be unique, and\nMUST be unpredictable for each invocation (that is why it was\noriginally obtained by encrypting a nonce), while \"r\" MAY be\nconstant, but needs to be modified as follows before being used: (\"r\"\nis treated as a 16-octet little-endian number):\n\n *  r[3], r[7], r[11], and r[15] are required to have their top four\n    bits clear (be smaller than 16)\n\n```cryptol\nOm = 15 \/\/ odd masks - for 3, 7, 11 & 15\n```\n *  r[4], r[8], and r[12] are required to have their bottom two bits\n    clear (be divisible by 4)\n\nThe following Cryptol code clamps \"r\" to be appropriate:\n\n```cryptol\nEm = 252 \/\/ even masks - for 4, 8 & 12\nnm = 255 \/\/ no mask\n\nPolyMasks : [16][8]            \/\/ mask indices\nPolyMasks = [ nm, nm, nm, Om,  \/\/ 0-3\n              Em, nm, nm, Om,  \/\/ 4-7\n              Em, nm, nm, Om,  \/\/ 8-11\n              Em, nm, nm, Om ] \/\/ 12-15\n\nPoly1305_clamp : [16][8] -> [16][8]\nPoly1305_clamp r = [ re && mask | re <- r | mask <- PolyMasks ]\n```\n\nThe \"s\" should be unpredictable, but it is perfectly acceptable to\ngenerate both \"r\" and \"s\" uniquely each time.  Because each of them\nis 128-bit, pseudo-randomly generating them (see \"Generating the\nPoly1305 key using ChaCha20\") is also acceptable.\n\nThe inputs to Poly1305 are:\n\n *  A 256-bit one-time key\n *  An arbitrary length message (comprised of `floorBlocks` 16-byte blocks,\n    and `rem` bytes left over)\n\nThe output is a 128-bit tag.\n\n```cryptol\nPoly1305 : {m} (fin m)\n           => [256] -> [m][8] -> [16][8]\n```\n\nSet the constant prime \"P\" be 2^130-5.\n\n```cryptol\nP : [136]\nP = 2^^130 - 5\n```\n\nFirst, the \"r\" value should be clamped.\n\n```cryptol\nPoly1305 key msg = result where\n    type floorBlocks = m \/ 16\n    type rem = m - floorBlocks*16\n    [ru, su] = split key\n    r : [136] \/\/ internal arithmetic on (128+8)-bit numbers\n    r = littleendian ((Poly1305_clamp (split ru)) # [0x00])\n    s = littleendian ((split su) # [0x00])\n```\n\nNext, divide the message into 16-byte blocks. The last block might be shorter:\n\n * Read each block as a little-endian number.\n * Add one bit beyond the number of octets.  For a 16-byte block this\n   is equivalent to adding 2^128 to the number.  For the shorter\n   block it can be 2^120, 2^112, or any power of two that is evenly\n   divisible by 8, all the way down to 2^8.\n\n```cryptol\n    \/\/ pad all the blocks uniformly (we'll handle the final block later)\n    paddedBlocks = [ 0x01 # (littleendian block)\n                   | block <- groupBy`{16}(msg # (zero:[inf][8])) ]\n```\n * If the block is not 17 bytes long (the last block), then left-pad it with\n   zeros.  This is meaningless if you're treating it them as numbers.\n\n```cryptol\n    lastBlock : [136]\n    lastBlock = zero # 0x01 # (littleendian (drop`{16*floorBlocks} msg))\n```\n\n *  Add the current block to the accumulator.\n *  Multiply by \"r\"\n *  Set the accumulator to the result modulo p.  To summarize:\n    ``accum[i+1] = ((accum[i]+block)*r) % p``.\n\n```cryptol\n    accum:[_][136]\n    accum = [zero:[136]] # [ computeElt a b r P | a <- accum | b <- paddedBlocks ]\n    \/\/       ^ the accumulator starts at zero\n```\n\n * If the block division leaves no remainder, the last value of the accumulator is good\n   otherwise compute the special-case padded block, and compute the final value of the accumulator\n\n```cryptol\n    lastAccum : [136]\n    lastAccum = if `rem == 0\n                   then accum@`floorBlocks\n                   else computeElt (accum@`floorBlocks) lastBlock r P\n```\n\nFinally, the value of the secret key \"s\" is added to the accumulator,\nand the 128 least significant bits are serialized in little-endian\norder to form the tag.\n\n```cryptol\n    result = reverse (groupBy`{8} (drop`{8}(lastAccum + s)))\n\n\/\/ Compute ((a + b) * r ) % P being pedantic about bit-widths\ncomputeElt : [136] -> [136] -> [136] -> [136] -> [136]\ncomputeElt a b r p = (drop`{137}bigResult) where\n    bigResult : [273]\n    aPlusB : [137]\n    aPlusB = (0b0#a) + (0b0#b)                        \/\/ make room for carry\n    timesR : [273]\n    timesR = ((zero:[136])#aPlusB) * ((zero:[137])#r) \/\/ [a]*[b]=[a+b]\n    bigResult = timesR % ((zero:[137])#p)\n\n```\n\n### Poly1305 Example and Test Vector\n\nFor our example, we will dispense with generating the one-time key\nusing AES, and assume that we got the following keying material:\n\n * Key Material: 85:d6:be:78:57:55:6d:33:7f:44:52:fe:42:d5:06:a8:01:\n   03:80:8a:fb:0d:b2:fd:4a:bf:f6:af:41:49:f5:1b\n\n```cryptol\nPoly1305TestKey = join (parseHexString\n    ( \"85:d6:be:78:57:55:6d:33:7f:44:52:fe:42:d5:06:a8:01:\"\n    # \"03:80:8a:fb:0d:b2:fd:4a:bf:f6:af:41:49:f5:1b.\"\n    ) )\n```\n\n * s as an octet string: 01:03:80:8a:fb:0d:b2:fd:4a:bf:f6:af:41:49:f5:1b\n * s as a 128-bit number: 1bf54941aff6bf4afdb20dfb8a800301\n\n```cryptol\nPoly1305Test_s = parseHexString\n    \"01:03:80:8a:fb:0d:b2:fd:4a:bf:f6:af:41:49:f5:1b.\"\nPoly1305Test_sbits = join (reverse Poly1305Test_s)\n\nproperty poly1306Sokay = Poly1305Test_sbits == 0x1bf54941aff6bf4afdb20dfb8a800301\n```\n\n\n```cryptol\nPoly1305TestMessage = \"Cryptographic Forum Research Group\"\n```\n\n * r before clamping: 85:d6:be:78:57:55:6d:33:7f:44:52:fe:42:d5:06:a8\n * Clamped r as a number: 806d5400e52447c036d555408bed685.\n\nSince Poly1305 works in 16-byte chunks, the 34-byte message divides\ninto 3 blocks.  In the following calculation, \"Acc\" denotes the\naccumulator and \"Block\" the current block:\n\nHere we define a Cryptol function that returns all of the intermediate\nvalues of the accumulator:\n\n```cryptol\n\/\/ TODO: refactor the Poly function in terms of this AccumBlocks\n\/\/ challenge: doing so while maintaining the clean literate correspondence with the spec\nAccumBlocks : {m, floorBlocks, rem} (fin m, floorBlocks == m\/16, rem == m - floorBlocks*16)\n              => [256] -> [m][8] -> ([_][136], [136])\n\nAccumBlocks key msg = (accum, lastAccum) where\n    [ru, su] = split key\n    r : [136] \/\/ internal arithmetic on (128+8)-bit numbers\n    r = littleendian ((Poly1305_clamp (split ru)) # [0x00])\n    s = littleendian ((split su) # [0x00])\n    \/\/ pad all the blocks uniformly (we'll handle the final block later)\n    paddedBlocks = [ 0x01 # (littleendian block)\n                   | block <- groupBy`{16}(msg # (zero:[inf][8])) ]\n    lastBlock : [136]\n    lastBlock = zero # 0x01 # (littleendian (drop`{16*floorBlocks} msg))\n    accum:[_][136]\n    accum = [zero:[136]] # [ computeElt a b r P | a <- accum | b <- paddedBlocks ]\n    \/\/       ^ the accumulator starts at zero\n    lastAccum : [136]\n    lastAccum = if `rem == 0\n                   then accum@`floorBlocks\n                   else computeElt (accum@`floorBlocks) lastBlock r P\n\n```\n\n```example\nBlock #1\n\nAcc = 00\nBlock = 6f4620636968706172676f7470797243\nBlock with 0x01 byte = 016f4620636968706172676f7470797243\nAcc + block = 016f4620636968706172676f7470797243\n(Acc+Block) * r =\n    b83fe991ca66800489155dcd69e8426ba2779453994ac90ed284034da565ecf\nAcc = ((Acc+Block)*r) % P = 2c88c77849d64ae9147ddeb88e69c83fc\n\nBlock #2\n\nAcc = 2c88c77849d64ae9147ddeb88e69c83fc\nBlock = 6f7247206863726165736552206d7572\nBlock with 0x01 byte = 016f7247206863726165736552206d7572\nAcc + block = 437febea505c820f2ad5150db0709f96e\n(Acc+Block) * r =\n    21dcc992d0c659ba4036f65bb7f88562ae59b32c2b3b8f7efc8b00f78e548a26\nAcc = ((Acc+Block)*r) % P = 2d8adaf23b0337fa7cccfb4ea344b30de\n\nLast Block\n\nAcc = 2d8adaf23b0337fa7cccfb4ea344b30de\nBlock = 7075\nBlock with 0x01 byte = 017075\nAcc + block = 2d8adaf23b0337fa7cccfb4ea344ca153\n(Acc + Block) * r =\n    16d8e08a0f3fe1de4fe4a15486aca7a270a29f1e6c849221e4a6798b8e45321f\n((Acc + Block) * r) % P = 28d31b7caff946c77c8844335369d03a7\n```\n\n```cryptol\nproperty polyBlocksOK =\n    (blocks @ 1 == 0x02c88c77849d64ae9147ddeb88e69c83fc) \/\\\n    (blocks @ 2 == 0x02d8adaf23b0337fa7cccfb4ea344b30de) \/\\\n    (lastBlock  == 0x028d31b7caff946c77c8844335369d03a7) where\n        (blocks, lastBlock) = AccumBlocks Poly1305TestKey Poly1305TestMessage\n```\n\nAdding s we get this number, and serialize if to get the tag:\n\nAcc + s = 2a927010caf8b2bc2c6365130c11d06a8\n\nTag: a8:06:1d:c1:30:51:36:c6:c2:2b:8b:af:0c:01:27:a9\n\n```cryptol\n\/\/ Putting it all together and testing:\n\nPoly1305TestTag = \"a8:06:1d:c1:30:51:36:c6:c2:2b:8b:af:0c:01:27:a9.\"\n\nproperty Poly1305_passes_test = Poly1305 Poly1305TestKey Poly1305TestMessage ==\n    parseHexString Poly1305TestTag\n```\n\n## Generating the Poly1305 key using ChaCha20\n\nAs said in the \"Poly 1305 Algorithm\" section, it is acceptable to generate\nthe one-time Poly1305 pseudo-randomly.  This section proposes such a method.\n\nTo generate such a key pair (r,s), we will use the ChaCha20 block\nfunction described in Section 2.3.  This assumes that we have a 256-\nbit session key for the MAC function, such as SK_ai and SK_ar in\nIKEv2 ([RFC5996]), the integrity key in ESP and AH, or the\nclient_write_MAC_key and server_write_MAC_key in TLS.  Any document\nthat specifies the use of Poly1305 as a MAC algorithm for some\nprotocol must specify that 256 bits are allocated for the integrity\nkey.  Note that in the AEAD construction defined in Section 2.8, the\nsame key is used for encryption and key generation, so the use of\nSK_a* or *_write_MAC_key is only for stand-alone Poly1305.\n\nThe method is to call the block function with the following\nparameters:\n\n * The 256-bit session integrity key is used as the ChaCha20 key.\n * The block counter is set to zero.\n * The protocol will specify a 96-bit or 64-bit nonce.  This MUST be\n   unique per invocation with the same key, so it MUST NOT be\n   randomly generated.  A counter is a good way to implement this,\n   but other methods, such as an LFSR are also acceptable.  ChaCha20\n   as specified here requires a 96-bit nonce.  So if the provided\n   nonce is only 64-bit, then the first 32 bits of the nonce will be\n   set to a constant number.  This will usually be zero, but for\n   protocols with multiple senders it may be different for each\n   sender, but should be the same for all invocations of the function\n   with the same key by a particular sender.\n\nAfter running the block function, we have a 512-bit state.  We take\nthe first 256 bits or the serialized state, and use those as the one-\ntime Poly1305 key: The first 128 bits are clamped, and form \"r\",\nwhile the next 128 bits become \"s\".  The other 256 bits are\ndiscarded.\n\nNote that while many protocols have provisions for a nonce for\nencryption algorithms (often called Initialization Vectors, or IVs),\nthey usually don't have such a provision for the MAC function.  In\nthat case the per-invocation nonce will have to come from somewhere\nelse, such as a message counter.\n\n### Poly1305 Key Generation Test Vector\n\nFor this example, we'll set:\n\n```cryptol\nPolyKeyTest = join (parseHexString (\n    \"80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f \" #\n    \"90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f \"\n    ))\n\nPolyNonceTest : [96]\nPolyNonceTest = join (\n    parseHexString (\"00 00 00 00 00 01 02 03 04 05 06 07 \"))\n```\n\nThe ChaCha state set up with key, nonce, and block counter zero:\n\n```cryptol\nPolyBuildState_testVector = [\n     0x61707865,  0x3320646e,  0x79622d32,  0x6b206574,\n     0x83828180,  0x87868584,  0x8b8a8988,  0x8f8e8d8c,\n     0x93929190,  0x97969594,  0x9b9a9998,  0x9f9e9d9c,\n     0x00000000,  0x00000000,  0x03020100,  0x07060504 ]\n\nproperty PolyBuildState_correct = BuildState PolyKeyTest PolyNonceTest 0\n    == PolyBuildState_testVector\n```\n\nThe ChaCha state after 20 rounds:\n\n```cryptol\nPolyChaChaState_testVector = [\n     0x8ba0d58a,  0xcc815f90,  0x27405081,  0x7194b24a,\n     0x37b633a8,  0xa50dfde3,  0xe2b8db08,  0x46a6d1fd,\n     0x7da03782,  0x9183a233,  0x148ad271,  0xb46773d1,\n     0x3cc1875a,  0x8607def1,  0xca5c3086,  0x7085eb87 ]\n\nproperty PolyChaCha_correct = ChaCha20Block PolyKeyTest PolyNonceTest 0 ==\n    PolyChaChaState_testVector\n```\n\nAnd that output is also the 32-byte one-time key used for Poly1305.\n\n```cryptol\nPolyOutput = join (parseHexString (\n    \"8a d5 a0 8b 90 5f 81 cc 81 50 40 27 4a b2 94 71 \" #\n    \"a8 33 b6 37 e3 fd 0d a5 08 db b8 e2 fd d1 a6 46 \"))\n\nGeneratePolyKeyUsingChaCha k n i = join [littleendian (groupBy`{8}b)\n                                        | b <- take `{8}(ChaCha20Block k n i) ]\n\nproperty Poly_passes_test = GeneratePolyKeyUsingChaCha PolyKeyTest PolyNonceTest 0 == PolyOutput\n```\n\n## A Pseudo-Random Function for ChaCha\/Poly-1305 based Crypto Suites\n\nSome protocols such as IKEv2([RFC5996]) require a Pseudo-Random\nFunction (PRF), mostly for key derivation.  In the IKEv2 definition,\na PRF is a function that accepts a variable-length key and a\nvariable-length input, and returns a fixed-length output.  This\nsection does not specify such a function.\n\nPoly-1305 is an obvious choice, because MAC functions are often used\nas PRFs.  However, Poly-1305 prohibits using the same key twice,\nwhereas the PRF in IKEv2 is used multiple times with the same key.\nAdding a nonce or a counter to Poly-1305 can solve this issue, much\nas we do when using this function as a MAC, but that would require\nchanging the interface for the PRF function.\n\nChacha20 could be used as a key-derivation function, by generating an\narbitrarily long keystream.  However, that is not what protocols such\nas IKEv2 require.\n\nFor this reason, this document does not specify a PRF, and recommends\nthat crypto suites use some other PRF such as PRF_HMAC_SHA2_256\n(section 2.1.2 of [RFC4868])\n\n## AEAD Construction\n\nAEAD_CHACHA20-POLY1305 is an authenticated encryption with additional\ndata algorithm.  The inputs to AEAD_CHACHA20-POLY1305 are:\n\n *  A 256-bit key\n *  A 96-bit nonce - different for each invocation with the same key.\n *  An arbitrary length plaintext (fewer than 2^64 bytes)\n *  Arbitrary length additional data (AAD) (fewer than 2^64 bytes)\n\n```cryptol\nAEAD_CHACHA20_POLY1305 : {m, n}\n                         (fin m, 64 >= width m\n                         ,fin n, 64 >= width n )\n                       => [256] -> [96] -> [m][8] -> [n][8]\n                       -> [m+16][8]\n\nAEAD_CHACHA20_POLY1305 k nonce p aad = (ct # tag) where\n```\n\nSome protocols may have unique per-invocation inputs that are not 96-\nbit in length.  For example, IPsec may specify a 64-bit nonce.  In\nsuch a case, it is up to the protocol document to define how to\ntransform the protocol nonce into a 96-bit nonce, for example by\nconcatenating a constant value.\n\nThe ChaCha20 and Poly1305 primitives are combined into an AEAD that\ntakes a 256-bit key and 96-bit nonce as follows:\n\n *  First, a Poly1305 one-time key is generated from the 256-bit key\n    and nonce using the procedure described in \"Generating the Poly1305 key using ChaCha20\".\n\n```cryptol\n    PolyKey = GeneratePolyKeyUsingChaCha k nonce 0\n```\n\n *  Next, the ChaCha20 encryption function is called to encrypt the\n    plaintext, using the input key and nonce, and with the initial\n    counter set to 1.\n\n```cryptol\n    ct = ChaCha20EncryptBytes p k nonce 1\n```\n\n *  Finally, the Poly1305 function is called with the Poly1305 key\n    calculated above, and a message constructed as a concatenation of\n    the following:\n    *  The AAD\n    *  padding1 - the padding is up to 15 zero bytes, and it brings\n       the total length so far to an integral multiple of 16.  If the\n       length of the AAD was already an integral multiple of 16 bytes,\n       this field is zero-length.\n    *  The ciphertext\n    *  padding2 - the padding is up to 15 zero bytes, and it brings\n       the total length so far to an integral multiple of 16.  If the\n       length of the ciphertext was already an integral multiple of 16\n       bytes, this field is zero-length.\n    *  The length of the additional data in octets (as a 64-bit\n       little-endian integer).\n    *  The length of the ciphertext in octets (as a 64-bit little-\n       endian integer).\n\n```cryptol\n    ptlen : [8][8]\n    ptlen = groupBy`{8}(littleendian (groupBy`{8}(`m:[64])))\n    adlen : [8][8]\n    adlen = groupBy`{8}(littleendian (groupBy`{8}(`n:[64])))\n    \/\/ compute padding\n    tag = Poly1305 PolyKey (AeadConstruction aad ct)\n\n\/\/ct in this function has tag removed\nAeadConstruction (AAD : [n][8]) (CT : [m][8]) = (AAD # padding1 # CT # padding2 # adlen # ptlen) where\n\tpadding1 = (zero:[n %^ 16][8])\n\tpadding2 = (zero:[m %^ 16][8])\n\tadlen : [8][8]\n\tadlen = groupBy`{8}(littleendian (groupBy`{8}(`n:[64])))\n\tptlen : [8][8]\n\tptlen = groupBy`{8}(littleendian (groupBy`{8}(`m:[64])))\n\n```\n\nThe output from the AEAD is twofold:\n\n *  A ciphertext of the same length as the plaintext.\n *  A 128-bit tag, which is the output of the Poly1305 function.\n\nDecryption is pretty much the same thing.\n\n```cryptol\nAEAD_CHACHA20_POLY1305_DECRYPT : {m, n} (fin m, fin n\n                                 ,64 >= width m, 64 >= width n)\n                                 => [256] -> [96]\n                                    -> [m+16][8] -> [n][8]\n                                    -> Option ([m][8])\nAEAD_CHACHA20_POLY1305_DECRYPT k nonce ct ad = if valid then Some pt else None where\n    inTag = drop`{m}ct\n    inCt = take`{m}ct\n    PolyKey = GeneratePolyKeyUsingChaCha k nonce 0\n    pt = ChaCha20DecryptBytes inCt k nonce 1\n    ptlen : [8][8]\n    ptlen = groupBy`{8}(littleendian (groupBy`{8}(`m:[64])))\n    adlen : [8][8]\n    adlen = groupBy`{8}(littleendian (groupBy`{8}(`n:[64])))\n    tag = Poly1305 PolyKey (AeadConstruction ad inCt)\n    valid = tag == inTag\n```\n\nA few notes about this design:\n\n 1.  The amount of encrypted data possible in a single invocation is\n     2^32-1 blocks of 64 bytes each, because of the size of the block\n     counter field in the ChaCha20 block function.  This gives a total\n     of 247,877,906,880 bytes, or nearly 256 GB.  This should be\n     enough for traffic protocols such as IPsec and TLS, but may be\n     too small for file and\/or disk encryption.  For such uses, we can\n     return to the original design, reduce the nonce to 64 bits, and\n     use the integer at position 13 as the top 32 bits of a 64-bit\n     block counter, increasing the total message size to over a\n     million petabytes (1,180,591,620,717,411,303,360 bytes to be\n     exact).\n\n 1.  Despite the previous item, the ciphertext length field in the\n     construction of the buffer on which Poly1305 runs limits the\n     ciphertext (and hence, the plaintext) size to 2^64 bytes, or\n     sixteen thousand petabytes (18,446,744,073,709,551,616 bytes to\n     be exact).\n\n### Example and Test Vector for AEAD_CHACHA20-POLY1305\n\nFor a test vector, we will use the following inputs to the\nAEAD_CHACHA20-POLY1305 function:\n\nPlaintext:\n\n```cryptol\nAeadPt = \"Ladies and Gentlemen of the class of '99: \" #\n         \"If I could offer you only one tip for \" #\n         \"the future, sunscreen would be it.\"\n\nAeadAAD = parseHexString \"50 51 52 53 c0 c1 c2 c3 c4 c5 c6 c7 \"\n\nAeadKey = join (parseHexString (\n    \"80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f \" #\n    \"90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f \" ))\n\n\nAeadIV = join [ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47 ]\n\nAeadC = join [0x07, 0x00, 0x00, 0x00]\n\nAeadNonce = AeadC # AeadIV\n```\n\n32-bit fixed-common part:\n\n```cryptol\nAeadCT = ChaCha20EncryptBytes AeadPt AeadKey AeadNonce 1\n\nAeadPolyKey = GeneratePolyKeyUsingChaCha AeadKey (AeadC # AeadIV) 0\n\nADleLen : [8][8]\nADleLen = groupBy`{8}(littleendian (groupBy`{8}((length AeadAAD):[64])))\n\nCTleLen : [8][8]\nCTleLen = groupBy`{8}(littleendian (groupBy`{8}((length AeadCT):[64])))\n\nAeadTag = Poly1305 AeadPolyKey (AeadConstruction AeadAAD AeadCT)\n```\n\nSet up for generating poly1305 one-time key (sender id=7):\n\n```cryptol\nAeadPolyOneTimeKey_testVector = [\n    0x61707865,  0x3320646e,  0x79622d32,  0x6b206574,\n    0x83828180,  0x87868584,  0x8b8a8988,  0x8f8e8d8c,\n    0x93929190,  0x97969594,  0x9b9a9998,  0x9f9e9d9c,\n    0x00000000,  0x00000007,  0x43424140,  0x47464544 ]\n\nproperty AeadPolyKeyBuildState_correct =\n    BuildState AeadKey AeadNonce 0 == AeadPolyOneTimeKey_testVector\n```\n\nAfter generating Poly1305 one-time key:\n\n```cryptol\nAeadPolyOneTimeKeyState = [\n    0x252bac7b,  0xaf47b42d,  0x557ab609,  0x8455e9a4,\n    0x73d6e10a,  0xebd97510,  0x7875932a,  0xff53d53e,\n    0xdecc7ea2,  0xb44ddbad,  0xe49c17d1,  0xd8430bc9,\n    0x8c94b7bc,  0x8b7d4b4b,  0x3927f67d,  0x1669a432]\n\nproperty AeadPolyChaCha_correct =\n    ChaCha20Block AeadKey AeadNonce 0 == AeadPolyOneTimeKeyState\n```\n\nPoly1305 Key:\n\n```cryptol\nPoly1305Key_testVector = join (parseHexString (\n    \"7b ac 2b 25 2d b4 47 af 09 b6 7a 55 a4 e9 55 84 \" #\n    \"0a e1 d6 73 10 75 d9 eb 2a 93 75 78 3e d5 53 ff \" ))\n\nproperty poly1305Test_correct = AeadPolyKey == Poly1305Key_testVector\n\nPoly1305_r = 0x0455e9a4057ab6080f47b42c052bac7b\nPoly1305_s = 0xff53d53e7875932aebd9751073d6e10a\n```\n\n```verbatim\nKeystream bytes:\n9f:7b:e9:5d:01:fd:40:ba:15:e2:8f:fb:36:81:0a:ae:\nc1:c0:88:3f:09:01:6e:de:dd:8a:d0:87:55:82:03:a5:\n4e:9e:cb:38:ac:8e:5e:2b:b8:da:b2:0f:fa:db:52:e8:\n75:04:b2:6e:be:69:6d:4f:60:a4:85:cf:11:b8:1b:59:\nfc:b1:c4:5f:42:19:ee:ac:ec:6a:de:c3:4e:66:69:78:\n8e:db:41:c4:9c:a3:01:e1:27:e0:ac:ab:3b:44:b9:cf:\n5c:86:bb:95:e0:6b:0d:f2:90:1a:b6:45:e4:ab:e6:22:\n15:38\n\n\nCiphertext:\n000  d3 1a 8d 34 64 8e 60 db 7b 86 af bc 53 ef 7e c2|...4d.`.{...S.~.\n016  a4 ad ed 51 29 6e 08 fe a9 e2 b5 a7 36 ee 62 d6|...Q)n......6.b.\n032  3d be a4 5e 8c a9 67 12 82 fa fb 69 da 92 72 8b|=..^..g....i..r.\n048  1a 71 de 0a 9e 06 0b 29 05 d6 a5 b6 7e cd 3b 36|.q.....)....~.;6\n064  92 dd bd 7f 2d 77 8b 8c 98 03 ae e3 28 09 1b 58|...-w......(..X\n080  fa b3 24 e4 fa d6 75 94 55 85 80 8b 48 31 d7 bc|..$...u.U...H1..\n096  3f f4 de f0 8e 4b 7a 9d e5 76 d2 65 86 ce c6 4b|?....Kz..v.e...K\n112  61 16                                          |a.\n```\n\nAEAD Construction for Poly1305:\n\n```cryptol\nAeadConstructionTestVector = parseHexString (\n   \"50:51:52:53:c0:c1:c2:c3:c4:c5:c6:c7:00:00:00:00:\" #\n   \"d3:1a:8d:34:64:8e:60:db:7b:86:af:bc:53:ef:7e:c2:\" #\n   \"a4:ad:ed:51:29:6e:08:fe:a9:e2:b5:a7:36:ee:62:d6:\" #\n   \"3d:be:a4:5e:8c:a9:67:12:82:fa:fb:69:da:92:72:8b:\" #\n   \"1a:71:de:0a:9e:06:0b:29:05:d6:a5:b6:7e:cd:3b:36:\" #\n   \"92:dd:bd:7f:2d:77:8b:8c:98:03:ae:e3:28:09:1b:58:\" #\n   \"fa:b3:24:e4:fa:d6:75:94:55:85:80:8b:48:31:d7:bc:\" #\n   \"3f:f4:de:f0:8e:4b:7a:9d:e5:76:d2:65:86:ce:c6:4b:\" #\n   \"61:16:00:00:00:00:00:00:00:00:00:00:00:00:00:00:\" #\n   \"0c:00:00:00:00:00:00:00:72:00:00:00:00:00:00:00.\" )\n```\n\nNote the 4 zero bytes in line 000 and the 14 zero bytes in line 128\n\n```cryptol\n\/\/ Tag:\nAeadTagTestVector = parseHexString \"1a:e1:0b:59:4f:09:e2:6a:7e:90:2e:cb:d0:60:06:91.\"\n```\n\n```cryptol\nproperty AeadTag_correct = AeadTag == AeadTagTestVector\n\nproperty AeadConstruction_correct = (AeadConstruction AeadAAD AeadCT) == AeadConstructionTestVector\n\nproperty AeadDecrypt_correct = ptMatches where\n    opt        = AEAD_CHACHA20_POLY1305_DECRYPT AeadKey (AeadIV # AeadC) cipherText AeadAAD\n    cipherText = (AEAD_CHACHA20_POLY1305 AeadKey (AeadIV # AeadC) AeadPt AeadAAD)\n    ptMatches  = optFold False (\\pt -> AeadPt == pt) opt\n\n```\n\n# Implementation Advice\n\nEach block of ChaCha20 involves 16 move operations and one increment\noperation for loading the state, 80 each of XOR, addition and Roll\noperations for the rounds, 16 more add operations and 16 XOR\noperations for protecting the plaintext.  Section 2.3 describes the\nChaCha block function as \"adding the original input words\".  This\nimplies that before starting the rounds on the ChaCha state, we copy\nit aside, only to add it in later.  This is correct, but we can save\na few operations if we instead copy the state and do the work on the\ncopy.  This way, for the next block you don't need to recreate the\nstate, but only to increment the block counter.  This saves\napproximately 5.5% of the cycles.\n\nIt is not recommended to use a generic big number library such as the\none in OpenSSL for the arithmetic operations in Poly1305.  Such\nlibraries use dynamic allocation to be able to handle any-sized\ninteger, but that flexibility comes at the expense of performance as\nwell as side-channel security.  More efficient implementations that\nrun in constant time are available, one of them in DJB's own library,\nNaCl ([NaCl]).  A constant-time but not optimal approach would be to\nnaively implement the arithmetic operations for a 288-bit integers,\nbecause even a naive implementation will not exceed 2^288 in the\nmultiplication of (acc+block) and r.  An efficient constant-time\nimplementation can be found in the public domain library poly1305-\ndonna ([poly1305_donna]).\n\n\n# Security Considerations\n\nThe ChaCha20 cipher is designed to provide 256-bit security.\n\nThe Poly1305 authenticator is designed to ensure that forged messages\nare rejected with a probability of 1-(n\/(2^102)) for a 16n-byte\nmessage, even after sending 2^64 legitimate messages, so it is SUF-\nCMA in the terminology of [AE].\n\nProving the security of either of these is beyond the scope of this\ndocument.  Such proofs are available in the referenced academic\npapers.\n\nThe most important security consideration in implementing this draft\nis the uniqueness of the nonce used in ChaCha20.  Counters and LFSRs\nare both acceptable ways of generating unique nonces, as is\nencrypting a counter using a 64-bit cipher such as DES.  Note that it\nis not acceptable to use a truncation of a counter encrypted with a\n128-bit or 256-bit cipher, because such a truncation may repeat after\na short time.\n\nThe Poly1305 key MUST be unpredictable to an attacker.  Randomly\ngenerating the key would fulfill this requirement, except that\nPoly1305 is often used in communications protocols, so the receiver\nshould know the key.  Pseudo-random number generation such as by\nencrypting a counter is acceptable.  Using ChaCha with a secret key\nand a nonce is also acceptable.\n\nThe algorithms presented here were designed to be easy to implement\nin constant time to avoid side-channel vulnerabilities.  The\noperations used in ChaCha20 are all additions, XORs, and fixed\nrotations.  All of these can and should be implemented in constant\ntime.  Access to offsets into the ChaCha state and the number of\noperations do not depend on any property of the key, eliminating the\nchance of information about the key leaking through the timing of\ncache misses.\n\nFor Poly1305, the operations are addition, multiplication and\nmodulus, all on >128-bit numbers.  This can be done in constant time,\nbut a naive implementation (such as using some generic big number\nlibrary) will not be constant time.  For example, if the\nmultiplication is performed as a separate operation from the modulus,\nthe result will some times be under 2^256 and some times be above\n2^256.  Implementers should be careful about timing side-channels for\nPoly1305 by using the appropriate implementation of these operations.\n\n\n# Appendix: Additional test vectors\n\n## The ChaCha20 Block Functions\n\n```cryptol\n\/\/ helper macros for higher-up properties\nTV_block_correct key nonce blockcounter result = ChaCha20Block key nonce blockcounter == result\n\nTV_block_Keystream_correct key nonce blockcounter keystream =\n\ttake`{0x40} (groupBy`{8} (join (join (ChaCha20ExpandKey key nonce blockcounter)))) == keystream\n\nChaCha20_block_correct key nonce blockcounter result keystream =\n\tTV_block_correct key nonce blockcounter result \/\\\n\tTV_block_Keystream_correct key nonce blockcounter keystream\n```\n\n### Test Vector #1\n\n```cryptol\nTV1_block_Key = zero:ChaChaKey\nTV1_block_Nonce = zero:[96]\nTV1_block_BlockCounter = 0\n\nTV1_block_After20 = [\n    0xade0b876, 0x903df1a0, 0xe56a5d40, 0x28bd8653,\n    0xb819d2bd, 0x1aed8da0, 0xccef36a8, 0xc70d778b,\n    0x7c5941da, 0x8d485751, 0x3fe02477, 0x374ad8b8,\n    0xf4b8436a, 0x1ca11815, 0x69b687c3, 0x8665eeb2]\n\nTV1_block_KeyStream = [\n    0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90, 0x40, 0x5d, 0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28,\n    0xbd, 0xd2, 0x19, 0xb8, 0xa0, 0x8d, 0xed, 0x1a, 0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77, 0x0d, 0xc7,\n    0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d, 0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37,\n    0x6a, 0x43, 0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c, 0xc3, 0x87, 0xb6, 0x69, 0xb2, 0xee, 0x65, 0x86]\n\nproperty TV1_block_correct = ChaCha20_block_correct TV1_block_Key TV1_block_Nonce TV1_block_BlockCounter TV1_block_After20 TV1_block_KeyStream\n\n```\n\n### Test Vector #2\n\n```cryptol\nTV2_block_Key = zero:ChaChaKey\nTV2_block_Nonce = zero:[96]\nTV2_block_BlockCounter = 1\n\nTV2_block_After20 = [\n\t0xbee7079f, 0x7a385155, 0x7c97ba98, 0x0d082d73,\n\t0xa0290fcb, 0x6965e348, 0x3e53c612, 0xed7aee32,\n\t0x7621b729, 0x434ee69c, 0xb03371d5, 0xd539d874,\n\t0x281fed31, 0x45fb0a51, 0x1f0ae1ac, 0x6f4d794b]\n\nTV2_block_KeyStream = [\n\t0x9f, 0x07, 0xe7, 0xbe, 0x55, 0x51, 0x38, 0x7a, 0x98, 0xba, 0x97, 0x7c, 0x73, 0x2d, 0x08, 0x0d,\n\t0xcb, 0x0f, 0x29, 0xa0, 0x48, 0xe3, 0x65, 0x69, 0x12, 0xc6, 0x53, 0x3e, 0x32, 0xee, 0x7a, 0xed,\n\t0x29, 0xb7, 0x21, 0x76, 0x9c, 0xe6, 0x4e, 0x43, 0xd5, 0x71, 0x33, 0xb0, 0x74, 0xd8, 0x39, 0xd5,\n\t0x31, 0xed, 0x1f, 0x28, 0x51, 0x0a, 0xfb, 0x45, 0xac, 0xe1, 0x0a, 0x1f, 0x4b, 0x79, 0x4d, 0x6f]\n\nproperty TV2_block_correct = ChaCha20_block_correct TV2_block_Key TV2_block_Nonce TV2_block_BlockCounter TV2_block_After20 TV2_block_KeyStream\n\n\n```\n\n### Test Vector #3\n\n```cryptol\nTV3_block_Key = (zero # 0b1):ChaChaKey\nTV3_block_Nonce = zero:[96]\nTV3_block_BlockCounter = 1\n\nTV3_block_After20 = [\n\t0x2452eb3a, 0x9249f8ec, 0x8d829d9b, 0xddd4ceb1,\n\t0xe8252083, 0x60818b01, 0xf38422b8, 0x5aaa49c9,\n\t0xbb00ca8e, 0xda3ba7b4, 0xc4b592d1, 0xfdf2732f,\n\t0x4436274e, 0x2561b3c8, 0xebdd4aa6, 0xa0136c00]\n\nTV3_block_KeyStream = [\n\t0x3a, 0xeb, 0x52, 0x24, 0xec, 0xf8, 0x49, 0x92, 0x9b, 0x9d, 0x82, 0x8d, 0xb1, 0xce, 0xd4, 0xdd,\n\t0x83, 0x20, 0x25, 0xe8, 0x01, 0x8b, 0x81, 0x60, 0xb8, 0x22, 0x84, 0xf3, 0xc9, 0x49, 0xaa, 0x5a,\n\t0x8e, 0xca, 0x00, 0xbb, 0xb4, 0xa7, 0x3b, 0xda, 0xd1, 0x92, 0xb5, 0xc4, 0x2f, 0x73, 0xf2, 0xfd,\n\t0x4e, 0x27, 0x36, 0x44, 0xc8, 0xb3, 0x61, 0x25, 0xa6, 0x4a, 0xdd, 0xeb, 0x00, 0x6c, 0x13, 0xa0]\n\nproperty TV3_block_correct = ChaCha20_block_correct TV3_block_Key TV3_block_Nonce TV3_block_BlockCounter TV3_block_After20 TV3_block_KeyStream\n\n```\n\n### Test Vector #4\n\n```cryptol\nTV4_block_Key = ( 0x00ff # zero):ChaChaKey\nTV4_block_Nonce = zero:[96]\nTV4_block_BlockCounter = 2\n\nTV4_block_After20 = [\n\t0xfb4dd572, 0x4bc42ef1, 0xdf922636, 0x327f1394,\n\t0xa78dea8f, 0x5e269039, 0xa1bebbc1, 0xcaf09aae,\n\t0xa25ab213, 0x48a6b46c, 0x1b9d9bcb, 0x092c5be6,\n\t0x546ca624, 0x1bec45d5, 0x87f47473, 0x96f0992e]\n\nTV4_block_KeyStream = [\n\t0x72, 0xd5, 0x4d, 0xfb, 0xf1, 0x2e, 0xc4, 0x4b, 0x36, 0x26, 0x92, 0xdf, 0x94, 0x13, 0x7f, 0x32,\n\t0x8f, 0xea, 0x8d, 0xa7, 0x39, 0x90, 0x26, 0x5e, 0xc1, 0xbb, 0xbe, 0xa1, 0xae, 0x9a, 0xf0, 0xca,\n\t0x13, 0xb2, 0x5a, 0xa2, 0x6c, 0xb4, 0xa6, 0x48, 0xcb, 0x9b, 0x9d, 0x1b, 0xe6, 0x5b, 0x2c, 0x09,\n\t0x24, 0xa6, 0x6c, 0x54, 0xd5, 0x45, 0xec, 0x1b, 0x73, 0x74, 0xf4, 0x87, 0x2e, 0x99, 0xf0, 0x96]\n\nproperty TV4_block_correct = ChaCha20_block_correct TV4_block_Key TV4_block_Nonce TV4_block_BlockCounter TV4_block_After20 TV4_block_KeyStream\n\n```\n\n### Test Vector #5\n\n```cryptol\nTV5_block_Key = (zero):ChaChaKey\nTV5_block_Nonce = zero # 0x02:[96]\nTV5_block_BlockCounter = 0\n\nTV5_block_After20 = [\n\t0x374dc6c2, 0x3736d58c, 0xb904e24a, 0xcd3f93ef,\n\t0x88228b1a, 0x96a4dfb3, 0x5b76ab72, 0xc727ee54,\n\t0x0e0e978a, 0xf3145c95, 0x1b748ea8, 0xf786c297,\n\t0x99c28f5f, 0x628314e8, 0x398a19fa, 0x6ded1b53]\n\nTV5_block_KeyStream = [\n\t0xc2, 0xc6, 0x4d, 0x37, 0x8c, 0xd5, 0x36, 0x37, 0x4a, 0xe2, 0x04, 0xb9, 0xef, 0x93, 0x3f, 0xcd,\n\t0x1a, 0x8b, 0x22, 0x88, 0xb3, 0xdf, 0xa4, 0x96, 0x72, 0xab, 0x76, 0x5b, 0x54, 0xee, 0x27, 0xc7,\n\t0x8a, 0x97, 0x0e, 0x0e, 0x95, 0x5c, 0x14, 0xf3, 0xa8, 0x8e, 0x74, 0x1b, 0x97, 0xc2, 0x86, 0xf7,\n\t0x5f, 0x8f, 0xc2, 0x99, 0xe8, 0x14, 0x83, 0x62, 0xfa, 0x19, 0x8a, 0x39, 0x53, 0x1b, 0xed, 0x6d]\n\nproperty TV5_block_correct = ChaCha20_block_correct TV5_block_Key TV5_block_Nonce TV5_block_BlockCounter TV5_block_After20 TV5_block_KeyStream\n\nproperty all_block_tests_correct =\n\tTV1_block_correct \/\\\n\tTV2_block_correct \/\\\n\tTV3_block_correct \/\\\n\tTV4_block_correct \/\\\n\tTV5_block_correct\n\n```\n\n## ChaCha20 Encryption\n\n```cryptol\nChaCha20_enc_correct key nonce blockcounter plaintext ciphertext = ChaCha20EncryptBytes plaintext key nonce blockcounter == ciphertext\n```\n\n### Test Vector #1\n\n```cryptol\nTV1_enc_Key = (zero):ChaChaKey\nTV1_enc_Nonce = zero:[96]\nTV1_enc_BlockCounter = 0\n\nTV1_enc_plaintext = zero:[64][8]\n\nTV1_enc_ciphertext = [\n\t0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90, 0x40, 0x5d, 0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28,\n\t0xbd, 0xd2, 0x19, 0xb8, 0xa0, 0x8d, 0xed, 0x1a, 0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77, 0x0d, 0xc7,\n\t0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d, 0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37,\n\t0x6a, 0x43, 0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c, 0xc3, 0x87, 0xb6, 0x69, 0xb2, 0xee, 0x65, 0x86]\n\nproperty TV1_enc_correct = ChaCha20_enc_correct TV1_enc_Key TV1_enc_Nonce TV1_enc_BlockCounter TV1_enc_plaintext TV1_enc_ciphertext\n\n```\n\n### Test Vector #2\n\n```cryptol\nTV2_enc_Key = (zero # 0x1):ChaChaKey\nTV2_enc_Nonce = zero # 0x2:[96]\nTV2_enc_BlockCounter = 1\n\nIETF_submission_text = [\n\t0x41, 0x6e, 0x79, 0x20, 0x73, 0x75, 0x62, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x74,\n\t0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x6e,\n\t0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72,\n\t0x69, 0x62, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x70, 0x75, 0x62, 0x6c, 0x69,\n\t0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6f, 0x72,\n\t0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x45, 0x54, 0x46,\n\t0x20, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x2d, 0x44, 0x72, 0x61, 0x66, 0x74, 0x20,\n\t0x6f, 0x72, 0x20, 0x52, 0x46, 0x43, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x73,\n\t0x74, 0x61, 0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x64, 0x65, 0x20, 0x77, 0x69,\n\t0x74, 0x68, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,\n\t0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x61, 0x63, 0x74, 0x69,\n\t0x76, 0x69, 0x74, 0x79, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x72,\n\t0x65, 0x64, 0x20, 0x61, 0x6e, 0x20, 0x22, 0x49, 0x45, 0x54, 0x46, 0x20, 0x43, 0x6f, 0x6e, 0x74,\n\t0x72, 0x69, 0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x2e, 0x20, 0x53, 0x75, 0x63, 0x68, 0x20,\n\t0x73, 0x74, 0x61, 0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75,\n\t0x64, 0x65, 0x20, 0x6f, 0x72, 0x61, 0x6c, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6d, 0x65, 0x6e,\n\t0x74, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x73, 0x65, 0x73, 0x73, 0x69,\n\t0x6f, 0x6e, 0x73, 0x2c, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6c, 0x6c, 0x20, 0x61, 0x73, 0x20,\n\t0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x65, 0x6c, 0x65, 0x63,\n\t0x74, 0x72, 0x6f, 0x6e, 0x69, 0x63, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61,\n\t0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x6d, 0x61, 0x64, 0x65, 0x20, 0x61, 0x74, 0x20, 0x61, 0x6e,\n\t0x79, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x2c,\n\t0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65,\n\t0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f ]\n\nTV2_enc_plaintext = IETF_submission_text\n\n\nTV2_enc_ciphertext = [\n\t0xa3, 0xfb, 0xf0, 0x7d, 0xf3, 0xfa, 0x2f, 0xde, 0x4f, 0x37, 0x6c, 0xa2, 0x3e, 0x82, 0x73, 0x70,\n\t0x41, 0x60, 0x5d, 0x9f, 0x4f, 0x4f, 0x57, 0xbd, 0x8c, 0xff, 0x2c, 0x1d, 0x4b, 0x79, 0x55, 0xec,\n\t0x2a, 0x97, 0x94, 0x8b, 0xd3, 0x72, 0x29, 0x15, 0xc8, 0xf3, 0xd3, 0x37, 0xf7, 0xd3, 0x70, 0x05,\n\t0x0e, 0x9e, 0x96, 0xd6, 0x47, 0xb7, 0xc3, 0x9f, 0x56, 0xe0, 0x31, 0xca, 0x5e, 0xb6, 0x25, 0x0d,\n\t0x40, 0x42, 0xe0, 0x27, 0x85, 0xec, 0xec, 0xfa, 0x4b, 0x4b, 0xb5, 0xe8, 0xea, 0xd0, 0x44, 0x0e,\n\t0x20, 0xb6, 0xe8, 0xdb, 0x09, 0xd8, 0x81, 0xa7, 0xc6, 0x13, 0x2f, 0x42, 0x0e, 0x52, 0x79, 0x50,\n\t0x42, 0xbd, 0xfa, 0x77, 0x73, 0xd8, 0xa9, 0x05, 0x14, 0x47, 0xb3, 0x29, 0x1c, 0xe1, 0x41, 0x1c,\n\t0x68, 0x04, 0x65, 0x55, 0x2a, 0xa6, 0xc4, 0x05, 0xb7, 0x76, 0x4d, 0x5e, 0x87, 0xbe, 0xa8, 0x5a,\n\t0xd0, 0x0f, 0x84, 0x49, 0xed, 0x8f, 0x72, 0xd0, 0xd6, 0x62, 0xab, 0x05, 0x26, 0x91, 0xca, 0x66,\n\t0x42, 0x4b, 0xc8, 0x6d, 0x2d, 0xf8, 0x0e, 0xa4, 0x1f, 0x43, 0xab, 0xf9, 0x37, 0xd3, 0x25, 0x9d,\n\t0xc4, 0xb2, 0xd0, 0xdf, 0xb4, 0x8a, 0x6c, 0x91, 0x39, 0xdd, 0xd7, 0xf7, 0x69, 0x66, 0xe9, 0x28,\n\t0xe6, 0x35, 0x55, 0x3b, 0xa7, 0x6c, 0x5c, 0x87, 0x9d, 0x7b, 0x35, 0xd4, 0x9e, 0xb2, 0xe6, 0x2b,\n\t0x08, 0x71, 0xcd, 0xac, 0x63, 0x89, 0x39, 0xe2, 0x5e, 0x8a, 0x1e, 0x0e, 0xf9, 0xd5, 0x28, 0x0f,\n\t0xa8, 0xca, 0x32, 0x8b, 0x35, 0x1c, 0x3c, 0x76, 0x59, 0x89, 0xcb, 0xcf, 0x3d, 0xaa, 0x8b, 0x6c,\n\t0xcc, 0x3a, 0xaf, 0x9f, 0x39, 0x79, 0xc9, 0x2b, 0x37, 0x20, 0xfc, 0x88, 0xdc, 0x95, 0xed, 0x84,\n\t0xa1, 0xbe, 0x05, 0x9c, 0x64, 0x99, 0xb9, 0xfd, 0xa2, 0x36, 0xe7, 0xe8, 0x18, 0xb0, 0x4b, 0x0b,\n\t0xc3, 0x9c, 0x1e, 0x87, 0x6b, 0x19, 0x3b, 0xfe, 0x55, 0x69, 0x75, 0x3f, 0x88, 0x12, 0x8c, 0xc0,\n\t0x8a, 0xaa, 0x9b, 0x63, 0xd1, 0xa1, 0x6f, 0x80, 0xef, 0x25, 0x54, 0xd7, 0x18, 0x9c, 0x41, 0x1f,\n\t0x58, 0x69, 0xca, 0x52, 0xc5, 0xb8, 0x3f, 0xa3, 0x6f, 0xf2, 0x16, 0xb9, 0xc1, 0xd3, 0x00, 0x62,\n\t0xbe, 0xbc, 0xfd, 0x2d, 0xc5, 0xbc, 0xe0, 0x91, 0x19, 0x34, 0xfd, 0xa7, 0x9a, 0x86, 0xf6, 0xe6,\n\t0x98, 0xce, 0xd7, 0x59, 0xc3, 0xff, 0x9b, 0x64, 0x77, 0x33, 0x8f, 0x3d, 0xa4, 0xf9, 0xcd, 0x85,\n\t0x14, 0xea, 0x99, 0x82, 0xcc, 0xaf, 0xb3, 0x41, 0xb2, 0x38, 0x4d, 0xd9, 0x02, 0xf3, 0xd1, 0xab,\n\t0x7a, 0xc6, 0x1d, 0xd2, 0x9c, 0x6f, 0x21, 0xba, 0x5b, 0x86, 0x2f, 0x37, 0x30, 0xe3, 0x7c, 0xfd,\n\t0xc4, 0xfd, 0x80, 0x6c, 0x22, 0xf2, 0x21]\n\nproperty TV2_enc_correct = ChaCha20_enc_correct TV2_enc_Key TV2_enc_Nonce TV2_enc_BlockCounter TV2_enc_plaintext TV2_enc_ciphertext\n\n```\n\n### Test Vector #3\n\n```cryptol\nTV3_enc_Key = join([\n\t0x1c, 0x92, 0x40, 0xa5, 0xeb, 0x55, 0xd3, 0x8a, 0xf3, 0x33, 0x88, 0x86, 0x04, 0xf6, 0xb5, 0xf0,\n\t0x47, 0x39, 0x17, 0xc1, 0x40, 0x2b, 0x80, 0x09, 0x9d, 0xca, 0x5c, 0xbc, 0x20, 0x70, 0x75, 0xc0]):ChaChaKey\nTV3_enc_Nonce = zero # 0x2:[96]\nTV3_enc_BlockCounter = 42:[32]\n\njabberwock_text = [\n\t0x27, 0x54, 0x77, 0x61, 0x73, 0x20, 0x62, 0x72, 0x69, 0x6c, 0x6c, 0x69, 0x67, 0x2c, 0x20, 0x61,\n\t0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6c, 0x69, 0x74, 0x68, 0x79, 0x20, 0x74, 0x6f,\n\t0x76, 0x65, 0x73, 0x0a, 0x44, 0x69, 0x64, 0x20, 0x67, 0x79, 0x72, 0x65, 0x20, 0x61, 0x6e, 0x64,\n\t0x20, 0x67, 0x69, 0x6d, 0x62, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77,\n\t0x61, 0x62, 0x65, 0x3a, 0x0a, 0x41, 0x6c, 0x6c, 0x20, 0x6d, 0x69, 0x6d, 0x73, 0x79, 0x20, 0x77,\n\t0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6f, 0x72, 0x6f, 0x67, 0x6f, 0x76, 0x65,\n\t0x73, 0x2c, 0x0a, 0x41, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x6f, 0x6d, 0x65, 0x20,\n\t0x72, 0x61, 0x74, 0x68, 0x73, 0x20, 0x6f, 0x75, 0x74, 0x67, 0x72, 0x61, 0x62, 0x65, 0x2e]\n\nTV3_enc_plaintext = jabberwock_text\n\n\nTV3_enc_ciphertext = [\n\t0x62, 0xe6, 0x34, 0x7f, 0x95, 0xed, 0x87, 0xa4, 0x5f, 0xfa, 0xe7, 0x42, 0x6f, 0x27, 0xa1, 0xdf,\n\t0x5f, 0xb6, 0x91, 0x10, 0x04, 0x4c, 0x0d, 0x73, 0x11, 0x8e, 0xff, 0xa9, 0x5b, 0x01, 0xe5, 0xcf,\n\t0x16, 0x6d, 0x3d, 0xf2, 0xd7, 0x21, 0xca, 0xf9, 0xb2, 0x1e, 0x5f, 0xb1, 0x4c, 0x61, 0x68, 0x71,\n\t0xfd, 0x84, 0xc5, 0x4f, 0x9d, 0x65, 0xb2, 0x83, 0x19, 0x6c, 0x7f, 0xe4, 0xf6, 0x05, 0x53, 0xeb,\n\t0xf3, 0x9c, 0x64, 0x02, 0xc4, 0x22, 0x34, 0xe3, 0x2a, 0x35, 0x6b, 0x3e, 0x76, 0x43, 0x12, 0xa6,\n\t0x1a, 0x55, 0x32, 0x05, 0x57, 0x16, 0xea, 0xd6, 0x96, 0x25, 0x68, 0xf8, 0x7d, 0x3f, 0x3f, 0x77,\n\t0x04, 0xc6, 0xa8, 0xd1, 0xbc, 0xd1, 0xbf, 0x4d, 0x50, 0xd6, 0x15, 0x4b, 0x6d, 0xa7, 0x31, 0xb1,\n\t0x87, 0xb5, 0x8d, 0xfd, 0x72, 0x8a, 0xfa, 0x36, 0x75, 0x7a, 0x79, 0x7a, 0xc1, 0x88, 0xd1]\n\nproperty TV3_enc_correct = ChaCha20_enc_correct TV3_enc_Key TV3_enc_Nonce TV3_enc_BlockCounter TV3_enc_plaintext TV3_enc_ciphertext\n\nproperty all_enc_tests_correct =\n\tTV1_enc_correct \/\\\n\tTV2_enc_correct \/\\\n\tTV3_enc_correct\n```\n\n## Poly1305 Message Authentication Code\n\n```cryptol\npoly1305_MAC_correct key text tag = Poly1305 key text == tag\n```\n\n### Test Vector #1\n\n```cryptol\nTV1_MAC_Key = zero:[256]\n\nTV1_MAC_text = zero:[64][8]\n\nTV1_MAC_tag = zero : [16][8]\n\nproperty TV1_MAC_correct = poly1305_MAC_correct TV1_MAC_Key TV1_MAC_text TV1_MAC_tag\n```\n\n### Test Vector #2\n\n```cryptol\nreused_key = [0x36, 0xe5, 0xf6, 0xb5, 0xc5, 0xe0, 0x60, 0x70, 0xf0, 0xef, 0xca, 0x96, 0x22, 0x7a, 0x86, 0x3e]\nTV2_MAC_Key = zero # join(reused_key):[256]\n\nTV2_MAC_text = IETF_submission_text\n\nTV2_MAC_tag = reused_key: [16][8]\n\nproperty TV2_MAC_correct = poly1305_MAC_correct TV2_MAC_Key TV2_MAC_text TV2_MAC_tag\n```\n\n### Test Vector #3\n\n```cryptol\nTV3_MAC_Key = join(reused_key) # 0:[256]\n\nTV3_MAC_text = IETF_submission_text\n\nTV3_MAC_tag = [0xf3, 0x47, 0x7e, 0x7c, 0xd9, 0x54, 0x17, 0xaf, 0x89, 0xa6, 0xb8, 0x79, 0x4c, 0x31, 0x0c, 0xf0]: [16][8]\n\nproperty TV3_MAC_correct = poly1305_MAC_correct TV3_MAC_Key TV3_MAC_text TV3_MAC_tag\n```\n\n### Test Vector #4\n\n```cryptol\nTV4_MAC_Key =  join(\n\t[0x1c, 0x92, 0x40, 0xa5, 0xeb, 0x55, 0xd3, 0x8a, 0xf3, 0x33, 0x88, 0x86, 0x04, 0xf6, 0xb5, 0xf0,\n\t 0x47, 0x39, 0x17, 0xc1, 0x40, 0x2b, 0x80, 0x09, 0x9d, 0xca, 0x5c, 0xbc, 0x20, 0x70, 0x75, 0xc0]):[256]\n\nTV4_MAC_text = jabberwock_text\n\nTV4_MAC_tag = [0x45, 0x41, 0x66, 0x9a, 0x7e, 0xaa, 0xee, 0x61, 0xe7, 0x08, 0xdc, 0x7c, 0xbc, 0xc5, 0xeb, 0x62]: [16][8]\n\nproperty TV4_MAC_correct = poly1305_MAC_correct TV4_MAC_Key TV4_MAC_text TV4_MAC_tag\n```\n\n### Test Vector #5\n\nIf one uses 130-bit partial reduction, does the code\nhandle the case where partially reduced final result is not fully\nreduced?\n\n```cryptol\n\nTV5_MAC_Key =  0x02 # zero:[256]\n\nFF_16 = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]\nTV5_MAC_text = FF_16\n\nTV5_MAC_tag = split(0x03 # zero): [16][8]\n\nproperty TV5_MAC_correct = poly1305_MAC_correct TV5_MAC_Key TV5_MAC_text TV5_MAC_tag\n```\n\n### Test Vector #6\n\nWhat happens if addition of s overflows modulo 2^128?\n\n```cryptol\nTV6_MAC_Key =  0x02 # zero # join(FF_16):[256]\n\nTV6_MAC_text = split(0x02 # zero) : [16][8]\n\nTV6_MAC_tag = split(0x03 # 0): [16][8]\n\nproperty TV6_MAC_correct = poly1305_MAC_correct TV6_MAC_Key TV6_MAC_text TV6_MAC_tag\n```\n\n### Test Vector #7\n\nWhat happens if data limb is all ones and there is\ncarry from lower limb?\n\n```cryptol\n\nTV7_MAC_Key =  0x01 # zero:[256]\n\nTV7_MAC_text = [\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n\nTV7_MAC_tag = split(0x05 # zero): [16][8]\n\nproperty TV7_MAC_correct = poly1305_MAC_correct TV7_MAC_Key TV7_MAC_text TV7_MAC_tag\n```\n\n### Test Vector #8\n\nWhat happens if final result from polynomial part is\nexactly 2^130-5?\n\n```cryptol\n\nTV8_MAC_Key =  0x01 # zero:[256]\n\nTV8_MAC_text = [\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFB, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01]\n\nTV8_MAC_tag = split(zero): [16][8]\n\nproperty TV8_MAC_correct = poly1305_MAC_correct TV8_MAC_Key TV8_MAC_text TV8_MAC_tag\n```\n\n### Test Vector #9\n\nWhat happens if final result from polynomial part is\nexactly 2^130-6?\n\n```cryptol\n\nTV9_MAC_Key =  0x02 # zero:[256]\n\nTV9_MAC_text =\n\t[0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]\n\nTV9_MAC_tag = [0xFA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]: [16][8]\n\nproperty TV9_MAC_correct = poly1305_MAC_correct TV9_MAC_Key TV9_MAC_text TV9_MAC_tag\n```\n\n### Test Vector #10\n\nWhat happens if 5*H+L-type reduction produces 131-\nbit intermediate result?\n\n```cryptol\n\nTV10_MAC_Key =  join([0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) # 0 :[256]\n\nTV10_MAC_text = [\n\t0xE3, 0x35, 0x94, 0xD7, 0x50, 0x5E, 0x43, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x33, 0x94, 0xD7, 0x50, 0x5E, 0x43, 0x79, 0xCD, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n\nTV10_MAC_tag = [0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]: [16][8]\n\nproperty TV10_MAC_correct = poly1305_MAC_correct TV10_MAC_Key TV10_MAC_text TV10_MAC_tag\n```\n\n### Test Vector #11\n\nWhat happens if 5*H+L-type reduction produces 131-\nbit final result?\n\n```cryptol\n\nTV11_MAC_Key =  join([0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) # 0 :[256]\n\nTV11_MAC_text = [\n\t0xE3, 0x35, 0x94, 0xD7, 0x50, 0x5E, 0x43, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x33, 0x94, 0xD7, 0x50, 0x5E, 0x43, 0x79, 0xCD, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n\nTV11_MAC_tag = split(0x13 # 0): [16][8]\n\nproperty TV11_MAC_correct = poly1305_MAC_correct TV11_MAC_Key TV11_MAC_text TV11_MAC_tag\n\nproperty all_MAC_tests_correct =\n\tTV1_MAC_correct \/\\\n\tTV2_MAC_correct \/\\\n\tTV3_MAC_correct \/\\\n\tTV4_MAC_correct \/\\\n\tTV5_MAC_correct \/\\\n\tTV6_MAC_correct \/\\\n\tTV7_MAC_correct \/\\\n\tTV8_MAC_correct \/\\\n\tTV9_MAC_correct \/\\\n\tTV10_MAC_correct \/\\\n\tTV11_MAC_correct\n\n```\n\n## Poly1305 Key Generation Using ChaCha20\n\n```cryptol\nPoly1305_key_correct key nonce otk = GeneratePolyKeyUsingChaCha key nonce 0 == otk\n```\n\n### Test Vector #1\n\n```cryptol\nTV1_key_Key = zero:ChaChaKey\nTV1_key_Nonce = zero:[96]\n\nTV1_key_OneTimeKey = join([\n\t0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90, 0x40, 0x5d, 0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28,\n\t0xbd, 0xd2, 0x19, 0xb8, 0xa0, 0x8d, 0xed, 0x1a, 0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77, 0x0d, 0xc7])\n\nproperty TV1_key_correct = Poly1305_key_correct TV1_key_Key TV1_key_Nonce TV1_key_OneTimeKey\n```\n\n### Test Vector #2\n\n```cryptol\nTV2_key_Key = zero # 0x01:ChaChaKey\nTV2_key_Nonce = zero # 0x02:[96]\n\nTV2_key_OneTimeKey = join([\n\t0xec, 0xfa, 0x25, 0x4f, 0x84, 0x5f, 0x64, 0x74, 0x73, 0xd3, 0xcb, 0x14, 0x0d, 0xa9, 0xe8, 0x76,\n\t0x06, 0xcb, 0x33, 0x06, 0x6c, 0x44, 0x7b, 0x87, 0xbc, 0x26, 0x66, 0xdd, 0xe3, 0xfb, 0xb7, 0x39])\n\nproperty TV2_key_correct = Poly1305_key_correct TV2_key_Key TV2_key_Nonce TV2_key_OneTimeKey\n```\n\n### Test Vector #3\n\n```cryptol\nTV3_key_Key = join([\n\t0x1c, 0x92, 0x40, 0xa5, 0xeb, 0x55, 0xd3, 0x8a, 0xf3, 0x33, 0x88, 0x86, 0x04, 0xf6, 0xb5, 0xf0,\n\t0x47, 0x39, 0x17, 0xc1, 0x40, 0x2b, 0x80, 0x09, 0x9d, 0xca, 0x5c, 0xbc, 0x20, 0x70, 0x75, 0xc0]):ChaChaKey\nTV3_key_Nonce = zero # 0x02:[96]\n\nTV3_key_OneTimeKey = join([\n\t0x96, 0x5e, 0x3b, 0xc6, 0xf9, 0xec, 0x7e, 0xd9, 0x56, 0x08, 0x08, 0xf4, 0xd2, 0x29, 0xf9, 0x4b,\n\t0x13, 0x7f, 0xf2, 0x75, 0xca, 0x9b, 0x3f, 0xcb, 0xdd, 0x59, 0xde, 0xaa, 0xd2, 0x33, 0x10, 0xae])\n\nproperty TV3_key_correct = Poly1305_key_correct TV3_key_Key TV3_key_Nonce TV3_key_OneTimeKey\n\nproperty all_key_tests_correct =\n\tTV1_key_correct \/\\\n\tTV2_key_correct \/\\\n\tTV3_key_correct\n```\n\n## ChaCha20-Poly1305 AEAD Decryption\n\nBelow we\u2019ll see decrypting a message. We receive a ciphertext, a\nnonce, and a tag. We know the key. We will check the tag, and then\n(assuming that it validates) decrypt the ciphertext. In this\nparticular protocol, we\u2019ll assume that there is no padding of the\nplaintext.\n\n```cryptol\nAEAD_correct key nonce cipherText tag AAD = ptMatches where\n    opt        = AEAD_CHACHA20_POLY1305_DECRYPT key nonce cipherText AAD\n    cipherText = (AEAD_CHACHA20_POLY1305 key nonce AeadPt AAD)\n    ptMatches  = optFold False (\\pt -> tag == pt) opt\n```\n\n```cryptol\n\/\/known\nTV1_AEAD_key = join([\n\t0x1c, 0x92, 0x40, 0xa5, 0xeb, 0x55, 0xd3, 0x8a, 0xf3, 0x33, 0x88, 0x86, 0x04, 0xf6, 0xb5, 0xf0,\n\t0x47, 0x39, 0x17, 0xc1, 0x40, 0x2b, 0x80, 0x09, 0x9d, 0xca, 0x5c, 0xbc, 0x20, 0x70, 0x75, 0xc0])\n\n\/\/sent\nTV1_AEAD_nonce = join([0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08])\n\n\/\/sent\nTV1_AEAD_AAD = [0xf3, 0x33, 0x88, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x91]\n\n\/\/\tcalculated\nTV1_AEAD_known_otk = join([\n\t0xbd, 0xf0, 0x4a, 0xa9, 0x5c, 0xe4, 0xde, 0x89, 0x95, 0xb1, 0x4b, 0xb6, 0xa1, 0x8f, 0xec, 0xaf,\n\t0x26, 0x47, 0x8f, 0x50, 0xc0, 0x54, 0xf5, 0x63, 0xdb, 0xc0, 0xa2, 0x1e, 0x26, 0x15, 0x72, 0xaa])\n\n\/\/sent\nTV1_AEAD_tag = [0xee, 0xad, 0x9d, 0x67, 0x89, 0x0c, 0xbb, 0x22, 0x39, 0x23, 0x36, 0xfe, 0xa1, 0x85, 0x1f, 0x38]\n\nTV1_AEAD_cipherText = [\n\t0x64, 0xa0, 0x86, 0x15, 0x75, 0x86, 0x1a, 0xf4, 0x60, 0xf0, 0x62, 0xc7, 0x9b, 0xe6, 0x43, 0xbd,\n\t0x5e, 0x80, 0x5c, 0xfd, 0x34, 0x5c, 0xf3, 0x89, 0xf1, 0x08, 0x67, 0x0a, 0xc7, 0x6c, 0x8c, 0xb2,\n\t0x4c, 0x6c, 0xfc, 0x18, 0x75, 0x5d, 0x43, 0xee, 0xa0, 0x9e, 0xe9, 0x4e, 0x38, 0x2d, 0x26, 0xb0,\n\t0xbd, 0xb7, 0xb7, 0x3c, 0x32, 0x1b, 0x01, 0x00, 0xd4, 0xf0, 0x3b, 0x7f, 0x35, 0x58, 0x94, 0xcf,\n\t0x33, 0x2f, 0x83, 0x0e, 0x71, 0x0b, 0x97, 0xce, 0x98, 0xc8, 0xa8, 0x4a, 0xbd, 0x0b, 0x94, 0x81,\n\t0x14, 0xad, 0x17, 0x6e, 0x00, 0x8d, 0x33, 0xbd, 0x60, 0xf9, 0x82, 0xb1, 0xff, 0x37, 0xc8, 0x55,\n\t0x97, 0x97, 0xa0, 0x6e, 0xf4, 0xf0, 0xef, 0x61, 0xc1, 0x86, 0x32, 0x4e, 0x2b, 0x35, 0x06, 0x38,\n\t0x36, 0x06, 0x90, 0x7b, 0x6a, 0x7c, 0x02, 0xb0, 0xf9, 0xf6, 0x15, 0x7b, 0x53, 0xc8, 0x67, 0xe4,\n\t0xb9, 0x16, 0x6c, 0x76, 0x7b, 0x80, 0x4d, 0x46, 0xa5, 0x9b, 0x52, 0x16, 0xcd, 0xe7, 0xa4, 0xe9,\n\t0x90, 0x40, 0xc5, 0xa4, 0x04, 0x33, 0x22, 0x5e, 0xe2, 0x82, 0xa1, 0xb0, 0xa0, 0x6c, 0x52, 0x3e,\n\t0xaf, 0x45, 0x34, 0xd7, 0xf8, 0x3f, 0xa1, 0x15, 0x5b, 0x00, 0x47, 0x71, 0x8c, 0xbc, 0x54, 0x6a,\n\t0x0d, 0x07, 0x2b, 0x04, 0xb3, 0x56, 0x4e, 0xea, 0x1b, 0x42, 0x22, 0x73, 0xf5, 0x48, 0x27, 0x1a,\n\t0x0b, 0xb2, 0x31, 0x60, 0x53, 0xfa, 0x76, 0x99, 0x19, 0x55, 0xeb, 0xd6, 0x31, 0x59, 0x43, 0x4e,\n\t0xce, 0xbb, 0x4e, 0x46, 0x6d, 0xae, 0x5a, 0x10, 0x73, 0xa6, 0x72, 0x76, 0x27, 0x09, 0x7a, 0x10,\n\t0x49, 0xe6, 0x17, 0xd9, 0x1d, 0x36, 0x10, 0x94, 0xfa, 0x68, 0xf0, 0xff, 0x77, 0x98, 0x71, 0x30,\n\t0x30, 0x5b, 0xea, 0xba, 0x2e, 0xda, 0x04, 0xdf, 0x99, 0x7b, 0x71, 0x4d, 0x6c, 0x6f, 0x2c, 0x29,\n\t0xa6, 0xad, 0x5c, 0xb4, 0x02, 0x2b, 0x02, 0x70, 0x9b]\n\nTV1_AEAD_Poly_input = [\n\t0xf3, 0x33, 0x88, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x91, 0x00, 0x00, 0x00, 0x00,\n\t0x64, 0xa0, 0x86, 0x15, 0x75, 0x86, 0x1a, 0xf4, 0x60, 0xf0, 0x62, 0xc7, 0x9b, 0xe6, 0x43, 0xbd,\n\t0x5e, 0x80, 0x5c, 0xfd, 0x34, 0x5c, 0xf3, 0x89, 0xf1, 0x08, 0x67, 0x0a, 0xc7, 0x6c, 0x8c, 0xb2,\n\t0x4c, 0x6c, 0xfc, 0x18, 0x75, 0x5d, 0x43, 0xee, 0xa0, 0x9e, 0xe9, 0x4e, 0x38, 0x2d, 0x26, 0xb0,\n\t0xbd, 0xb7, 0xb7, 0x3c, 0x32, 0x1b, 0x01, 0x00, 0xd4, 0xf0, 0x3b, 0x7f, 0x35, 0x58, 0x94, 0xcf,\n\t0x33, 0x2f, 0x83, 0x0e, 0x71, 0x0b, 0x97, 0xce, 0x98, 0xc8, 0xa8, 0x4a, 0xbd, 0x0b, 0x94, 0x81,\n\t0x14, 0xad, 0x17, 0x6e, 0x00, 0x8d, 0x33, 0xbd, 0x60, 0xf9, 0x82, 0xb1, 0xff, 0x37, 0xc8, 0x55,\n\t0x97, 0x97, 0xa0, 0x6e, 0xf4, 0xf0, 0xef, 0x61, 0xc1, 0x86, 0x32, 0x4e, 0x2b, 0x35, 0x06, 0x38,\n\t0x36, 0x06, 0x90, 0x7b, 0x6a, 0x7c, 0x02, 0xb0, 0xf9, 0xf6, 0x15, 0x7b, 0x53, 0xc8, 0x67, 0xe4,\n\t0xb9, 0x16, 0x6c, 0x76, 0x7b, 0x80, 0x4d, 0x46, 0xa5, 0x9b, 0x52, 0x16, 0xcd, 0xe7, 0xa4, 0xe9,\n\t0x90, 0x40, 0xc5, 0xa4, 0x04, 0x33, 0x22, 0x5e, 0xe2, 0x82, 0xa1, 0xb0, 0xa0, 0x6c, 0x52, 0x3e,\n\t0xaf, 0x45, 0x34, 0xd7, 0xf8, 0x3f, 0xa1, 0x15, 0x5b, 0x00, 0x47, 0x71, 0x8c, 0xbc, 0x54, 0x6a,\n\t0x0d, 0x07, 0x2b, 0x04, 0xb3, 0x56, 0x4e, 0xea, 0x1b, 0x42, 0x22, 0x73, 0xf5, 0x48, 0x27, 0x1a,\n\t0x0b, 0xb2, 0x31, 0x60, 0x53, 0xfa, 0x76, 0x99, 0x19, 0x55, 0xeb, 0xd6, 0x31, 0x59, 0x43, 0x4e,\n\t0xce, 0xbb, 0x4e, 0x46, 0x6d, 0xae, 0x5a, 0x10, 0x73, 0xa6, 0x72, 0x76, 0x27, 0x09, 0x7a, 0x10,\n\t0x49, 0xe6, 0x17, 0xd9, 0x1d, 0x36, 0x10, 0x94, 0xfa, 0x68, 0xf0, 0xff, 0x77, 0x98, 0x71, 0x30,\n\t0x30, 0x5b, 0xea, 0xba, 0x2e, 0xda, 0x04, 0xdf, 0x99, 0x7b, 0x71, 0x4d, 0x6c, 0x6f, 0x2c, 0x29,\n\t0xa6, 0xad, 0x5c, 0xb4, 0x02, 0x2b, 0x02, 0x70, 0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n```\n\nFirst, we calculate the one-time Poly1305 key\n\n```cryptol\n\n\/\/generate and check the one time key (leaving out the given states from the document, they will be correct if this is correct)\nproperty TV1_otk_correct = Poly1305_key_correct TV1_AEAD_key TV1_AEAD_nonce TV1_AEAD_known_otk\n\n```\n\nNext, we construct the AEAD buffer\n\n```cryptol\n\/\/ Helper macros for further properties\npoly_input_correct AeadAAD cipherText result = (AeadConstruction AeadAAD cipherText) == result\n\nproperty TV1_poly_input_correct = (poly_input_correct TV1_AEAD_AAD TV1_AEAD_cipherText TV1_AEAD_Poly_input)\n```\n\nWe calculate the Poly1305 tag and find that it matches\n\n```cryptol\nproperty TV1_tag_correct = poly1305_MAC_correct TV1_AEAD_known_otk (AeadConstruction TV1_AEAD_AAD TV1_AEAD_cipherText) TV1_AEAD_tag\n```\n\n```cryptol\nTV1_plaintext = [\n\t0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x2d, 0x44, 0x72, 0x61, 0x66, 0x74, 0x73, 0x20,\n\t0x61, 0x72, 0x65, 0x20, 0x64, 0x72, 0x61, 0x66, 0x74, 0x20, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65,\n\t0x6e, 0x74, 0x73, 0x20, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x20,\n\t0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x69, 0x78, 0x20, 0x6d,\n\t0x6f, 0x6e, 0x74, 0x68, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65,\n\t0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x2c, 0x20, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x63,\n\t0x65, 0x64, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x6f, 0x62, 0x73, 0x6f, 0x6c, 0x65, 0x74, 0x65, 0x64,\n\t0x20, 0x62, 0x79, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65,\n\t0x6e, 0x74, 0x73, 0x20, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2e,\n\t0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x70, 0x72,\n\t0x69, 0x61, 0x74, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x75, 0x73, 0x65, 0x20, 0x49, 0x6e, 0x74, 0x65,\n\t0x72, 0x6e, 0x65, 0x74, 0x2d, 0x44, 0x72, 0x61, 0x66, 0x74, 0x73, 0x20, 0x61, 0x73, 0x20, 0x72,\n\t0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x6d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61,\n\t0x6c, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x69, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65,\n\t0x6d, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x61, 0x73, 0x20,\n\t0x2f, 0xe2, 0x80, 0x9c, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x69, 0x6e, 0x20, 0x70, 0x72, 0x6f, 0x67,\n\t0x72, 0x65, 0x73, 0x73, 0x2e, 0x2f, 0xe2, 0x80, 0x9d]\n\n\nTV1_calculate_plaintext = AEAD_CHACHA20_POLY1305_DECRYPT TV1_AEAD_key TV1_AEAD_nonce (TV1_AEAD_cipherText # TV1_AEAD_tag) TV1_AEAD_AAD\n\nproperty TV1_plaintext_correct = ptMatches where\n\topt       = TV1_calculate_plaintext\n\tptMatches = optFold False (\\pt -> pt == TV1_plaintext) opt\n\nproperty decryption_vector_correct =\n\tTV1_plaintext_correct \/\\\n\tTV1_tag_correct \/\\\n\tTV1_otk_correct\n\n\nproperty all_test_vectors_correct =\n  all_block_tests_correct \/\\\n  all_enc_tests_correct \/\\\n  all_MAC_tests_correct \/\\\n  all_key_tests_correct \/\\\n  decryption_vector_correct\n```\n\n\n# Appendix: Utility functions\n\n```cryptol\nindexOf e (xs:[a+1]_) = ixs ! 0 where\n    ixs = [ 0 ] #\n                 [ if ix == e then j else old\n                 | ix <- xs\n                 | j <- [ 0 .. a ]\n                 | old <- ixs\n                 ]\n\nToLittleEndian : ChaChaState -> ChaChaState\nToLittleEndian s = [littleendian (split words) | words <- s]\n\n\/\/ Takes a finite sequence of bytes, and turns them into a word via\n\/\/ a little-endian interpretation\nlittleendian : {a}(fin a) => [a][8] -> [a*8]\nlittleendian b = join(reverse b)\n\n\/\/ Converts a bytestring encoded like \"fe:ed:fa:ce.\" into a sequence of bytes\n\/\/ Note: the trailing punctuation is needed\nparseHexString : {n} (fin n) => [3*n][8] -> [n][8]\nparseHexString hexString = [ charsToByte (take`{2} cs) | cs <- groupBy`{3} hexString ] where\n    charsToByte : [2][8] -> [8]\n    charsToByte [ ub, lb ] = (charToByte ub) << 4 || (charToByte lb)\n    charToByte c = if c >= '0' \/\\ c <= '9' then c-'0'\n                   | c >= 'a' \/\\ c <= 'f' then 10+(c-'a')\n                   else 0     \/\/ error case\n\nproperty parseHexString_check =\n    join (parseHexString\n        (\"00:01:02:03:04:05:06:07:08:09:0a:0b:0c:0d:0e:0f:10:11:12:13:\" #\n         \"14:15:16:17:18:19:1a:1b:1c:1d:1e:1f.\")) ==\n    0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n\nproperty AllPropertiesPass =\n    ChaChaQuarterround_passes_test \/\\\n    ChaChaQuarterround_passes_column_test \/\\\n    FirstRow_correct \/\\\n    BuildState_correct \/\\\n    ChaChaStateAfter20_correct \/\\\n    ChaCha20_test1 \/\\\n    SunscreenBuildState_correct \/\\\n    SunscreenBuildState2_correct \/\\\n    SunscreenBlock1_correct \/\\\n    SunscreenBlock2_correct \/\\\n    SunscreenKeystream_correct SunscreenKeystream \/\\\n    ChaCha_encrypt_sunscreen_correct \/\\\n    Sunscreen_decrypt_correct \/\\\n    poly1306Sokay \/\\\n    polyBlocksOK \/\\\n    Poly1305_passes_test \/\\\n    PolyBuildState_correct \/\\\n    PolyChaCha_correct \/\\\n    Poly_passes_test \/\\\n    AeadPolyKeyBuildState_correct \/\\\n    AeadPolyChaCha_correct \/\\\n    poly1305Test_correct \/\\\n    AeadTag_correct \/\\\n    AeadConstruction_correct \/\\\n    AeadDecrypt_correct \/\\\n    parseHexString_check \/\\\n    all_test_vectors_correct\n\n```\n\nSince this file is literate Cryptol, the properties above can be checked\nby loading it into a Cryptol interpreter, and running the AllPropertiesPass\nfunction, like this:\n\n```example\n$ cryptol ChaChaPolyCryptolIETF.md\n                        _        _\n   ___ _ __ _   _ _ __ | |_ ___ | |\n  \/ __| '__| | | | '_ \\| __\/ _ \\| |\n | (__| |  | |_| | |_) | || (_) | |\n  \\___|_|   \\__, | .__\/ \\__\\___\/|_|\n            |___\/|_| version 2.0.0 (62acc96)\n\nLoading module Cryptol\nLoading module ChaCha20\n... a bunch of warnings about the use of ambiguous-width constants\nChaCha20> AllPropertiesPass\nTrue\n```\nThis check verifies the implementation of `ChaCha`, `Poly1305` and the `AEAD`\nconstruction all work with the provided test vectors.","variant":null,"set":"supervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/SIV_rfc5297.md","filetype":"txt","content":"module Primitive::Symmetric::Cipher::Authenticated::SIV_rfc5297 where\n\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128 as AES128\n\ntype Key = [AES128::KeySize]\n```\n\n\nSynthetic Initialization Vector (SIV) Authenticated Encryption\nUsing the Advanced Encryption Standard (AES)\n\n\nAbstract\n\n   This memo describes SIV (Synthetic Initialization Vector), a block\n   cipher mode of operation.  SIV takes a key, a plaintext, and multiple\n   variable-length octet strings that will be authenticated but not\n   encrypted.  It produces a ciphertext having the same length as the\n   plaintext and a synthetic initialization vector.  Depending on how it\n   is used, SIV achieves either the goal of deterministic authenticated\n   encryption or the goal of nonce-based, misuse-resistant authenticated\n   encryption.\n\n\n1.  Introduction\n\n1.1.  Background\n\n   Various attacks have been described (e.g., [BADESP]) when data is\n   merely privacy protected and not additionally authenticated or\n   integrity protected.  Therefore, combined modes of encryption and\n   authentication have been developed ([RFC5116], [RFC3610], [GCM],\n   [JUTLA], [OCB]).  These provide conventional authenticated encryption\n   when used with a nonce (\"a number used once\") and typically accept\n   additional inputs that are authenticated but not encrypted,\n   hereinafter referred to as \"associated data\" or AD.\n\n   A deterministic, nonce-less, form of authenticated encryption has\n   been used to protect the transportation of cryptographic keys (e.g.,\n   [X9F1], [RFC3217], [RFC3394]).  This is generally referred to as \"Key\n   Wrapping\".\n\n   This memo describes a new block cipher mode, SIV, that provides both\n   nonce-based authenticated encryption as well as deterministic, nonce-\n   less key wrapping.  It contains a Pseudo-Random Function (PRF)\n   construction called S2V and an encryption\/decryption construction,\n   called CTR.  SIV was specified by Phillip Rogaway and Thomas\n   Shrimpton in [DAE].  The underlying block cipher used herein for both\n   S2V and CTR is AES with key lengths of 128 bits, 192 bits, or 256\n   bits.  S2V uses AES in Cipher-based Message Authentication Code\n   ([CMAC]) mode, CTR uses AES in counter ([MODES]) mode.\n\n   Associated data is data input to an authenticated-encryption mode\n   that will be authenticated but not encrypted.  [RFC5116] says that\n   associated data can include \"addresses, ports, sequence numbers,\n   protocol version numbers, and other fields that indicate how the\n   plaintext or ciphertext should be handled, forwarded, or processed\".\n   These are multiple, distinct inputs and may not be contiguous.  Other\n   authenticated-encryption cipher modes allow only a single associated\n   data input.  Such a limitation may require implementation of a\n   scatter\/gather form of data marshalling to combine the multiple\n   components of the associated data into a single input or may require\n   a pre-processing step where the associated data inputs are\n   concatenated together.  SIV accepts multiple variable-length octet\n   strings (hereinafter referred to as a \"vector of strings\") as\n   associated data inputs.  This obviates the need for data marshalling\n   or pre-processing of associated data to package it into a single\n   input.\n\n   By allowing associated data to consist of a vector of strings SIV\n   also obviates the requirement to encode the length of component\n   fields of the associated data when those fields have variable length.\n\n1.2.  Definitions\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC 2119 [RFC2119].\n\n1.3.  Motivation\n\n1.3.1.  Key Wrapping\n\n   A key distribution protocol must protect keys it is distributing.\n   This has not always been done correctly.  For example, RADIUS\n   [RFC2865] uses Microsoft Point-to-Point Encryption (MPPE) [RFC2548]\n   to encrypt a key prior to transmission from server to client.  It\n   provides no integrity checking of the encrypted key.  [RADKEY]\n   specifies the use of [RFC3394] to wrap a key in a RADIUS request but\n   because of the inability to pass associated data, a Hashed Message\n   Authentication Code (HMAC) [RFC2104] is necessary to provide\n   authentication of the entire request.\n\n   SIV can be used as a drop-in replacement for any specification that\n   uses [RFC3394] or [RFC3217], including the aforementioned use.  It is\n   a more general purpose solution as it allows for associated data to\n   be specified.\n\n1.3.2.  Resistance to Nonce Misuse\/Reuse\n\n   The nonce-based authenticated encryption schemes described above are\n   susceptible to reuse and\/or misuse of the nonce.  Depending on the\n   specific scheme there are subtle and critical requirements placed on\n   the nonce (see [SP800-38D]).  [GCM] states that it provides\n   \"excellent security\" if its nonce is guaranteed to be distinct but\n   provides \"no security\" otherwise.  Confidentiality guarantees are\n   voided if a counter in [RFC3610] is reused.  In many cases,\n   guaranteeing no reuse of a nonce\/counter\/IV is not a problem, but in\n   others it will be.\n\n   For example, many applications obtain access to cryptographic\n   functions via an application program interface to a cryptographic\n   library.  These libraries are typically not stateful and any nonce,\n   initialization vector, or counter required by the cipher mode is\n   passed to the cryptographic library by the application.  Putting the\n   construction of a security-critical datum outside the control of the\n   encryption engine places an onerous burden on the application writer\n   who may not provide the necessary cryptographic hygiene.  Perhaps his\n   random number generator is not very good or maybe an application\n   fault causes a counter to be reset.  The fragility of the cipher mode\n   may result in its inadvertent misuse.  Also, if one's environment is\n   (knowingly or unknowingly) a virtual machine, it may be possible to\n   roll back a virtual state machine and cause nonce reuse thereby\n   gutting the security of the authenticated encryption scheme (see\n   [VIRT]).\n\n   If the nonce is random, a requirement that it never repeat will limit\n   the amount of data that can be safely protected with a single key to\n   one block.  More sensibly, a random nonce is required to \"almost\n   always\" be non-repeating, but that will drastically limit the amount\n   of data that can be safely protected.\n\n   SIV provides a level of resistance to nonce reuse and misuse.  If the\n   nonce is never reused, then the usual notion of nonce-based security\n   of an authenticated encryption mode is achieved.  If, however, the\n   nonce is reused, authenticity is retained and confidentiality is only\n   compromised to the extent that an attacker can determine that the\n   same plaintext (and same associated data) was protected with the same\n   nonce and key.  See Security Considerations (Section 7).\n\n1.3.3.  Key Derivation\n\n   A PRF is frequently used as a key derivation function (e.g., [WLAN])\n   by passing it a key and a single string.  Typically, this single\n   string is the concatenation of a series of smaller strings -- for\n   example, a label and some context to bind into the derived string.\n\n   These are usually multiple strings but are mapped to a single string\n   because of the way PRFs are typically defined -- two inputs: a key\n   and data.  Such a crude mapping is inefficient because additional\n   data must be included -- the length of variable-length inputs must be\n   encoded separately -- and, depending on the PRF, memory allocation\n   and copying may be needed.  Also, if only one or two of the inputs\n   changed when deriving a new key, it may still be necessary to process\n   all of the other constants that preceded it every time the PRF is\n   invoked.\n\n   When a PRF is used in this manner its input is a vector of strings\n   and not a single string and the PRF should handle the data as such.\n   The S2V (\"string to vector\") PRF construction accepts a vector of\n   inputs and provides a more natural mapping of input that does not\n   require additional lengths encodings and obviates the memory and\n   processing overhead to marshal inputs and their encoded lengths into\n   a single string.  Constant inputs to the PRF need only be computed\n   once.\n\n1.3.4.  Robustness versus Performance\n\n   SIV cannot perform at the same high throughput rates that other\n   authenticated encryption schemes can (e.g., [GCM] or [OCB]) due to\n   the requirement for two passes of the data, but for situations where\n   performance is not a limiting factor -- e.g., control plane\n   applications -- it can provide a robust alternative, especially when\n   considering its resistance to nonce reuse.\n\n1.3.5.  Conservation of Cryptographic Primitives\n\n   The cipher mode described herein can do authenticated encryption, key\n   wrapping, key derivation, and serve as a generic message\n   authentication algorithm.  It is therefore possible to implement all\n   these functions with a single tool, instead of one tool for each\n   function.  This is extremely attractive for devices that are memory\n   and\/or processor constrained and that cannot afford to implement\n   multiple cryptographic primitives to accomplish these functions.\n\n2.  Specification of SIV\n\n2.1.  Notation\n\n   SIV and S2V use the following notation:\n\n   len(A)\n      returns the number of bits in A.\n\n   pad(X)\n      indicates padding of string X, len(X) < 128, out to 128 bits by\n      the concatenation of a single bit of 1 followed by as many 0 bits\n      as are necessary.\n\n```\npad : {x} (fin x) => [x] -> [128]\npad x = take `{128} (x # [True] # (zero : [127]))\n```\n\n   leftmost(A,n)\n      the n most significant bits of A.\n\n   rightmost(A,n)\n      the n least significant bits of A.\n\n   A || B\n      means concatenation of string A with string B.\n\n   A xor B\n      is the exclusive OR operation on two equal length strings, A and\n      B.\n\n   A xorend B\n      where len(A) >= len(B), means xoring a string B onto the end of\n      string A -- i.e., leftmost(A, len(A)-len(B)) || (rightmost(A,\n      len(B)) xor B).\n\n```\nxorend : {a,b} (fin a, fin b, a >= b) => [a] -> [b] -> [a]\nxorend a b = a ^ ((zero : [a-b]) # b)\n```\n\n   A bitand B\n      is the logical AND operation on two equal length strings, A and B.\n\n```\nbitand a b = a && b\n```\n\n   dbl(S)\n      is the multiplication of S and 0...010 in the finite field\n      represented using the primitive polynomial\n      x^128 + x^7 + x^2 + x + 1.  See Doubling (Section 2.3).\n\n   a^b\n      indicates a string that is \"b\" bits, each having the value \"a\".\n\n```\n\/\/ In cryptol tye symbole '^' is taken, we will use the native name 'repeat'\n\/\/ instead. This should not lead to errors due to the different types, which\n\/\/ the compiler would detect if one operation were used in place of the other.\n```\n\n   <zero>\n      indicates a string that is 128 zero bits.\n\n   <one>\n      indicates a string that is 127 zero bits concatenated with a\n      single one bit, that is 0^127 || 1^1.\n\n   A\/B\n      indicates the greatest integer less than or equal to the real-\n      valued quotient of A and B.\n\n   E(K,X)\n      indicates AES encryption of string X using key K.\n\n```\nE : (Key,[128]) -> [128]\nE(K,X) = AES128::encrypt K X\n\n\/\/ 1. Apply the subkey generation process in Sec. 6.1 to K to produce K1 and K2.\n\/\/ 2. If Mlen = 0, let n = 1; else, let n = \u23a1Mlen\/b\u23a4.\n\/\/ 3. Let M1, M2, ... , Mn-1, Mn* denote the unique sequence of bit strings such that M = M1 || M2 || ... || Mn-1 || Mn*, where M1, M2,..., Mn-1 are complete blocks.\n\/\/ 4. If Mn* is a complete block, let Mn = K1 \u2295 Mn* ; else, let Mn = K2 \u2295 (Mn* ||10j), where j = nb-Mlen-1.\n\/\/ 5. Let C0 = 0b.\n\/\/ 6. For i = 1 to n, let Ci = CIPHK(Ci-1 \u2295 Mi).\n\/\/ 7. Let T = MSBTlen(Cn).\n\/\/ 8. Return T.\n\naesCMAC : {m} (fin m) => Key -> [m] -> [128]\naesCMAC K m =\n    cmacBlocks K ((`m%128) == 0 \/\\ `m > 0) (split `{each=128,parts=blocks} full)\n where\n pd   = [True] # zero : [128]\n full = take `{front=128 * blocks, back = (m + 128) - 128*blocks} (m # pd)\n type blocks = max ((m + 127) \/ 128) 1\n\ncmacBlocks : {blocks} (fin blocks, blocks >= 1) => Key -> Bit -> [blocks][128] -> [128]\ncmacBlocks K completeMn ms = ci ! 0\n  where\n   (K1,K2) = subkeyGen K\n   xs      = take `{back=1} ms\n   mn      = KN ^ (ms ! 0)\n   KN      = if completeMn then K1 else K2\n   ci      = [zero] # [ E(K,c ^ mi) | c <- ci | mi <- (xs # [mn]) ]\n\nproperty cmacKAT1 =\n    and\n    [ aesCMAC 0x2b7e151628aed2a6abf7158809cf4f3c [] == 0xbb1d6929e95937287fa37d129b756746\n    , aesCMAC 0x2b7e151628aed2a6abf7158809cf4f3c 0x6bc1bee22e409f96e93d7e117393172a == 0x070a16b46b4d4144f79bdd9dd04a287c\n    , aesCMAC 0x2b7e151628aed2a6abf7158809cf4f3c 0x6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411 == 0xdfa66747de9ae63030ca32611497c827\n    , aesCMAC 0x2b7e151628aed2a6abf7158809cf4f3c 0x6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710 == 0x51f0bebf7e3b9d92fc49741779363cfe\n    ]\n```\n\n```\n\/\/ 1. Let L = CIPHK(0b).\n\/\/ 2. If MSB1(L) = 0\n\/\/         then K1 = L << 1;\n\/\/         else K1 = (L << 1) \u2295 Rb; see Sec. 5.3 for the definition of Rb.\n\/\/ 3. If MSB1(K1) = 0\n\/\/         then K2 = K1 << 1;\n\/\/         else K2 = (K1 << 1) \u2295 Rb.\n\/\/ 4. Return K1, K2.\nprivate\n subkeyGen : Key -> (Key, Key)\n subkeyGen K = (K1,K2)\n  where\n    L  = E(K,zero)\n    K1 = ite (L@0 == False) (L << 1) ((L << 1) ^ Rb)\n    K2 = ite ((K1@0) == False) (K1 << 1) ((K1 << 1) ^ Rb)\n    Rb = `0b10000111\n\nite : {n} (fin n, n >= 1) => Bit -> [n] -> [n] -> [n]\nite pred t e = t && m1 || e && m2\n where m1 = [pred | _ <- [1..n]]\n       m2 = ~m1\n```\n\n2.2.  Overview\n\n   SIV-AES uses AES in CMAC mode (S2V) and in counter mode (CTR).  SIV-\n   AES takes either a 256-, 384-, or 512-bit key (which is broken up\n   into two equal-sized keys, one for S2V and the other for CTR), a\n   variable length plaintext, and multiple variable-length strings\n   representing associated data.  Its output is a ciphertext that\n   comprises a synthetic initialization vector concatenated with the\n   encrypted plaintext.\n\n2.3.  Doubling\n\n   The doubling operation on a 128-bit input string is performed using a\n   left-shift of the input followed by a conditional xor operation on\n   the result with the constant:\n\n>                   00000000 00000000 00000000 00000087\n\n   The condition under which the xor operation is performed is when the\n   bit being shifted off is one.\n\n   Note that this is the same operation used to generate sub-keys for\n   CMAC-AES.\n\n```\n\/\/ dblRef x = if x@0 == False then (x << 1)\n\/\/                            else (x << 1) ^ `0x87\n\/\/ :prove \\x -> dbl x == (dblRef x : [128])\n\/\/ Q.E.D.\n\ndbl x = ite ((x@0) == False) (x << 1) ((x << 1) ^ `0x87)\n```\n\n2.4.  S2V\n\n   The S2V operation consists of the doubling and xoring of the outputs\n   of a pseudo-random function, CMAC, operating over individual strings\n   in the input vector: S1, S2, ... , Sn.  It is bootstrapped by\n   performing CMAC on a 128-bit string of zeros.  If the length of the\n   final string in the vector is greater than or equal to 128 bits, the\n   output of the double\/xor chain is xored onto the end of the final\n   input string.  That result is input to a final CMAC operation to\n   produce the output V.  If the length of the final string is less than\n   128 bits, the output of the double\/xor chain is doubled once more and\n   it is xored with the final string padded using the padding function\n   pad(X).  That result is input to a final CMAC operation to produce\n   the output V.\n\n   S2V with key K on a vector of n inputs S1, S2, ..., Sn-1, Sn, and\n   len(Sn) >= 128:\n\n>                  +----+       +----+       +------+      +----+\n>                  | S1 |       | S2 | . . . | Sn-1 |      | Sn |\n>                  +----+       +----+       +------+      +----+\n>     <zero>   K     |            |             |             |\n>       |      |     |            |             |             V\n>       V      |     V            V             V    \/----> xorend\n>   +-----+    |  +-----+      +-----+       +-----+ |        |\n>   | AES-|<----->| AES-|  K-->| AES-|  K--->| AES-| |        |\n>   | CMAC|       | CMAC|      | CMAC|       | CMAC| |        |\n>   +-----+       +-----+      +-----+       +-----+ |        V\n>       |           |             |             |    |     +-----+\n>       |           |             |             |    | K-->| AES-|\n>       |           |             |             |    |     | CMAC|\n>       |           |             |             |    |     +-----+\n>       \\-> dbl -> xor -> dbl -> xor -> dbl -> xor---\/        |\n>                                                             V\n>                                                           +---+\n>                                                           | V |\n>                                                           +---+\n>\n>                                 Figure 2\n\n   S2V with key K on a vector of n inputs S1, S2, ..., Sn-1, Sn, and\n   len(Sn) < 128:\n\n>                +----+       +----+       +------+      +---------+\n>                | S1 |       | S2 | . . . | Sn-1 |      | pad(Sn) |\n>                +----+       +----+       +------+      +---------+\n>    <zero>  K     |            |             |               |\n>      |     |     |            |             |               V\n>      V     |     V            V             V     \/------> xor\n>   +-----+  |  +-----+      +-----+       +-----+  |         |\n>   | AES-|<--->| AES-|  K-->| AES-|   K-->| AES-|  |         |\n>   | CMAC|     | CMAC|      | CMAC|       | CMAC|  |         |\n>   +-----+     +-----+      +-----+       +-----+  |         V\n>     |           |             |             |     |      +-----+\n>     |           |             |             |     |  K-->| AES-|\n>     |           |             |             |     |      | CMAC|\n>     |           |             |             |     |      +-----+\n>     \\-> dbl -> xor -> dbl -> xor -> dbl -> xor-> dbl        |\n>                                                             V\n>                                                           +---+\n>                                                           | V |\n>                                                           +---+\n>\n>                                 Figure 3\n\n   Algorithmically S2V can be described as:\n\n>      S2V(K, S1, ..., Sn) {\n>        if n = 0 then\n>          return V = AES-CMAC(K, <one>)\n>        fi\n>        D = AES-CMAC(K, <zero>)\n>        for i = 1 to n-1 do\n>          D = dbl(D) xor AES-CMAC(K, Si)\n>        done\n>        if len(Sn) >= 128 then\n>          T = Sn xorend D\n>        else\n>          T = dbl(D) xor pad(Sn)\n>        fi\n>        return V = AES-CMAC(K, T)\n>      }\n\n```\n\/\/ S2V for n=2\nS2V : {ad, p} (fin ad, fin p) => Key -> [ad] -> [p] -> [128]\nS2V K S1 S2 = res\n where\n D0 = aesCMAC K (zero : [128])\n D1 = dbl D0 ^ aesCMAC K S1\n res  = if `p >= 128\n        then aesCMAC K (xorend (fixSize S2)  D1)\n        else aesCMAC K (dbl D1 ^ pad S2)\n\nprivate\n    \/\/ The length of 'p' is >= 128, but Cryptol lacks\n    \/\/ dependent types and can not infer this fact. We\n    \/\/ Provide a no-op computation that results in a\n    \/\/ new type for 'p' that is at least 128 bits\n    fixSize : {p} (fin p) => [p] -> [max p 128]\n    fixSize p = take `{front=max p 128, back = p + 128 - max p 128} (p # (zero : [128]))\n```\n\n2.5.  CTR\n\n   CTR is a counter mode of AES.  It takes as input a plaintext P of\n   arbitrary length, a key K of length 128, 192, or 256 bits, and a\n   counter X that is 128 bits in length, and outputs Z, which represents\n   a concatenation of a synthetic initialization vector V and the\n   ciphertext C, which is the same length as the plaintext.\n\n   The ciphertext is produced by xoring the plaintext with the first\n   len(P) bits of the following string:\n\n>                 E(K, X) || E(K, X+1) || E(K, X+2) || ...\n\n   Before beginning counter mode, the 31st and 63rd bits (where the\n   rightmost bit is the 0th bit) of the counter are cleared.  This\n   enables implementations that support native 32-bit (64-bit) addition\n   to increment the counter modulo 2^32 (2^64) in a manner that cannot\n   be distinguished from 128-bit increments, as long as the number of\n   increment operations is limited by an upper bound that safely avoids\n   carry to occur out of the respective pre-cleared bit.  More formally,\n   for 32-bit addition, the counter is incremented as:\n\n>      SALT=leftmost(X,96)\n>\n>      n=rightmost(X,32)\n>\n>      X+i = SALT || (n + i mod 2^32).\n\n   For 64-bit addition, the counter is incremented as:\n\n>      SALT=leftmost(X,64)\n>\n>      n=rightmost(X,64)\n>\n>      X+i = SALT || (n + i mod 2^64).\n\n   Performing 32-bit or 64-bit addition on the counter will limit the\n   amount of plaintext that can be safely protected by SIV-AES to 2^39 -\n   128 bits or 2^71 - 128 bits, respectively.\n\n```\nctr32 : {n} (2^^39 - 128 >= n) => Key -> [128] -> [n] -> [n]\nctr32 k iv pt = pt ^ take stream\n where\n stream = join [E(k,v) | v <- ivs]\n ivs    = [take `{96} iv # cnt + i | i <- [0...]]\n cnt    = drop `{back=32} iv\n\nctr64 : {n} (2^^71 - 128 >= n) => Key -> [128] -> [n] -> [n]\nctr64 k iv pt = pt ^ take stream\n where\n stream = join [E(k,v) | v <- ivs]\n ivs    = [take `{64} iv # cnt + i | i <- [0...]]\n cnt    = drop `{back=64} iv\n```\n\n2.6.  SIV Encrypt\n\n   SIV-encrypt takes as input a key K of length 256, 384, or 512 bits,\n   plaintext of arbitrary length, and a vector of associated data AD[ ]\n   where the number of components in the vector is not greater than 126\n   (see Section 7).  It produces output, Z, which is the concatenation\n   of a 128-bit synthetic initialization vector and ciphertext whose\n   length is equal to the length of the plaintext.\n\n   The key is split into equal halves, K1 = leftmost(K, len(K)\/2) and K2\n   = rightmost(K, len(K)\/2).  K1 is used for S2V and K2 is used for CTR.\n\n   In the encryption mode, the associated data and plaintext represent\n   the vector of inputs to S2V, with the plaintext being the last string\n   in the vector.  The output of S2V is a synthetic IV that represents\n   the initial counter to CTR.\n\n   The encryption construction of SIV is as follows:\n\n>    +------+ +------+   +------+              +---+\n>    | AD 1 | | AD 2 |...| AD n |              | P |\n>    +------+ +------+   +------+              +---+\n>       |         |         |                    |\n>       |         |   ...   |  ------------------|\n>       \\         |        \/  \/                  |\n>        \\        |       \/  \/ +------------+    |\n>         \\       |      \/  \/  | K = K1||K2 |    |\n>          \\      |     \/  \/   +------------+    V\n>           \\     |    \/  \/      |     |       +-----+\n>            \\    |   \/  \/   K1  |     |  K2   |     |\n>             \\   |  \/  \/  ------\/     \\------>| CTR |\n>              \\  | \/  \/  \/            ------->|     |\n>               | | | |  |             |       +-----+\n>               V V V V  V             |          |\n>             +------------+       +--------+     V\n>             |    S2V     |------>|   V    |   +----+\n>             +------------+       +--------+   | C  |\n>                                      |        +----+\n>                                      |          |\n>                                      -----\\     |\n>                                            \\    |\n>                                             \\   |\n>                                              V  V\n>                                             +-----+\n>                                             |  Z  |\n>                                             +-----+\n\n   where the plaintext is P, the associated data is AD1 through ADn, V\n   is the synthetic IV, the ciphertext is C, and Z is the output.\n\n   Algorithmically, SIV Encrypt can be described as:\n\n>      SIV-ENCRYPT(K, P, AD1, ..., ADn) {\n>        K1 = leftmost(K, len(K)\/2)\n>        K2 = rightmost(K, len(K)\/2)\n>        V = S2V(K1, AD1, ..., ADn, P)\n>        Q = V bitand (1^64 || 0^1 || 1^31 || 0^1 || 1^31)\n>        m = (len(P) + 127)\/128\n>\n>        for i = 0 to m-1 do\n>          Xi = AES(K2, Q+i)\n>        done\n>        X = leftmost(X0 || ... || Xm-1, len(P))\n>        C = P xor X\n>\n>        return V || C\n>      }\n\n```\nsivEncrypt : {p, ad} (fin ad, 2^^71-128 >= p) => [256] -> [ad] -> [p] -> [128 + p]\nsivEncrypt K ad P = V # C\n where\n [K1,K2] = split K\n V = S2V K1 ad P\n Q = bitand V (repeat `{64} True # [False] # repeat `{31} True # [False] # repeat `{31} True)\n C = ctr64 K2 Q P\n```\n\n   where the key length used by AES in CTR and S2V is len(K)\/2 and will\n   each be either 128 bits, 192 bits, or 256 bits.\n\n   The 31st and 63rd bit (where the rightmost bit is the 0th) of the\n   counter are zeroed out just prior to being used by CTR for\n   optimization purposes, see Section 5.\n\n2.7.  SIV Decrypt\n\n   SIV-decrypt takes as input a key K of length 256, 384, or 512 bits,\n   Z, which represents a synthetic initialization vector V concatenated\n   with a ciphertext C, and a vector of associated data AD[ ] where the\n   number of components in the vector is not greater than 126 (see\n   Section 7).  It produces either the original plaintext or the special\n   symbol FAIL.\n\n   The key is split as specified in Section 2.6\n\n   The synthetic initialization vector acts as the initial counter to\n   CTR to decrypt the ciphertext.  The associated data and the output of\n   CTR represent a vector of strings that is passed to S2V, with the CTR\n   output being the last string in the vector.  The output of S2V is\n   then compared against the synthetic IV that accompanied the original\n   ciphertext.  If they match, the output from CTR is returned as the\n   decrypted and authenticated plaintext; otherwise, the special symbol\n   FAIL is returned.\n\n   The decryption construction of SIV is as follows:\n\n>   +------+ +------+   +------+           +---+\n>   | AD 1 | | AD 2 |...| AD n |           | P |\n>   +------+ +------+   +------+           +---+\n>      |        |         |                  ^\n>      |        |    ...  \/                  |\n>      |        |        \/  \/----------------|\n>      |        |       \/  \/                 |\n>      \\        |      \/  \/  +------------+  |\n>       \\       |     \/  \/   | K = K1||k2 |  |\n>        \\      |    \/  \/    +------------+  |\n>         \\     |   \/  \/       |   |      +-----+\n>          \\    |  \/  \/     K1 |   |  K2  |     |\n>           \\   | |  |   \/-----\/   \\----->| CTR |\n>            \\  | |  |  |         ------->|     |\n>             | | |  |  |         |       +-----+\n>             V V V  V  V         |         ^\n>           +-------------+   +--------+    |\n>           |    S2V      |   |   V    |  +---+\n>           +-------------+   +--------+  | C |\n>                 |               | ^     +---+\n>                 |               | |       ^\n>                 |               |  \\      |\n>                 |               |   \\___  |\n>                 V               V       \\ |\n>             +-------+      +---------+ +---+\n>             |   T   |----->|  if !=  | | Z |\n>             +-------+      +---------+ +---+\n>                                 |\n>                                 |\n>                                 V\n>                                FAIL\n>\n>                                 Figure 10\n\n\n   Algorithmically, SIV-Decrypt can be described as:\n\n>      SIV-DECRYPT(K, Z, AD1, ..., ADn) {\n>        V = leftmost(Z, 128)\n>        C = rightmost(Z, len(Z)-128)\n>        K1 = leftmost(K, len(K)\/2)\n>        K2 = rightmost(K, len(K)\/2)\n>        Q = V bitand (1^64 || 0^1 || 1^31 || 0^1 || 1^31)\n>\n>        m = (len(C) + 127)\/128\n>        for i = 0 to m-1 do\n>          Xi = AES(K2, Q+i)\n>        done\n>        X = leftmost(X0 || ... || Xm-1, len(C))\n>        P = C xor X\n>        T = S2V(K1, AD1, ..., ADn, P)\n>\n>        if T = V then\n>          return P\n>        else\n>          return FAIL\n>        fi\n>      }\n\n```\nsivDecrypt : {p, ad} (2^^71 - 128 >= p, fin ad) => [256] -> [ad] -> [p+128] -> (Bit, [p])\nsivDecrypt K ad Z = (T == V, P)\n where\n V = take `{128} Z\n C = drop `{back=p} Z\n [K1,K2] = split `{parts=2} K\n Q = bitand V (repeat `{64} True # [False] # repeat `{31} True # [False] # repeat `{31} True)\n P = ctr64 K2 Q C\n T = S2V K1 ad P\n```\n\n   where the key length used by AES in CTR and S2V is len(K)\/2 and will\n   each be either 128 bits, 192 bits, or 256 bits.\n\n   The 31st and 63rd bit (where the rightmost bit is the 0th) of the\n   counter are zeroed out just prior to being used in CTR mode for\n   optimization purposes, see Section 5.\n\n3.  Nonce-Based Authenticated Encryption with SIV\n\n   SIV performs nonce-based authenticated encryption when a component of\n   the associated data is a nonce.  For purposes of interoperability the\n   final component -- i.e., the string immediately preceding the\n   plaintext in the vector input to S2V -- is used for the nonce.  Other\n   associated data are optional.  It is up to the specific application\n   of SIV to specify how the rest of the associated data are input.\n\n   If the nonce is random, it SHOULD be at least 128 bits in length and\n   be harvested from a pool having at least 128 bits of entropy.  A non-\n   random source MAY also be used, for instance, a time stamp, or a\n   counter.  The definition of a nonce precludes reuse, but SIV is\n   resistant to nonce reuse.  See Section 1.3.2 for a discussion on the\n   security implications of nonce reuse.\n\n   It MAY be necessary to transport this nonce with the output generated\n   by S2V.\n\n4.  Deterministic Authenticated Encryption with SIV\n\n   When the plaintext to encrypt and authenticate contains data that is\n   unpredictable to an adversary -- for example, a secret key -- SIV can\n   be used in a deterministic mode to perform \"key wrapping\".  Because\n   S2V allows for associated data and imposes no unnatural size\n   restrictions on the data it is protecting, it is a more useful and\n   general purpose solution than [RFC3394].  Protocols that use SIV for\n   deterministic authenticated encryption (i.e., for more than just\n   wrapping of keys) MAY define associated data inputs to SIV.  It is\n   not necessary to add a nonce component to the AD in this case.\n\n5.  Optimizations\n\n   Implementations that cannot or do not wish to support addition modulo\n   2^128 can take advantage of the fact that the 31st and 63rd bits\n   (where the rightmost bit is the 0th bit) in the counter are cleared\n   before being used by CTR.  This allows implementations that natively\n   support 32-bit or 64-bit addition to increment the counter naturally.\n   Of course, in this case, the amount of plaintext that can be safely\n   protected by SIV is reduced by a commensurate amount -- addition\n   modulo 2^32 limits plaintext to (2^39 - 128) bits, addition modulo\n   2^64 limits plaintext to (2^71 - 128) bits.\n\n   It is possible to optimize an implementation of S2V when it is being\n   used as a key derivation function (KDF), for example in [WLAN].  This\n   is because S2V operates on a vector of distinct strings and typically\n   the data passed to a KDF contains constant strings.  Depending on the\n   location of variant components of the input different optimizations\n   are possible.  The CMACed output of intermediate and invariant\n   components can be computed once and cached.  This can then be doubled\n   and xored with the running sum to produce the output.  Or an\n   intermediate value that represents the doubled and xored output of\n   multiple components, up to the variant component, can be computed\n   once and cached.\n\n6.  IANA Considerations\n\n   [RFC5116] defines a uniform interface to cipher modes that provide\n   nonce-based Authenticated Encryption with Associated Data (AEAD).  It\n   does this via a registry of AEAD algorithms.\n\n   The Internet Assigned Numbers Authority (IANA) assigned three entries\n   from the AEAD Registry for AES-SIV-CMAC-256 (15), AES-SIV-CMAC-384\n   (16), and AES-SIV-CMAC-512 (17) based upon the following AEAD\n   algorithm definitions.  [RFC5116] defines operations in octets, not\n   bits.  Limits in this section will therefore be specified in octets.\n   The security analysis for each of these algorithms is in [DAE].\n\n   Unfortunately, [RFC5116] restricts AD input to a single component and\n   limits the benefit SIV offers for dealing in a natural fashion with\n   AD consisting of multiple distinct components.  Therefore, when it is\n   required to access SIV through the interface defined in [RFC5116], it\n   is necessary to marshal multiple AD inputs into a single string (see\n   Section 1.1) prior to invoking SIV.  Note that this requirement is\n   not unique to SIV.  All cipher modes using [RFC5116] MUST similarly\n   marshal multiple AD inputs into a single string, and any technique\n   used for any other AEAD mode (e.g., a scatter\/gather technique) can\n   be used with SIV.\n\n   [RFC5116] requires AEAD algorithm specifications to include maximal\n   limits to the amount of plaintext, the amount of associated data, and\n   the size of a nonce that the AEAD algorithm can accept.\n\n   SIV uses AES in counter mode and the security guarantees of SIV would\n   be lost if the counter was allowed to repeat.  Since the counter is\n   128 bits, a limit to the amount of plaintext that can be safely\n   protected by a single invocation of SIV is 2^128 blocks.\n\n   To prevent the possibility of collisions, [CMAC] recommends that no\n   more than 2^48 invocations be made to CMAC with the same key.  This\n   is not a limit on the amount of data that can be passed to CMAC,\n   though.  There is no practical limit to the amount of data that can\n   be made to a single invocation of CMAC, and likewise, there is no\n   practical limit to the amount of associated data or nonce material\n   that can be passed to SIV.\n\n   A collision in the output of S2V would mean the same counter would be\n   used with different plaintext in counter mode.  This would void the\n   security guarantees of SIV.  The \"Birthday Paradox\" (see [APPCRY])\n   would imply that no more than 2^64 distinct invocations to SIV be\n   made with the same key.  It is prudent to follow the example of\n   [CMAC] though, and further limit the number of distinct invocations\n   of SIV using the same key to 2^48.  Note that [RFC5116] does not\n   provide a variable to describe this limit.\n\n   The counter-space for SIV is 2^128.  Each invocation of SIV consumes\n   a portion of that counter-space and the amount consumed depends on\n   the amount of plaintext being passed to that single invocation.\n   Multiple invocations of SIV with the same key can increase the\n   possibility of distinct invocations overlapping the counter-space.\n   The total amount of plaintext that can be safely protected with a\n   single key is, therefore, a function of the number of distinct\n   invocations and the amount of plaintext protected with each\n   invocation.\n\n6.1.  AEAD_AES_SIV_CMAC_256\n\n   The AES-SIV-CMAC-256 AEAD algorithm works as specified in Sections\n   2.6 and 2.7.  The input and output lengths for AES-SIV-CMAC-256 as\n   defined by [RFC5116] are:\n\n   K_LEN  is 32 octets.\n\n   P_MAX  is 2^132 octets.\n\n   A_MAX  is unlimited.\n\n   N_MIN  is 1 octet.\n\n   N_MAX  is unlimited.\n\n   C_MAX  is 2^132 + 16 octets.\n\n   The security implications of nonce reuse and\/or misuse are described\n   in Section 1.3.2.\n\n6.2.  AEAD_AES_SIV_CMAC_384\n\n   The AES-SIV-CMAC-384 AEAD algorithm works as specified in Sections\n   2.6 and 2.7.  The input and output lengths for AES-SIV-CMAC-384 as\n   defined by [RFC5116] are:\n\n   K_LEN  is 48 octets.\n\n   P_MAX  is 2^132 octets.\n\n   A_MAX  is unlimited.\n\n   N_MIN  is 1 octet.\n\n   N_MAX  is unlimited.\n\n   C_MAX  is 2^132 + 16 octets.\n\n   The security implications of nonce reuse and\/or misuse are described\n   in Section 1.3.2.\n\n6.3.  AEAD_AES_SIV_CMAC_512\n\n   The AES-SIV-CMAC-512 AEAD algorithm works as specified in Sections\n   2.6 and 2.7.  The input and output lengths for AES-SIV-CMAC-512 as\n   defined by [RFC5116] are:\n\n   K_LEN  is 64 octets.\n\n   P_MAX  is 2^132 octets.\n\n   A_MAX  is unlimited.\n\n   N_MIN  is 1 octet.\n\n   N_MAX  is unlimited.\n\n   C_MAX  is 2^132 + 16 octets.\n\n   The security implications of nonce reuse and\/or misuse are described\n   in Section 1.3.2.\n\n7.  Security Considerations\n\n   SIV provides confidentiality in the sense that the output of SIV-\n   Encrypt is indistinguishable from a random string of bits.  It\n   provides authenticity in the sense that an attacker is unable to\n   construct a string of bits that will return other than FAIL when\n   input to SIV-Decrypt.  A proof of the security of SIV with an \"all-\n   in-one\" notion of security for an authenticated encryption scheme is\n   provided in [DAE].\n\n   SIV provides deterministic \"key wrapping\" when the plaintext contains\n   data that is unpredictable to an adversary (for instance, a\n   cryptographic key).  Even when this key is made available to an\n   attacker the output of SIV-Encrypt is indistinguishable from random\n   bits.  Similarly, even when this key is made available to an\n   attacker, she is unable to construct a string of bits that when input\n   to SIV-Decrypt will return anything other than FAIL.\n\n   When the nonce used in the nonce-based authenticated encryption mode\n   of SIV-AES is treated with the care afforded a nonce or counter in\n   other conventional nonce-based authenticated encryption schemes --\n   i.e., guarantee that it will never be used with the same key for two\n   distinct invocations -- then SIV achieves the level of security\n   described above.  If, however, the nonce is reused SIV continues to\n   provide the level of authenticity described above but with a slightly\n   reduced amount of privacy (see Section 1.3.2).\n\n   If S2V is used as a key derivation function, the secret input MUST be\n   generated uniformly at random.  S2V is a pseudo-random function and\n   is not suitable for use as a random oracle as defined in [RANDORCL].\n\n   The security bound set by the proof of security of S2V in [DAE]\n   depends on the number of vector-based queries made by an adversary\n   and the total number of all components in those queries.  The\n   security is only proven when the number of components in each query\n   is limited to n-1, where n is the blocksize of the underlying pseudo-\n   random function.  The underlying pseudo-random function used here is\n   based on AES whose blocksize is 128 bits.  Therefore, S2V must not be\n   passed more than 127 components.  Since SIV includes the plaintext as\n   a component to S2V, that limits the number of components of\n   associated data that can be safely passed to SIV to 126.\n\n\n\nAppendix A.  Test Vectors\n\n   The following test vectors are for the mode defined in Section 6.1.\n\nA.1.  Deterministic Authenticated Encryption Example\n\n   Input:\n   -----\n   Key:\n           fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0\n           f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff\n\n   AD:\n           10111213 14151617 18191a1b 1c1d1e1f\n           20212223 24252627\n\n   Plaintext:\n           11223344 55667788 99aabbcc ddee\n\n```\nproperty KAT1 =\n   sivEncrypt 0xfffefdfcfbfaf9f8f7f6f5f4f3f2f1f0f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n           0x101112131415161718191a1b1c1d1e1f2021222324252627\n           0x112233445566778899aabbccddee\n      == 0x85632d07c6e8f37f950acd320a2ecc9340c02b9690c4dc04daef7f6afe5c\n\nenc_dec : {ad,p} (fin ad, fin p, 2^^71 - 128 >= p) => [256] -> [ad] -> [p] -> Bit\nproperty enc_dec k ad p = (sivDecrypt k ad (sivEncrypt k ad p)).1 == p\n\n\/\/ `encrypt . decrypt ~ ident` for inputs larger, equal to, and smaller than the block size\n\/\/ Expect ~20 minutes for ABC to prove each property\nproperty enc_dec_ll k ad p = enc_dec `{431,500} k ad p\nproperty enc_dec_el k ad p = enc_dec `{128,140} k ad p\nproperty enc_dec_le k ad p = enc_dec `{148,128} k ad p\nproperty enc_dec_se k ad p = enc_dec `{18,128} k ad p\nproperty enc_dec_es k ad p = enc_dec `{128,18} k ad p\nproperty enc_dec_sl k ad p = enc_dec `{12,180} k ad p\nproperty enc_dec_ls k ad p = enc_dec `{140,18} k ad p\nproperty enc_dec_ee k ad p = enc_dec `{128,128} k ad p\nproperty enc_dec_ss k ad p = enc_dec `{50,80} k ad p\n\nproperty enc_dec_block k ad p = (sivDecrypt k (ad : [50]) (sivEncrypt k ad p)).1 == (p : [500])\n```\n\n   S2V-CMAC-AES\n   ------------\n   CMAC(zero):\n           0e04dfaf c1efbf04 01405828 59bf073a\n\n   double():\n           1c09bf5f 83df7e08 0280b050 b37e0e74\n\n   CMAC(ad):\n           f1f922b7 f5193ce6 4ff80cb4 7d93f23b\n\n   xor:\n           edf09de8 76c642ee 4d78bce4 ceedfc4f\n\n   double():\n           dbe13bd0 ed8c85dc 9af179c9 9ddbf819\n\n   pad:\n           11223344 55667788 99aabbcc ddee8000\n\n   xor:\n           cac30894 b8eaf254 035bc205 40357819\n\n   CMAC(final):\n           85632d07 c6e8f37f 950acd32 0a2ecc93\n\n   CTR-AES\n   -------\n   CTR:\n           85632d07 c6e8f37f 150acd32 0a2ecc93\n\n   E(K,CTR):\n           51e218d2 c5a2ab8c 4345c4a6 23b2f08f\n\n   ciphertext:\n           40c02b96 90c4dc04 daef7f6a fe5c\n\n   output\n   ------\n   IV || C:\n           85632d07 c6e8f37f 950acd32 0a2ecc93\n           40c02b96 90c4dc04 daef7f6a fe5c\n\nA.2.  Nonce-Based Authenticated Encryption Example\n\n   Input:\n   -----\n   Key:\n           7f7e7d7c 7b7a7978 77767574 73727170\n           40414243 44454647 48494a4b 4c4d4e4f\n\n   AD1:\n           00112233 44556677 8899aabb ccddeeff\n           deaddada deaddada ffeeddcc bbaa9988\n           77665544 33221100\n\n   AD2:\n           10203040 50607080 90a0\n\n   Nonce:\n           09f91102 9d74e35b d84156c5 635688c0\n\n   Plaintext:\n           74686973 20697320 736f6d65 20706c61\n           696e7465 78742074 6f20656e 63727970\n           74207573 696e6720 5349562d 414553\n\n   S2V-CMAC-AES\n   ------------\n   CMAC(zero):\n           c8b43b59 74960e7c e6a5dd85 231e591a\n\n   double():\n           916876b2 e92c1cf9 cd4bbb0a 463cb2b3\n\n   CMAC(ad1)\n           3c9b689a b41102e4 80954714 1dd0d15a\n\n   xor:\n           adf31e28 5d3d1e1d 4ddefc1e 5bec63e9\n\n   double():\n           5be63c50 ba7a3c3a 9bbdf83c b7d8c755\n\n   CMAC(ad2)\n           d98c9b0b e42cb2d7 aa98478e d11eda1b\n\n   xor:\n           826aa75b 5e568eed 3125bfb2 66c61d4e\n\n   double():\n           04d54eb6 bcad1dda 624b7f64 cd8c3a1b\n\n   CMAC(nonce)\n           128c62a1 ce3747a8 372c1c05 a538b96d\n\n   xor:\n           16592c17 729a5a72 55676361 68b48376\n\n   xorend:\n           74686973 20697320 736f6d65 20706c61\n           696e7465 78742074 6f20656e 63727966\n           2d0c6201 f3341575 342a3745 f5c625\n\n   CMAC(final)\n           7bdb6e3b 432667eb 06f4d14b ff2fbd0f\n\n\n\n   CTR-AES\n   -------\n   CTR:\n           7bdb6e3b 432667eb 06f4d14b 7f2fbd0f\n\n   E(K,CTR):\n           bff8665c fdd73363 550f7400 e8f9d376\n\n   CTR+1:\n           7bdb6e3b 432667eb 06f4d14b 7f2fbd10\n\n   E(K,CTR+1):\n           b2c9088e 713b8617 d8839226 d9f88159\n\n   CTR+2\n           7bdb6e3b 432667eb 06f4d14b 7f2fbd11\n\n   E(K,CTR+2):\n           9e44d827 234949bc 1b12348e bc195ec7\n\n   ciphertext:\n           cb900f2f ddbe4043 26601965 c889bf17\n           dba77ceb 094fa663 b7a3f748 ba8af829\n           ea64ad54 4a272e9c 485b62a3 fd5c0d\n\n   output\n   ------\n   IV || C:\n           7bdb6e3b 432667eb 06f4d14b ff2fbd0f\n           cb900f2f ddbe4043 26601965 c889bf17\n           dba77ceb 094fa663 b7a3f748 ba8af829\n           ea64ad54 4a272e9c 485b62a3 fd5c0d","variant":null,"set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/ZUC1_6_Tests.md","filetype":"txt","content":"# ZUC Algorithm Specification: Implementor's Test Data\n\n## Introduction\n\nAll text in this document is directly from the\n[ZUC Test Data](https:\/\/www.gsma.com\/security\/wp-content\/uploads\/2019\/05\/eea3eia3testdatav11.pdf).\n\n\n## 3 ZUC\n\n```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::ZUC1_6_Tests where\n\nimport Primitive::Symmetric::Cipher::Stream::ZUC1_6\n```\n\n### 3.1 Overview\n\nThe test data sets presented here are for the ZUC stream cipher algorithm.\n\n### 3.2 Format\n\nEach test set starts by showing the input and output data values.\n\nThis is followed by a table showing the state of the LFSR at the beginning of the computation.\n\nThen for the first 10 steps of the initialization the content of X0,X1,X2,X3,R1,R2 is given in a\ntable. Steps are indexed by *t* (for \"time\").\n\nThen the state of the LFSR and the nonlinear function F at the end of the initialization is given.\n\nFor the first 3 steps of keystream generation X0,X1,X2,X3,R1,R2 are given in a table.\n\n### 3.3 Test Set 1\n\n```cryptol\nproperty test1 = KeyLoad key iv == sKeyLoad\n              \/\\ InitializeStage key iv == (sAfterInit, RAfterInit)\n              \/\\ take (WorkStage (sAfterInit, RAfterInit)) == [z1, z2]\n    where\n        key = 0x00000000000000000000000000000000\n        iv  = 0x00000000000000000000000000000000\n        R0 = zero : [2][32]\n        z1 = 0x27bede74\n        z2 = 0x018082da\n        sKeyLoad = map drop [ 0x0044d700, 0x0026bc00, 0x00626b00, 0x00135e00\n                            , 0x00578900, 0x0035e200, 0x00713500, 0x0009af00\n                            , 0x004d7800, 0x002f1300, 0x006bc400, 0x001af100\n                            , 0x005e2600, 0x003c4d00, 0x00789a00, 0x0047ac00\n                            ] : LFSR\n        sAfterInit = map drop [ 0x7ce15b8b, 0x747ca0c4, 0x6259dd0b, 0x47a94c2b\n                              , 0x3a89c82e, 0x32b433fc, 0x231ea13f, 0x31711e42\n                              , 0x4ccce955, 0x3fb6071e, 0x161d3512, 0x7114b136\n                              , 0x5154d452, 0x78c69a74, 0x4f26ba6b, 0x3e1b8d6a\n                              ] : LFSR\n        RAfterInit = [ 0x14cfd44c, 0x8c6de800 ]\n```\n\n### 3.4 Test Set 2\n\n```cryptol\nproperty test2 = KeyLoad key iv == sKeyLoad\n              \/\\ InitializeStage key iv == (sAfterInit, RAfterInit)\n              \/\\ take (WorkStage (sAfterInit, RAfterInit)) == [z1, z2]\n    where\n        key = 0xffffffffffffffffffffffffffffffff\n        iv  = 0xffffffffffffffffffffffffffffffff\n        z1 = 0x0657cfa0\n        z2 = 0x7096398b\n        R0 = zero : [2][32]\n        sKeyLoad = map drop [ 0x7fc4d7ff, 0x7fa6bcff, 0x7fe26bff, 0x7f935eff\n                            , 0x7fd789ff, 0x7fb5e2ff, 0x7ff135ff, 0x7f89afff\n                            , 0x7fcd78ff, 0x7faf13ff, 0x7febc4ff, 0x7f9af1ff\n                            , 0x7fde26ff, 0x7fbc4dff, 0x7ff89aff, 0x7fc7acff\n                            ] : LFSR\n        sAfterInit = map drop [ 0x09a339ad, 0x1291d190, 0x25554227, 0x36c09187\n                              , 0x0697773b, 0x443cf9cd, 0x6a4cd899, 0x49e34bd0\n                              , 0x56130b14, 0x20e8f24c, 0x7a5b1dcc, 0x0c3cc2d1\n                              , 0x1cc082c8, 0x7f5904a2, 0x55b61ce8, 0x1fe46106\n                              ] : LFSR\n        RAfterInit = [ 0xb8017bd5, 0x9ce2de5c ]\n```\n\n### 3.5 Test Set 3\n\n```cryptol\nproperty test3 = KeyLoad key iv == sKeyLoad\n              \/\\ InitializeStage key iv == (sAfterInit, RAfterInit)\n              \/\\ take (WorkStage (sAfterInit, RAfterInit)) == [z1, z2]\n    where\n        key = 0x3d4c4be96a82fdaeb58f641db17b455b\n        iv  = 0x84319aa8de6915ca1f6bda6bfbd8c766\n        z1  = 0x14f1c272\n        z2  = 0x3279c419\n        R0 = zero : [2][32]\n        sKeyLoad = map drop [ 0x1ec4d784, 0x2626bc31, 0x25e26b9a, 0x74935ea8\n                            , 0x355789de, 0x4135e269, 0x7ef13515, 0x5709afca\n                            , 0x5acd781f, 0x47af136b, 0x326bc4da, 0x0e9af16b\n                            , 0x58de26fb, 0x3dbc4dd8, 0x22f89ac7, 0x2dc7ac66\n                            ] : LFSR\n        sAfterInit = map drop [ 0x10da5941, 0x5b6acbf6, 0x17060ce1, 0x35368174\n                              , 0x5cf4385a, 0x479943df, 0x2753bab2, 0x73775d6a\n                              , 0x43930a37, 0x77b4af31, 0x15b2e89f, 0x24ff6e20\n                              , 0x740c40b9, 0x026a5503, 0x194b2a57, 0x7a9a1cff\n                              ] : LFSR\n        RAfterInit = [ 0x860a7dfa, 0xbf0e0ffc ]\n```\n\n### 3.6 Test Set 4\n\n```cryptol\nproperty test4 = KeyLoad key iv == sKeyLoad\n              \/\\ InitializeStage key iv == (sAfterInit, RAfterInit)\n              \/\\ (keystream@@[0..1] # [keystream@1999]) == [z1, z2, z2000]\n    where\n        key = 0x4d320bfad4c285bfd6b8bd00f39d8b41\n        iv  = 0x52959daba0bf176ece2dc315049eb574\n        z1  = 0xed4400e7\n        z2  = 0x0633e5c5\n        z2000 = 0x7a574cdb\n        sKeyLoad = map drop [ 0x26c4d752, 0x1926bc95, 0x05e26b9d, 0x7d135eab\n                            , 0x6a5789a0, 0x6135e2bf, 0x42f13517, 0x5f89af6e\n                            , 0x6b4d78ce, 0x5c2f132d, 0x5eebc4c3, 0x001af115\n                            , 0x79de2604, 0x4ebc4d9e, 0x45f89ab5, 0x20c7ac74\n                            ] : LFSR\n        sAfterInit = map drop [ 0x1f808882, 0x4fc08639, 0x246a9891, 0x1f77c16f\n                              , 0x50f0e1c9, 0x723e8fac, 0x24334616, 0x4471b734\n                              , 0x7dba1992, 0x25180096, 0x4637117c, 0x2a92aac8\n                              , 0x7da8d7b5, 0x58f45afe, 0x42814800, 0x56d7e7d8\n                              ] : LFSR\n        RAfterInit = [ 0x52761a25, 0x38f712e1 ]\n        keystream = WorkStage (sAfterInit, RAfterInit)\n```\n\n## Backwards Compatibility\n\nTest vectors from the original ZUC implementation are included to ensure backwards compatibility is\nmaintained.\n\n```cryptol\nproperty ZUC_TestVectors =\n    t1 \/\\ t2 \/\\ t3 \/\\ t4\n    where\n      t1 = take (ZUC zero    zero   ) == [0x27BEDE74, 0x018082DA]\n      t2 = take (ZUC (~zero) (~zero)) == [0x0657CFA0, 0x7096398B]\n      t3 = take (ZUC (join [ 0x3D, 0x4C, 0x4B, 0xE9, 0x6A, 0x82, 0xFD, 0xAE\n                           , 0xB5, 0x8F, 0x64, 0x1D, 0xB1, 0x7B, 0x45, 0x5B\n                           ])\n                     (join [ 0x84, 0x31, 0x9A, 0xA8, 0xDE, 0x69, 0x15, 0xCA\n                           , 0x1F, 0x6B, 0xDA, 0x6B, 0xFB, 0xD8, 0xC7, 0x66\n                           ])) == [0x14F1C272, 0x3279C419]\n      t4 = take ks # [ks @ 1999] == [0xED4400E7, 0x0633E5C5, 0x7A574CDB]\n        where\n          ks = ZUC (join [ 0x4D, 0x32, 0x0B, 0xFA, 0xD4, 0xC2, 0x85, 0xBF\n                         , 0xD6, 0xB8, 0xBD, 0x00, 0xF3, 0x9D, 0x8B, 0x41\n                         ])\n                   (join [ 0x52, 0x95, 0x9D, 0xAB, 0xA0, 0xBF, 0x17, 0x6E\n                         , 0xCE, 0x2D, 0xC3, 0x15, 0x04, 0x9E, 0xB5, 0x74\n                         ])","variant":null,"set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/Salsa20.md","filetype":"txt","content":"# Salsa20 specification\n\n## Introduction\n\nAll text in this document is directly from the\n[Salsa20 specification](http:\/\/cr.yp.to\/snuffle\/spec.pdf).\n\n## Abstract\n\nThis document defines the Salsa20 hash function, the Salsa20 expansion function, and the Salsa20\nencryption function.\n\n```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::Salsa20 where\n```\n\n## 1 Introduction\n\nThe core of Salsa20 is a hash function with 64-byte input and 64-byte output. The hash function is\nused in counter mode as a stream cipher: Salsa20 encrypts a 64-byte block of plaintext by hashing\nthe key, nonce, and block number and xor'ing the result with the plaintext.\n\nThis document defines Salsa20 from bottom up, starting with three simple operations on 4-byte words,\ncontinuing through the Salsa20 hash function, and finishing with the Salsa20 encryption function.\n\nIn this document, a `byte` is an element of `{0,1,...,255}`. There are many common ways to represent\na byte as a sequence of electrical signals; the details of this representation are of no relevance\nto the definition of Salsa20.\n\n## 2 Words\n\nA **word** is an element of {0,1,...,2<sup>32<\/sup>-1}. Words in the document are often written in\nhexadecimal, indicated by the symbols `0x`: for example, ```\n0xc0a8787e = 12\u00b72^28 + 0\u00b72^24 + 10\u00b72^20 + 8\u00b72^16 + 7\u00b72^12 + 8\u00b72^8 + 7\u00b72^4 + 14\u00b72^0 = 3232266366```.\n\nThe **sum** of two words *u*, *v* is `u+v mod 2^32`. The sum is denoted `u + v`; there is not risk\nof confusion. For example,\n\n```cryptol\nproperty exampleSum = 0xc0a8787e + 0x9fd1161d == 0x60798e9b\n```\n\nThe **exclusive-or** of two words *u*, *v*, denoted by `u^v`, is the sum of *u* and *v* with carries\nsuppressed. In other words, if *u=\u2211<sub>i<\/sub> 2<sup>i<\/sup>u<sub>i<\/sub>* and\n*v=\u2211<sub>i<\/sub> 2<sup>i<\/sup>v<sub>i<\/sub>* then\n*u\u2295v=\u2211<sub>i<\/sub> 2<sup>i<\/sup>(u<sub>i<\/sub>+v<sub>i<\/sub>-2u<sub>i<\/sub>v<sub>i<\/sub>)*. For\nexample,\n\n```cryptol\nproperty exampleXor = 0xc0a8787e ^ 0x9fd1161d == 0x5f796e63\n```\n\nFor each `c \u2208 {0,1,2,3...}`, the *c*-**bit left rotation** of a word *u*, denoted `u <<< c`, is the\nunique nonzero word congruent to `2^c u modulo 2^32 - 1`, except that `0 <<< c = 0`. In other words,\nif *u=\u2211<sub>i<\/sub> 2<sup>i<\/sup>u<sub>i<\/sub>* then\n*u <<< c = \u2211<sub>i<\/sub> 2<sup>i+c mod 32<\/sup>u<sub>i<\/sub>*. For example,\n\n```cryptol\nproperty exampleLeftRot = 0xc0a8787e <<< 5 == 0x150f0fd8\nproperty exampleLeftRotZero = (0 : [32]) <<< 5 == 0\n```\n\n## 3 The quarterround function\n\n### Inputs and outputs\n\nIf *y* is a 4-word sequence then quarterround(y) is a 4-word sequence.\n\n```cryptol\nquarterround : [4][32] -> [4][32]\n```\n\n### Definitions\n\nIf `y = (y0,y1,y2,y3)` then `quarterround(y) = (z0,z1,z2,z3)` where\n\n```cryptol\nquarterround [y0, y1, y2, y3] = [z0, z1, z2, z3]\n    where\n        z1 = y1 ^ ((y0 + y3) <<< 7)\n        z2 = y2 ^ ((z1 + y0) <<< 9)\n        z3 = y3 ^ ((z2 + z1) <<< 13)\n        z0 = y0 ^ ((z3 + z2) <<< 18)\n```\n\n### Examples\n\n```cryptol\nproperty quarterroundExamples = quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000000] == [0x00000000, 0x00000000, 0x00000000, 0x00000000]\n                             \/\\ quarterround [0x00000001, 0x00000000, 0x00000000, 0x00000000] == [0x08008145, 0x00000080, 0x00010200, 0x20500000]\n                             \/\\ quarterround [0x00000000, 0x00000001, 0x00000000, 0x00000000] == [0x88000100, 0x00000001, 0x00000200, 0x00402000]\n                             \/\\ quarterround [0x00000000, 0x00000000, 0x00000001, 0x00000000] == [0x80040000, 0x00000000, 0x00000001, 0x00002000]\n                             \/\\ quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000001] == [0x00048044, 0x00000080, 0x00010000, 0x20100001]\n                             \/\\ quarterround [0xe7e8c006, 0xc4f9417d, 0x6479b4b2, 0x68c67137] == [0xe876d72b, 0x9361dfd5, 0xf1460244, 0x948541a3]\n                             \/\\ quarterround [0xd3917c5b, 0x55f1c407, 0x52a58a7a, 0x8f887a3b] == [0x3e2f308c, 0xd90a8f36, 0x6ab2a923, 0x2883524c]\n```\n\n### Comments\n\nOne can visualize the quarterround function as modifying *y* in place: first y1 changes to z1, then\ny2 changes to z2, then y3 changes to z3, then y0 changes to z0. Each modification is invertible, so\nthe entire function is invertible.\n\n```cryptol\nproperty quarterroundInverts y y' = y != y' ==> quarterround y != quarterround y'\n```\n\n## 4 The rowround function\n\n### Inputs and outputs\n\nIf y is a 16-word sequence then rowround(y) is a 16-word sequence.\n\n```cryptol\nrowround : [16][32] -> [16][32]\n```\n\n### Definition\n\nIf `y = (y0,y1,y2,y3,...,y15)` then `rowround(y) = (z0,z1,z2,z3,...,z15)` where\n\n```cryptol\nrowround [y0,y1,y2,y3,y4,y5,y6,y7,y8,y9,y10,y11,y12,y13,y14,y15] =\n         [z0,z1,z2,z3,z4,z5,z6,z7,z8,z9,z10,z11,z12,z13,z14,z15]\n    where\n        [z0,z1,z2,z3]     = quarterround [y0,y1,y2,y3]\n        [z5,z6,z7,z4]     = quarterround [y5,y6,y7,y4]\n        [z10,z11,z8,z9]   = quarterround [y10,y11,y8,y9]\n        [z15,z12,z13,z14] = quarterround [y15,y12,y13,y14]\n```\n\n### Examples\n\n```cryptol\nproperty rowroundExamples = rowround [ 0x00000001, 0x00000000, 0x00000000, 0x00000000\n                                     , 0x00000001, 0x00000000, 0x00000000, 0x00000000\n                                     , 0x00000001, 0x00000000, 0x00000000, 0x00000000\n                                     , 0x00000001, 0x00000000, 0x00000000, 0x00000000 ] ==\n                                     [ 0x08008145, 0x00000080, 0x00010200, 0x20500000\n                                     , 0x20100001, 0x00048044, 0x00000080, 0x00010000\n                                     , 0x00000001, 0x00002000, 0x80040000, 0x00000000\n                                     , 0x00000001, 0x00000200, 0x00402000, 0x88000100 ]\n                         \/\\ rowround [ 0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365\n                                     , 0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6\n                                     , 0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e\n                                     , 0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a ] ==\n                                     [ 0xa890d39d, 0x65d71596, 0xe9487daa, 0xc8ca6a86\n                                     , 0x949d2192, 0x764b7754, 0xe408d9b9, 0x7a41b4d1\n                                     , 0x3402e183, 0x3c3af432, 0x50669f96, 0xd89ef0a8\n                                     , 0x0040ede5, 0xb545fbce, 0xd257ed4f, 0x1818882d ]\n```\n\n### Comments\n\nOne can visualize the input (y0,y1,..,y15) as a square matrix:\n\n```example\n y0  y1  y2  y3\n y4  y5  y6  y7\n y8  y9 y10 y11\ny12 y13 y14 y15\n```\n\nThe rowround function modifies the rows of the matrix in parallel by feeding a permutation of each\nrow through the quarterround function. In the first row, the rowround function modifies y1, then y2,\nthen y3, then y0; in the second row, the rowround function modifies y6, then y7, then y4, then y5;\nin the third row, the rowround function modifies y11, then y8, then y9, then y10; in the fourth row,\nthe rowround function modifies y12, then y13, then y14, then y15.\n\n## 5 The columnround function\n\n### Inputs and outputs\n\nIf x is a 16-word sequence then columnround(x) is a 16-word sequence.\n\n```cryptol\ncolumnround : [16][32] -> [16][32]\n```\n\n### Definition\n\nIf `x = (x0,x1,x2,...,x15)` then `columnround(x) = (y0,y1,y2,...,y15)` where:\n\n```cryptol\ncolumnround [x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15] =\n            [y0,y1,y2,y3,y4,y5,y6,y7,y8,y9,y10,y11,y12,y13,y14,y15]\n    where\n        [y0,y4,y8,y12]  = quarterround [x0,x4,x8,x12]\n        [y5,y9,y13,y1]  = quarterround [x5,x9,x13,x1]\n        [y10,y14,y2,y6] = quarterround [x10,x14,x2,x6]\n        [y15,y3,y7,y11] = quarterround [x15,x3,x7,x11]\n```\n\nEquivalent formula:\n\n```cryptol\ncolumnround_equiv : [16][32] -> [16][32]\ncolumnround_equiv [x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15] =\n                  [y0,y1,y2,y3,y4,y5,y6,y7,y8,y9,y10,y11,y12,y13,y14,y15]\n    where\n        [y0,y4,y8,y12,y1,y5,y9,y13,y2,y6,y10,y14,y3,y7,y11,y15] =\n            rowround [x0,x4,x8,x12,x1,x5,x9,x13,x2,x6,x10,x14,x3,x7,x11,x15]\n\nproperty columnroundEquivalent x = columnround x == columnround_equiv x\n```\n\n### Examples\n\n```cryptol\nproperty columnroundExamples = columnround [ 0x00000001, 0x00000000, 0x00000000, 0x00000000\n                                           , 0x00000001, 0x00000000, 0x00000000, 0x00000000\n                                           , 0x00000001, 0x00000000, 0x00000000, 0x00000000\n                                           , 0x00000001, 0x00000000, 0x00000000, 0x00000000 ] ==\n                                           [ 0x10090288, 0x00000000, 0x00000000, 0x00000000\n                                           , 0x00000101, 0x00000000, 0x00000000, 0x00000000\n                                           , 0x00020401, 0x00000000, 0x00000000, 0x00000000\n                                           , 0x40a04001, 0x00000000, 0x00000000, 0x00000000 ]\n                            \/\\ columnround [ 0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365\n                                           , 0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6\n                                           , 0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e\n                                           , 0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a ] ==\n                                           [ 0x8c9d190a, 0xce8e4c90, 0x1ef8e9d3, 0x1326a71a\n                                           , 0x90a20123, 0xead3c4f3, 0x63a091a0, 0xf0708d69\n                                           , 0x789b010c, 0xd195a681, 0xeb7d5504, 0xa774135c\n                                           , 0x481c2027, 0x53a8e4b5, 0x4c1f89c5, 0x3f78c9c8 ]\n```\n\n### Comments\n\nOne can visualize the inputs `(x0,x1,...,x15)` as a square matrix, as in Section 4:\n\n```example\n x0  x1  x2  x3\n x4  x5  x6  x7\n x8  x9 x10 x11\nx12 x13 x14 x15\n```\n\nThe columnround function is, from this perspective, simply the transpose of the rowround function:\nit modifies the columns of the matrix in parallel by feeding a permutation of each column through\nthe quarterround function. In the first column, the columnround function modifies y4, then y8, then\ny12, then y0; in the second column, the columnround function modifies y9, then y13, then y1, then\ny5; in the third column, the columnround function modifies y14, then y2, then y6, then y10; in the\nfourth column, the columnround function modifies y3, then y7, then y11, then y15.\n\n## 6 The doubleround function\n\n### Inputs and outputs\n\nIf x is a 16-word sequence then doubleround(x) is a 16-word sequence.\n\n```cryptol\ndoubleround : [16][32] -> [16][32]\n```\n\n### Definition\n\nA double round is a column round followed by a row round:\n\n```cryptol\ndoubleround x = rowround (columnround x)\n```\n\n### Examples\n\n```cryptol\nproperty doubleroundExamples = doubleround [ 0x00000001, 0x00000000, 0x00000000, 0x00000000\n                                           , 0x00000000, 0x00000000, 0x00000000, 0x00000000\n                                           , 0x00000000, 0x00000000, 0x00000000, 0x00000000\n                                           , 0x00000000, 0x00000000, 0x00000000, 0x00000000 ] ==\n                                           [ 0x8186a22d, 0x0040a284, 0x82479210, 0x06929051\n                                           , 0x08000090, 0x02402200, 0x00004000, 0x00800000\n                                           , 0x00010200, 0x20400000, 0x08008104, 0x00000000\n                                           , 0x20500000, 0xa0000040, 0x0008180a, 0x612a8020 ]\n                            \/\\ doubleround [ 0xde501066, 0x6f9eb8f7, 0xe4fbbd9b, 0x454e3f57\n                                           , 0xb75540d3, 0x43e93a4c, 0x3a6f2aa0, 0x726d6b36\n                                           , 0x9243f484, 0x9145d1e8, 0x4fa9d247, 0xdc8dee11\n                                           , 0x054bf545, 0x254dd653, 0xd9421b6d, 0x67b276c1 ] ==\n                                           [ 0xccaaf672, 0x23d960f7, 0x9153e63a, 0xcd9a60d0\n                                           , 0x50440492, 0xf07cad19, 0xae344aa0, 0xdf4cfdfc\n                                           , 0xca531c29, 0x8e7943db, 0xac1680cd, 0xd503ca00\n                                           , 0xa74b2ad6, 0xbc331c5c, 0x1dda24c7, 0xee928277 ]\n```\n\n### Comments\n\nOne can visualize a double round as modifying the columns of the input in parallel, and then\nmodifying the rows in parallel. Each word is modified twice.\n\n## 7 The littleendian function\n\n### Inputs and outputs\n\nIf b is a 4-byte sequence then littleendian(b) is a word.\n\n```cryptol\nlittleendian : [4][8] -> [32]\n```\n\n### Definition\n\nIf *b = (b<sub>0<\/sub>,b<sub>1<\/sub>,b<sub>2<\/sub>,b<sub>3<\/sub>)* then\n*littleendian(b) = b<sub>0<\/sub> + 2<sup>8<\/sup>b<sub>1<\/sub> + 2<sup>16<\/sup>b<sub>2<\/sub> +\n2<sup>24<\/sup>b<sub>3<\/sub>*.\n\n```cryptol\nlittleendian b = join (reverse b)\n```\n\n### Examples\n\n```cryptol\nproperty littleendianExamples = littleendian [0,0,0,0] == 0x00000000\n                             \/\\ littleendian [86,75,30,9] == 0x091e4b56\n                             \/\\ littleendian [255,255,255,250] == 0xfaffffff\n```\n\n### Comments\n\nNote that littleendian is invertible.\n\n```cryptol\nproperty littleendianInvertible b b' = b != b' ==> littleendian b != littleendian b'\n\nlittleendian' : [32] -> [4][8]\nlittleendian' b = reverse (split b)\n\nproperty littleendianInverseExamples = littleendian' 0x00000000 == [0,0,0,0]\n                                    \/\\ littleendian' 0x091e4b56 == [86,75,30,9]\n                                    \/\\ littleendian' 0xfaffffff == [255,255,255,250]\n\nproperty littleendianInverts b = littleendian' (littleendian b) == b\n```\n\n## 8 The Salsa20 hash function\n\n### Inputs and outputs\n\nIf x is a 64-byte sequence then Salsa20(x) is a 64-byte sequence.\n\n```cryptol\nSalsa20 : [64][8] -> [64][8]\n```\n\n### Definition\n\nIn short: Salsa20(x) = x + doubleround^10 (x), where each 4-byte sequence is viewed as a word in\nlittle-endian form.\n\nIn detail:\n\n```cryptol\nSalsa20 x = join [ littleendian' y | y <- x' + z@10 ]\n    where\n        x' = [ littleendian xi | xi <- split x ]\n        z  = [x'] # [ doubleround zi | zi <- z]\n```\n\n### Examples\n\n```cryptol\nproperty Salsa20Examples = Salsa20 [  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n                                   ,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n                                   ,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n                                   ,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ==\n                                   [  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n                                   ,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n                                   ,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n                                   ,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\n                        \/\\ Salsa20 [ 211,159, 13,115, 76, 55, 82,183, 3,117,222, 37\n                                   , 191,187,234,136, 49,237,179, 48, 1,106,178,219\n                                   , 175,199,166, 48, 86, 16,179,207, 31,240, 32, 63\n                                   ,  15, 83, 93,161,116,147, 48,113,238, 55,204, 36\n                                   ,  79,201,235, 79, 3, 81,156, 47,203, 26,244,243\n                                   ,  88, 118,104, 54 ] ==\n                                   [ 109, 42,178,168,156,240,248,238,168,196,190,203\n                                   ,  26,110,170,154, 29, 29,150, 26,150, 30,235,249\n                                   , 190,163,251, 48, 69,144, 51, 57, 118, 40,152,157\n                                   , 180, 57, 27, 94,107, 42,236, 35, 27,111,114,114\n                                   , 219,236,232,135,111,155,110, 18, 24,232, 95,158\n                                   , 179, 19, 48,202 ]\n                        \/\\ Salsa20 [ 88,118,104, 54, 79,201,235, 79, 3, 81,156, 47,203\n                                   , 26,244,243,191,187,234,136,211,159, 13,115, 76, 55\n                                   , 82,183, 3,117,222, 37, 86, 16,179,207, 49,237,179\n                                   , 48, 1,106,178,219,175,199,166, 48,238, 55,204, 36\n                                   , 31,240, 32, 63, 15, 83, 93,161,116,147, 48,113 ] ==\n                                   [ 179, 19, 48,202,219,236,232,135,111,155,110, 18, 24\n                                   , 232, 95,158, 26,110,170,154,109, 42,178,168,156,240\n                                   , 248,238,168,196,190,203, 69,144, 51, 57, 29, 29,150\n                                   ,  26,150, 30,235,249,190,163,251, 48, 27,111,114,114\n                                   , 118, 40,152,157,180, 57, 27, 94,107, 42,236, 35 ]\n```\n\n## 9 The Salsa20 expansion function\n\n### Inputs and outputs\n\n*Note: The original document defines the Salsa20 expansion function as Salsa20<sub>k<\/sub>(n). For*\n*clarity it is defined in this document to Salsa20_expansion(k, n).*\n\nIf k is a 32-byte or 16-byte sequence and n is a 16-byte sequence then Salsa20_expansion(k, n) is a\n64-byte sequence.\n\n```cryptol\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8] -> [64][8]\n```\n\n### Definition\n\n```cryptol\nSalsa20_expansion k n = Salsa20 x\n    where\n        [\u03c30, \u03c31, \u03c32, \u03c33] = \u03c30\u03c31\u03c32\u03c33\n        [\u03c40, \u03c41, \u03c42, \u03c43] = \u03c40\u03c41\u03c42\u03c43\n        [ k0, k1 ] = split (k # zero) : [2][16][8]\n        x = if `a == 2 then \u03c30 # k0 # \u03c31 # n # \u03c32 # k1 # \u03c33\n                       else \u03c40 # k0 # \u03c41 # n # \u03c42 # k0 # \u03c43\n```\n\n### Examples\n\n```cryptol\nproperty Salsa20kExamples = Salsa20_expansion (k0 # k1) n == [ 69, 37, 68, 39, 41, 15,107,193,255,139,122, 6\n                                                             ,170,233,217, 98, 89,144,182,106, 21, 51,200, 65\n                                                             ,239, 49,222, 34,215,114, 40,126,104,197, 7,225\n                                                             ,197,153, 31, 2,102, 78, 76,176, 84,245,246,184\n                                                             ,177,160,133,130, 6, 72,149,119,192,195,132,236\n                                                             ,234,103,246, 74 ]\n                         \/\\ Salsa20_expansion k0 n        == [ 39,173, 46,248, 30,200, 82, 17, 48, 67,254,239\n                                                             , 37, 18, 13,247,241,200, 61,144, 10, 55, 50,185\n                                                             ,  6, 47,246,253,143, 86,187,225,134, 85,110,246\n                                                             ,161,163, 43,235,231, 94,171, 51,145,214,112, 29\n                                                             , 14,232, 5, 16,151,140,183,141,171, 9,122,181\n                                                             ,104,182,177,193 ]\n    where\n        k0 = [1..16]\n        k1 = [201..216]\n        n  = [101..116]\n```\n\n### Comments\n\n\"Expansion\" refers to the expansion of (k,n) into Salsa20_expansion(k, n). It also refers to the\nexpansion of k into a long stream of Salsa20_expansion outputs for various n's; see Section 10.\n\nThe constants `\u03c30 # \u03c31 # \u03c32 # \u03c33` and `\u03c40 # \u03c41 # \u03c42 # \u03c43` are \"expand 32-byte k\" and\n\"expand 16-byte k\" in ASCII.\n\n```cryptol\n\u03c30\u03c31\u03c32\u03c33 : [4][4][8]\n\u03c30\u03c31\u03c32\u03c33 = split \"expand 32-byte k\"\n\n\u03c40\u03c41\u03c42\u03c43 : [4][4][8]\n\u03c40\u03c41\u03c42\u03c43 = split \"expand 16-byte k\"\n\nproperty expansionConstants = [\u03c30, \u03c31, \u03c32, \u03c33] == \u03c30\u03c31\u03c32\u03c33\n                           \/\\ [\u03c40, \u03c41, \u03c42, \u03c43] == \u03c40\u03c41\u03c42\u03c43\n    where\n        \u03c30 = [ 101, 120, 112,  97 ]\n        \u03c31 = [ 110, 100,  32,  51 ]\n        \u03c32 = [  50,  45,  98, 121 ]\n        \u03c33 = [ 116, 101,  32, 107 ]\n        \u03c40 = [ 101, 120, 112,  97 ]\n        \u03c41 = [ 110, 100,  32,  49 ]\n        \u03c42 = [  54,  45,  98, 121 ]\n        \u03c43 = [ 116, 101,  32, 107 ]\n```\n\n## 10 The Salsa20 encryption function\n\n### Inputs and outputs\n\n*Note: The original document defines the Salsa20 encryption function as Salsa20<sub>k<\/sub>(v) \u2295 m.*\n*For clarity it is defined in this document to Salsa20_encrypt(k, v, m).*\n\nLet k be a 32-byte or 16-byte sequence. Let v be an 8-byte sequence. Let m be an l-byte sequence for\nsome `l \u2208 {0,1,...,2^70}`. The **Salsa20 encryption of** m **with nonce** v **under key** k, denoted\nSalsa20_encrypt(k, v, m), is an l-byte sequence.\n\nNormally k is a secret key (preferably 32 bytes); v is a nonce, i.e., a unique message number; m is\na plaintext message; and Salsa20_encrypt(k, v, m) is a ciphertext message. Or m can be a ciphertext message,\nin which case Salsa20_encrypt(k, v, m) is the original plaintext message.\n\n```cryptol\nSalsa20_encrypt : {a, l} (a >= 1, 2 >= a, l >= 0, 2^^70 >= l)\n       => [16*a][8] -> [8][8] -> [l][8] -> [l][8]\n```\n\n### Definition\n\nSalsa20_expansion(k, v) is the 2^70-byte sequence\n\n*Salsa20_expansion(k,v#0), Salsa20_expansion(k,v#1), Salsa20_expansion(k,v#2),...,\nSalsa20_expansion(k,v#2^64-1)*\n\nHere i is the unique 8-byte sequence (i<sub>0<\/sub>,i<sub>1<\/sub>,...,i<sub>7<\/sub>) such that\n*i = i<sub>0<\/sub> + 2<sup>8<\/sup>i<sub>1<\/sub> + 2<sup>16<\/sup>i<sub>2<\/sub>+ ...\n+2<sup>56<\/sup>i<sub>7<\/sub>*.\n\nThe formula Salsa20_encrypt(k, v, m) implicitly truncates Salsa20_expansion(k, v) to the same length\nas m. In other words,\n\nSalsa20_encrypt(k,v,m) = Salsa20_expansion(k,v) \u2295 (m[0],m[1],...,m[l-1]) = (c[0],c[1],...,c[l-1])\n\nwhere c[i] = m[i] \u2295 Salsa20_expansion(k,v#\u230ai\/64\u230b)[i mod 64].\n\n```cryptol\nSalsa20_encrypt k v m = m ^ s\n    where\n        s = take (join [ Salsa20_expansion k (v # (reverse (split i))) | i <- [0,1...] ])\n\nSalsa20_encryptDecrypts : [32][8] -> [8][8] -> [32][8] -> Bit\nproperty Salsa20_encryptDecrypts k v m = m == Salsa20_encrypt k0 v c1\n                                      \/\\ m == Salsa20_encrypt k v c2\n    where\n        [ k0, k1 ] = split k : [2][16][8]\n        c1  = Salsa20_encrypt k0 v m  \/\/ with 16 bit k\n        c2  = Salsa20_encrypt k v m  \/\/ with 32 bit k\n```\n\n### Comments\n\nThe definition of Salsa20 could easily be generalized from byte sequences to bit sequences, given an\nencoding of bytes as sequences of bits. However, there is no apparent application of this\ngeneralization.","variant":null,"set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/ZUC1_6.md","filetype":"txt","content":"# ZUC Algorithm Specification Version 1.6\n\n## Introduction\n\nAll text in this document is directly from the\n[ZUC 1.6 specification](https:\/\/www.gsma.com\/aboutus\/wp-content\/uploads\/2014\/12\/eea3eia3zucv16.pdf).\n\n## 1 Introduction\n\nZUC is a word-oriented stream cipher. It takes a 128-bit initial key and a 128-bit initial vector\n(IV) as input, and outputs a keystream of 32-bit words (where each 32-bit word is hence called a\n*key-word*). This keystream can be used for encryption\/decryption.\n\nThe execution of ZUC has two stages: initialization stage and working stage. In the first stage, a\nkey\/IV initialization is performed, i.e., the cipher is clocked without producing output (see\nsection 3.6.1). The second stage is a working stage. In this stage, with every clock pulse, it\nproduces a 32-bit word of output (see section 3.6.2).\n\n```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::ZUC1_6 where\n```\n\n## 2 Notations and conventions\n\n### 2.1 Radix\n\nIn this document, integers are represented as decimal numbers unless specified otherwise. We use the\nprefix `0x` to indicate hexadecimal numbers, and the prefix `0b` to indicate a number in binary\nrepresentation. [Note: the original document uses the subscript `2` to represent binary numbers].\n\n**Example 1:** Integer a can be written in different representations:\n\n```cryptol\nproperty example1 = a == 0x499602D2      \/\/ hexadecimal representation\n                     \/\\ a == 0b01001001100101100000001011010010  \/\/ binary representation\n    where\n        a = 1234567890  \/\/ decimal representation\n```\n\n### 2.2 Bit ordering\n\nIn this document, all data variables are presented with the most significant bit(byte) on the left\nhand side and the least significant bit(byte) on the right hand side.\n\n**Example 2:**\n\n```cryptol\nproperty example2 = most_sig == take`{1} a  \/\/ the leftmost bit\n                       \/\\ least_sig == (a ! 0)     \/\/ the rightmost bit\n    where\n        a = 0b1001001100101100000001011010010\n        most_sig = 1\n        least_sig = 0\n```\n\n### 2.3 Notations\n\n|  |  |\n| -----: | ------ |\n| `+` | The addition of two integers |\n| `ab` | The product of integers a and b |\n| `=` | The assignment operator |\n| `mod` | The modulo operator of integers |\n| `\u2295` | The bit-wise exclusive-OR operation of integers |\n| `\u229e` | The modulo 2^32 addition |\n| `a\\|\\|b` | The concatenation of strings a and b |\n| `a_H` | The leftmost 16 bits of integer a |\n| `a_L` | The rightmost 16 bits of integer a |\n| `a <<<_n k` | The k-bit cyclic shift of the n bit register a to the left |\n| `a >> 1` | The 1-bit right shift of integer a |\n| `(a1,a2,...an) \u2192 (b1,b2,...bn)` | The assignment of the values of ai to bi in parallel |\n\n**Example 3:** For any two strings a and b, the presentation of the string c created by the\nconcatenation of a and b also follows the rules defined in section 2.2 i.e., the most significant\ndigits are on the left hand side and the least significant digits are on the right hand side. For\ninstance,\n\n```cryptol\nproperty example3 = a # b == 0x12345678\n    where\n        a = 0x1234\n        b = 0x5678\n```\n\n**Example 4:**\n\n```cryptol\nH : {n} (fin n, n >= 16)\n => [n] -> [16]\nH a = take`{16} a\n\nL : {n} (fin n, n >= 16)\n => [n] -> [16]\nL a = drop`{back=16} a\n\nproperty example4 = ah == H a\n                 \/\\ al == L a\n    where\n        a  = 0b1001001100101100000001011010010\n        ah = 0b1001001100101100\n        al = 0b0000001011010010\n```\n\n**Example 5:**\n\n```cryptol\nproperty example5 = a >> 1 == 0b01100100110010110000000101101001\n    where\n        a = 0b11001001100101100000001011010010\n```\n\n**Example 6:** Let a0, a1, ... a15, b0, b1, ... b15 be all integer variables. Then\n\n```cryptol\nexample6 : [16]Integer -> Bit\nproperty example6 as = and [ as@i == bs@i | i <- [0..15] ]\n    where\n        bs = as\n```\n\n## 3 Algorithm description\n\n### 3.1 General structure of the algorithm\n\nZUC has three logical layers, see Fig. 1 in the original document. The top layer is a linear\nfeedback shift register (LFSR) of 16 stages, the middle layer is for bit-reorganization (BR), and\nthe bottom layer is a nonlinear function *F*.\n\n### 3.2 The linear feedback shift register (LFSR)\n\nThe linear feedback shift register (LFSR) has 16 of 31-bit cells (s0,s1,...,s15). Each cell si\n(0<=i<=15) is restricted to take values from the following set:\n`{1,2,3,...,2^31-1}`\n\n```cryptol\ntype LFSR = [16][31]\n```\n\nThe LFSR has 2 modes of operations: the initialization mode and the working mode.\n\nIn the initialization mode, the LFSR receives a 31-bit inputs word *u*, which is obtained by\nremoving the rightmost bit from the 32-bit output W of the nonlinear function *F*, i.e., `u=W>>1`.\nMore specifically, the initialization mode works as follows:\n\n```cryptol\nLFSRWithInitialisationMode : [31] -> LFSR -> LFSR\nLFSRWithInitialisationMode u s = s@@[1..15] # [s16]  \/\/step4\n    where\n        v = step1 s  \/\/step1\n        vu = add v u\n        s16 = if vu != 0 then vu     \/\/step2\n                            else 2^^31 - 1  \/\/ step3\n```\n\nIn the working mode, the LFSR does not receive any input, and it works as follows:\n\n```cryptol\nLFSRWithWorkMode : LFSR -> LFSR\nLFSRWithWorkMode s = s@@[1..15] # [s16]  \/\/ step3\n    where\n        v = step1 s \/\/step1\n        s16 = if v != 0 then v          \/\/ step1\n                        else 2^^31 - 1  \/\/ step2\n```\n\n*Informative note:* Since the multiplication of a 31-bit string *s* by 2^i over GF(2^31-1) can be\nimplemented by a cyclic shift of *s* to the left by *i* bits, only addition modulo 2^31-1 is needed\nin step 1 of the above function. More precisely, step 1 of the function LFSRWithInitialisationMode\ncan be implemented by\n\n```cryptol\nstep1 : LFSR -> [31]\nstep1 s = v\n    where\n        v = foldl add 0 [ ((s@15) <<< 15)\n                        , ((s@13) <<< 17)\n                        , ((s@10) <<< 21)\n                        , ((s@4)  <<< 20)\n                        , ((s@0)  <<< 8)\n                        , (s@0) ]\n```\n\nand the same implementation is needed for step 1 of the function LFSRWithWorkMode.\n\n\n*Informative note:* For two elements a, b over GF(2^31-1), the computation of `v=a+b mod (2^31-1)`\ncan be done by (1) compute `v=a+b`; and (2) if the carry bit is 1, then set `v=v+1`. Alternatively,\n(and better if the implementation should resist possible timing attacks): (1) compute `w=a+b`,\nwhere w is a 32-bit value; and (2) set `v = (least significant 31 bits of w)+(most significant bit\nof w)`.\n\n```cryptol\nadd : [31] -> [31] -> [31]\nadd a b = v'\n    where\n        v : [32]\n        v = ((zero # a) + (zero # b))\n        v' = if v@0 then (drop v) + 1\n                    else drop v\n\naddAlt : [31] -> [31] -> [31]\naddAlt a b = v\n    where\n        w : [32]\n        w = (zero # a) + (zero # b)\n        v = (drop w) + (zero # [w@0])\n\nproperty addEquiv a b = add a b == addAlt a b\n```\n\n### 3.3 The bit-reorganization\n\nThe middle layer of the algorithm is the bit-reorganization. It extracts 128 bits from the cells of\nthe LFSR and forms 4 of 32-bit words, where the first three words will be used by the nonlinear\nfunction *F* in the bottom layer, and the last word will be involved in producing the keystream,\n\nLet *s0,s2,s5,s7,s9,s11,s14,s15* by 8 cells of LFSR as in section 3.2. The the bit-reorganization\nforms 4 of 32-bit words *X0,X1,X2,X3* from the above cells as follows:\n\n```cryptol\nBitreorganization : LFSR -> [4][32]\nBitreorganization s = [X0, X1, X2, X3]\n    where\n        X0 = H (s@15) # L (s@14)\n        X1 = L (s@11) # H (s@9)\n        X2 = L (s@7)  # H (s@5)\n        X3 = L (s@2)  # H (s@0)\n```\n\n*Note*: That *s_i* are 31-bit integers, so *s_iH* means bits 30..15 and not 31..16 of *s_i*, for\n0<=i<=15.\n\n### 3.4 The nonlinear function F\n\nThe nonlinear function *F* has 2 of 32-bit memory cells *R1* and *R2*. Let the inputs to *F* be\n*X0,X1* and *X2*, which come from the outputs of the bit-reorganization (see section 3.3), then the\nfunction *F* outputs a 32-bit word *W*. The detailed process of *F* is as follows:\n\n```cryptol\nF : [2][32] -> [3][32] -> ([32], [2][32])\nF [R1, R2] [X0, X1, X2] = (W, [R1', R2'])\n    where\n        W = (X0 ^ R1) + R2\n        W1 = R1 + X1\n        W2 = R2 ^ X2\n        R1' = S (L1 (L W1 # H W2))\n        R2' = S (L2 (L W2 # H W1))\n```\n\nwhere *S* is a 32x32 S-box, see section 3.4.1, *L1* and *L2* are linear transforms as defined in\nsection 3.4.2.\n\n#### 3.4.1 The S-box *S*\n\nThe 32x32 S-box S is composed of 4 juxtaposed 8x8 S-boxes, i.e., *S=(S0,S1,S2,S3)*, where\n*S0=S2,S1=S3*. The definitions of *S0* and *S1* can be found in table 3.1 and table 3.2\nrespectively.\n\n```cryptol\nS0 : [8] -> [8]\nS0 x = S0Table@h@l\n    where\n        [h, l] = split x\n\nS1: [8] -> [8]\nS1 x = S1Table@h@l\n    where\n        [h, l] = split x\n\nS2 : [8] -> [8]\nS2 = S0\n\nS3 : [8] -> [8]\nS3 = S1\n```\n\nLet *x* be an 8-bit input to *S0* (or *S1*). Write *x* into two hexadecimal digits as `x=h||l`, then\nthe entry at the intersection of the *h*-th row and the *l*-th column in table 3.1 (or table 3.2) is\nthe output of *S0* (or *S1*).\n\n**Example 7:**\n\n```cryptol\nproperty example7 = S0 0x12 == 0xF9\n                 \/\\ S1 0x34 == 0xC0\n```\n\nLet the 32-bit input X and the 32-bit output Y of the S-box *S* be as follows:\n\n```cryptol\nS : [32] -> [32]\nS X =  y0 # y1 # y2 # y3\n    where\n        [x0, x1, x2, x3] = split X\n        y0 = S0 x0\n        y1 = S1 x1\n        y2 = S2 x2\n        y3 = S3 x3\n```\n\n**Example 8:**\n\n```cryptol\nproperty example8 = S X == Y\n    where\n        X = 0x12345678\n        Y = 0xF9C05A4E\n```\n\n**Table 3.1. The S-box S0**\n\n```cryptol\nS0Table : [16][16][8]\nS0Table =\n    [ [0x3E, 0x72, 0x5B, 0x47, 0xCA, 0xE0, 0x00, 0x33, 0x04, 0xD1, 0x54, 0x98, 0x09, 0xB9, 0x6D, 0xCB]\n    , [0x7B, 0x1B, 0xF9, 0x32, 0xAF, 0x9D, 0x6A, 0xA5, 0xB8, 0x2D, 0xFC, 0x1D, 0x08, 0x53, 0x03, 0x90]\n    , [0x4D, 0x4E, 0x84, 0x99, 0xE4, 0xCE, 0xD9, 0x91, 0xDD, 0xB6, 0x85, 0x48, 0x8B, 0x29, 0x6E, 0xAC]\n    , [0xCD, 0xC1, 0xF8, 0x1E, 0x73, 0x43, 0x69, 0xC6, 0xB5, 0xBD, 0xFD, 0x39, 0x63, 0x20, 0xD4, 0x38]\n    , [0x76, 0x7D, 0xB2, 0xA7, 0xCF, 0xED, 0x57, 0xC5, 0xF3, 0x2C, 0xBB, 0x14, 0x21, 0x06, 0x55, 0x9B]\n    , [0xE3, 0xEF, 0x5E, 0x31, 0x4F, 0x7F, 0x5A, 0xA4, 0x0D, 0x82, 0x51, 0x49, 0x5F, 0xBA, 0x58, 0x1C]\n    , [0x4A, 0x16, 0xD5, 0x17, 0xA8, 0x92, 0x24, 0x1F, 0x8C, 0xFF, 0xD8, 0xAE, 0x2E, 0x01, 0xD3, 0xAD]\n    , [0x3B, 0x4B, 0xDA, 0x46, 0xEB, 0xC9, 0xDE, 0x9A, 0x8F, 0x87, 0xD7, 0x3A, 0x80, 0x6F, 0x2F, 0xC8]\n    , [0xB1, 0xB4, 0x37, 0xF7, 0x0A, 0x22, 0x13, 0x28, 0x7C, 0xCC, 0x3C, 0x89, 0xC7, 0xC3, 0x96, 0x56]\n    , [0x07, 0xBF, 0x7E, 0xF0, 0x0B, 0x2B, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xA6, 0x4C, 0x10, 0xFE]\n    , [0xBC, 0x26, 0x95, 0x88, 0x8A, 0xB0, 0xA3, 0xFB, 0xC0, 0x18, 0x94, 0xF2, 0xE1, 0xE5, 0xE9, 0x5D]\n    , [0xD0, 0xDC, 0x11, 0x66, 0x64, 0x5C, 0xEC, 0x59, 0x42, 0x75, 0x12, 0xF5, 0x74, 0x9C, 0xAA, 0x23]\n    , [0x0E, 0x86, 0xAB, 0xBE, 0x2A, 0x02, 0xE7, 0x67, 0xE6, 0x44, 0xA2, 0x6C, 0xC2, 0x93, 0x9F, 0xF1]\n    , [0xF6, 0xFA, 0x36, 0xD2, 0x50, 0x68, 0x9E, 0x62, 0x71, 0x15, 0x3D, 0xD6, 0x40, 0xC4, 0xE2, 0x0F]\n    , [0x8E, 0x83, 0x77, 0x6B, 0x25, 0x05, 0x3F, 0x0C, 0x30, 0xEA, 0x70, 0xB7, 0xA1, 0xE8, 0xA9, 0x65]\n    , [0x8D, 0x27, 0x1A, 0xDB, 0x81, 0xB3, 0xA0, 0xF4, 0x45, 0x7A, 0x19, 0xDF, 0xEE, 0x78, 0x34, 0x60]\n    ]\n```\n\n**Table 3.2. The S-box S1**\n\n```cryptol\nS1Table : [16][16][8]\nS1Table =\n    [ [0x55, 0xC2, 0x63, 0x71, 0x3B, 0xC8, 0x47, 0x86, 0x9F, 0x3C, 0xDA, 0x5B, 0x29, 0xAA, 0xFD, 0x77]\n    , [0x8C, 0xC5, 0x94, 0x0C, 0xA6, 0x1A, 0x13, 0x00, 0xE3, 0xA8, 0x16, 0x72, 0x40, 0xF9, 0xF8, 0x42]\n    , [0x44, 0x26, 0x68, 0x96, 0x81, 0xD9, 0x45, 0x3E, 0x10, 0x76, 0xC6, 0xA7, 0x8B, 0x39, 0x43, 0xE1]\n    , [0x3A, 0xB5, 0x56, 0x2A, 0xC0, 0x6D, 0xB3, 0x05, 0x22, 0x66, 0xBF, 0xDC, 0x0B, 0xFA, 0x62, 0x48]\n    , [0xDD, 0x20, 0x11, 0x06, 0x36, 0xC9, 0xC1, 0xCF, 0xF6, 0x27, 0x52, 0xBB, 0x69, 0xF5, 0xD4, 0x87]\n    , [0x7F, 0x84, 0x4C, 0xD2, 0x9C, 0x57, 0xA4, 0xBC, 0x4F, 0x9A, 0xDF, 0xFE, 0xD6, 0x8D, 0x7A, 0xEB]\n    , [0x2B, 0x53, 0xD8, 0x5C, 0xA1, 0x14, 0x17, 0xFB, 0x23, 0xD5, 0x7D, 0x30, 0x67, 0x73, 0x08, 0x09]\n    , [0xEE, 0xB7, 0x70, 0x3F, 0x61, 0xB2, 0x19, 0x8E, 0x4E, 0xE5, 0x4B, 0x93, 0x8F, 0x5D, 0xDB, 0xA9]\n    , [0xAD, 0xF1, 0xAE, 0x2E, 0xCB, 0x0D, 0xFC, 0xF4, 0x2D, 0x46, 0x6E, 0x1D, 0x97, 0xE8, 0xD1, 0xE9]\n    , [0x4D, 0x37, 0xA5, 0x75, 0x5E, 0x83, 0x9E, 0xAB, 0x82, 0x9D, 0xB9, 0x1C, 0xE0, 0xCD, 0x49, 0x89]\n    , [0x01, 0xB6, 0xBD, 0x58, 0x24, 0xA2, 0x5F, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xB8, 0x95, 0xE4]\n    , [0xD0, 0x91, 0xC7, 0xCE, 0xED, 0x0F, 0xB4, 0x6F, 0xA0, 0xCC, 0xF0, 0x02, 0x4A, 0x79, 0xC3, 0xDE]\n    , [0xA3, 0xEF, 0xEA, 0x51, 0xE6, 0x6B, 0x18, 0xEC, 0x1B, 0x2C, 0x80, 0xF7, 0x74, 0xE7, 0xFF, 0x21]\n    , [0x5A, 0x6A, 0x54, 0x1E, 0x41, 0x31, 0x92, 0x35, 0xC4, 0x33, 0x07, 0x0A, 0xBA, 0x7E, 0x0E, 0x34]\n    , [0x88, 0xB1, 0x98, 0x7C, 0xF3, 0x3D, 0x60, 0x6C, 0x7B, 0xCA, 0xD3, 0x1F, 0x32, 0x65, 0x04, 0x28]\n    , [0x64, 0xBE, 0x85, 0x9B, 0x2F, 0x59, 0x8A, 0xD7, 0xB0, 0x25, 0xAC, 0xAF, 0x12, 0x03, 0xE2, 0xF2]\n    ]\n```\n\n#### 3.4.2 The linear transforms *L1* and *L2*\n\nBoth *L1* and *L2* are linear transforms from 32-bit words to 32-bit words, and are defined as\nfollows:\n\n```cryptol\nL1 : [32] -> [32]\nL1 X = X ^ (X <<< 2) ^ (X <<< 10) ^ (X <<< 18) ^ (X <<< 24)\n\nL2 : [32] -> [32]\nL2 X = X ^ (X <<< 8) ^ (X <<< 14) ^ (X <<< 22) ^ (X <<< 30)\n```\n\n### 3.5 Key loading\n\nThe key loading procedure will expand the initial key and the initial vector into 16 of 31-bit\nintegers as the initial state of the LFSR. Let the 128-bit initial key *k* and the 128-bit initial\nvector *iv* be\n\n`k=k0||k1||k2||...||k15`\n\nand\n\n`iv=iv0||iv1||iv2||...||iv15`\n\nrespectively, where *k_i* and *iv_i*, 0<=i<=15, are all bytes. Then *k* and *iv* are loaded to the\ncells *s0,s1,...,s15* of LFSR as follows:\n\n```cryptol\nD : [16][15]\nD = [ 0b100010011010111, 0b010011010111100, 0b110001001101011, 0b001001101011110\n    , 0b101011110001001, 0b011010111100010, 0b111000100110101, 0b000100110101111\n    , 0b100110101111000, 0b010111100010011, 0b110101111000100, 0b001101011110001\n    , 0b101111000100110, 0b011110001001101, 0b111100010011010, 0b100011110101100\n    ]\n\nKeyLoad : [128] -> [128] -> LFSR\nKeyLoad k iv = s\n    where\n        k' = split`{16} k\n        iv' = split`{16} iv\n        s = [ ki # di # ivi | ki <- k' | di <- D | ivi <- iv' ]\n```\n\n### 3.6 The execution of ZUC\n\nThe execution of ZUC has two stages: the initialization stage and the working stage.\n\n```cryptol\nZUC : [128] -> [128] -> [inf][32]\nZUC key iv = WorkStage initZuc\n    where\n        initZuc = InitializeStage key iv\n```\n\n#### 3.6.1 The initialization stage\n\nDuring the initialization stage, the algorithm calls the key loading procedure (see section 3.5) to\nload the 128-bit initial key *k* and the 128-bit initial vector *iv* into the LFSR, and set the\n32-bit memory cells *R1* and *R2* to be all 0. The the cipher runs the following operations 32\ntimes:\n\n```cryptol\nInitializeStage : [128] -> [128] -> (LFSR, [2][32])\nInitializeStage k iv = last s'\n    where\n        s = KeyLoad k iv\n        R0 = zero : [2][32]\n        s' = [ (s, R0)] # [ InitializeStep si Ri | (si, Ri) <- s' | i <- [1..32] ]\n\nInitializeStep : LFSR -> [2][32] -> (LFSR, [2][32])\nInitializeStep s Rs = (s', Rs')\n    where\n        [X0, X1, X2, _] = Bitreorganization s\n        (w, Rs') = F Rs [X0, X1, X2]\n        s' = LFSRWithInitialisationMode (drop (w >> 1)) s\n```\n\n#### 3.6.2 The working stage\n\nAfter the initialization stage, the algorithm moves in the working stage. At the working stage, the\nalgorithm executes the following operations once, and discards the output *W* of *F*:\n\n```cryptol\nWorkStep1 : LFSR -> [2][32] -> (LFSR, [2][32])\nWorkStep1 s Rs = (s', Rs')\n    where\n        [X0, X1, X2, _] = Bitreorganization s\n        (_, Rs') = F Rs [X0, X1, X2]\n        s' = LFSRWithWorkMode s\n```\n\nThen the algorithm goes into the stage of producing keystream, i.e., for each iteration, the\nfollowing operations are executed once, and a 32-bit word *Z* is produced as an output:\n\n```cryptol\nWorkStep2 : LFSR -> [2][32] -> ([32], LFSR, [2][32])\nWorkStep2 s Rs = (Z, s', Rs')\n    where\n        [X0, X1, X2, X3] = Bitreorganization s\n        (w, Rs') = F Rs [X0, X1, X2]\n        Z = w ^ X3\n        s' = LFSRWithWorkMode s\n\nWorkStage : (LFSR, [2][32]) -> [inf][32]\nWorkStage (s, Rs) = zs\n    where\n        (s', Rs') = WorkStep1 s Rs\n        z0 = zero : [32]\n        keystream = [ (z0, s', Rs') ]\n                  # [ WorkStep2 si Ri | (_, si, Ri) <- keystream | i <- [1...]]\n        zs = [ (keystream@i).0 | i <- [1...] ]","variant":null,"set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/KDF\/HKDF.md","filetype":"txt","content":"# HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\n\n## Introduction\n\nAll text in this document is directly from this [HKDF RFC](https:\/\/tools.ietf.org\/html\/rfc5869).\n\n## Abstract\n\nThis document specifies a simple Hashed Message Authentication Code\n(HMAC)-based key derivation function (HKDF), which can be used as a\nbuilding block in various protocols and applications.  The key\nderivation function (KDF) is intended to support a wide range of\napplications and requirements, and is conservative in its use of\ncryptographic hash functions.\n\n## 1.  Introduction\nA key derivation function (KDF) is a basic and essential component of\ncryptographic systems.  Its goal is to take some source of initial\nkeying material and derive from it one or more cryptographically\nstrong secret keys.\n\nThis document specifies a simple HMAC-based [HMAC] KDF, named HKDF,\nwhich can be used as a building block in various protocols and\napplications, and is already used in several IETF protocols,\nincluding [IKEv2], [PANA], and [EAP-AKA].  The purpose is to document\nthis KDF in a general way to facilitate adoption in future protocols\nand applications, and to discourage the proliferation of multiple KDF\nmechanisms.  It is not intended as a call to change existing\nprotocols and does not change or update existing specifications using\nthis KDF.\n\nHKDF follows the \"extract-then-expand\" paradigm, where the KDF\nlogically consists of two modules.  The first stage takes the input\nkeying material and \"extracts\" from it a fixed-length pseudorandom\nkey K.  The second stage \"expands\" the key K into several additional\npseudorandom keys (the output of the KDF).\n\nIn many applications, the input keying material is not necessarily\ndistributed uniformly, and the attacker may have some partial\nknowledge about it (for example, a Diffie-Hellman value computed by a\nkey exchange protocol) or even partial control of it (as in some\nentropy-gathering applications).  Thus, the goal of the \"extract\"\nstage is to \"concentrate\" the possibly dispersed entropy of the input\nkeying material into a short, but cryptographically strong,\npseudorandom key.  In some applications, the input may already be a\ngood pseudorandom key; in these cases, the \"extract\" stage is not\nnecessary, and the \"expand\" part can be used alone.\n\nThe second stage \"expands\" the pseudorandom key to the desired\nlength; the number and lengths of the output keys depend on the\nspecific cryptographic algorithms for which the keys are needed.\n\nNote that some existing KDF specifications, such as NIST Special\nPublication 800-56A [800-56A], NIST Special Publication 800-108\n[800-108] and IEEE Standard 1363a-2004 [1363a], either only consider\nthe second stage (expanding a pseudorandom key), or do not explicitly\ndifferentiate between the \"extract\" and \"expand\" stages, often\nresulting in design shortcomings.  The goal of this specification is\nto accommodate a wide range of KDF requirements while minimizing the\nassumptions about the underlying hash function.  The \"extract-then-\nexpand\" paradigm supports well this goal (see [HKDF-paper] for more\ninformation about the design rationale).\n\n## 2. HMAC-based Key Derivation Function (HKDF)\n\n```cryptol\nmodule Primitive::Symmetric::KDF::HKDF where\n```\n\n### 2.1.  Notation\n\nHMAC-Hash denotes the HMAC function [HMAC] instantiated with hash\nfunction 'Hash'.  HMAC always has two arguments: the first is a key\nand the second an input (or message).  (Note that in the extract\nstep, 'IKM' is used as the HMAC input, not as the HMAC key.)\n\n\n```cryptol\nparameter\n\n    type HashLen : #\n    type constraint (fin HashLen)\n\n    \/\/ HMAC has limitations on input sizes based on its own\n    \/\/ limitations and hash limits\n    type constraint validHMACSizes KeyLen MsgLen =\n      ( fin KeyLen, fin MsgLen\n          , 32 >= width MsgLen\n          , 64 >= width (8 * KeyLen)\n          , 64 >= width (8 * 64 + MsgLen))\n\n\n\n    \/\/ Hash : {MsgSize} (fin MsgSize) => [MsgSize][8] -> [HashLen][8] The hash will come with the HMAC\n\n    HMAC : {KeyLen, MsgLen} (validHMACSizes KeyLen MsgLen) =>\n           [KeyLen][8] -> [MsgLen][8] -> [HashLen][8]\n```\n\n### 2.2.  Step 1: Extract\n\n```cryptol\nHKDF_Extract : {SaltLen, IKMLen} (validHMACSizes SaltLen IKMLen) => [SaltLen][8] -> [IKMLen][8] -> [HashLen][8]\nHKDF_Extract salt IKM = PRK where\n```\n\n| Inputs  |                                                                                                           |\n|--------:|-----------------------------------------------------------------------------------------------------------|\n|  salt   | optional salt value a non-secret random value if not provided, it is set to a string of HashLen zeros.    |\n|  IKM    | input keying material                                                                                     |\n\n| Output |                                        |\n|-------:|----------------------------------------|\n| PRK    | a pseudorandom key (of HashLen octets) |\n\n```cryptol\n    PRK = HMAC salt IKM\n```\n\n### 2.2.  Step 2: Expand\n\n```cryptol\nHKDF_Expand : {PRKLen, InfoLen, L}\n              (fin PRKLen, fin InfoLen, fin L\n              , PRKLen >= HashLen, 255 * HashLen >= L\n              , L >= HashLen + 1\n              , validHMACSizes PRKLen (1 + InfoLen + HashLen)) =>\n              [PRKLen][8] -> [InfoLen][8] -> [L][8]\nHKDF_Expand PRK info = OKM where\n```\n| Inputs  |                                                                                                           |\n|--------:|-----------------------------------------------------------------------------------------------------------|\n|  PRK    | a pseudorandom key of at least HashLen octets (usually, the output from the extract step)                 |\n|  info   | optional context and application specific information (can be a zero-length string)                       |\n|  L      | length of output keying material in octets (<= 255*HashLen)\n\n| Output |                                        |\n|-------:|----------------------------------------|\n| OKM    |  output keying material (of L octets)  |\n\n```cryptol\n    type N   = L \/^ HashLen\n    (T : [N][HashLen][8]) =\n          [(HMAC PRK (info # [0x01]))]\n        # [HMAC PRK (t_n # info # [n]) | t_n <- T\n                                       | n <- [0x02 ..N]]\n    OKM = take (join T)\n```\n\n### Appendix A.  Test Vectors\n\nThis appendix provides test vectors for SHA-256 and SHA-1 hash\n   functions.\n\nSee file ```HKDF256Tests.cry","variant":null,"set":"unsupervised"}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/KDF\/HKDF256Tests.md","filetype":"txt","content":"cryptol\nmodule Primitive::Symmetric::KDF::HKDF256Tests where\n\nimport Primitive::Symmetric::KDF::HKDF256\n```\n\n### A.1. Test Case 1\n\nBasic test case with SHA-256\n\n```cryptol\n\/**\n * ```repl\n * :prove test1\n * ```\n *\/\ntest1 : Bit\ntest1 = result where\n  IKM  = split 0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b \/\/ (22 octets)\n  salt = split 0x000102030405060708090a0b0c                   \/\/ (13 octets)\n  info = split 0xf0f1f2f3f4f5f6f7f8f9                         \/\/ (10 octets)\n  \/\/L    = 42 L will be inferred by the length of OKM\n  PRK  = split ( 0x077709362c2e32df0ddc3f0dc47bba63\n               # 0x90b6c73bb50f9c3122ec844ad7c2b3e5)\n                                                              \/\/ (32 octets)\n  OKM  = split ( 0x3cb25f25faacd57a90434f64d0362f2a\n               # 0x2d2d0a90cf1a5a4c5db02d56ecc4c5bf\n               # 0x34007208d5b887185865 )                     \/\/ (42 octets)\n  PRKc = PRK == HKDF_Extract salt IKM\n  OKMc = OKM == HKDF_Expand PRK info\n  result = PRKc \/\\ OKMc\n```\n\n### A.2. Test Case 2\n\nTest with SHA-256 and longer inputs\/outputs\n\n```cryptol\n\/**\n * ```repl\n * :prove test2\n * ```\n *\/\ntest2 : Bit\ntest2 = result where\n  IKM  = split ( 0x000102030405060708090a0b0c0d0e0f\n               # 0x101112131415161718191a1b1c1d1e1f\n               # 0x202122232425262728292a2b2c2d2e2f\n               # 0x303132333435363738393a3b3c3d3e3f\n               # 0x404142434445464748494a4b4c4d4e4f)  \/\/ (80 octets)\n  salt = split ( 0x606162636465666768696a6b6c6d6e6f\n               # 0x707172737475767778797a7b7c7d7e7f\n               # 0x808182838485868788898a8b8c8d8e8f\n               # 0x909192939495969798999a9b9c9d9e9f\n               # 0xa0a1a2a3a4a5a6a7a8a9aaabacadaeaf)  \/\/ (80 octets)\n  info = split ( 0xb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\n               # 0xc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\n               # 0xd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\n               # 0xe0e1e2e3e4e5e6e7e8e9eaebecedeeef\n               # 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff)  \/\/ (10 octets)\n  \/\/L    = 82 L will be inferred by the length of OKM\n  PRK  = split ( 0x06a6b88c5853361a06104c9ceb35b45c\n               # 0xef760014904671014a193f40c15fc244)  \/\/ (32 octets)\n  OKM  = split ( 0xb11e398dc80327a1c8e7f78c596a4934\n               # 0x4f012eda2d4efad8a050cc4c19afa97c\n               # 0x59045a99cac7827271cb41c65e590e09\n               # 0xda3275600c2f09b8367793a9aca3db71\n               # 0xcc30c58179ec3e87c14c01d5c1f3434f\n               # 0x1d87)                              \/\/ (82 octets)\n  PRKc = PRK == HKDF_Extract salt IKM\n  OKMc = OKM == HKDF_Expand PRK info\n  result = PRKc \/\\ OKMc","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/overview.html","filetype":"txt","content":"## Overview\n\nThe Software Analysis Workbench (SAW) is a tool for constructing mathematical models of the computational behavior of software, transforming these models, and proving properties about them.\n\nSAW can currently construct models of a subset of programs written in Cryptol, LLVM (and therefore C), and JVM (and therefore Java). SAW also has experimental, incomplete support for MIR (and therefore Rust). The models take the form of typed functional programs, so in a sense SAW can be considered a translator from imperative programs to their functional equivalents. Various external proof tools, including a variety of SAT and SMT solvers, can be used to prove properties about the functional models. SAW can construct models from arbitrary Cryptol programs, and from C and Java programs that have fixed-size inputs and outputs and that terminate after a fixed number of iterations of any loop (or a fixed number of recursive calls). One common use case is to verify that an algorithm specification in Cryptol is equivalent to an algorithm implementation in C or Java.\n\nThe process of extracting models from programs, manipulating them, forming queries about them, and sending them to external provers is orchestrated using a special purpose language called SAWScript. SAWScript is a typed functional language with support for sequencing of imperative commands.\n\nThe rest of this document first describes how to use the SAW tool, saw, and outlines the structure of the SAWScript language and its relationship to Cryptol. It then presents the SAWScript commands that transform functional models and prove properties about them. Finally, it describes the specific commands available for constructing models from imperative programs.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/structure-of-sawscript.html","filetype":"txt","content":"## Structure of SAWScript\n\nA SAWScript program consists, at the top level, of a sequence of commands to be executed in order. Each command is terminated with a semicolon. For example, the print command displays a textual representation of its argument. Suppose the following text is stored in the file print.saw:\n\n```\nprint 3;\n```\n\nThe command `saw print.saw` will then yield output similar to the following:\n\n```\nLoading module Cryptol\nLoading file \"print.saw\"\n3\n```\n\nThe same code can be run from the interactive REPL:\n\n```\nsawscript> print 3;\n3\n```\n\nAt the REPL, terminating semicolons can be omitted:\n\n```\nsawscript> print 3\n3\n```\n\nTo make common use cases simpler, bare values at the REPL are treated as if they were arguments to print:\n\n```\nsawscript> 3\n3\n```\n\nOne SAWScript file can be included in another using the `include` command, which takes the name of the file to be included as an argument. For example:\n\n```\nsawscript> include \"print.saw\"\nLoading file \"print.saw\"\n3\n```\n\nTypically, included files are used to import definitions, not perform side effects like printing. However, if any commands with side effects occur at the top level of the imported file, those side effects will occur during import.\n\nTo get started with SAW, let\u2019s see what it takes to verify simple programs that do not use pointers (or that use them only internally). Consider, for instance, the C program that adds its two arguments together:\n\n```c\n#include <stdint.h>\nuint32_t add(uint32_t x, uint32_t y) {\n    return x + y;\n}\n```\n\nWe can specify this function\u2019s expected behavior as follows:\n\n```plaintext\nlet add_setup = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    llvm_execute_func [llvm_term x, llvm_term y];\n    llvm_return (llvm_term {{ x + y : [32] }});\n};\n```\n\nWe can then compile the C file add.c into the bitcode file add.bc and verify it with ABC:\n\n```plaintext\nm <- llvm_load_module \"add.bc\";\nadd_ms <- llvm_verify m \"add\" [] false add_setup abc;\n```\n\n## Syntax\n\nThe syntax of SAWScript is reminiscent of functional languages such as Cryptol, Haskell and ML. In particular, functions are applied by writing them next to their arguments rather than by using parentheses and commas. Rather than writing `f(x, y)`, write `f x y`.\n\nComments are written as in C, Java, and Rust (among many other languages). All text from `\/\/` until the end of a line is ignored. Additionally, all text between `\/*` and `*\/` is ignored, regardless of whether the line ends.\n\n## Basic Types and Values\n\nAll values in SAWScript have types, determined and checked before a program runs (SAWScript is statically typed). The basic types available are similar to those in many other languages:\n\n- The `Int` type represents unbounded mathematical integers. Integer constants can be written in decimal notation (e.g., 42), hexadecimal notation (0x2a), and binary (0b00101010). Integers in SAWScript are used primarily as constants. Arithmetic is usually encoded in Cryptol, as discussed in the next section.\n- The Boolean type, `Bool`, contains the values `true` and `false`, like in many other languages. Computations on Boolean values usually occur in Cryptol.\n- Values of any type can be aggregated into tuples. For example, `(true, 10)` has the type `(Bool, Int)`.\n- Values of any type can also be aggregated into records, which are like tuples except components have names. For example, `{ b = true, n = 10 }` has type `{ b : Bool, n : Int }`.\n- A sequence of values of the same type can be stored in a list. For example, `[true, false, true]` has the type `[Bool]`.\n- Strings of textual characters can be represented in the `String` type. For example, `\"example\"` has type `String`.\n- The \u201cunit\u201d type, written `()`, is essentially a placeholder, similar to `void` in languages like C and Java. It has only one value, also written `()`. Values of type `()` convey no information.\n- Functions are given types that indicate what type they consume and produce. For example, `Int -> Bool` indicates a function taking an Int input producing a Bool output. Multiple arguments use multiple arrows, e.g., `Int -> String -> Bool`. Grouping arguments in tuples is also possible, e.g., `(Int, String) -> Bool`.\n\nSAWScript also includes more specialized types appearing in later sections.\n\n## Basic Expression Forms\n\nOne key form of top-level command in SAWScript is a binding, introduced with the `let` keyword, which gives a name to a value. For example:\n\n```\nsawscript> let x = 5\nsawscript> x\n5\n```\n\nBindings can have parameters, defining functions. For instance, the following function takes one parameter and returns a list containing that parameter as its single element:\n\n```\nsawscript> let f x = [x]\nsawscript> f \"text\"\n[\"text\"]\n```\n\nFunctions themselves are values and have types. The type of a function taking an argument of type `a` and returning a result of type `b` is `a -> b`.\n\nFunction types are typically inferred, as in `f` above. Since `f` creates a list with the given argument, and lists can hold any element type, `f` is polymorphic. Concretely, the type of `f` is `{a} a -> [a]`. It can be applied to an argument of any type:\n\n```\nsawscript> f 10\n[10]\n```\n\nType annotations can restrict function parameter types:\n\n```\nsawscript> let f (x : Int) = [x]\n```\n\nThis works identically on Int parameters:\n\n```\nsawscript> f 10\n[10]\n```\n\nBut fails on String parameters:\n\n```\nsawscript> f \"text\"\n\ntype mismatch: String -> t.0 and Int -> [Int]\n at \"_\" (REPL)\nmismatched type constructors: String and Int\n```\n\nType annotations can be applied to any expression: `(e : t)` indicates expression `e` should have type `t`.\n\nFunctions can return other functions. For example, a function `g` with two arguments:\n\n```\nsawscript> let g x y = [x, y]\n```\n\nLike `f`, `g` is polymorphic, with type `{a} a -> a -> [a]`. It takes an argument of type `a`, returns a function taking an argument of the same type and returning a list of `a`.\n\nExamples:\n\n```\nsawscript> g 2 3\n[2,3]\nsawscript> g true false\n[true,false]\n```\n\nType checking fails if arguments differ in type:\n\n```\nsawscript> g 2 false\n\ntype mismatch: Bool -> t.0 and Int -> [Int]\n at \"_\" (REPL)\nmismatched type constructors: Bool and Int\n```\n\nFunctions and commands are related but distinct: a function is a value with a function type (e.g., `Int -> [Int]`), a command is a value with a special command type (e.g., `TopLevel ()`) restricting usage to specific contexts.\n\nThe most important command type is `TopLevel`, indicating a command runnable at the top level (REPL or scripts). For example, `print` has type `{a} a -> TopLevel ()`, a command with side effect but no useful return value.\n\nCommands can be sequenced with a `do { ... }` construct:\n\n```\nsawscript> let print_two = do { print \"first\"; print \"second\"; }\nsawscript> print_two\nfirst\nsecond\n```\n\nThe bound value `print_two` has type `TopLevel ()`.\n\nPrinting does not occur until the command is run directly. The `<-` operator runs a command and binds its result:\n\n```\nsawscript> print_two <- do { print \"first\"; print \"second\"; }\nfirst\nsecond\nsawscript> print print_two\n()\n```\n\nCommands run without `<-` ignore their results; the REPL prints results of commands run without `<-`.\n\nThe `return` command controls the value returned by a `do` block. For example:\n\n```plaintext\nlet run_with_message msg c =\n  do {\n    print \"Starting.\";\n    print msg;\n    res <- c;\n    print \"Done.\";\n    return res;\n  };\n\nx <- run_with_message \"Hello\" (return 3);\nprint x;\n```\n\nRunning this script (e.g., run.saw) yields:\n\n```\nLoading module Cryptol\nLoading file \"run.saw\"\nStarting.\nHello\nDone.\n3\n```\n\nThe command runs the first print, then the user-supplied command, then the second print, returning the result of `return` as the final result.\n\n## Other Basic Functions\n\nFunctions for working with lists:\n\n- `concat : {a} [a] -> [a] -> [a]`  \n  Concatenates two lists.\n\n- `head : {a} [a] -> a`  \n  Returns the first element of a list.\n\n- `tail : {a} [a] -> [a]`  \n  Returns everything except the first element.\n\n- `length : {a} [a] -> Int`  \n  Counts the number of elements.\n\n- `null : {a} [a] -> Bool`  \n  Indicates if a list is empty.\n\n- `nth : {a} [a] -> Int -> a`  \n  Returns the element at the given position; e.g., `nth l 0` is equivalent to `head l`.\n\n- `for : {m, a, b} [a] -> (a -> m b) -> m [b]`  \n  Runs a function (in some command context) for each element of a list and returns a list of results.\n\nFunctions interacting with the operating system:\n\n- `get_opt : Int -> String`  \n  Returns the command-line argument to saw at the given index. Argument 0 is the saw executable name.\n\n- `exec : String -> [String] -> String -> TopLevel String`  \n  Runs an external program given an executable name, argument list, and input string, returning the program's standard output and printing standard error.\n\n- `exit : Int -> TopLevel ()`  \n  Stops execution and returns the given exit code to the OS.\n\nMiscellaneous functions and commands:\n\n- `show : {a} a -> String`  \n  Computes a textual representation of its argument without displaying it, useful for constructing messages.\n\n- `str_concat : String -> String -> String`  \n  Concatenates two String values.\n\n- `time : {a} TopLevel a -> TopLevel a`  \n  Runs a TopLevel command and prints execution time.\n\n- `with_time : {a} TopLevel a -> TopLevel (Int, a)`  \n  Returns the result of a timed command and the execution time (in milliseconds), without printing.\n\n## REPL Actions\n\nAt the REPL, these commands are available:\n\n- `:cd`  \n  Changes the REPL\u2019s current directory.\n\n- `:pwd`  \n  Prints the REPL\u2019s current directory.\n\n- `:env`  \n  Displays values and types of all bound variables.\n\n- `:search`  \n  Searches bound variables by types, supports complex types in parentheses, wildcards `_`, and explicit forall-bound variables `{a}`.\n\n- `:tenv`  \n  Displays expansions of all type aliases.\n\n- `:type` or `:t`  \n  Checks and prints the type of an expression. Example:\n\n  ```\n  sawscript> :t show\n  {a.0} a.0 -> String\n  ```\n\n- `:help` or `:h`  \n  Prints help text for a function or command. Example:\n\n  ```\n  sawscript> :h show\n\n  Description\n  -----------\n      show : {a} a -> String\n\n  Convert the value of the given expression to a string.\n  ```\n\n- `:quit` or `:q`  \n  Exits the program.\n\n## Further built-in functions and commands\n\nSAW contains many built-in operations called \"primitives.\" These appear as built-in functions and commands. Subsequent chapters introduce many of these.\n\n## Experimental and deprecated functions and commands\n\nSome primitives are experimental\u2014possibly incomplete or unfinished\u2014and are unavailable by default. They can be enabled with the `enable_experimental` command.\n\nOthers are deprecated and may be unavailable by default but can be enabled with `enable_deprecated`.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/invoking-saw.html","filetype":"txt","content":"There are three ways to run saw. The most common is to provide the name of a SAWScript file to run: `saw proofs.saw`. If you leave the file name off, or give the `-I` option, SAW will start an interactive read-eval-print loop (\u201cREPL\u201d). It is also possible to use the `-B` (\u201cbatch\u201d) option to pass a file of REPL commands to run. This allows automated use of the REPL\u2019s `:-` commands.\n\nSee the REPL reference for additional details about the `saw` executable and its options.","variant":null,"set":"supervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/cryptol-and-its-role-in-saw.html","filetype":"txt","content":"## Cryptol and its Role in SAW\n\nCryptol is a domain-specific language originally designed for the high-level specification of cryptographic algorithms. It is general enough, however, to describe a wide variety of programs, and is particularly applicable to describing computations that operate on streams of data of some fixed size.\n\nIn addition to being integrated into SAW, Cryptol is a standalone language with its own manual.\n\nSAW includes deep support for Cryptol, and in fact requires the use of Cryptol for most non-trivial tasks. To fully understand the rest of this manual and to effectively use SAW, you will need to develop at least a rudimentary understanding of Cryptol.\n\nThe primary use of Cryptol within SAWScript is to construct values of type Term. Although Term values can be constructed from various sources, inline Cryptol expressions are the most direct and convenient way to create them.\n\nSpecifically, a Cryptol expression can be placed inside double curly braces ({{ and }}), resulting in a value of type Term. As a very simple example, there is no built-in integer addition operation in SAWScript. However, we can use Cryptol\u2019s built-in integer addition operator within SAWScript as follows:\n\n```\nsawscript> let t = {{ 0x22 + 0x33 }}\nsawscript> print t\n85\nsawscript> :type t\nTerm\n```\n\nAlthough it printed out in the same way as an Int, it is important to note that t actually has type Term. We can see how this term is represented internally, before being evaluated, with the `print_term` function.\n\n```\nsawscript> print_term t\nlet { x@1 = Prelude.Vec 8 Prelude.Bool\n      x@2 = Cryptol.TCNum 8\n      x@3 = Cryptol.PLiteralSeqBool x@2\n    }\n in Cryptol.ecPlus x@1 (Cryptol.PArithSeqBool x@2)\n      (Cryptol.ecNumber (Cryptol.TCNum 34) x@1 x@3)\n      (Cryptol.ecNumber (Cryptol.TCNum 51) x@1 x@3)\n```\n\nFor the moment, it\u2019s not important to understand what this output means. We show it only to clarify that Term values have their own internal structure that goes beyond what exists in SAWScript. The internal representation of Term values is in a language called SAWCore. The full semantics of SAWCore are beyond the scope of this manual.\n\nThe text constructed by `print_term` can also be accessed programmatically (instead of printing to the screen) using the `show_term` function, which returns a String. The `show_term` function is not a command, so it executes directly and does not need `<-` to bind its result. Therefore, the following will have the same result as the `print_term` command above:\n\n```\nsawscript> let s = show_term t\nsawscript> :type s\nString\nsawscript> print s\n<same as above>\n```\n\nNumbers are printed in decimal notation by default when printing terms, but the following two commands can change that behavior.\n\n- `set_ascii : Bool -> TopLevel ()`, when passed true, makes subsequent `print_term` or `show_term` commands print sequences of bytes as ASCII strings (and doesn\u2019t affect printing of anything else).\n- `set_base : Int -> TopLevel ()` prints all bit vectors in the given base, which can be between 2 and 36 (inclusive).\n\nA Term that represents an integer (any bit vector, as affected by `set_base`) can be translated into a SAWScript Int using the `eval_int : Term -> Int` function. This function returns an Int if the Term can be represented as one, and fails at runtime otherwise.\n\n```\nsawscript> print (eval_int t)\n85\nsawscript> print (eval_int {{ True }})\n\n\"eval_int\" (<stdin>:1:1):\neval_int: argument is not a finite bitvector\nsawscript> print (eval_int {{ [True] }})\n1\n```\n\nSimilarly, values of type Bit in Cryptol can be translated into values of type Bool in SAWScript using the `eval_bool : Term -> Bool` function:\n\n```\nsawscript> let b = {{ True }}\nsawscript> print_term b\nPrelude.True\nsawscript> print (eval_bool b)\ntrue\n```\n\nAnything with sequence type in Cryptol can be translated into a list of Term values in SAWScript using the `eval_list : Term -> [Term]` function.\n\n```\nsawscript> let l = {{ [0x01, 0x02, 0x03] }}\nsawscript> print_term l\nlet { x@1 = Prelude.Vec 8 Prelude.Bool\n      x@2 = Cryptol.PLiteralSeqBool (Cryptol.TCNum 8)\n    }\n in [Cryptol.ecNumber (Cryptol.TCNum 1) x@1 x@2\n    ,Cryptol.ecNumber (Cryptol.TCNum 2) x@1 x@2\n    ,Cryptol.ecNumber (Cryptol.TCNum 3) x@1 x@2]\nsawscript> print (eval_list l)\n[Cryptol.ecNumber (Cryptol.TCNum 1) (Prelude.Vec 8 Prelude.Bool)\n  (Cryptol.PLiteralSeqBool (Cryptol.TCNum 8))\n,Cryptol.ecNumber (Cryptol.TCNum 2) (Prelude.Vec 8 Prelude.Bool)\n  (Cryptol.PLiteralSeqBool (Cryptol.TCNum 8))\n,Cryptol.ecNumber (Cryptol.TCNum 3) (Prelude.Vec 8 Prelude.Bool)\n  (Cryptol.PLiteralSeqBool (Cryptol.TCNum 8))]\n```\n\nFinally, a list of Term values in SAWScript can be collapsed into a single Term with sequence type using the `list_term : [Term] -> Term` function, which is the inverse of `eval_list`.\n\n```\nsawscript> let ts = eval_list l\nsawscript> let l = list_term ts\nsawscript> print_term l\nlet { x@1 = Prelude.Vec 8 Prelude.Bool\n      x@2 = Cryptol.PLiteralSeqBool (Cryptol.TCNum 8)\n    }\n in [Cryptol.ecNumber (Cryptol.TCNum 1) x@1 x@2\n    ,Cryptol.ecNumber (Cryptol.TCNum 2) x@1 x@2\n    ,Cryptol.ecNumber (Cryptol.TCNum 3) x@1 x@2]\n```\n\nIn addition to being able to extract integer and Boolean values from Cryptol expressions, Term values can be injected into Cryptol expressions. When SAWScript evaluates a Cryptol expression between {{ and }} delimiters, it does so with several extra bindings in scope:\n\n- Any variable in scope that has SAWScript type `Bool` is visible in Cryptol expressions as a value of type `Bit`.\n- Any variable in scope that has SAWScript type `Int` is visible in Cryptol expressions as a type variable. Type variables can be demoted to numeric bit vector values using the backtick (`) operator.\n- Any variable in scope that has SAWScript type `Term` is visible in Cryptol expressions as a value with the Cryptol type corresponding to the internal type of the term. The power of this conversion is that the Term does not need to have originally been derived from a Cryptol expression.\n\nIn addition to these rules, bindings created at the Cryptol level, either from included files or inside Cryptol quoting brackets, are visible only to later Cryptol expressions, and not as SAWScript variables.\n\nTo make these rules more concrete, consider the following examples. If we bind a SAWScript Int, we can use it as a Cryptol type variable. If we create a Term variable that internally has function type, we can apply it to an argument within a Cryptol expression, but not at the SAWScript level:\n\n```\nsawscript> let n = 8\nsawscript> :type n\nInt\nsawscript> let {{ f (x : [n]) = x + 1 }}\nsawscript> :type {{ f }}\nTerm\nsawscript> :type f\n\n<stdin>:1:1-1:2: unbound variable: \"f\" (<stdin>:1:1-1:2)\nsawscript> print {{ f 2 }}\n3\n```\n\nIf `f` was a binding of a SAWScript variable to a Term of function type, we would get a different error:\n\n```\nsawscript> let f = {{ \\(x : [n]) -> x + 1 }}\nsawscript> :type {{ f }}\nTerm\nsawscript> :type f\nTerm\nsawscript> print {{ f 2 }}\n3\nsawscript> print (f 2)\n\ntype mismatch: Int -> t.0 and Term\n at \"_\" (REPL)\n mismatched type constructors: (->) and Term\n```\n\nOne subtlety of dealing with Terms constructed from Cryptol is that because the Cryptol expressions themselves are type checked by the Cryptol type checker, and because they may make use of other Term values already in scope, they are not type checked until the Cryptol brackets are evaluated. So type errors at the Cryptol level may occur at runtime from the SAWScript perspective (though they occur before the Cryptol expressions are run).\n\nSo far, we have talked about using Cryptol value expressions. However, SAWScript can also work with Cryptol types. The most direct way to refer to a Cryptol type is to use type brackets: {| and |}. Any Cryptol type written between these brackets becomes a `Type` value in SAWScript. Some types in Cryptol are numeric (also known as size) types, and correspond to non-negative integers. These can be translated into SAWScript integers with the `eval_size` function. For example:\n\n```\nsawscript> let {{ type n = 16 }}\nsawscript> eval_size {| n |}\n16\nsawscript> eval_size {| 16 |}\n16\n```\n\nFor non-numeric types, `eval_size` fails at runtime:\n\n```\nsawscript> eval_size {| [16] |}\n\n\"eval_size\" (<stdin>:1:1):\neval_size: not a numeric type\n```\n\nIn addition to the use of brackets to write Cryptol expressions inline, several built-in functions can extract Term values from Cryptol files in other ways. The `import` command at the top level imports all top-level definitions from a Cryptol file and places them in scope within later bracketed expressions. This includes Cryptol foreign declarations. If a Cryptol implementation of a foreign function is present, then it will be used as the definition when reasoning about the function. Otherwise, the function will be imported as an opaque constant with no definition.\n\nThe `cryptol_load` command behaves similarly, but returns a `CryptolModule` instead. If any `CryptolModule` is in scope, its contents are available qualified with the name of the `CryptolModule` variable. A specific definition can be explicitly extracted from a `CryptolModule` using the `cryptol_extract` command:\n\n```\ncryptol_extract : CryptolModule -> String -> TopLevel Term","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/loading-code.html","filetype":"txt","content":"## Loading Code\n\nThe first step in analyzing any code is to load it into the system.\n\n## Loading LLVM\n\nTo load LLVM code, simply provide the location of a valid bitcode file to the `llvm_load_module` function.\n\n```cryptol\nllvm_load_module : String -> TopLevel LLVMModule\n```\n\nThe resulting LLVMModule can be passed into the various functions described below to perform analysis of specific LLVM functions.\n\nThe LLVM bitcode parser should generally work with LLVM versions between 3.5 and 16.0, though it may be incomplete for some versions. Debug metadata has changed throughout that version range, so is the most likely cause of incompleteness. We aim to support every version after 3.5; please report any parsing failures on GitHub.\n\n## Loading Java\n\nLoading Java code is slightly more complex because of the structured nature of Java packages. When running saw, three flags control where to look for classes:\n\n- The `-b` flag takes the path where the `java` executable lives. This is used to locate the Java standard library classes and add them to the class database. Alternatively, you can put the directory where `java` lives on the `PATH`, which SAW will search if `-b` is not set.\n- The `-j` flag takes the name of a JAR file as an argument and adds the contents of that file to the class database.\n- The `-c` flag takes the name of a directory as an argument and adds all class files found in that directory (and its subdirectories) to the class database. By default, the current directory is included in the class path.\n\nMost Java programs only require setting the `-b` flag (or adjusting `PATH`), as that is enough to bring in the standard Java libraries. Note that when searching the `PATH`, SAW assumes the location of the standard library classes. These assumptions are likely to hold on JDK 7 or later, but not on older JDKs on certain OSes. If you use an old JDK and SAW cannot find a standard Java class, you may need to specify the location of the standard classes\u2019 JAR file with the `-j` flag or the `SAW_JDK_JAR` environment variable.\n\nOnce the class path is configured, you can pass the name of a class to the `java_load_class` function.\n\n```cryptol\njava_load_class : String -> TopLevel JavaClass\n```\n\nThe resulting JavaClass can be passed into the functions described below to analyze specific Java methods.\n\nJava class files from any JDK newer than version 6 should work. Support for JDK 9 and later is experimental. Verifying code using only primitive types is known to work well, but there are unresolved issues verifying code involving classes such as `String`. For more information, refer to the relevant GitHub issue.\n\n## Loading MIR\n\nTo load a piece of Rust code, first compile it to a MIR JSON file as described in this section, then provide the location of the JSON file to the `mir_load_module` function:\n\n```cryptol\nmir_load_module : String -> TopLevel MIRModule\n```\n\nSAW currently supports Rust code built with a January 23, 2023 Rust nightly. If you encounter unsupported Rust features, please report them on GitHub.\n\n## Notes on Compiling Code for SAW\n\nSAW can generally load arbitrary LLVM bitcode, JVM bytecode, and MIR JSON files, but several guidelines help make verification easier or more successful.\n\n### Compiling LLVM\n\nWhen generating LLVM with clang, it helps to:\n\n- Turn on debugging symbols with `-g` so SAW can find source locations, function names, variable names, etc.\n- Optimize with `-O1` so the generated bitcode more closely matches the C\/C++ source, making results more comprehensible.\n- Use `-fno-threadsafe-statics` to prevent clang from emitting unnecessary pthread code.\n- Link all relevant bitcode with `llvm-link` (including, e.g., the C++ standard library when analyzing C++ code).\n\nSAW proofs include side conditions to rule out undefined behavior, which must all be discharged for proofs to succeed. By default, SAW's notion of undefined behavior relates to LLVM semantics, rather than C or C++ standards. To rule out undefined behavior according to C or C++ standards, consider compiling with `-fsanitize=undefined` or related flags.\n\nIt's also recommended to use `-fsanitize-trap=undefined` or related flags to cause the compiled code to use `llvm.trap` for undefined behavior. Otherwise, the compiled code calls separate functions for each undefined behavior type (e.g., `__ubsan_handle_shift_out_of_bounds`), which SAW does not currently support unless manual overrides are created.\n\n### Compiling Java\n\nFor Java, the only useful compilation flag generally is `-g` to retain names of function arguments and local variables.\n\n### Compiling MIR\n\nTo verify Rust code, SAW analyzes Rust\u2019s MIR (mid-level intermediate representation) produced by the `mir-json` tool. You need to install `mir-json` and run it on Rust code to produce MIR JSON files for SAW. Also, you must use `mir-json` to build custom Rust standard libraries suited for verification.\n\nIf working from a checkout of the `saw-script` repo, install `mir-json` and the custom Rust libraries as follows:\n\n- Clone the `crucible` and `mir-json` submodules:\n\n  ```bash\n  $ git submodule update deps\/crucible deps\/mir-json\n  ```\n\n- Navigate to the `mir-json` submodule:\n\n  ```bash\n  $ cd deps\/mir-json\n  ```\n\n- Follow the `mir-json` installation instructions.\n\n- Run the `mir-json-translate-libs` script in the `mir-json` submodule:\n\n  ```bash\n  $ mir-json-translate-libs\n  ```\n\n  This compiles custom Rust standard libraries using `mir-json`, placing results under the `rlibs` subdirectory.\n\n- Define a `SAW_RUST_LIBRARY_PATH` environment variable pointing to the `rlibs` subdirectory:\n\n  ```bash\n  $ export SAW_RUST_LIBRARY_PATH=<...>\/mir-json\/rlibs\n  ```\n\nFor cargo-based projects, `mir-json` provides a cargo subcommand called `cargo saw-build` that builds a JSON file suitable for use with SAW, integrating directly with cargo. For example:\n\n```bash\n# Ensure SAW_RUST_LIBRARY_PATH is defined as above\n$ cargo saw-build <other cargo flags>\n...\nlinking 11 mir files into <...>\/example-364cf2df365c7055.linked-mir.json\n...\n```\n\nNotes:\n\n- The important output is the `.linked-mir.json` file created after linking multiple MIR files.\n- `SAW_RUST_LIBRARY_PATH` should point to the MIR JSON files for the Rust standard library.\n\n`mir-json` also supports compiling individual `.rs` files via `mir-json`\u2019s `saw-rustc` command, which accepts all `rustc` flags:\n\n```bash\n# Ensure SAW_RUST_LIBRARY_PATH is defined\n$ saw-rustc example.rs <other rustc flags>\n...\nlinking 11 mir files into <...>\/example.linked-mir.json\n...\n```\n\n## Direct Extraction\n\nIn many simple cases (such as a mathematical `max` function), relevant inputs and outputs are immediate. The function takes two integer arguments, always uses both, and returns a single integer with no other state changes.\n\nA direct translation is possible by identifying which code to execute. Three extraction functions exist for simple code, with the LLVM and JVM ones being more stable:\n\n```cryptol\nllvm_extract : LLVMModule -> String -> TopLevel Term\njvm_extract : JavaClass -> String -> TopLevel Term\n```\n\nAn experimental similar function exists for MIR:\n\n```cryptol\nmir_extract : MIRModule -> String -> TopLevel Term\n```\n\nDue to its experimental nature, the MIR extraction and related commands require running:\n\n```cryptol\nenable_experimental : TopLevel ()\n```\n\nbefore use.\n\nThese extraction functions have the same structure: the first argument specifies where to find the code (LLVM module, Java class, or MIR module), and the second is the name of the method or function to extract.\n\nThey return a `Term` corresponding to the function or method value as a function of its arguments.\n\nCurrently, extraction only works for functions with specific argument and result types:\n\n- For `llvm_extract`: the function must have a fixed number of integral parameters and return an integral result.\n- For `jvm_extract`: argument and result types must be scalar types (not classes or arrays).\n- For `mir_extract`: argument and result types must be primitive integer types (e.g., `u8`, `i8`), `bool`, `char`, arrays, or tuples.\n\nFunctions using pointers, classes, or references in type signatures may not be extracted, but the function implementation may allocate memory during execution.\n\nGlobal variable interaction requirements:\n\n- `llvm_extract`: Can read from immutable globals during execution; cannot read or write mutable globals.\n- `jvm_extract`: Can read\/write any class or static field during execution; these fields have initial values unless overwritten.\n- `mir_extract`: Can read immutable static items and write mutable static items during execution; cannot read mutable static items unless previously written.\n\n## Notes on C++ Analysis\n\nAnalyzing C++ code with SAW requires additional considerations because C++ diverges more from LLVM than C does.\n\n- The C++ standard library is large and complex, commonly used by C++ applications. To analyze most C++ code, link your code with a `libc++` version compiled to LLVM bitcode. The `wllvm` program can be helpful.\n\n- The C++ standard library includes key global variables that must be initialized with `llvm_alloc_global` if your code touches them.\n\n- Many C++ names can be awkward; they may be mangled relative to source code. SAW only understands mangled names. Use `llvm-nm` to list symbols in LLVM bitcode and `c++filt` to demangle names to help identify symbols. Namespaces can include quotes in LLVM encoding. For example:\n\n  ```\n  %\"class.quux::Foo\" = type { i32, i32 }\n  ```\n\n  This can be referenced in SAW as:\n\n  ```cryptol\n  llvm_type \"%\\\"class.quux::Foo\\\"\"\n  ```\n\n- SAW has no support for calling constructors in specifications. You must construct objects piece-by-piece using `llvm_alloc` and `llvm_points_to`.","variant":null,"set":"supervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/analyzing-hardware-circuits-using-yosys.html","filetype":"txt","content":"## Analyzing Hardware Circuits using Yosys\n\nSAW has experimental support for analysis of hardware descriptions written in VHDL (via GHDL) through an intermediate representation produced by Yosys. This generally follows the same conventions and idioms used in the rest of SAWScript.\n\n## Processing VHDL With Yosys\n\nGiven a VHDL file `test.vhd` containing an entity `test`, one can generate an intermediate representation `test.json` suitable for loading into SAW:\n\n```\n$ ghdl -a test.vhd\n$ yosys\n...\nYosys 0.10+1 (git sha1 7a7df9a3b4, gcc 10.3.0 -fPIC -Os)\nyosys> ghdl test\n\n1. Executing GHDL.\nImporting module test.\n\nyosys> write_json test.json\n\n2. Executing JSON backend.\n```\n\nIt can sometimes be helpful to invoke additional Yosys passes between the `ghdl` and `write_json` commands. For example, at present SAW does not support the `$pmux` cell type. Yosys is able to convert `$pmux` cells into trees of `$mux` cells using the `pmuxtree` command. We expect there are many other situations where Yosys\u2019 considerable library of commands is valuable for pre-processing.\n\n## Example: Ripple-Carry Adder\n\nConsider three VHDL entities. First, a half-adder:\n\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\nentity half is\n  port (\n    a : in std_logic;\n    b : in std_logic;\n    c : out std_logic;\n    s : out std_logic\n  );\nend half;\n\narchitecture halfarch of half is\nbegin\n  c <= a and b;\n  s <= a xor b;\nend halfarch;\n```\n\nNext, a one-bit adder built atop that half-adder:\n\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\nentity full is\n  port (\n    a : in std_logic;\n    b : in std_logic;\n    cin : in std_logic;\n    cout : out std_logic;\n    s : out std_logic\n  );\nend full;\n\narchitecture fullarch of full is\n  signal half0c : std_logic;\n  signal half0s : std_logic;\n  signal half1c : std_logic;\nbegin\n  half0 : entity work.half port map (a => a, b => b, c => half0c, s => half0s);\n  half1 : entity work.half port map (a => half0s, b => cin, c => half1c, s => s);\n  cout <= half0c or half1c;\nend fullarch;\n```\n\nFinally, a four-bit adder:\n\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\nentity add4 is\n  port (\n    a : in std_logic_vector(0 to 3);\n    b : in std_logic_vector(0 to 3);\n    res : out std_logic_vector(0 to 3)\n  );\nend add4;\n\narchitecture add4arch of add4 is\n  signal full0cout : std_logic;\n  signal full1cout : std_logic;\n  signal full2cout : std_logic;\n  signal ignore : std_logic;\nbegin\n  full0 : entity work.full port map (a => a(0), b => b(0), cin => '0', cout => full0cout, s => res(0));\n  full1 : entity work.full port map (a => a(1), b => b(1), cin => full0cout, cout => full1cout, s => res(1));\n  full2 : entity work.full port map (a => a(2), b => b(2), cin => full1cout, cout => full2cout, s => res(2));\n  full3 : entity work.full port map (a => a(3), b => b(3), cin => full2cout, cout => ignore, s => res(3));\nend add4arch;\n```\n\nUsing GHDL and Yosys, we can convert the VHDL source above into a format that SAW can import. If all of the code above is in a file `adder.vhd`, we can run the following commands:\n\n```\n$ ghdl -a adder.vhd\n$ yosys -p 'ghdl add4; write_json adder.json'\n```\n\nThe produced file `adder.json` can then be loaded into SAW with `yosys_import`:\n\n```\n$ saw\n...\nsawscript> enable_experimental\nsawscript> m <- yosys_import \"adder.json\"\nsawscript> :type m\nTerm\nsawscript> type m\n[23:57:14.492] {add4 : {a : [4], b : [4]} -> {res : [4]},\n full : {a : [1], b : [1], cin : [1]} -> {cout : [1], s : [1]},\n half : {a : [1], b : [1]} -> {c : [1], s : [1]}}\n```\n\n`yosys_import` returns a Term with a Cryptol record type, where the fields correspond to each VHDL module. We can access the fields of this record like any Cryptol record and call the functions within like any Cryptol function.\n\n```\nsawscript> type {{ m.add4 }}\n[00:00:25.255] {a : [4], b : [4]} -> {res : [4]}\nsawscript> eval_int {{ (m.add4 { a = 1, b = 2 }).res }}\n[00:02:07.329] 3\n```\n\nWe can also use all of SAW\u2019s infrastructure for asking solvers about Terms, such as the `sat` and `prove` commands. For example:\n\n```\nsawscript> sat w4 {{ m.add4 === \\_ -> { res = 5 } }}\n[00:04:41.993] Sat: [_ = (5, 0)]\nsawscript> prove z3 {{ m.add4 === \\inp -> { res = inp.a + inp.b } }}\n[00:05:43.659] Valid\nsawscript> prove yices {{ m.add4 === \\inp -> { res = inp.a - inp.b } }}\n[00:05:56.171] Invalid: [_ = (8, 13)]\n```\n\nThe full library of ProofScript tactics is available in this setting. If necessary, proof tactics like `simplify` can be used to rewrite goals before querying a solver.\n\nSpecial support is provided for the common case of equivalence proofs between HDL modules and other Terms (e.g. Cryptol functions, other HDL modules, or \u201cextracted\u201d imperative LLVM or JVM code). The command `yosys_verify` has an interface similar to `llvm_verify`: given a specification, some lemmas, and a proof tactic, it produces evidence of a proven equivalence that may be passed as a lemma to future calls of `yosys_verify`. For example, consider the following Cryptol specifications for one-bit and four-bit adders:\n\n```cryptol\ncryfull : {a : [1], b : [1], cin : [1]} -> {cout : [1], s : [1]}\ncryfull inp = { cout = [cout], s = [s] }\n  where [cout, s] = zext inp.a + zext inp.b + zext inp.cin\n\ncryadd4 : {a : [4], b : [4]} -> {res : [4]}\ncryadd4 inp = { res = inp.a + inp.b }\n```\n\nWe can prove equivalence between `cryfull` and the VHDL `full` module:\n\n```\nsawscript> full_spec <- yosys_verify {{ m.full }} [] {{ cryfull }} [] w4;\n```\n\nThe result `full_spec` can then be used as an \u201coverride\u201d when proving equivalence between `cryadd4` and the VHDL `add4` module:\n\n```\nsawscript> add4_spec <- yosys_verify {{ m.add4 }} [] {{ cryadd4 }} [full_spec] w4;\n```\n\nThe above could also be accomplished through the use of `prove_print` and term rewriting, but it is much more verbose.\n\n`yosys_verify` may also be given a list of preconditions under which the equivalence holds. For example, consider the following Cryptol specification for `full` that ignores the `cin` bit:\n\n```cryptol\ncryfullnocarry : {a : [1], b : [1], cin : [1]} -> {cout : [1], s : [1]}\ncryfullnocarry inp = { cout = [cout], s = [s] }\n  where [cout, s] = zext inp.a + zext inp.b\n```\n\nThis is not equivalent to `full` in general, but it is if constrained to inputs where `cin = 0`. We may express that precondition like so:\n\n```\nsawscript> full_nocarry_spec <- yosys_verify {{ adderm.full }} [{{\\(inp : {a : [1], b : [1], cin : [1]}) -> inp.cin == 0}}] {{ cryfullnocarry }} [] w4;\n```\n\nThe resulting override `full_nocarry_spec` may still be used in the proof for `add4` (this is accomplished by rewriting to a conditional expression).\n\n## API Reference\n\nN.B: The following commands must first be enabled using `enable_experimental`.\n\n`yosys_import : String -> TopLevel Term` produces a Term given the path to a JSON file produced by the Yosys `write_json` command. The resulting term is a Cryptol record, where each field corresponds to one HDL module exported by Yosys. Each HDL module is in turn represented by a function from a record of input port values to a record of output port values. For example, consider a Yosys JSON file derived from the following VHDL entities:\n\n```vhdl\nentity half is\n  port (\n    a : in std_logic;\n    b : in std_logic;\n    c : out std_logic;\n    s : out std_logic\n  );\nend half;\n\nentity full is\n  port (\n    a : in std_logic;\n    b : in std_logic;\n    cin : in std_logic;\n    cout : out std_logic;\n    s : out std_logic\n  );\nend full;\n```\n\nThe resulting Term will have the type:\n\n```cryptol\n{ half : {a : [1], b : [1]} -> {c : [1], s : [1]}\n, full : {a : [1], b : [1], cin : [1]} -> {cout : [1], s : [1]}\n}\n```\n\n`yosys_verify : Term -> [Term] -> Term -> [YosysTheorem] -> ProofScript () -> TopLevel YosysTheorem` proves equality between an HDL module and a specification. The first parameter is the HDL module - given a record `m` from `yosys_import`, this will typically look something like `{{ m.foo }}`. The second parameter is a list of preconditions for the equality. The third parameter is the specification, a term of the same type as the HDL module, which will typically be some Cryptol function or another HDL module. The fourth parameter is a list of \u201coverrides\u201d, which witness the results of previous `yosys_verify` proofs. These overrides can be used to simplify terms by replacing uses of submodules with their specifications.\n\nNote that Terms derived from HDL modules are \u201cfirst class\u201d, and are not restricted to `yosys_verify`: they may also be used with SAW\u2019s typical Term infrastructure like `sat`, `prove_print`, term rewriting, etc. `yosys_verify` simply provides a convenient and familiar interface, similar to `llvm_verify` or `jvm_verify`.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/creating-symbolic-variables.html","filetype":"txt","content":"## Creating Symbolic Variables\n\nThe direct extraction process discussed previously introduces symbolic variables and then abstracts over them, yielding a SAWScript Term that reflects the semantics of the original Java, LLVM, or MIR code. For simple functions, this is often the most convenient interface. For more complex code, however, it can be necessary (or more natural) to specifically introduce fresh variables and indicate what portions of the program state they correspond to.\n\n`fresh_symbolic : String -> Type -> TopLevel Term` is responsible for creating new variables in this context. The first argument is a name used for pretty-printing of terms and counter-examples. In many cases it makes sense for this to be the same as the name used within SAWScript, as in the following:\n\n```sawscript\nx <- fresh_symbolic \"x\" ty;\n```\n\nHowever, using the same name is not required.\n\nThe second argument to `fresh_symbolic` is the type of the fresh variable. Ultimately, this will be a SAWCore type; however, it is usually convenient to specify it using Cryptol syntax with the type quoting brackets `{|` and `|}`. For example, creating a 32-bit integer, as might be used to represent a Java int or an LLVM i32, can be done as follows:\n\n```sawscript\nx <- fresh_symbolic \"x\" {| [32] |};\n```\n\nAlthough symbolic execution works best on symbolic variables, which are \u201cunbound\u201d or \u201cfree\u201d, most of the proof infrastructure within SAW uses variables that are bound by an enclosing lambda expression. Given a Term with free symbolic variables, we can construct a lambda term that binds them in several ways.\n\n`abstract_symbolic : Term -> Term` finds all symbolic variables in the Term and constructs a lambda expression binding each one, in some order. The result is a function of some number of arguments, one for each symbolic variable. It is the simplest but least flexible way to bind symbolic variables.\n\n```sawscript\nsawscript> x <- fresh_symbolic \"x\" {| [8] |}\nsawscript> let t = {{ x + x }}\nsawscript> print_term t\nlet { x@1 = Prelude.Vec 8 Prelude.Bool\n    }\n in Cryptol.ecPlus x@1 (Cryptol.PArithSeqBool (Cryptol.TCNum 8))\n      x\n      x\nsawscript> let f = abstract_symbolic t\nsawscript> print_term f\nlet { x@1 = Prelude.Vec 8 Prelude.Bool\n    }\n in \\(x : x@1) ->\n      Cryptol.ecPlus x@1 (Cryptol.PArithSeqBool (Cryptol.TCNum 8)) x x\n```\n\nIf there are multiple symbolic variables in the Term passed to `abstract_symbolic`, the ordering of parameters can be hard to predict. In some cases (such as when a proof is the immediate next step, and it\u2019s expected to succeed) the order isn\u2019t important. In others, it\u2019s nice to have more control over the order.\n\n`lambda : Term -> Term -> Term` is the building block for controlled binding. It takes two terms: the one to transform, and the portion of the term to abstract over. Generally, the first Term is one obtained from `fresh_symbolic` and the second is a Term that would be passed to `abstract_symbolic`.\n\n```sawscript\nsawscript> let f = lambda x t\nsawscript> print_term f\nlet { x@1 = Prelude.Vec 8 Prelude.Bool\n    }\n in \\(x : x@1) ->\n      Cryptol.ecPlus x@1 (Cryptol.PArithSeqBool (Cryptol.TCNum 8)) x x\n```\n\n`lambdas : [Term] -> Term -> Term` allows you to list the order in which symbolic variables should be bound. Consider, for example, a Term which adds two symbolic variables:\n\n```sawscript\nsawscript> x1 <- fresh_symbolic \"x1\" {| [8] |}\nsawscript> x2 <- fresh_symbolic \"x2\" {| [8] |}\nsawscript> let t = {{ x1 + x2 }}\nsawscript> print_term t\nlet { x@1 = Prelude.Vec 8 Prelude.Bool\n    }\n in Cryptol.ecPlus x@1 (Cryptol.PArithSeqBool (Cryptol.TCNum 8))\n      x1\n      x2\n```\n\nWe can turn `t` into a function that takes `x1` followed by `x2`:\n\n```sawscript\nsawscript> let f1 = lambdas [x1, x2] t\nsawscript> print_term f1\nlet { x@1 = Prelude.Vec 8 Prelude.Bool\n    }\n in \\(x1 : x@1) ->\n      \\(x2 : x@1) ->\n        Cryptol.ecPlus x@1 (Cryptol.PArithSeqBool (Cryptol.TCNum 8)) x1\n          x2\n```\n\nOr we can turn `t` into a function that takes `x2` followed by `x1`:\n\n```sawscript\nsawscript> let f1 = lambdas [x2, x1] t\nsawscript> print_term f1\nlet { x@1 = Prelude.Vec 8 Prelude.Bool\n    }\n in \\(x2 : x@1) ->\n      \\(x1 : x@1) ->\n        Cryptol.ecPlus x@1 (Cryptol.PArithSeqBool (Cryptol.TCNum 8)) x1\n          x2\n```","variant":null,"set":"supervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/symbolic-execution.html","filetype":"txt","content":"## Symbolic Execution\n\nAnalysis of Java and LLVM within SAWScript relies heavily on symbolic execution, so some background on how this process works can help with understanding the behavior of the available built-in functions.\n\nAt the most abstract level, symbolic execution works like normal program execution except that the values of all variables within the program can be arbitrary expressions, potentially containing free variables, rather than concrete values. Therefore, each symbolic execution corresponds to some set of possible concrete executions.\n\nAs a concrete example, consider the following C program that returns the maximum of two values:\n\n```c\nunsigned int max(unsigned int x, unsigned int y) {\n    if (y > x) {\n        return y;\n    } else {\n        return x;\n    }\n}\n```\n\nIf you call this function with two concrete inputs, like this:\n\n```c\nint r = max(5, 4);\n```\n\nthen it will assign the value 5 to r. However, we can also consider what it will do for arbitrary inputs. Consider the following example:\n\n```c\nint r = max(a, b);\n```\n\nwhere a and b are variables with unknown values. It is still possible to describe the result of the max function in terms of a and b. The following expression describes the value of r:\n\n```\nite (b > a) b a\n```\n\nwhere `ite` is the \u201cif-then-else\u201d mathematical function, which based on the value of the first argument returns either the second or third. One subtlety of constructing this expression, however, is the treatment of conditionals in the original program. For any concrete values of a and b, only one branch of the if statement will execute. During symbolic execution, on the other hand, it is necessary to execute both branches, track two different program states (each composed of symbolic values), and then merge those states after executing the if statement. This merging process takes into account the original branch condition and introduces the `ite` expression.\n\nA symbolic execution system, then, is very similar to an interpreter that has a different notion of what constitutes a value and executes all paths through the program instead of just one. Therefore, the execution process is similar to that of a normal interpreter, and the process of generating a model for a piece of code is similar to building a test harness for that same code.\n\nMore specifically, the setup process for a test harness typically takes the following form:\n\n- Initialize or allocate any resources needed by the code. For Java and LLVM code, this typically means allocating memory and setting the initial values of variables.\n- Execute the code.\n- Check the desired properties of the system state after the code completes.\n\nAccordingly, three pieces of information are particularly relevant to the symbolic execution process, and are therefore needed as input to the symbolic execution system:\n\n1. The initial (potentially symbolic) state of the system.\n2. The code to execute.\n3. The final state of the system, and which parts of it are relevant to the properties being tested.\n\nIn the following sections, we describe how the Java and LLVM analysis primitives work in the context of these key concepts. We start with the simplest situation, in which the structure of the initial and final states can be directly inferred, and move on to more complex cases that require more information from the user.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/symbolic-termination.html","filetype":"txt","content":"## Symbolic Termination\n\nAbove we described the process of executing multiple branches and merging the results when encountering a conditional statement in the program. When a program contains loops, the branch that chooses to continue or terminate a loop could go either way. Therefore, without a bit more information, the most obvious implementation of symbolic execution would never terminate when executing programs that contain loops.\n\nThe solution to this problem is to analyze the branch condition whenever considering multiple branches. If the condition for one branch can never be true in the context of the current symbolic state, there is no reason to execute that branch, and skipping it can make it possible for symbolic execution to terminate.\n\nDirectly comparing the branch condition to a constant can sometimes be enough to ensure termination. For example, in simple, bounded loops like the following, comparison with a constant is sufficient.\n\n```c\nfor (int i = 0; i < 10; i++) {\n    \/\/ do something\n}\n```\n\nIn this case, the value of i is always concrete, and will eventually reach the value 10, at which point the branch corresponding to continuing the loop will be infeasible.\n\nAs a more complex example, consider the following function:\n\n```c\nuint8_t f(uint8_t i) {\n  int done = 0;\n  while (!done) {\n    if (i % 8 == 0) done = 1;\n    i += 5;\n  }\n  return i;\n}\n```\n\nThe loop in this function can only be determined to symbolically terminate if the analysis takes into account algebraic rules about common multiples. Similarly, it can be difficult to prove that a base case is eventually reached for all inputs to a recursive program.\n\nIn this particular case, however, the code is guaranteed to terminate after a fixed number of iterations (where the number of possible iterations is a function of the number of bits in the integers being used). To show that the last iteration is in fact the last possible one, it\u2019s necessary to do more than just compare the branch condition with a constant. Instead, we can use the same proof tools that we use to ultimately analyze the generated models to, early in the process, prove that certain branch conditions can never be true (i.e., are unsatisfiable).\n\nNormally, most of the Java and LLVM analysis commands simply compare branch conditions to the constant True or False to determine whether a branch may be feasible. However, each form of analysis allows branch satisfiability checking to be turned on if needed, in which case functions like f above will terminate.\n\nNext, we examine the details of the specific commands available to analyze JVM and LLVM programs.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/the-term-type.html","filetype":"txt","content":"## The Term Type\n\nPerhaps the most important type in SAWScript, and the one most unlike the built-in types of most other languages, is the Term type. Essentially, a value of type Term precisely describes all possible computations performed by some program. In particular, if two Term values are equivalent, then the programs that they represent will always compute the same results given the same inputs. We will say more later about exactly what it means for two terms to be equivalent, and how to determine whether two terms are equivalent.\n\nBefore exploring the Term type more deeply, it is important to understand the role of the Cryptol language in SAW \u2013 make sure to read that section of the manual before continuing.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/specification-based-verification.html","filetype":"txt","content":"## Specification-Based Verification\n\nThe built-in functions described so far work by extracting models of code that can then be used for a variety of purposes, including proofs about the properties of the code.\n\nWhen the goal is to prove equivalence between some LLVM, Java, or MIR code and a specification, however, a more declarative approach is sometimes convenient. The following sections describe an approach that combines model extraction and verification with respect to a specification. A verified specification can then be used as input to future verifications, allowing the proof process to be decomposed.\n\n## Running a Verification\n\nVerification of LLVM is controlled by the llvm_verify command.\n\n```cryptol\nllvm_verify :\n  LLVMModule ->\n  String ->\n  [CrucibleMethodSpec] ->\n  Bool ->\n  LLVMSetup () ->\n  ProofScript SatResult ->\n  TopLevel CrucibleMethodSpec\n```\n\nThe first two arguments specify the module and function name to verify, as with llvm_verify. The third argument specifies the list of already-verified specifications to use for compositional verification (described later; use [] for now). The fourth argument specifies whether to do path satisfiability checking, and the fifth gives the specification of the function to be verified. Finally, the last argument gives the proof script to use for verification. The result is a proved specification that can be used to simplify verification of functions that call this one.\n\nSimilar commands are available for JVM programs:\n\n```cryptol\njvm_verify :\n  JavaClass ->\n  String ->\n  [JVMMethodSpec] ->\n  Bool ->\n  JVMSetup () ->\n  ProofScript SatResult ->\n  TopLevel JVMMethodSpec\n```\n\nAnd for MIR programs:\n\n```cryptol\nmir_verify :\n  MIRModule ->\n  String ->\n  [MIRSpec] ->\n  Bool ->\n  MIRSetup () ->\n  ProofScript () ->\n  TopLevel MIRSpec\n```\n\n## Running a MIR-based verification\n\n(Note: API functions involving MIR verification require enable_experimental in order to be used. As such, some parts of this API may change before being finalized.)\n\nThe String supplied as an argument to mir_verify is expected to be a function identifier. An identifier should adhere to one of the following conventions:\n\n```\n<crate name>\/<disambiguator>::<function path>\n<crate name>::<function path>\n```\n\nWhere:\n\n- `<crate name>` is the name of the crate in which the function is defined. (If you produced your MIR JSON file by compiling a single .rs file with saw-rustc, then the crate name is the same as the name of the file, but without the .rs file extension.)\n- `<disambiguator>` is a hash of the crate and its dependencies. In rare cases, two different crates may share a crate name, so the disambiguator must be used to distinguish between them. Usually, the disambiguator can be omitted.\n- `<function path>` is the path to the function within the crate. This may be as simple as the function name or a multi-segment path, e.g., `core::ptr::read`.\n\nFor functions defined in an impl block, one segment may be `{impl}`, e.g.:\n\n```\ncore::ptr::const_ptr::{impl}::offset\n```\n\nIf unsure about the full identifier, consult the MIR JSON file.\n\n## Structure of a Specification\n\nA specification for Crucible consists of three logical components:\n\n- A specification of the initial state before execution of the function.\n- A description of how to call the function within that state.\n- A specification of the expected final value of the program state.\n\nThese three portions are written in sequence within a do block of type {LLVM,JVM,MIR}Setup. The command {llvm,jvm,mir}_execute_func separates the specification of the initial state from the specification of the final state, and specifies the arguments to the function in terms of the initial state.\n\n## Creating Fresh Variables\n\nTo prove a property about all inputs of a function, the initial values of some program state elements must contain fresh variables. These are created with {llvm,jvm,mir}_fresh_var commands:\n\n```cryptol\nllvm_fresh_var : String -> LLVMType -> LLVMSetup Term\njvm_fresh_var : String -> JavaType -> JVMSetup Term\nmir_fresh_var : String -> MIRType -> MIRSetup Term\n```\n\nThe first parameter is a name for presentation only. The second parameter specifies the variable type. The returned Term can be used in subsequent commands.\n\nIf the type lacks a Cryptol counterpart, the function raises an error. Expanded value creation functions (e.g., llvm_fresh_expanded_val) can be used for types without a Cryptol counterpart.\n\n## Type Constructors\n\n### LLVM types:\n\n```cryptol\nllvm_int : Int -> LLVMType\nllvm_alias : String -> LLVMType\nllvm_array : Int -> LLVMType -> LLVMType\nllvm_float : LLVMType\nllvm_double : LLVMType\nllvm_packed_struct : [LLVMType] -> LLVMType\nllvm_struct_type : [LLVMType] -> LLVMType\n```\n\nNote: Arrays must have fixed sizes.\n\n### Java types:\n\n```cryptol\njava_bool : JavaType\njava_byte : JavaType\njava_char : JavaType\njava_short : JavaType\njava_int : JavaType\njava_long : JavaType\njava_float : JavaType\njava_double : JavaType\njava_class : String -> JavaType\njava_array : Int -> JavaType -> JavaType\n```\n\n### MIR types:\n\n```cryptol\nmir_adt : MIRAdt -> MIRType\nmir_array : Int -> MIRType -> MIRType\nmir_bool : MIRType\nmir_char : MIRType\nmir_i8 : MIRType\nmir_i16 : MIRType\nmir_i32 : MIRType\nmir_i64 : MIRType\nmir_i128 : MIRType\nmir_isize : MIRType\nmir_f32 : MIRType\nmir_f64 : MIRType\nmir_lifetime : MIRType\nmir_raw_ptr_const : MIRType -> MIRType\nmir_raw_ptr_mut : MIRType -> MIRType\nmir_ref : MIRType -> MIRType\nmir_ref_mut : MIRType -> MIRType\nmir_slice : MIRType -> MIRType\nmir_str : MIRType\nmir_tuple : [MIRType] -> MIRType\nmir_u8 : MIRType\nmir_u16 : MIRType\nmir_u32 : MIRType\nmir_u64 : MIRType\nmir_u128 : MIRType\nmir_usize : MIRType\n```\n\nNote: Most types correspond straightforwardly to LLVM or Java types. Arrays must have a fixed size.\n\n## Cryptol Type Correspondence\n\nThe {llvm,jvm,mir}_fresh_var functions create a Cryptol Term corresponding to the type. Similarly, {llvm,jvm,mir}_term functions create values of the corresponding type from Cryptol terms.\n\n### LLVM verification\n\nTypes corresponding to Cryptol:\n\n- llvm_alias <name>: same as the type used in the alias.\n- llvm_array <n> <ty>: Cryptol sequence `[n][cty]`.\n- llvm_int <n>: Cryptol word `[n]`.\n- llvm_struct_type, llvm_packed_struct [tys]: Cryptol tuple.\n\nTypes not corresponding:\n\n- llvm_double, llvm_float, llvm_pointer\n\n### JVM verification\n\nCorresponding types:\n\n- java_array <n> <ty>: `[n][cty]`\n- java_bool: Bit\n- java_byte: [8]\n- java_char: [16]\n- java_int: [32]\n- java_long: [64]\n- java_short: [16]\n\nNon-corresponding:\n\n- java_class, java_double, java_float\n\n### MIR verification\n\nCorresponding types:\n\n- mir_array <n> <ty>: `[n][cty]`\n- mir_bool: Bit\n- mir_char: [32]\n- mir_i8, mir_u8: [8]\n- mir_i16, mir_u16: [16]\n- mir_i32, mir_u32: [32]\n- mir_i64, mir_u64: [64]\n- mir_i128, mir_u128: [128]\n- mir_isize, mir_usize: [64]\n- mir_tuple [tys]: Cryptol tuple\n\nNon-corresponding:\n\n- mir_adt, mir_f32, mir_f64, mir_ref, mir_ref_mut, mir_raw_ptr_const, mir_raw_ptr_mut, mir_slice, mir_str\n\n## Executing\n\nAfter state configuration, specify function parameters:\n\n```cryptol\nllvm_execute_func : [SetupValue] -> LLVMSetup ()\njvm_execute_func : [JVMValue] -> JVMSetup ()\nmir_execute_func : [MIRValue] -> MIRSetup ()\n```\n\n## Return Values\n\nSpecify return values:\n\n```cryptol\nllvm_return : SetupValue -> LLVMSetup ()\njvm_return : JVMValue -> JVMSetup ()\nmir_return : MIRValue -> MIRSetup ()\n```\n\n## Compositional Verification\n\nAllows using specifications of callees to verify callers. The {llvm,jvm,mir}_verify functions return opaque MethodSpec objects which can be passed into other verifications.\n\nExample doubling function in C:\n\n```c\nuint32_t dbl(uint32_t x) {\n    return add(x, x);\n}\n```\n\nSpecification:\n\n```cryptol\nlet dbl_setup = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_execute_func [llvm_term x];\n    llvm_return (llvm_term {{ x + x : [32] }});\n};\n```\n\nVerification using previous add spec:\n\n```cryptol\nllvm_verify m \"dbl\" [add_ms] false dbl_setup abc;\n```\n\n## Compositional Verification and Mutable Allocations\n\nUnderspecifying mutable allocations in postconditions leads to unsound verification.\n\nExample:\n\n```c\nvoid side_effect(uint32_t *a) { *a = 0; }\nuint32_t foo(uint32_t x) { uint32_t b = x; side_effect(&b); return b; }\n```\n\nSpecification `side_effect_spec` must fully specify postcondition of `a_ptr` to ensure soundness:\n\n```cryptol\nlet side_effect_spec = do {\n  a_ptr <- llvm_alloc (llvm_int 32);\n  a_val <- llvm_fresh_var \"a_val\" (llvm_int 32);\n  llvm_points_to a_ptr (llvm_term a_val);\n\n  llvm_execute_func [a_ptr];\n\n  llvm_points_to a_ptr (llvm_term {{ 0 : [32] }});\n};\n```\n\nOtherwise, verification of `foo` against its spec may fail due to invalidated memory reads.\n\n## Compositional Verification and Mutable Global Variables\n\nLikewise, mutable globals must have their postconditions fully specified.\n\nExample:\n\n```c\nuint32_t a = 42;\n\nvoid side_effect(void) {\n  a = 0;\n}\n\nuint32_t foo(void) {\n  side_effect();\n  return a;\n}\n```\n\nSpecification must include:\n\n```cryptol\nllvm_alloc_global \"a\";\nllvm_points_to (llvm_global \"a\") (llvm_term {{ 0 : [32] }});\n```\n\nto be sound.\n\n## Specifying Heap Layout\n\nSpecify pointers to allocated memory using:\n\n```cryptol\nllvm_alloc : LLVMType -> LLVMSetup SetupValue\n```\n\nAnd for pointers not pointing to allocated memory (for pointer manipulation):\n\n```cryptol\nllvm_fresh_pointer : LLVMType -> LLVMSetup SetupValue\n```\n\nNULL pointers:\n\n```cryptol\nllvm_null : SetupValue\njvm_null : JVMValue\n```\n\nRead-only allocations:\n\n```cryptol\nllvm_alloc_readonly : LLVMType -> LLVMSetup SetupValue\n```\n\nJava arrays and objects:\n\n```cryptol\njvm_alloc_array : Int -> JavaType -> JVMSetup JVMValue\njvm_alloc_object : String -> JVMSetup JVMValue\n```\n\nMIR allocations:\n\n```cryptol\nmir_alloc : MIRType -> MIRSetup MIRValue\nmir_alloc_mut : MIRType -> MIRSetup MIRValue\nmir_alloc_raw_ptr_const : MIRType -> MIRSetup MIRValue\nmir_alloc_raw_ptr_mut : MIRType -> MIRSetup MIRValue\nmir_alloc_raw_ptr_const_multi : Int -> MIRType -> MIRSetup MIRValue\nmir_alloc_raw_ptr_mut_multi : Int -> MIRType -> MIRSetup MIRValue\n```\n\n## Specifying Heap Values\n\n### LLVM\n\n```cryptol\nllvm_points_to : SetupValue -> SetupValue -> LLVMSetup ()\nllvm_points_to_untyped : SetupValue -> SetupValue -> LLVMSetup ()\n```\n\n### JVM\n\nCommands to specify heap objects:\n\n```cryptol\njvm_array_is : JVMValue -> Term -> JVMSetup ()\njvm_elem_is : JVMValue -> Int -> JVMValue -> JVMSetup ()\njvm_field_is : JVMValue -> String -> JVMValue -> JVMSetup ()\njvm_static_field_is : String -> JVMValue -> JVMSetup ()\n```\n\nCommands that specify unspecified modifications:\n\n```cryptol\njvm_modifies_array : JVMValue -> JVMSetup ()\njvm_modifies_elem : JVMValue -> Int -> JVMSetup ()\njvm_modifies_field : JVMValue -> String -> JVMSetup ()\njvm_modifies_static_field : String -> JVMSetup ()\n```\n\n### MIR\n\n```cryptol\nmir_points_to : MIRValue -> MIRValue -> MIRSetup ()\nmir_ref_of : MIRValue -> MIRSetup MIRValue\nmir_ref_of_mut : MIRValue -> MIRSetup MIRValue\nmir_cast_raw_ptr : MIRValue -> MIRType -> MIRType\nmir_points_to_multi : MIRValue -> MIRValue -> MIRSetup ()\n```\n\n## Working with Compound Types\n\nAccess elements or fields:\n\n```cryptol\nllvm_elem : SetupValue -> Int -> SetupValue\nllvm_field : SetupValue -> String -> SetupValue\n```\n\nConstruct compound values:\n\n```cryptol\nllvm_array_value : [SetupValue] -> SetupValue\nllvm_struct_value : [SetupValue] -> SetupValue\nllvm_packed_struct_value : [SetupValue] -> SetupValue\n```\n\nCast pointer types:\n\n```cryptol\nllvm_cast_pointer : SetupValue -> LLVMType -> SetupValue\nllvm_union : SetupValue -> String -> SetupValue\n```\n\n### Java\n\n```cryptol\njvm_elem_is : JVMValue -> Int -> JVMValue -> JVMSetup ()\njvm_field_is : JVMValue -> String -> JVMValue -> JVMSetup ()\n```\n\n### MIR\n\nConstruct compound values:\n\n```cryptol\nmir_array_value : MIRType -> [MIRValue] -> MIRValue\nmir_enum_value : MIRAdt -> String -> [MIRValue] -> MIRValue\nmir_slice_value : MIRValue -> MIRValue\nmir_slice_range_value : MIRValue -> Int -> Int -> MIRValue\nmir_str_slice_value : MIRValue -> MIRValue\nmir_str_slice_range_value : MIRValue -> Int -> Int -> MIRValue\nmir_struct_value : MIRAdt -> [MIRValue] -> MIRValue\nmir_tuple_value : [MIRValue] -> MIRValue\n```\n\nFresh expanded compound values:\n\n```cryptol\nmir_fresh_expanded_value : String -> MIRType -> MIRSetup MIRValue\n```\n\nExtract components:\n\n```cryptol\nmir_elem_value : MIRValue -> Int -> MIRValue\nmir_elem_ref : MIRValue -> Int -> MIRValue\n```\n\n## MIR Slices\n\n### Array slices\n\n```cryptol\nmir_slice_value : MIRValue -> MIRValue\nmir_slice_range_value : MIRValue -> Int -> Int -> MIRValue\n```\n\nExample:\n\n```cryptol\nlet f_spec_1 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a (mir_term {{ [1, 2, 3, 4, 5] : [5][32] }});\n  mir_execute_func [mir_slice_value a];\n  mir_return (mir_term {{ 3 : [32] }});\n};\n\nlet f_spec_2 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a (mir_term {{ [1, 2, 3, 4, 5] : [5][32] }});\n  mir_execute_func [mir_slice_range_value a 1 3];\n  mir_return (mir_term {{ 5 : [32] }});\n};\n```\n\n### String slices\n\n```cryptol\nmir_str_slice_value : MIRValue -> MIRValue\nmir_str_slice_range_value : MIRValue -> Int -> Int -> MIRValue\n```\n\nExample:\n\n```cryptol\nlet my_len_spec = do {\n  s <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to s (mir_term {{ \"hello\" }});\n  mir_execute_func [mir_str_slice_value s];\n  mir_return (mir_term {{ 5 : [64] }});\n};\n```\n\n## MIR Vecs\n\n```cryptol\nmir_vec_of : String -> MIRType -> MIRValue -> MIRSetup MIRValue\n```\n\n## Finding MIR Algebraic Data Types\n\n```cryptol\nmir_find_adt : MIRModule -> String -> [MIRType] -> MIRAdt\nmir_find_mangled_adt : MIRModule -> String -> MIRAdt\n```\n\nUse `mir_find_adt` where possible for robustness across recompilations.\n\n## Enums\n\nUse `mir_enum_value`:\n\n```cryptol\nmir_enum_value : MIRAdt -> String -> [MIRValue] -> MIRValue\n```\n\nExample:\n\n```cryptol\nlet option_u32 = mir_find_adt m \"core::option::Option\" [mir_u32];\n\nlet n_spec = do {\n  mir_execute_func [];\n  mir_return (mir_enum_value option_u32 \"None\" []);\n};\n\nlet s_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_execute_func [mir_term x];\n  mir_return (mir_enum_value option_u32 \"Some\" [mir_term x]);\n};\n```\n\n## Lifetimes\n\nLifetime parameters are instantiated with `mir_lifetime`.\n\nExample:\n\n```cryptol\ns_adt = mir_find_adt m \"example::S\" [mir_lifetime]\n```\n\n## Bitfields\n\nSupport via:\n\n```cryptol\nllvm_points_to_bitfield : SetupValue -> String -> SetupValue -> LLVMSetup ()\nenable_lax_loads_and_stores : TopLevel ()\n```\n\nRequires debug information and `enable_experimental`.\n\n## Global Variables\n\n### LLVM\n\nMutable globals must be allocated with:\n\n```cryptol\nllvm_alloc_global : String -> LLVMSetup ()\n```\n\nUse `llvm_global` to get pointers:\n\n```cryptol\nllvm_global : String -> SetupValue\nllvm_global_initializer : String -> SetupValue\n```\n\nExample:\n\n```cryptol\nlet init_global name = do {\n  llvm_alloc_global name;\n  llvm_points_to (llvm_global name) (llvm_global_initializer name);\n};\n```\n\n### MIR Static Items\n\n```cryptol\nmir_static : String -> MIRValue\nmir_static_initializer : String -> MIRValue\n```\n\nMutable static items require explicit initialization.\n\n## Preconditions and Postconditions\n\n```cryptol\nllvm_precond : Term -> LLVMSetup ()\nllvm_postcond : Term -> LLVMSetup ()\nllvm_assert : Term -> LLVMSetup ()\njvm_precond : Term -> JVMSetup ()\njvm_postcond : Term -> JVMSetup ()\njvm_assert : Term -> JVMSetup ()\nmir_precond : Term -> MIRSetup ()\nmir_postcond : Term -> MIRSetup ()\nmir_assert : Term -> MIRSetup ()\nllvm_equal : SetupValue -> SetupValue -> LLVMSetup ()\njvm_equal : JVMValue -> JVMValue -> JVMSetup ()\nmir_equal : MIRValue -> MIRValue -> MIRSetup ()\n```\n\n## Assuming specifications\n\nSkip simulation:\n\n```cryptol\nllvm_unsafe_assume_spec : LLVMModule -> String -> LLVMSetup () -> TopLevel CrucibleMethodSpec\njvm_unsafe_assume_spec : JavaClass -> String -> JVMSetup () -> TopLevel JVMMethodSpec\nmir_unsafe_assume_spec : MIRModule -> String -> MIRSetup () -> TopLevel MIRSpec\n```\n\n## A Heap-Based Example\n\nCryptol dot product:\n\n```cryptol\ndotprod : {n, a} (fin n, fin a) => [n][a] -> [n][a] -> [a]\ndotprod xs ys = sum (zip (*) xs ys)\n```\n\nC struct:\n\n```c\ntypedef struct {\n    uint32_t *elts;\n    uint32_t size;\n} vec_t;\n```\n\nC dot product function:\n\n```c\nuint32_t dotprod_struct(vec_t *x, vec_t *y) {\n    uint32_t size = MIN(x->size, y->size);\n    uint32_t res = 0;\n    for(size_t i = 0; i < size; i++) {\n        res += x->elts[i] * y->elts[i];\n    }\n    return res;\n}\n```\n\nUtilities:\n\n```cryptol\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n```\n\nSpecification:\n\n```cryptol\nlet dotprod_spec n = do {\n    let nt = llvm_term {{ `n : [32] }};\n    (xs, xsp) <- ptr_to_fresh \"xs\" (llvm_array n (llvm_int 32));\n    (ys, ysp) <- ptr_to_fresh \"ys\" (llvm_array n (llvm_int 32));\n    let xval = llvm_struct_value [ xsp, nt ];\n    let yval = llvm_struct_value [ ysp, nt ];\n    xp <- alloc_init (llvm_alias \"struct.vec_t\") xval;\n    yp <- alloc_init (llvm_alias \"struct.vec_t\") yval;\n    llvm_execute_func [xp, yp];\n    llvm_return (llvm_term {{ dotprod xs ys }});\n};\n```\n\n## Using Ghost State\n\nDeclare ghost state:\n\n```cryptol\ndeclare_ghost_state : String -> TopLevel Ghost\n```\n\nSet ghost values:\n\n```cryptol\nllvm_ghost_value : Ghost -> Term -> LLVMSetup ()\njvm_ghost_value  : Ghost -> Term -> JVMSetup  ()\nmir_ghost_value  : Ghost -> Term -> MIRSetup  ()\n```\n\n## An Extended Example: Salsa20\n\n### Utility functions\n\n```cryptol\nimport \"Salsa20.cry\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p (llvm_term v);\n    return p;\n};\n\nlet alloc_init_readonly ty v = do {\n    p <- llvm_alloc_readonly ty;\n    llvm_points_to p (llvm_term v);\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet ptr_to_fresh_readonly n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init_readonly ty (llvm_term x);\n    return (x, p);\n};\n\nlet oneptr_update_func n ty f = do {\n    (x, p) <- ptr_to_fresh n ty;\n    llvm_execute_func [p];\n    llvm_points_to p (llvm_term {{ f x }});\n};\n```\n\n### The quarterround operation\n\nSpecification:\n\n```cryptol\nlet quarterround_setup : LLVMSetup () = do {\n    (y0, p0) <- ptr_to_fresh \"y0\" (llvm_int 32);\n    (y1, p1) <- ptr_to_fresh \"y1\" (llvm_int 32);\n    (y2, p2) <- ptr_to_fresh \"y2\" (llvm_int 32);\n    (y3, p3) <- ptr_to_fresh \"y3\" (llvm_int 32);\n\n    llvm_execute_func [p0, p1, p2, p3];\n\n    let zs = {{ quarterround [y0,y1,y2,y3] }}; \/\/ from Salsa20.cry\n    llvm_points_to p0 (llvm_term {{ zs@0 }});\n    llvm_points_to p1 (llvm_term {{ zs@1 }});\n    llvm_points_to p2 (llvm_term {{ zs@2 }});\n    llvm_points_to p3 (llvm_term {{ zs@3 }});\n};\n```\n\n### Simple Updating Functions\n\n```cryptol\nlet rowround_setup =\n    oneptr_update_func \"y\" (llvm_array 16 (llvm_int 32)) {{ rowround }};\n\nlet columnround_setup =\n    oneptr_update_func \"x\" (llvm_array 16 (llvm_int 32)) {{ columnround }};\n\nlet doubleround_setup =\n    oneptr_update_func \"x\" (llvm_array 16 (llvm_int 32)) {{ doubleround }};\n\nlet salsa20_setup =\n    oneptr_update_func \"seq\" (llvm_array 64 (llvm_int 8)) {{ Salsa20 }};\n```\n\n### 32-Bit Key Expansion\n\n```cryptol\nlet salsa20_expansion_32 = do {\n    (k, pk) <- ptr_to_fresh_readonly \"k\" (llvm_array 32 (llvm_int 8));\n    (n, pn) <- ptr_to_fresh_readonly \"n\" (llvm_array 16 (llvm_int 8));\n\n    pks <- llvm_alloc (llvm_array 64 (llvm_int 8));\n\n    llvm_execute_func [pk, pn, pks];\n\n    let rks = {{ Salsa20_expansion`{a=2}(k, n) }};\n    llvm_points_to pks (llvm_term rks);\n};\n```\n\n### 32-bit Key Encryption\n\n```cryptol\nlet s20_encrypt32 n = do {\n    (key, pkey) <- ptr_to_fresh_readonly \"key\" (llvm_array 32 (llvm_int 8));\n    (v, pv) <- ptr_to_fresh_readonly \"nonce\" (llvm_array 8 (llvm_int 8));\n    (m, pm) <- ptr_to_fresh \"buf\" (llvm_array n (llvm_int 8));\n\n    llvm_execute_func [ pkey\n                      , pv\n                      , llvm_term {{ 0 : [32] }}\n                      , pm\n                      , llvm_term {{ `n : [32] }}\n                      ];\n\n    llvm_points_to pm (llvm_term {{ Salsa20_encrypt (key, v, m) }});\n    llvm_return (llvm_term {{ 0 : [32] }});\n};\n```\n\n### Verifying Everything\n\n```cryptol\nlet main : TopLevel () = do {\n    m      <- llvm_load_module \"salsa20.bc\";\n    qr     <- llvm_verify m \"s20_quarterround\" []      false quarterround_setup   abc;\n    rr     <- llvm_verify m \"s20_rowround\"     [qr]    false rowround_setup       abc;\n    cr     <- llvm_verify m \"s20_columnround\"  [qr]    false columnround_setup    abc;\n    dr     <- llvm_verify m \"s20_doubleround\"  [cr,rr] false doubleround_setup    abc;\n    s20    <- llvm_verify m \"s20_hash\"         [dr]    false salsa20_setup        abc;\n    s20e32 <- llvm_verify m \"s20_expand32\"     [s20]   true  salsa20_expansion_32 abc;\n    s20encrypt_63 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 63) abc;\n    s20encrypt_64 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 64) abc;\n    s20encrypt_65 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 65) abc;\n\n    print \"Done!\";\n};\n```\n\n## Verifying Cryptol FFI functions\n\nSAW can generate LLVMSetup specs from Cryptol foreign functions using:\n\n```cryptol\nllvm_ffi_setup : Term -> LLVMSetup ()\n```\n\nExample:\n\n```cryptol\nlet add_setup = llvm_ffi_setup {{ add }};\n```\n\nEquivalent to:\n\n```cryptol\nlet add_setup = do {\n  in0 <- llvm_fresh_var \"in0\" (llvm_int 32);\n  in1 <- llvm_fresh_var \"in1\" (llvm_int 32);\n  llvm_execute_func [llvm_term in0, llvm_term in1];\n  llvm_return (llvm_term {{ add in0 in1 }});\n};\n```\n\nPolymorphic functions can be specified by providing type arguments:\n\n```cryptol\nlet f_setup (n : Int) (m : Int) = llvm_ffi_setup {{ f`{n, m} }};\n```\n\nSupported types exclude Integer, Rational, Z, and Float.\n\nOnly the c calling convention is supported.\n\nVerify via:\n\n```cryptol\nf_ov <- llvm_verify mod \"f\" [] true (f_setup 3 5) z3;\n```\n\nSAW does not manage compilation; LLVM modules must match compiled libraries. Experimental support exists for direct ELF verification with `llvm_verify_x86`.","variant":null,"set":"supervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/bisimulation-prover.html","filetype":"txt","content":"## Bisimulation Prover\n\nSAW contains a bisimulation prover to prove that two terms simulate each other. This prover allows users to prove that two terms executing in lockstep satisfy some relations over the state of each circuit and their outputs. This type of proof is useful in demonstrating the eventual equivalence of two circuits, or of a circuit and a functional specification. SAW enables these proofs with the experimental `prove_bisim` command:\n\n```cryptol\nprove_bisim : ProofScript () -> [BisimTheorem] -> Term -> Term -> Term -> Term -> TopLevel BisimTheorem\n```\n\nWhen invoking `prove_bisim strat theorems srel orel lhs rhs`, the arguments represent the following:\n\n- **strat**: A proof strategy to use during verification.\n- **theorems**: A list of already proven bisimulation theorems.\n- **srel**: A state relation between `lhs` and `rhs`. This relation must have the type `lhsState -> rhsState -> Bit`. The relation\u2019s first argument is `lhs`\u2019s state prior to execution. The relation\u2019s second argument is `rhs`\u2019s state prior to execution. `srel` then returns a `Bit` indicating whether the two arguments satisfy the bisimulation\u2019s state relation.\n- **orel**: An output relation between `lhs` and `rhs`. This relation must have the type `(lhsState, output) -> (rhsState, output) -> Bit`. The relation\u2019s first argument is a pair consisting of `lhs`\u2019s state and output following execution. The relation\u2019s second argument is a pair consisting of `rhs`\u2019s state and output following execution. `orel` then returns a `Bit` indicating whether the two arguments satisfy the bisimulation\u2019s output relation.\n- **lhs**: A term that simulates `rhs`. `lhs` must have the type `(lhsState, input) -> (lhsState, output)`. The first argument to `lhs` is a tuple containing the internal state of `lhs`, as well as the input to `lhs`. `lhs` returns a tuple containing its internal state after execution, as well as its output.\n- **rhs**: A term that simulates `lhs`. `rhs` must have the type `(rhsState, input) -> (rhsState, output)`. The first argument to `rhs` is a tuple containing the internal state of `rhs`, as well as the input to `rhs`. `rhs` returns a tuple containing its internal state after execution, as well as its output.\n\nOn success, `prove_bisim` returns a `BisimTheorem` that can be used in future bisimulation proofs to enable compositional bisimulation proofs. On failure, `prove_bisim` will abort.\n\n## Bisimulation Example\n\nThis section walks through an example proving that the Cryptol implementation of an AND gate that makes use of internal state and takes two cycles to complete is equivalent to a pure function that computes the logical AND of its inputs in one cycle. First, we define the implementation\u2019s state type:\n\n```cryptol\ntype andState = { loaded : Bit, origX : Bit, origY : Bit }\n```\n\n`andState` is a record type with three fields:\n\n- `loaded`: A `Bit` indicating whether the input to the AND gate has been loaded into the state record.\n- `origX`: A `Bit` storing the first input to the AND gate.\n- `origY`: A `Bit` storing the second input to the AND gate.\n\nNow, we define the AND gate\u2019s implementation:\n\n```cryptol\nandImp : (andState, (Bit, Bit)) -> (andState, (Bit, Bit))\nandImp (s, (x, y)) =\n  if s.loaded \/\\ x == s.origX \/\\ y == s.origY\n  then (s, (True, s.origX && s.origY))\n  else ({ loaded = True, origX = x, origY = y }, (False, 0))\n```\n\n`andImp` takes a tuple as input where the first field is an `andState` holding the gate\u2019s internal state, and the second field is a tuple containing the inputs to the AND gate. `andImp` returns a tuple consisting of the updated `andState` and the gate\u2019s output. The output is a tuple where the first field is a ready bit that is 1 when the second field is ready to be read, and the second field is the result of gate\u2019s computation.\n\n`andImp` takes two cycles to complete:\n\n1. The first cycle loads the inputs into its state\u2019s `origX` and `origY` fields and sets `loaded` to True. It sets both of its output bits to 0.\n2. The second cycle uses the stored input values to compute the logical AND. It sets its ready bit to 1 and its second output to the logical AND result.\n\nSo long as the inputs remain fixed after the second cycle, `andImp`\u2019s output remains unchanged. If the inputs change, then `andImp` restarts the computation (even if the inputs change between the first and second cycles).\n\nNext, we define the pure function we\u2019d like to prove `andImp` bisimilar to:\n\n```cryptol\nandSpec : ((), (Bit, Bit)) -> ((), (Bit, Bit))\nandSpec (_, (x, y)) = ((), (True, x && y))\n```\n\n`andSpec` takes a tuple as input where the first field is `()`, indicating that `andSpec` is a pure function without internal state, and the second field is a tuple containing the inputs to the AND function. `andSpec` returns a tuple consisting of `()` (again, because `andSpec` is stateless) and the function\u2019s output. Like `andImp`, the output is a tuple where the first field is a ready bit that is 1 when the second field is ready to be read, and the second field is the result of the function\u2019s computation.\n\n`andSpec` completes in a single cycle, and as such its ready bit is always 1. It computes the logical AND directly on the function\u2019s inputs using Cryptol\u2019s `(&&)` operator.\n\nNext, we define a state relation over `andImp` and `andSpec`:\n\n```cryptol\nandStateRel : andState -> () -> Bit\nandStateRel _ () = True\n```\n\n`andStateRel` takes two arguments:\n\n- An `andState` for `andImp`.\n- An empty state (`()`) for `andSpec`.\n\n`andStateRel` returns a `Bit` indicating whether the relation is satisfied. In this case, `andStateRel` always returns `True` because `andSpec` is stateless and therefore the state relation permits `andImp` to accept any state.\n\nLastly, we define a relation over `andImp` and `andSpec`:\n\n```cryptol\nandOutputRel : (andState, (Bit, Bit)) -> ((), (Bit, Bit)) -> Bit\nandOutputRel (s, (impReady, impO)) ((), (_, specO)) =\n  if impReady then impO == specO else True\n```\n\n`andOutputRel` takes two arguments:\n\n- A return value from `andImp`. Specifically, a pair consisting of an `andState` and a pair containing a ready bit and result of the logical AND.\n- A return value from `andSpec`. Specifically, a pair consisting of an empty state `()` and a pair containing a ready bit and result of the logical AND.\n\n`andOutputRel` returns a `Bit` indicating whether the relation is satisfied. It considers the relation satisfied in two ways:\n\n- If `andImp`\u2019s ready bit is set, the relation is satisfied if the output values `impO` and `specO` from `andImp` and `andSpec` respectively are equivalent.\n- If `andImp`\u2019s ready bit is not set, the relation is satisfied.\n\nPut another way, the relation is satisfied if the end result of `andImp` and `andSpec` are equivalent. The relation permits intermediate outputs to differ.\n\nWe can verify that this relation is always satisfied\u2014and therefore the two terms are bisimilar\u2014by using `prove_bisim`:\n\n```cryptol\nimport \"And.cry\";\nenable_experimental;\n\nand_bisim <- prove_bisim z3 [] {{ andStateRel }} {{ andOutputRel }} {{ andImp }} {{ andSpec }};\n```\n\nUpon running this script, SAW prints:\n\n```\nSuccessfully proved bisimulation between andImp and andSpec\n```\n\n## Building a NAND Gate\n\nWe can make the example more interesting by reusing components to build a NAND gate. We first define a state type for the NAND gate implementation that contains `andImp`\u2019s state. This NAND gate will not need any additional state, so we will define a type `nandState` that is equal to `andState`:\n\n```cryptol\ntype nandState = andState\n```\n\nNow, we define an implementation `nandImp` that calls `andImp` and negates the result:\n\n```cryptol\nnandImp : (nandState, (Bit, Bit)) -> (nandState, (Bit, Bit))\nnandImp x = (s, (andReady, ~andRes))\n  where\n    (s, (andReady, andRes)) = andImp x\n```\n\nNote that `nandImp` is careful to preserve the ready status of `andImp`. Because `nandImp` relies on `andImp`, it also takes two cycles to compute the logical NAND of its inputs.\n\nNext, we define a specification `nandSpec` in terms of `andSpec`:\n\n```cryptol\nnandSpec : ((), (Bit, Bit)) -> ((), (Bit, Bit))\nnandSpec (_, (x, y)) = ((), (True, ~(andSpec ((), (x, y))).1.1))\n```\n\nAs with `andSpec`, `nandSpec` is pure and computes its result in a single cycle.\n\nNext, we define a state relation over `nandImp` and `nandSpec`:\n\n```cryptol\nnandStateRel : andState -> () -> Bit\nnandStateRel _ () = True\n```\n\nAs with `andStateRel`, this state relation is always `True` because `nandSpec` is stateless.\n\nLastly, we define an output relation indicating that `nandImp` and `nandSpec` produce equivalent results once `nandImp`\u2019s ready bit is 1:\n\n```cryptol\nnandOutputRel : (nandState, (Bit, Bit)) -> ((), (Bit, Bit)) -> Bit\nnandOutputRel (s, (impReady, impO)) ((), (_, specO)) =\n  if impReady then impO == specO else True\n```\n\nTo prove that `nandImp` and `nandSpec` are bisimilar, we again use `prove_bisim`. This time however, we can reuse the bisimulation proof for the AND gate by including it in the theorems parameter for `prove_bisim`:\n\n```cryptol\nprove_bisim z3 [and_bisim] {{ nandStateRel }} {{ nandOutputRel }} {{ nandImp }} {{ nandSpec }};\n```\n\nUpon running this script, SAW prints:\n\n```\nSuccessfully proved bisimulation between nandImp and nandSpec\n```\n\n## Understanding the Proof Goals\n\nWhile not necessary for simple proofs, more advanced proofs may require inspecting proof goals. `prove_bisim` generates and attempts to solve the following proof goals:\n\n```\nOUTPUT RELATION THEOREM:\n  forall s1 s2 in.\n    srel s1 s2 -> orel (lhs (s1, in)) (rhs (s2, in))\n\nSTATE RELATION THEOREM:\n  forall s1 s2 out1 out2.\n    orel (s1, out1) (s2, out2) -> srel s1 s2\n```\n\nwhere the variables in the foralls are:\n\n- `s1`: Initial state for `lhs`\n- `s2`: Initial state for `rhs`\n- `in`: Input value to `lhs` and `rhs`\n- `out1`: Initial output value for `lhs`\n- `out2`: Initial output value for `rhs`\n\nThe STATE RELATION THEOREM verifies that the output relation properly captures the guarantees of the state relation. The OUTPUT RELATION THEOREM verifies that if `lhs` and `rhs` are executed with related states, then the result of that execution is also related. These two theorems together guarantee that the terms simulate each other.\n\nWhen using composition, `prove_bisim` also generates and attempts to solve the proof goal below for any successfully applied `BisimTheorem` in the theorems list:\n\n```\nCOMPOSITION SIDE CONDITION:\n  forall g_lhs_s g_rhs_s.\n    g_srel g_lhs_s g_rhs_s -> f_srel f_lhs_s f_rhs_s\n    where\n      f_lhs_s = extract_inner_state g_lhs g_lhs_s f_lhs\n      f_rhs_s = extract_inner_state g_rhs g_rhs_s f_rhs\n```\n\nwhere `g_lhs` is an outer term containing a call to an inner term `f_lhs` represented by a `BisimTheorem` and `g_rhs` is an outer term containing a call to an inner term `f_rhs` represented by the same `BisimTheorem`. The variables in COMPOSITION SIDE CONDITION are:\n\n- `extract_inner_state x x_s y`: A helper function that takes an outer term `x`, an outer state `x_s`, and an inner term `y`, and returns the inner state of `x_s` that `x` passes to `y`.\n- `g_lhs_s`: The state for `g_lhs`\n- `g_rhs_s`: The state for `g_rhs`\n- `g_srel`: The state relation for `g_lhs` and `g_rhs`\n- `f_srel`: The state relation for `f_lhs` and `f_rhs`\n- `f_lhs_s`: The state for `f_lhs`, as represented in `g_lhs_s` (extracted using `extract_inner_state`)\n- `f_rhs_s`: The state for `f_rhs`, as represented in `g_rhs_s` (extracted using `extract_inner_state`)\n\nThe COMPOSITION SIDE CONDITION exists to verify that the terms in the bisimulation relation properly set up valid states for subterms they contain.\n\n## Limitations\n\nFor now, the `prove_bisim` command has a couple limitations:\n\n- `lhs` and `rhs` must be named functions. This is because `prove_bisim` uses these names to perform substitution when making use of compositionality.\n- Each subterm present in the list of bisimulation theorems already proven may be invoked at most once in `lhs` or `rhs`. That is, if some function `g_lhs` calls `f_lhs`, and `prove_bisim` is invoked with a `BisimTheorem` proving that `f_lhs` is bisimilar to `f_rhs`, then `g_lhs` may call `f_lhs` at most once.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/transforming-term-values.html","filetype":"txt","content":"## Transforming Term Values\n\nThe three primary functions of SAW are extracting models (Term values) from programs, transforming those models, and proving properties about models using external provers. We\u2019ve seen how to construct Term values from a range of sources. Now we show how to use the various term transformation features available in SAW.\n\n## Rewriting\n\nRewriting a Term consists of applying one or more rewrite rules to it, resulting in a new Term. A rewrite rule in SAW can be specified in multiple ways:\n\n- as the definition of a function that can be unfolded,\n- as a term of Boolean type (or a function returning a Boolean) that is an equality statement, and\n- as a term of equality type with a body that encodes a proof that the equality in the type is valid.\n\nIn each case the term logically consists of two sides and describes a way to transform the left side into the right side. Each side may contain variables (bound by enclosing lambda expressions) and is therefore a pattern which can match any term in which each variable represents an arbitrary sub-term. The left-hand pattern describes a term to match (which may be a sub-term of the full term being rewritten), and the right-hand pattern describes a term to replace it with. Any variable in the right-hand pattern must also appear in the left-hand pattern and will be instantiated with whatever sub-term matched that variable in the original term.\n\nFor example, say we have the following Cryptol function:\n\n```cryptol\n\\(x:[8]) -> (x * 2) + 1\n```\n\nWe might for some reason want to replace multiplication by a power of two with a shift. We can describe this replacement using an equality statement in Cryptol (a rule of form 2 above):\n\n```cryptol\n\\(y:[8]) -> (y * 2) == (y << 1)\n```\n\nInterpreting this as a rewrite rule, it says that for any 8-bit vector (call it y for now), we can replace `y * 2` with `y << 1`. Using this rule to rewrite the earlier expression would then yield:\n\n```cryptol\n\\(x:[8]) -> (x << 1) + 1\n```\n\nThe general philosophy of rewriting is that the left and right patterns, while syntactically different, should be semantically equivalent. Therefore, applying a set of rewrite rules should not change the fundamental meaning of the term being rewritten. SAW is particularly focused on the task of proving that some logical statement expressed as a Term is always true. If that is in fact the case, then the entire term can be replaced by the term `True` without changing its meaning. The rewriting process can in some cases, by repeatedly applying rules that themselves are known to be valid, reduce a complex term entirely to `True`, which constitutes a proof of the original statement. In other cases, rewriting can simplify terms before sending them to external automated provers that can then finish the job. Sometimes this simplification can help the automated provers run more quickly, and sometimes it can help them prove things they would otherwise be unable to prove by applying reasoning steps (rewrite rules) that are not available to the automated provers.\n\nIn practical use, rewrite rules can be aggregated into Simpset values in SAWScript. A few pre-defined Simpset values exist:\n\n- `empty_ss : Simpset` is the empty set of rules. Rewriting with it should have no effect, but it is useful as an argument to some of the functions that construct larger Simpset values.\n- `basic_ss : Simpset` is a collection of rules that are useful in most proof scripts.\n- `cryptol_ss : () -> Simpset` includes a collection of Cryptol-specific rules. Some of these simplify away the abstractions introduced in the translation from Cryptol to SAWCore, which can be useful when proving equivalence between Cryptol and non-Cryptol code. Leaving these abstractions in place is appropriate when comparing only Cryptol code, however, so `cryptol_ss` is not included in `basic_ss`.\n\nThe following function can apply a Simpset:\n\n```cryptol\nrewrite : Simpset -> Term -> Term\n```\n\napplies a Simpset to an existing Term to produce a new Term.\n\nTo make this more concrete, we examine how the rewriting example sketched above, to convert multiplication into shift, can work in practice. We simplify everything with `cryptol_ss` as we go along so that the Terms don\u2019t get too cluttered. First, we declare the term to be transformed:\n\n```sawscript\nlet term = rewrite (cryptol_ss ()) {{ \\(x:[8]) -> (x * 2) + 1 }}\nprint_term term\n```\n\nThis prints:\n\n```\n\\(x : Prelude.Vec 8 Prelude.Bool) ->\n  Prelude.bvAdd 8 (Prelude.bvMul 8 x (Prelude.bvNat 8 2))\n    (Prelude.bvNat 8 1)\n```\n\nNext, we declare the rewrite rule:\n\n```sawscript\nlet rule = rewrite (cryptol_ss ()) {{ \\(y:[8]) -> (y * 2) == (y << 1) }}\nprint_term rule\n```\n\nThis prints:\n\n```\nlet { x@1 = Prelude.Vec 8 Prelude.Bool\n    }\n in \\(y : x@1) ->\n      Cryptol.ecEq x@1 (Cryptol.PCmpWord 8)\n        (Prelude.bvMul 8 y (Prelude.bvNat 8 2))\n        (Prelude.bvShiftL 8 Prelude.Bool 1 Prelude.False y\n           (Prelude.bvNat 1 1))\n```\n\nThe primary interface to rewriting uses the `Theorem` type instead of the `Term` type, as shown in the signatures for `addsimp` and `addsimps`.\n\n```cryptol\naddsimp : Theorem -> Simpset -> Simpset\naddsimps : [Theorem] -> Simpset -> Simpset\n```\n\nadds single or multiple Theorems to a Simpset.\n\nA `Theorem` is essentially a `Term` that is proven correct in some way. In general, a `Theorem` can be any statement, and may not be useful as a rewrite rule. However, if it has an appropriate shape it can be used for rewriting. In the \u201cProofs about Terms\u201d section, we\u2019ll describe how to construct `Theorem` values from `Term` values.\n\nFor the time being, we\u2019ll assume we\u2019ve proved our rule term correct in some way, and have a `Theorem` named `rule_thm`.\n\nFinally, we apply the rule to the target term:\n\n```sawscript\nlet result = rewrite (addsimp rule_thm empty_ss) term\nprint_term result\n```\n\nThis prints:\n\n```\n\\(x : Prelude.Vec 8 Prelude.Bool) ->\n  Prelude.bvAdd 8\n    (Prelude.bvShiftL 8 Prelude.Bool 1 Prelude.False x\n       (Prelude.bvNat 1 1))\n    (Prelude.bvNat 8 1)\n```\n\nIn the absence of user-constructed `Theorem` values, there are some additional built-in rules that are not included in either `basic_ss` and `cryptol_ss` because they are not always beneficial, but that can sometimes be helpful or essential. The `cryptol_ss` simpset includes rewrite rules to unfold all definitions in the Cryptol SAWCore module, but does not include any of the terms of equality type.\n\n- `add_cryptol_defs : [String] -> Simpset -> Simpset` adds unfolding rules for functions with the given names from the SAWCore Cryptol module to the given Simpset.\n- `add_cryptol_eqs : [String] -> Simpset -> Simpset` adds the terms of equality type with the given names from the SAWCore Cryptol module to the given Simpset.\n- `add_prelude_defs : [String] -> Simpset -> Simpset` adds unfolding rules from the SAWCore Prelude module to a Simpset.\n- `add_prelude_eqs : [String] -> Simpset -> Simpset` adds equality-typed terms from the SAWCore Prelude module to a Simpset.\n\nFinally, it\u2019s possible to construct a theorem from an arbitrary SAWCore expression (rather than a Cryptol expression), using the `core_axiom` function.\n\n```cryptol\ncore_axiom : String -> Theorem\n```\n\ncreates a `Theorem` from a String in SAWCore syntax. Any `Theorem` introduced by this function is assumed to be correct, so use it with caution.\n\n## Folding and Unfolding\n\nA SAWCore term can be given a name using the `define` function, and is then by default printed as that name alone. A named subterm can be \u201cunfolded\u201d so that the original definition appears again.\n\n```cryptol\ndefine : String -> Term -> TopLevel Term\nunfold_term : [String] -> Term -> Term\n```\n\nFor example:\n\n```sawscript\nlet t = {{ 0x22 }}\nprint_term t\n```\n\nprints:\n\n```\nCryptol.ecNumber (Cryptol.TCNum 34) (Prelude.Vec 8 Prelude.Bool)\n  (Cryptol.PLiteralSeqBool (Cryptol.TCNum 8))\n```\n\nThen:\n\n```sawscript\nt' <- define \"t\" t\nprint_term t'\nlet t'' = unfold_term [\"t\"] t'\nprint_term t''\n```\n\nprints:\n\n```\nt\n```\n\nand then\n\n```\nCryptol.ecNumber (Cryptol.TCNum 34) (Prelude.Vec 8 Prelude.Bool)\n  (Cryptol.PLiteralSeqBool (Cryptol.TCNum 8))\n```\n\nThis process of folding and unfolding is useful both to make large terms easier for humans to work with and to make automated proofs more tractable. We\u2019ll describe the latter in more detail when we discuss interacting with external provers.\n\nIn some cases, folding happens automatically when constructing Cryptol expressions. Consider the following example:\n\n```sawscript\nlet t = {{ 0x22 }}\nprint_term t\n```\n\nprints:\n\n```\nCryptol.ecNumber (Cryptol.TCNum 34) (Prelude.Vec 8 Prelude.Bool)\n  (Cryptol.PLiteralSeqBool (Cryptol.TCNum 8))\n```\n\nThen:\n\n```sawscript\nlet {{ t' = 0x22 }}\nprint_term {{ t' }}\n```\n\nprints:\n\n```\nt'\n```\n\nThis illustrates that a bare expression in Cryptol braces gets translated directly to a SAWCore term. However, a Cryptol definition gets translated into a folded SAWCore term. In addition, because the second definition of `t` occurs at the Cryptol level, rather than the SAWScript level, it is visible only inside Cryptol braces. Definitions imported from Cryptol source files are also initially folded and can be unfolded as needed.\n\n## Other Built-in Transformation and Inspection Functions\n\nIn addition to the Term transformation functions described so far, a variety of others also exist.\n\n- `beta_reduce_term : Term -> Term` takes any sub-expression of the form `(\\x -> t) v` in the given Term and replaces it with a transformed version of `t` in which all instances of `x` are replaced by `v`.\n\n- `replace : Term -> Term -> Term -> TopLevel Term` replaces arbitrary subterms. A call to `replace x y t` replaces any instance of `x` inside `t` with `y`.\n\nAssessing the size of a term can be particularly useful during benchmarking. SAWScript provides two mechanisms for this.\n\n- `term_size : Term -> Int` calculates the number of nodes in the Directed Acyclic Graph (DAG) representation of a Term used internally by SAW. This is the most appropriate way of determining the resource use of a particular term.\n\n- `term_tree_size : Term -> Int` calculates how large a Term would be if it were represented by a tree instead of a DAG. This can, in general, be much, much larger than the number returned by `term_size`, and serves primarily as a way of assessing, for a specific term, how much benefit there is to the term sharing used by the DAG representation.\n\nFinally, there are a few commands related to the internal SAWCore type of a Term.\n\n- `check_term : Term -> TopLevel ()` checks that the internal structure of a Term is well-formed and that it passes all of the rules of the SAWCore type checker.\n\n- `type : Term -> Type` returns the type of a particular Term, which can then be used to, for example, construct a new fresh variable with `fresh_symbolic`.\n\n## Loading and Storing Terms\n\nMost frequently, Term values in SAWScript come from Cryptol, JVM, or LLVM programs, or some transformation thereof. However, it is also possible to obtain them from various other sources.\n\n- `parse_core : String -> Term` parses a String containing a term in SAWCore syntax, returning a Term.\n\n- `read_core : String -> TopLevel Term` is like `parse_core`, but obtains the text from the given file and expects it to be in the simpler SAWCore external representation format, rather than the human-readable syntax shown so far.\n\n- `read_aig : String -> TopLevel Term` returns a Term representation of an And-Inverter-Graph (AIG) file in AIGER format.\n\n- `read_bytes : String -> TopLevel Term` reads a constant sequence of bytes from a file and represents it as a Term. Its result will always have Cryptol type `[n][8]` for some n.\n\nIt is also possible to write Term values into files in various formats, including: AIGER (`write_aig`), CNF (`write_cnf`), SAWCore external representation (`write_core`), and SMT-Lib version 2 (`write_smtlib2`).\n\n```cryptol\nwrite_aig : String -> Term -> TopLevel ()\nwrite_cnf : String -> Term -> TopLevel ()\nwrite_core : String -> Term -> TopLevel ()\nwrite_smtlib2 : String -> Term -> TopLevel ()\n```","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/proofs-about-terms.html","filetype":"txt","content":"## Proofs about Terms\n\nThe goal of SAW is to facilitate proofs about the behavior of programs. It may be useful to prove some small fact to use as a rewrite rule in later proofs, but ultimately these rewrite rules come together into a proof of some higher-level property about a software system.\n\nWhether proving small lemmas (in the form of rewrite rules) or a top-level theorem, the process builds on the idea of a proof script that is run by one of the top-level proof commands.\n\n- `prove_print : ProofScript () -> Term -> TopLevel Theorem` takes a proof script (which we\u2019ll describe next) and a Term. The Term should be of function type with a return value of Bool (Bit at the Cryptol level). It will then use the proof script to attempt to show that the Term returns True for all possible inputs. If it is successful, it will print `Valid` and return a Theorem. If not, it will abort.\n\n- `sat_print : ProofScript () -> Term -> TopLevel ()` is similar except that it looks for a single value for which the Term evaluates to True and prints out that value, returning nothing.\n\n- `prove_core : ProofScript () -> String -> TopLevel Theorem` proves and returns a Theorem from a string in SAWCore syntax.\n\n## Automated Tactics\n\nThe simplest proof scripts just specify the automated prover to use. The ProofScript values `abc` and `z3` select the ABC and Z3 theorem provers, respectively, and are typically good choices.\n\nFor example, combining `prove_print` with `abc`:\n\n```sawscript\nsawscript> t <- prove_print abc {{ \\(x:[8]) -> x + x == x * 2 }}\nValid\nsawscript> t\nTheorem (let { x@1 = Prelude.Vec 8 Prelude.Bool\n      x@2 = Cryptol.TCNum 8\n      x@3 = Cryptol.PArithSeqBool x@2\n    }\n in (x : x@1)\n-> Prelude.EqTrue\n     (Cryptol.ecEq x@1 (Cryptol.PCmpSeqBool x@2)\n        (Cryptol.ecPlus x@1 x@3 x x)\n        (Cryptol.ecMul x@1 x@3 x\n           (Cryptol.ecNumber (Cryptol.TCNum 2) x@1\n              (Cryptol.PLiteralSeqBool x@2)))))\n```\n\nSimilarly, `sat_print` will show that the function returns True for one specific input (which it should, since we already know it returns True for all inputs):\n\n```sawscript\nsawscript> sat_print abc {{ \\(x:[8]) -> x + x == x * 2 }}\nSat: [x = 0]\n```\n\nIn addition to these, the `bitwuzla`, `boolector`, `cvc4`, `cvc5`, `mathsat`, and `yices` provers are available. The internal decision procedure `rme`, short for Reed-Muller Expansion, is an automated prover that works particularly well on the Galois field operations that show up, for example, in AES.\n\nIn more complex cases, some pre-processing can be helpful or necessary before handing the problem off to an automated prover. The pre-processing can involve rewriting, beta reduction, unfolding, the use of provers that require slightly more configuration, or the use of provers that do very little real work.\n\n## Proof Script Diagnostics\n\nDuring development of a proof, it can be useful to print various information about the current goal. The following tactics are useful in that context.\n\n- `print_goal : ProofScript ()` prints the entire goal in SAWCore syntax.\n\n- `print_goal_consts : ProofScript ()` prints a list of unfoldable constants in the current goal.\n\n- `print_goal_depth : Int -> ProofScript ()` takes an integer argument, n, and prints the goal up to depth n. Any elided subterms are printed with a `...` notation.\n\n- `print_goal_size : ProofScript ()` prints the number of nodes in the DAG representation of the goal.\n\n## Rewriting in Proof Scripts\n\nOne of the key techniques available for completing proofs in SAWScript is the use of rewriting or transformation. The following commands support this approach.\n\n- `simplify : Simpset -> ProofScript ()` works just like `rewrite`, except that it works in a ProofScript context and implicitly transforms the current (unnamed) goal rather than taking a Term as a parameter.\n\n- `goal_eval : ProofScript ()` will evaluate the current proof goal to a first-order combination of primitives.\n\n- `goal_eval_unint : [String] -> ProofScript ()` works like `goal_eval` but avoids expanding or simplifying the given names.\n\n## Other Transformations\n\nSome useful transformations are not easily specified using equality statements, and instead have special tactics.\n\n- `beta_reduce_goal : ProofScript ()` works like `beta_reduce_term` but on the current goal. It takes any sub-expression of the form `(\\x -> t) v` and replaces it with a transformed version of `t` in which all instances of `x` are replaced by `v`.\n\n- `unfolding : [String] -> ProofScript ()` works like `unfold_term` but on the current goal.\n\nUsing unfolding is mostly valuable for proofs based entirely on rewriting, since the default behavior for automated provers is to unfold everything before sending a goal to a prover. However, with some provers it is possible to indicate that specific named subterms should be represented as uninterpreted functions.\n\n### Uninterpreted tactics\n\n```cryptol\nunint_bitwuzla : [String] -> ProofScript ()\nunint_cvc4 : [String] -> ProofScript ()\nunint_cvc5 : [String] -> ProofScript ()\nunint_yices : [String] -> ProofScript ()\nunint_z3 : [String] -> ProofScript ()\n```\n\nThe list of `String` arguments in these cases indicates the names of the subterms to leave folded, and therefore present as uninterpreted functions to the prover. To determine which folded constants appear in a goal, use the `print_goal_consts` function described above.\n\nUltimately, we plan to implement a more generic tactic that leaves certain constants uninterpreted in whatever prover is ultimately used (provided that uninterpreted functions are expressible in the prover).\n\nNote that each of the `unint_*` tactics have variants that are prefixed with `sbv_` and `w4_`. The `sbv_`-prefixed tactics make use of the SBV library to represent and solve SMT queries:\n\n```cryptol\nsbv_unint_bitwuzla : [String] -> ProofScript ()\nsbv_unint_cvc4 : [String] -> ProofScript ()\nsbv_unint_cvc5 : [String] -> ProofScript ()\nsbv_unint_yices : [String] -> ProofScript ()\nsbv_unint_z3 : [String] -> ProofScript ()\n```\n\nThe `w4_`-prefixed tactics make use of the What4 library instead of SBV:\n\n```cryptol\nw4_unint_bitwuzla : [String] -> ProofScript ()\nw4_unint_cvc4 : [String] -> ProofScript ()\nw4_unint_cvc5 : [String] -> ProofScript ()\nw4_unint_yices : [String] -> ProofScript ()\nw4_unint_z3 : [String] -> ProofScript ()\n```\n\nIn most specifications, the choice of SBV versus What4 is not important, as both libraries are broadly compatible in terms of functionality. There are some situations where one library may outperform the other, however, due to differences in how each library represents certain SMT queries. There are also some experimental features that are only supported with What4 at the moment, such as `enable_lax_loads_and_stores`.\n\n## Caching Solver Results\n\nSAW has the capability to cache the results of tactics which call out to automated provers. This can save a considerable amount of time in cases such as proof development and CI, where the same proof scripts are often run repeatedly without changes.\n\nThis caching is available for all tactics which call out to automated provers at runtime: `abc`, `boolector`, `cvc4`, `cvc5`, `mathsat`, `yices`, `z3`, `rme`, and the family of `unint` tactics described in the previous section.\n\nWhen solver caching is enabled and one of the tactics mentioned above is encountered, if there is already an entry in the cache corresponding to the call then the cached result is used, otherwise the appropriate solver is queried, and the result saved to the cache. Entries are indexed by a SHA256 hash of the exact query to the solver (ignoring variable names), any options passed to the solver, and the names and full version strings of all the solver backends involved (e.g., ABC and SBV for the `abc` tactic). This ensures cached results are only used when they would be identical to the result of actually running the tactic.\n\nThe simplest way to enable solver caching is to set the environment variable `SAW_SOLVER_CACHE_PATH`. With this environment variable set, `saw` and `saw-remote-api` will automatically keep an LMDB database at the given path containing the solver result cache. Setting this environment variable globally therefore creates a global, concurrency-safe solver result cache used by all newly created `saw` or `saw-remote-api` processes. Note that when this environment variable is set, SAW does not create a cache at the specified path until it is actually needed.\n\nThere are also a number of SAW commands related to solver caching.\n\n- `set_solver_cache_path` is like setting `SAW_SOLVER_CACHE_PATH` for the remainder of the current session, but opens an LMDB database at the specified path immediately. If a cache is already in use in the current session (i.e., through a prior call to `set_solver_cache_path` or through `SAW_SOLVER_CACHE_PATH` being set and the cache being used at least once) then all entries in the cache already in use will be copied to the new cache being opened.\n\n- `set_solver_cache_timeout` sets the cache\u2019s timeout (in microseconds) used for database lookups and inserts. The default timeout value is 2,000,000 microseconds (2 seconds). This is a reasonably large timeout for most cache operations, but it may be convenient to increase this timeout for especially large proof goals.\n\n- `clean_mismatched_versions_solver_cache` will remove all entries in the solver result cache which were created using solver backend versions which do not match the versions in the current environment. This can be run after an update to clear out any old, unusable entries from the solver cache. This command can also be run directly from the command line through the `--clean-mismatched-versions-solver-cache` command-line option.\n\n- `print_solver_cache` prints to the console all entries in the cache whose SHA256 hash keys start with the given hex string. Providing an empty string results in all entries in the cache being printed.\n\n- `print_solver_cache_stats` prints to the console statistics including the size of the solver cache, where on disk it is stored, and some counts of how often it has been used during the current session.\n\nFor performing more complicated database operations on the set of cached results, the file `solver_cache.py` is provided with the Python bindings of the SAW Remote API. This file implements a general-purpose Python interface for interacting with the LMDB databases kept by SAW for solver caching.\n\nBelow is an example of using solver caching with `saw -v Debug`. Only the relevant output is shown, the rest abbreviated with `\u2026`.\n\n```sawscript\nsawscript> set_solver_cache_path \"example.cache\"\nsawscript> prove_print z3 {{ \\(x:[8]) -> x + x == x * 2 }}\n[22:13:00.832] Caching result: d1f5a76e7a0b7c01 (SBV 9.2, Z3 4.8.7 - 64 bit)\n...\nsawscript> prove_print z3 {{ \\(new:[8]) -> new + new == new * 2 }}\n[22:13:04.122] Using cached result: d1f5a76e7a0b7c01 (SBV 9.2, Z3 4.8.7 - 64 bit)\n...\nsawscript> prove_print (w4_unint_z3_using \"qfnia\" []) \\\n                                  {{ \\(x:[8]) -> x + x == x * 2 }}\n[22:13:09.484] Caching result: 4ee451f8429c2dfe (What4 v1.3-29-g6c462cd using qfnia, Z3 4.8.7 - 64 bit)\n...\nsawscript> print_solver_cache \"d1f5a76e7a0b7c01\"\n[22:13:13.250] SHA: d1f5a76e7a0b7c01bdfe7d0e1be82b4f233a805ae85a287d45933ed12a54d3eb\n[22:13:13.250] - Result: unsat\n[22:13:13.250] - Solver: \"SBV->Z3\"\n[22:13:13.250] - Versions: SBV 9.2, Z3 4.8.7 - 64 bit\n[22:13:13.250] - Last used: 2023-07-25 22:13:04.120351 UTC\n\nsawscript> print_solver_cache \"4ee451f8429c2dfe\"\n[22:13:16.727] SHA: 4ee451f8429c2dfefecb6216162bd33cf053f8e66a3b41833193529449ef5752\n[22:13:16.727] - Result: unsat\n[22:13:16.727] - Solver: \"W4 ->z3\"\n[22:13:16.727] - Versions: What4 v1.3-29-g6c462cd using qfnia, Z3 4.8.7 - 64 bit\n[22:13:16.727] - Last used: 2023-07-25 22:13:09.484464 UTC\n\nsawscript> print_solver_cache_stats\n[22:13:20.585] == Solver result cache statistics ==\n[22:13:20.585] - 2 results cached in example.cache\n[22:13:20.585] - 2 insertions into the cache so far this run (0 failed attempts)\n[22:13:20.585] - 1 usage of cached results so far this run (0 failed attempts)\n```\n\n## Other External Provers\n\nIn addition to the built-in automated provers already discussed, SAW supports more generic interfaces to other arbitrary theorem provers supporting specific interfaces.\n\n- `external_aig_solver : String -> [String] -> ProofScript ()` supports theorem provers that can take input as a single-output AIGER file. The first argument is the name of the executable to run. The second argument is the list of command-line parameters to pass to that executable. Any element of this list equal to `%f` will be replaced with the name of the temporary AIGER file generated for the proof goal. The output from the solver is expected to be in DIMACS solution format.\n\n- `external_cnf_solver : String -> [String] -> ProofScript ()` works similarly but for SAT solvers that take input in DIMACS CNF format and produce output in DIMACS solution format.\n\n## Offline Provers\n\nFor provers that must be invoked in more complex ways, or to defer proof until a later time, there are functions to write the current goal to a file in various formats, and then assume that the goal is valid through the rest of the script.\n\n- `offline_aig : String -> ProofScript ()`\n\n- `offline_cnf : String -> ProofScript ()`\n\n- `offline_extcore : String -> ProofScript ()`\n\n- `offline_smtlib2 : String -> ProofScript ()`\n\n- `offline_unint_smtlib2 : [String] -> String -> ProofScript ()`\n\nThese support the AIGER, DIMACS CNF, shared SAWCore, and SMT-Lib v2 formats, respectively. The shared representation for SAWCore is described in the saw-script repository. The `offline_unint_smtlib2` command represents the folded subterms listed in its first argument as uninterpreted functions.\n\n## Finishing Proofs without External Solvers\n\nSome proofs can be completed using unsound placeholders, or using techniques that do not require significant computation.\n\n- `assume_unsat : ProofScript ()` indicates that the current goal should be assumed to be unsatisfiable. This is an alias for `assume_valid`. Users should prefer to use `admit` instead.\n\n- `assume_valid : ProofScript ()` indicates that the current goal should be assumed to be valid. Users should prefer to use `admit` instead.\n\n- `admit : String -> ProofScript ()` indicates that the current goal should be assumed to be valid without proof. The given string should be used to record why the user has decided to assume this proof goal.\n\n- `quickcheck : Int -> ProofScript ()` runs the goal on the given number of random inputs, and succeeds if the result of evaluation is always True. This is unsound, but can be helpful during proof development, or as a way to provide some evidence for the validity of a specification believed to be true but difficult or infeasible to prove.\n\n- `trivial : ProofScript ()` states that the current goal should be trivially true. This tactic recognizes instances of equality that can be demonstrated by conversion alone. In particular it is able to prove `EqTrue x` goals where `x` reduces to the constant value True. It fails if this is not the case.\n\n## Multiple Goals\n\nThe proof scripts shown so far all have a single implicit goal. As in many other interactive provers, however, SAWScript proofs can have multiple goals. The following commands can introduce or work with multiple goals. These are experimental and can be used only after `enable_experimental` has been called.\n\n- `goal_apply : Theorem -> ProofScript ()` will apply a given introduction rule to the current goal. This will result in zero or more new subgoals.\n\n- `goal_assume : ProofScript Theorem` will convert the first hypothesis in the current proof goal into a local Theorem.\n\n- `goal_insert : Theorem -> ProofScript ()` will insert a given Theorem as a new hypothesis in the current proof goal.\n\n- `goal_intro : String -> ProofScript Term` will introduce a quantified variable in the current proof goal, returning the variable as a Term.\n\n- `goal_when : String -> ProofScript () -> ProofScript ()` will run the given proof script only when the goal name contains the given string.\n\n- `goal_exact : Term -> ProofScript ()` will attempt to use the given term as an exact proof for the current goal. This tactic will succeed whenever the type of the given term exactly matches the current goal, and will fail otherwise.\n\n- `split_goal : ProofScript ()` will split a goal of the form `Prelude.and prop1 prop2` into two separate goals `prop1` and `prop2`.\n\n## Proof Failure and Satisfying Assignments\n\nThe `prove_print` and `sat_print` commands print out their essential results (potentially returning a Theorem in the case of `prove_print`). In some cases, though, one may want to act programmatically on the result of a proof rather than displaying it.\n\nThe `prove` and `sat` commands allow this sort of programmatic analysis of proof results. To allow this, they use two types we haven\u2019t mentioned yet: `ProofResult` and `SatResult`. These are different from the other types in SAWScript because they encode the possibility of two outcomes. In the case of `ProofResult`, a statement may be valid or there may be a counter-example. In the case of `SatResult`, there may be a satisfying assignment or the statement may be unsatisfiable.\n\n```cryptol\nprove : ProofScript SatResult -> Term -> TopLevel ProofResult\nsat : ProofScript SatResult -> Term -> TopLevel SatResult\n```\n\nTo operate on these new types, SAWScript includes a pair of functions:\n\n- `caseProofResult : {b} ProofResult -> b -> (Term -> b) -> b` takes a `ProofResult`, a value to return in the case that the statement is valid, and a function to run on the counter-example, if there is one.\n\n- `caseSatResult : {b} SatResult -> b -> (Term -> b) -> b` has the same shape: it returns its first argument if the result represents an unsatisfiable statement, or its second argument applied to a satisfying assignment if it finds one.\n\n## AIG Values and Proofs\n\nMost SAWScript programs operate on `Term` values, and in most cases this is the appropriate representation. It is possible, however, to represent the same function that a `Term` may represent using a different data structure: an And-Inverter-Graph (AIG). An AIG is a representation of a Boolean function as a circuit composed entirely of AND gates and inverters. Hardware synthesis and verification tools, including the ABC tool that SAW has built in, can do efficient verification and particularly equivalence checking on AIGs.\n\nTo take advantage of this capability, a handful of built-in commands can operate on AIGs.\n\n- `bitblast : Term -> TopLevel AIG` represents a Term as an AIG by \u201cblasting\u201d all its primitive operations (things like bit-vector addition) down to the level of individual bits.\n\n- `load_aig : String -> TopLevel AIG` loads an AIG from an external AIGER file.\n\n- `save_aig : String -> AIG -> TopLevel ()` saves an AIG to an external AIGER file.\n\n- `save_aig_as_cnf : String -> AIG -> TopLevel ()` writes an AIG out in CNF format for input into a standard SAT solver.","variant":null,"set":"unsupervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/extraction-to-the-coq-theorem-prover.html","filetype":"txt","content":"## Extraction to the Coq theorem prover\n\nIn addition to the (semi-)automatic and compositional proof modes already discussed above, SAW has experimental support for exporting Cryptol and SAWCore values as terms to the Coq proof assistant. This is intended to support more manual proof efforts for properties that go beyond what SAW can support (for example, proofs requiring induction) or for connecting to preexisting formalizations in Coq of useful algorithms (e.g. the fiat crypto library).\n\nThis support consists of two related pieces. The first piece is a library of formalizations of the primitives underlying Cryptol and SAWCore and various supporting concepts that help bridge the conceptual gap between SAW and Coq. The second piece is a term translation that maps the syntactic forms of SAWCore onto corresponding concepts in Coq syntax, designed to dovetail with the concepts defined in the support library. SAWCore is a quite similar language to the core calculus underlying Coq, so much of this translation is quite straightforward; however, the languages are not exactly equivalent, and there are some tricky cases that mostly arise from Cryptol code that can only be partially supported. We will note these restrictions later in the manual.\n\nWe expect this extraction process to work with a fairly wide range of Coq versions, as we are not using bleeding-edge Coq features. It has been most fully tested with Coq version 8.13.2.\n\n## Support Library\n\nIn order to make use of SAW\u2019s extraction capabilities, one must first compile the support library using Coq so that the included definitions and theorems can be referenced by the extracted code. From the top directory of the SAW source tree, the source code for this support library can be found in the saw-core-coq\/coq subdirectory. In this subdirectory you will find a _CoqProject and a Makefile. A simple make invocation should be enough to compile all the necessary files, assuming Coq is installed and coqc is available in the user\u2019s PATH. HTML documentation for the support library can also be generated by make html from the same directory.\n\nOnce the library is compiled, the recommended way to import it into your subsequent development is by adding the following lines to your _CoqProject file:\n\n```\n-Q <SAWDIR>\/saw-core-coq\/coq\/generated\/CryptolToCoq CryptolToCoq\n-Q <SAWDIR>\/saw-core-coq\/coq\/handwritten\/CryptolToCoq CryptolToCoq\n```\n\nHere `<SAWDIR>` refers to the location on your system where the SAWScript source tree is checked out. This will add the relevant library files to the CryptolToCoq namespace, where the extraction process will expect to find them.\n\nThe support library for extraction is broken into two parts: those files which are handwritten, versus those that are automatically generated. The handwritten files are generally fairly readable and are reasonable for human inspection; they define most of the interesting pipe-fitting that allows Cryptol and SAWCore definitions to connect to corresponding Coq concepts. In particular the file `SAWCoreScaffolding.v` defines most of the bindings of base types to Coq types, and the `SAWCoreVectorsAsCoqVectors.v` defines the core bitvector operations. The automatically generated files are direct translations of the SAWCore source files (`saw-core\/prelude\/Prelude.sawcore` and `cryptol-saw-core\/saw\/Cryptol.sawcore`) that correspond to the standard libraries for SAWCore and Cryptol, respectively.\n\nThe autogenerated files are intended to be kept up-to-date with changes in the corresponding sawcore files, and end users should not need to generate them. Nonetheless, if they are out of sync for some reason, these files may be regenerated using the saw executable by running \n\n```shell\n(cd saw-core-coq; saw saw\/generate_scaffolding.saw)\n```\n\nfrom the top-level of the SAW source directory before compiling them with Coq as described above.\n\nYou may also note some additional files and concepts in the standard library, such as `CompM.v`, and a variety of lemmas and definitions related to it. These definitions are related to the \u201cheapster\u201d system, which form a separate use-case for the SAWCore to Coq translation. These definitions will not be used for code extracted from Cryptol.\n\n## Cryptol module extraction\n\nThere are several modes of use for the SAW to Coq term extraction facility, but the easiest to use is whole Cryptol module extraction. This will extract all the definitions in the given Cryptol module, together with its transitive dependencies, into a single Coq module which can then be compiled and pulled into subsequent developments.\n\nSuppose we have a Cryptol source file named `source.cry` and we want to generate a Coq file named `output.v`. We can accomplish this by running the following commands in saw (either directly from the saw command prompt, or via a script file):\n\n```cryptol\nenable_experimental;\nwrite_coq_cryptol_module \"source.cry\" \"output.v\" [] [];\n```\n\nIn this default mode, identifiers in the Cryptol source will be directly translated into identifiers in Coq. This may occasionally cause problems if source identifiers clash with Coq keywords or preexisting definitions. The third argument to `write_coq_cryptol_module` can be used to remap such names if necessary by giving a list of (in,out) pairs of names. The fourth argument is a list of source identifiers to skip translating, if desired. Authoritative online documentation for this command can be obtained directly from the saw executable via `:help write_coq_cryptol_module` after `enable_experimental`.\n\nThe resulting `output.v` file will have some of the usual hallmarks of computer-generated code; it will have poor formatting, explicit parentheses, and fully-qualified names. Thankfully, once loaded into Coq, the Coq pretty-printer will do a much better job of rendering these terms in a somewhat human-readable way.\n\n## Proofs involving uninterpreted functions\n\nIt is possible to write a Cryptol module that references uninterpreted functions by using the `primitive` keyword to declare them in your Cryptol source. Primitive Cryptol declarations will be translated into Coq section variables; as usual in Coq, uses of these section variables will be translated into additional parameters to the definitions from outside the section. In this way, consumers of the translated module can instantiate the declared Cryptol functions with corresponding terms in subsequent Coq developments.\n\nAlthough the Cryptol interpreter itself will not be able to compute with declared but undefined functions of this sort, they can be used both to provide specifications for functions to be verified with `llvm_verify` or `jvm_verify` and also for Coq extraction.\n\nFor example, if we write the following Cryptol source file:\n\n```cryptol\nprimitive f : Integer -> Integer\n\ng : Integer -> Bool\ng x = f (f x) > 0\n```\n\nAfter extraction, the generated term `g` will have Coq type:\n\n```\n(Integer -> Integer) -> Integer -> Bool\n```\n\n## Translation limitations and caveats\n\nTranslation from Cryptol to Coq has a number of fundamental limitations that must be addressed. The most severe of these is that Cryptol is a fully general-recursive language, and may exhibit runtime errors directly via calls to the `error` primitive, or via partial operations (such as indexing a sequence out-of-bounds). The internal language of Coq, by contrast, is a strongly-normalizing language of total functions. As such, our translation is unable to extract all Cryptol programs.\n\n## Recursive programs\n\nThe most severe of the current limitations for our system is that the translation is unable to translate any recursive Cryptol program. Doing this would require us to attempt to find some termination argument for the recursive function sufficient to satisfy Coq; for now, no attempt is made to do so. If you attempt to extract a recursive function, SAW will produce an error about a \u201cmalformed term\u201d with `Prelude.fix` as the head symbol.\n\nCertain limited kinds of recursion are available via the `foldl` Cryptol primitive operation, which is translated directly into a fold operation in Coq. This is sufficient for many basic iterative algorithms.\n\n## Type coercions\n\nAnother limitation of the translation system is that Cryptol uses SMT solvers during its typechecking process and uses the results of solver proofs to justify some of its typing judgments. When extracting these terms to Coq, type equality coercions must be generated. Currently, we do not have a good way to transport the reasoning done inside Cryptol\u2019s typechecker into Coq, so we just supply a very simple Ltac tactic to discharge these coercions (see `solveUnsafeAssert` in `CryptolPrimitivesForSAWCoreExtra.v`). This tactic is able to discover simple coercions, but for anything nontrivial it may fail. The result will be a typechecking failure when compiling the generated code in Coq when the tactic fails. If you encounter this problem, it may be possible to enhance the `solveUnsafeAssert` tactic to cover your use case.\n\n## Error terms\n\nA final caveat that is worth mentioning is that Cryptol can sometimes produce runtime errors. These can arise from explicit calls to the `error` primitive, or from partially defined operations (e.g., division by zero or sequence access out of bounds). Such instances are translated to occurrences of an unrealized Coq axiom named `error`. In order to avoid introducing an inconsistent environment, the error axiom is restricted to apply only to inhabited types. All the types arising from Cryptol programs are inhabited, so this is no problem in principle. However, collecting and passing this information around on the Coq side is a little tricky.\n\nThe main technical device we use here is the `Inhabited` type class; it simply asserts that a type has some distinguished inhabitant. We provide instances for the base types and type constructors arising from Cryptol, so the necessary instances ought to be automatically constructed when needed. However, polymorphic Cryptol functions add some complications, as type arguments must also come together with evidence that they are inhabited. The translation process takes care to add the necessary `Inhabited` arguments, so everything ought to work out. However, if Coq typechecking of generated code fails with errors about `Inhabited` class instances, it likely represents some problem with this aspect of the translation.","variant":null,"set":"supervised"}
{"filename":"https:\/\/galoisinc.github.io\/saw-script\/master\/saw-user-manual\/formal-deprecation-process.html","filetype":"txt","content":"## Formal Deprecation Process\n\nSAW primitives, and thus their associated SAWScript built-ins, sometimes become obsolete or are found inadequate and replaced. The process by which that happens has three steps, as follows:\n\n1. The decision is made to deprecate and eventually remove the objects in question. This can happen at the level of individual built-in elements (for example, when replacing a function with an awkward interface or unfortunate name) or at the level of internal units of functionality with possibly multiple built-ins affected. At this step the built-ins in question are marked for a deprecation warning. They remain available by default, but referring to them will trigger a warning.\n\n2. The objects in question are made invisible by default. Now, referring to the affected built-ins will fail unless the `enable_deprecated` command is used. In that case referring to them will still produce a warning.\n\n3. The objects in question are removed entirely and are no longer available.\n\nIn general any object or group of objects will move only one step per release; that is, something first marked deprecated (so it warns) in saw-script 1.2 will not disappear by default before saw-script 1.3 and not be removed entirely before saw-script 1.4. The time frame may be longer depending on the needs of downstream users, the complexity of migration, and the cost\/impact of keeping the deprecated code in the system.\n\nWe may move faster if circumstances dictate, but hope not to need to.\n\nObjects that have never appeared in a release, or that have never moved past experimental, may be removed without first being deprecated. However, we aim to avoid this in cases where the objects in question have gotten substantial use despite their formal status.","variant":null,"set":"unsupervised"}
